; ModuleID = 'main'
source_filename = "main"

%CALENDAR = type { i64, i64, i64, i64, i16, i16, i16, i16, i16, i8, i8, [6 x i8], i16, float, float, i64, i64, i64, float, float, float, i8, i8, [31 x i8], i16 }
%COMPLEX = type { float, float }
%CONSTANTS_LANGUAGE = type { i16, i16, [21 x [11 x i8]], [21 x [3 x i8]], [36 x [11 x i8]], [36 x [4 x i8]], [48 x [4 x i8]] }
%CONSTANTS_LOCATION = type { i16, i16, [5 x i16] }
%CONSTANTS_MATH = type { float, float, float, float, float, float, float, float, float, [13 x i32] }
%CONSTANTS_PHYS = type { float, float, float, float, float, float }
%CONSTANTS_SETUP = type { i8, [4 x [254 x i8]], [12 x i16], [9 x float] }
%ESR_DATA = type { i8, [11 x i8], i64, i64, [8 x i8] }
%FRACTION = type { i16, i16 }
%HOLIDAY_DATA = type { [31 x i8], i8, i8, i8 }
%REAL2 = type { float, float }
%SDT = type { i16, i16, i16, i16, i16, i16, i16, i16 }
%TIMER_EVENT = type { i8, i8, i8, i64, i64, i8, i8, i64 }
%VECTOR_3 = type { float, float, float }
%DRIVER_1_interface = type { i8, i64, i8, i8, i8, i8, %TON_interface, i8 }
%TON_interface = type { i8, i64, i8, i64, i8, i64 }
%DRIVER_4_interface = type { i8, i64, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, %DRIVER_1_interface, %DRIVER_1_interface, %DRIVER_1_interface, %DRIVER_1_interface }
%DRIVER_4C_interface = type { i8, i8, i64, [7 x i8], i16, i8, i8, i8, i8, %TON_interface, i8 }
%FLOW_CONTROL_interface = type { i8, i8, i8, i8, i64, i64, i8, i8, %TP_1D_interface }
%TP_1D_interface = type { i8, i64, i64, i8, i8, i8, i64, i64, i8 }
%FT_Profile_interface = type { float, float, float, i8, float, i64, float, i64, float, i64, float, i64, float, i64, float, i64, float, i64, float, float, i8, i64, i64, i8, i8, i64, i64, i64, float, float, float }
%INC_DEC_interface = type { i8, i8, i8, i8, i16, i8, i8, i8, i8, i8, i8 }
%INTERLOCK_interface = type { i8, i8, i64, i8, i8, %TOF_interface, %TOF_interface }
%TOF_interface = type { i8, i64, i8, i64, i8, i64 }
%INTERLOCK_4_interface = type { i8, i8, i8, i8, i8, i16, i8, i8, i8, i8, i8, i16 }
%MANUAL_1_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%MANUAL_2_interface = type { i8, i8, i8, i8, i8, i8, i8 }
%MANUAL_4_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i16, i8 }
%PARSET_interface = type { i8, i8, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, i64, float, float, float, float, [16 x float], float, float, float, float, i32, i32, i8, i8, i8 }
%PARSET2_interface = type { float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, i64, float, float, float, float, %PARSET_interface, i8 }
%SIGNAL_interface = type { i8, i8, i64, i8, i32, i8, i8 }
%SIGNAL_4_interface = type { i8, i8, i8, i8, i64, i8, i8, i8, i8, i8, %SIGNAL_interface }
%SRAMP_interface = type { float, float, float, float, float, float, float, i8, float, float, %TC_S_interface, i8 }
%TC_S_interface = type { float, i8, i32, i32 }
%TUNE_interface = type { i8, i8, i8, i8, float, float, float, float, float, i64, i64, float, float, float, i32, i32, i32, i16, i8, float, float, float, float }
%TUNE2_interface = type { i8, i8, i8, i8, i8, i8, float, float, float, float, float, float, i64, float, float, float, i32, i32, i16, i8, float, float, float }
%CONTROL_SET1_interface = type { float, float, i8, i8, float, float, float, float, float, float, float, float, float, float, float }
%CONTROL_SET2_interface = type { float, float, float, i8, i8, float, float, float, float, float, float, float, float, float, float, float, float }
%CTRL_OUT_interface = type { float, float, float, float, float, i8, float, i8 }
%CTRL_PI_interface = type { float, float, float, float, float, i8, i8, float, float, float, float, float, float, i8, %FT_PIWL_interface, %CTRL_OUT_interface }
%FT_PIWL_interface = type { float, float, float, float, float, i8, float, i8, i8, i32, float, i32, float, float, float }
%CTRL_PID_interface = type { float, float, float, float, float, i8, i8, float, float, float, float, float, float, float, i8, %FT_PIDWL_interface, %CTRL_OUT_interface }
%FT_PIDWL_interface = type { float, float, float, float, float, float, i8, float, i8, %FT_PIWL_interface, %FT_DERIV_interface }
%FT_DERIV_interface = type { float, float, i8, float, float, i32, i32, i8, float }
%CTRL_PWM_interface = type { float, float, i8, float, i8, %PWM_DC_interface }
%PWM_DC_interface = type { float, float, i8, %CLK_PRG_interface, %TP_X_interface, float }
%CLK_PRG_interface = type { i64, i8, i8, i64, i64 }
%TP_X_interface = type { i8, i64, i8, i64, i8, i64, i64 }
%DEAD_BAND_A_interface = type { float, i64, float, float, float, float, %FT_PT1_interface, %FT_PT1_interface }
%FT_PT1_interface = type { float, i64, float, float, i32, i32, i8 }
%DEAD_ZONE2_interface = type { float, float, float }
%FT_IMP_interface = type { float, i64, float, float, %FT_PT1_interface }
%FT_INT_interface = type { float, float, i8, i8, float, float, float, i8, %INTEGRATE_interface }
%INTEGRATE_interface = type { i8, float, float, float*, float, i8, i32, i32 }
%FT_INT2_interface = type { float, float, i8, i8, float, float, float, i8, %INTEGRATE_interface, float, %REAL2 }
%FT_PD_interface = type { float, float, float, float, %FT_DERIV_interface }
%FT_PDT1_interface = type { float, float, float, float, float, %FT_DERIV_interface, %FT_PT1_interface }
%FT_PI_interface = type { float, float, float, float, float, i8, i8, float, i8, %FT_INT_interface }
%FT_PID_interface = type { float, float, float, float, float, float, i8, i8, float, i8, %FT_INT_interface, %FT_DERIV_interface }
%FT_PIDW_interface = type { float, float, float, float, float, float, i8, float, i8, %INTEGRATE_interface, %FT_DERIV_interface, float }
%FT_PIW_interface = type { float, float, float, float, float, i8, float, i8, %FT_INT_interface }
%FT_PT2_interface = type { float, i64, float, float, float, i8, %INTEGRATE_interface, %INTEGRATE_interface, float, float, float, float }
%FT_TN16_interface = type { float, i64, float, i8, i16, [16 x float], i16, i64, i64, i8 }
%FT_TN64_interface = type { float, i64, float, i8, i16, [64 x float], i16, i64, i64, i8 }
%FT_TN8_interface = type { float, i64, float, i8, i16, [8 x float], i16, i64, i64, i8 }
%HYST_interface = type { float, float, float, i8, i8 }
%HYST_1_interface = type { float, float, float, i8, i8 }
%HYST_2_interface = type { float, float, float, i8, i8, float }
%HYST_3_interface = type { float, float, float, float, i8, i8, float }
%ASTRO_interface = type { float, float, float, float, float, float, float, float }
%ENERGY_interface = type { float, float, float, float, float, float }
%LENGTH_interface = type { float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }
%PRESSURE_interface = type { float, float, float, float, float, float, float, float, float, float, float, float }
%SPEED_interface = type { float, float, float, float, float, float, float, float }
%TEMPERATURE_interface = type { float, float, float, float, float, float, float, float, float, float }
%ALARM_2_interface = type { float, float, float, float, float, float, i8, i8, i8, i8, float }
%BAR_GRAPH_interface = type { float, i8, float, float, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, float, float, float, float, float }
%CALIBRATE_interface = type { float, i8, i8, float, float, float, float, float }
%CYCLE_TIME_interface = type { i8, i64, i64, i64, i64, i16, i32, i64, i64, i8 }
%DT_SIMU_interface = type { i64, float, i64, i32, i8, i32, i32, i32 }
%FLOW_METER_interface = type { float, i8, i8, i8, i64, float, float*, i32*, i64, i64, %INTEGRATE_interface, i8, i8, i16, float, i32 }
%M_D_interface = type { i8, i8, i64, i8, i64, i64, i8, i8, i64, i64, i8 }
%M_T_interface = type { i8, i64, i8, i64, i64, i8, i64, i64 }
%M_TX_interface = type { i8, i64, i8, i64, i64, float, float, i64, i8, i64, i64, i64, i8, i8, i8 }
%METER_interface = type { float, float, i8, i8, float, i8, float*, %REAL2, float, float, i32, i32, float, i8 }
%METER_STAT_interface = type { float, i64, i8, float*, float*, float*, float*, float*, float*, float*, float*, float, float, float, float, i64 }
%ONTIME_interface = type { i8, i8, i32*, i32*, i32, i32, i8, i8, i32 }
%TC_MS_interface = type { i32, i8, i32, i32 }
%TC_US_interface = type { i32, i8, i32, i32 }
%_RMP_B_interface = type { i8, i8, i64, i8*, i64, i64, i64, i8, i8, i8 }
%_RMP_NEXT_interface = type { i8, i8, i64, i64, i64, i8, i8, i8, i8*, %_RMP_B_interface, %TREND_DW_interface, %TP_interface, i8, i8 }
%TREND_DW_interface = type { i32, i8, i8, i8, i32, i32 }
%TP_interface = type { i8, i64, i8, i64, i64 }
%_RMP_W_interface = type { i8, i8, i64, i16*, i32, i32, i32, i8, i8 }
%GEN_PULSE_interface = type { i8, i64, i64, i8, i64, i64, i8 }
%GEN_PW2_interface = type { i8, i64, i64, i64, i64, i8, i8, i64, i64, i64, i64, i64, i64, i8, i64 }
%GEN_RDM_interface = type { i64, float, float, i8, float, i64, i64, i8 }
%GEN_RDT_interface = type { i8, i64, i64, i64, i8, %TON_interface, %TOF_interface, i64, float }
%GEN_RMP_interface = type { i64, float, float, float, i8, float, i64, i64, i8, float, float }
%GEN_SIN_interface = type { i64, float, float, float, i8, float, i64, i64, i8, float }
%GEN_SQR_interface = type { i64, float, float, float, float, i8, float, i64, i64, i8 }
%PWM_PW_interface = type { float, i64, i8, %CLK_PRG_interface, %TP_X_interface }
%RMP_B_interface = type { i8, i64, i8, i8, i8, i8, i8, i8, i8, %_RMP_B_interface }
%RMP_SOFT_interface = type { i8, i8, i64, i64, i8, %_RMP_B_interface, i8 }
%RMP_W_interface = type { i8, i64, i8, i8, i8, i16, i8, i8, i8, %_RMP_W_interface }
%AIN1_interface = type { i32, i16, i16, i8, i32, i16, i8, i32, i16, i16, float, float, i32, i32, float, float, float, i8, i8, i8, i32 }
%DELAY_interface = type { float, i16, i8, float, [32 x float], i16, i8, i16 }
%DELAY_4_interface = type { float, float, float, float, float, float }
%FADE_interface = type { float, float, i8, i64, i8, float, %RMP_W_interface }
%FILTER_DW_interface = type { i32, i64, i32, i32, i32, i8, float }
%FILTER_I_interface = type { i16, i64, i16, i32, i32, i32, i8 }
%FILTER_MAV_DW_interface = type { i32, i16, i8, i32, i8, [32 x i32], i16 }
%FILTER_MAV_W_interface = type { i16, i16, i8, i16, i8, [32 x i16], i16, i32 }
%FILTER_W_interface = type { i16, i64, i16, i32, i32, i8, i32 }
%FILTER_WAV_interface = type { float, [16 x float], i8, float, i8, [16 x float], i16, i16 }
%SEL2_OF_3_interface = type { float, float, float, float, float, i16, i8, i8, i8, i8 }
%SEL2_OF_3B_interface = type { i8, i8, i8, i64, i8, i8, %TON_interface }
%SH_interface = type { float, i8, float, i8, i8 }
%SH_1_interface = type { float, i64, float, i8, i64, i64 }
%SH_2_interface = type { float, i64, i16, i16, float, i8, float, float, float, i16, [16 x float], [16 x float], i64, i16, i16, float, i16, i64, i16 }
%SH_T_interface = type { float, i8, float }
%STAIR2_interface = type { float, float, float }
%TREND_interface = type { float, i8, i8, i8, float, float }
%LIST_NEXT_interface = type { i8, i8, [251 x i8]*, [251 x i8], i8, i16, [250 x i8]*, [250 x i8]*, i8, i16 }
%COUNT_BR_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%COUNT_DR_interface = type { i8, i32, i8, i8, i32, i32, i8, i32, i8, i8 }
%FF_D2E_interface = type { i8, i8, i8, i8, i8, i8, i8 }
%FF_D4E_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%FF_DRE_interface = type { i8, i8, i8, i8, i8, i8 }
%FF_JKE_interface = type { i8, i8, i8, i8, i8, i8, i8 }
%FF_RSE_interface = type { i8, i8, i8, i8, i8, i8 }
%SELECT_8_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i16, i8, i8 }
%SHR_4E_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, %R_TRIG_interface }
%R_TRIG_interface = type { i8, i8, i8 }
%SHR_4UDE_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, %R_TRIG_interface }
%SHR_8PLE_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%SHR_8UDE_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, %R_TRIG_interface }
%TOGGLE_interface = type { i8, i8, i8, i8 }
%LTCH_interface = type { i8, i8, i8, i8 }
%LTCH_4_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%STORE_8_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%BYTE_TO_BITS_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%DEC_2_interface = type { i8, i8, i8, i8 }
%DEC_4_interface = type { i8, i8, i8, i8, i8, i8, i8 }
%DEC_8_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i16 }
%A_TRIG_interface = type { float, float, i8, float, float }
%B_TRIG_interface = type { i8, i8, i8 }
%CLICK_CNT_interface = type { i8, i16, i64, i8, %TP_interface, i8, i16 }
%CLICK_DEC_interface = type { i8, i64, i8, i8, i8, i8, %TP_interface, i8, i16 }
%CLK_DIV_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%CLK_N_interface = type { i16, i8, i8, i32, i8 }
%CLK_PULSE_interface = type { i64, i16, i8, i8, i16, i8, i32, i32, i8 }
%CYCLE_4_interface = type { i8, i64, i64, i64, i64, i8, i16, i8, i16, i64, i64, i8 }
%D_TRIG_interface = type { i32, i8, i32, i32 }
%GEN_BIT_interface = type { i32, i32, i32, i32, i8, i16, i16, i8, i8, i8, i8, i8, i16, i8, i32, i32, i32, i32, i16 }
%GEN_SQ_interface = type { i64, i8, i32, i32, i8 }
%SCHEDULER_interface = type { i8, i8, i8, i8, i64, i64, i64, i64, i8, i8, i8, i8, i8, i64, i64, i64, i64, i64, i16 }
%SCHEDULER_2_interface = type { i8, i8, i8, i8, i16, i16, i16, i16, i16, i16, i16, i16, i8, i8, i8, i8, i16 }
%SEQUENCE_4_interface = type { i8, i8, i8, i8, i8, i8, i64, i64, i64, i64, i64, i64, i64, i64, i8, i8, i8, i8, i8, i8, i8, i16, i8, i64, i8, i64, i8 }
%SEQUENCE_64_interface = type { i8, i16, [64 x i64], i8, i16, i8, i64, i8, i64 }
%SEQUENCE_8_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i16, i8, i64, i8, i64, i8 }
%TMAX_interface = type { i8, i64, i8, i8, i64, i64, i8 }
%TMIN_interface = type { i8, i64, i8, %TP_interface }
%TOF_1_interface = type { i8, i64, i8, i8, i64, i64 }
%TONOF_interface = type { i8, i64, i64, i8, %TON_interface, i8, i8 }
%TP_1_interface = type { i8, i64, i8, i8, i64, i64, i8 }
%FIFO_16_interface = type { i32, i8, i8, i8, i8, i32, i8, i8, [17 x i32], i16, i16, i16 }
%FIFO_32_interface = type { i32, i8, i8, i8, i8, i32, i8, i8, [33 x i32], i16, i16, i16 }
%STACK_16_interface = type { i32, i8, i8, i8, i8, i32, i8, i8, [16 x i32], i16, i16 }
%STACK_32_interface = type { i32, i8, i8, i8, i8, i32, i8, i8, [32 x i32], i16, i16 }
%MATRIX_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, [4 x i8], [4 x i8], i16, i8 }
%PIN_CODE_interface = type { i8, i8, [9 x i8], i8, i16 }
%FT_AVG_interface = type { float, i8, i16, i8, float, %DELAY_interface, i16, i8 }
%FT_MIN_MAX_interface = type { float, i8, float, float, i8 }
%FT_RMP_interface = type { i8, float, float, float, float, i8, i8, i64, i64, i8 }
%ESR_COLLECT_interface = type { [4 x %ESR_DATA], [4 x %ESR_DATA], [4 x %ESR_DATA], [4 x %ESR_DATA], [4 x %ESR_DATA], [4 x %ESR_DATA], [4 x %ESR_DATA], [4 x %ESR_DATA], i8, i16*, [32 x %ESR_DATA], i16, i16, i16 }
%ESR_MON_B8_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i64, [11 x i8], [11 x i8], [11 x i8], [11 x i8], [11 x i8], [11 x i8], [11 x i8], [11 x i8], i8, [4 x %ESR_DATA]*, i8, i8, i8, i8, i8, i8, i8, i8, i64, i16 }
%ESR_MON_R4_interface = type { float, float, float, float, i64, [11 x i8], [11 x i8], [11 x i8], [11 x i8], float, float, float, float, i8, [4 x %ESR_DATA]*, i32*, i32*, i32*, i32*, float, float, float, float, i64, i16 }
%ESR_MON_X8_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, i64, i8, [11 x i8], [11 x i8], [11 x i8], [11 x i8], [11 x i8], [11 x i8], [11 x i8], [11 x i8], i8, [4 x %ESR_DATA]*, i8, i8, i8, i8, i8, i8, i8, i8, i64, i16 }
%MESSAGE_4R_interface = type { [251 x i8], [251 x i8], [251 x i8], [251 x i8], i16, i8, i8, i64, [251 x i8], i16, i8, %TON_interface, i8 }
%MESSAGE_8_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, [251 x i8], [251 x i8], [251 x i8], [251 x i8], [251 x i8], [251 x i8], [251 x i8], [251 x i8], [251 x i8] }
%TICKER_interface = type { i16, i64, [251 x i8]*, [251 x i8], %TP_interface, i16 }
%CALENDAR_CALC_interface = type { i8, float, %CALENDAR*, [30 x %HOLIDAY_DATA]*, i64, i32, %HOLIDAY_interface, %SUN_TIME_interface, i16, i64, %SUN_POS_interface, i64 }
%HOLIDAY_interface = type { i64, i16, i8, i8, i8, [30 x %HOLIDAY_DATA]*, i16, i8, [31 x i8], i64, i64, i16, i16, i64, i16, i16 }
%SUN_TIME_interface = type { float, float, i64, float, i64, i64, i64, float, float, i64, float }
%SUN_POS_interface = type { float, float, i64, float, float, float }
%DCF77_interface = type { i8, i8, i64, i8, i64, i16, i8, i8, i8, i16, i8, i64, i64, i16, i8, i64, i64, i16, i8, i64, i64, i64, [59 x i8], i16, i16, i64, i16, i16, i16, i16, i16, i64, i64, i64, i8 }
%EVENTS_interface = type { i64, i8, i8, [31 x i8], i16, i64, i16, i32, i16, i32, %HOLIDAY_DATA, i8, [31 x i8], [50 x %HOLIDAY_DATA]* }
%RTC_2_interface = type { i8, i64, i16, i8, i16, i64, i64, i8, i16, %RTC_MS_interface }
%RTC_MS_interface = type { i8, i64, i16, i64, i16, i8, i32, i32 }
%CTD_interface = type { i8, i8, i16, i8, i16, i8 }
%CTU_interface = type { i8, i8, i16, i8, i16, i8 }
%CTUD_interface = type { i8, i8, i8, i8, i16, i8, i8, i16, i8, i8 }
%F_TRIG_interface = type { i8, i8, i8 }
%RS_interface = type { i8, i8, i8 }
%SR_interface = type { i8, i8, i8 }
%_BUFFER_CLEAR_interface = type { i8*, i16, i32*, i32, i32, i32 }
%_BUFFER_INIT_interface = type { i8*, i16, i8, i32*, i32, i32, i32 }
%_BUFFER_INSERT_interface = type { [251 x i8], i16, [32768 x i8]*, i16, i16, i16, i16 }
%LEN_interface = type { [1024 x i8] }
%UINT_TO_INT_interface = type { i16 }
%_STRING_TO_BUFFER_interface = type { [251 x i8], i16, [32768 x i8]*, i16, i8*, i16, i16 }
%_BUFFER_UPPERCASE_interface = type { [32001 x i8]*, i16, i16 }
%TO_UPPER_interface = type { i8 }
%BUFFER_COMP_interface = type { [32768 x i8]*, i16, [32768 x i8]*, i16, i16, i16, i16, i16, i8 }
%BUFFER_SEARCH_interface = type { [32768 x i8]*, i16, [251 x i8], i16, i8, [251 x i8]*, i8, i16, i16, i16, i16 }
%BUFFER_TO_STRING_interface = type { [32768 x i8]*, i16, i16, i16, i8*, i16, i16, i16 }
%DWORD_TO_TIME_interface = type { i32 }
%T_PLC_MS_interface = type { i8, i16, i32, i64 }
%MULTIME_interface = type { i64, float }
%TIME_TO_REAL_interface = type { i64 }
%MANUAL_interface = type { i8, i8, i8 }
%INC_interface = type { i16, i16, i16 }
%DWORD_TO_REAL_interface = type { i32 }
%TIME_TO_DWORD_interface = type { i64 }
%ABS_interface = type { i64 }
%DWORD_TO_BYTE_interface = type { i32 }
%SHL_interface = type { i64, i16 }
%SHR_interface = type { i64, i16 }
%MAX_interface = type { i64, i64 }
%MIN_interface = type { i64, i64 }
%SQRT_interface = type { i32 }
%LIMIT_interface = type { i64, i64, i64 }
%BAND_B_interface = type { i8, i8 }
%CTRL_IN_interface = type { float, float, float }
%DEAD_ZONE_interface = type { float, float }
%SEL_interface = type { i8, i64, i64 }
%DEAD_BAND_interface = type { float, float }
%T_PLC_US_interface = type { i8, i16, i32, i64 }
%R2_SET_interface = type { float }
%R2_ADD_interface = type { %REAL2, float, float }
%REAL_TO_TIME_interface = type { float }
%BFT_TO_MS_interface = type { i16 }
%EXPT_interface = type { i32, i32 }
%C_TO_F_interface = type { float }
%C_TO_K_interface = type { float }
%DEG_TO_DIR_interface = type { i16, i16, i16, i16 }
%DIR_TO_DEG_interface = type { [4 x i8], i16, i16, i16 }
%F_TO_C_interface = type { float }
%F_TO_OM_interface = type { float }
%F_TO_PT_interface = type { float }
%REAL_TO_DWORD_interface = type { float }
%GEO_TO_DEG_interface = type { i16, i16, float }
%INT_TO_REAL_interface = type { i16 }
%K_TO_C_interface = type { float }
%KMH_TO_MS_interface = type { float }
%MS_TO_BFT_interface = type { float }
%REAL_TO_INT_interface = type { float }
%MS_TO_KMH_interface = type { float }
%OM_TO_F_interface = type { float }
%PT_TO_F_interface = type { i64 }
%EXP_interface = type { i32 }
%LN_interface = type { i32 }
%DWORD_TO_DT_interface = type { i32 }
%DT_TO_DWORD_interface = type { i64 }
%FLOOR_interface = type { float }
%INT_TO_UDINT_interface = type { i16 }
%UDINT_TO_REAL_interface = type { i32 }
%YEAR_OF_DATE_interface = type { i64 }
%MONTH_OF_DATE_interface = type { i64 }
%DAY_OF_YEAR_interface = type { i64 }
%DAY_OF_WEEK_interface = type { i64 }
%BOOL_TO_UINT_interface = type { i8 }
%_TIME_interface = type {}
%MULTI_IN_interface = type { float, float, float, float, float, float, i8, i16, i8, i8, i8 }
%MID3_interface = type { float, float, float }
%RES_NI_interface = type { float, float, float, float, float, float }
%RES_NTC_interface = type { float, float, float }
%RES_PT_interface = type { float, float, float, float, float, float }
%RES_SI_interface = type { float, float, float, float, float, float }
%SENSOR_INT_interface = type { float, float, float, float, float }
%TEMP_NI_interface = type { float, float }
%TEMP_NTC_interface = type { float, float, float }
%TEMP_PT_interface = type { float, float, float, float, float, float, float, float, float, i32* }
%TEMP_SI_interface = type { float, float, float }
%FRMP_B_interface = type { i8, i8, i64, i64 }
%DWORD_TO_DINT_interface = type { i32 }
%DINT_TO_WORD_interface = type { i32 }
%WORD_TO_DINT_interface = type { i16 }
%RDM_interface = type { float, i32, i16 }
%DINT_TO_REAL_interface = type { i32 }
%TIME_TO_DINT_interface = type { i64 }
%MODR_interface = type { float, float }
%FRACT_interface = type { float }
%SIN_interface = type { i32 }
%SIGN_R_interface = type { float }
%AIN_interface = type { i32, i8, i8, float, float, i32, i32, i32, i8 }
%AOUT_interface = type { float, i8, i8, float, float, i32, float, i8 }
%AOUT1_interface = type { float, i16, i16, i16, float, float, i32, i8, float }
%BYTE_TO_RANGE_interface = type { i8, float, float }
%INC1_interface = type { i16, i16 }
%WORD_TO_REAL_interface = type { i16 }
%INT_TO_DINT_interface = type { i16 }
%DINT_TO_INT_interface = type { i32 }
%DWORD_TO_WORD_interface = type { i32 }
%WORD_TO_DWORD_interface = type { i16 }
%DEC1_interface = type { i16, i16 }
%MIX_interface = type { float, float, float }
%MUX_R2_interface = type { float, float, i8 }
%MUX_R4_interface = type { float, float, float, float, i8, i8 }
%OFFSET_interface = type { float, i8, i8, i8, i8, i8, float, float, float, float, float }
%OFFSET2_interface = type { float, i8, i8, i8, i8, i8, float, float, float, float, float }
%_OVERRIDE_interface = type { float, float, float, i8, i8, i8 }
%RANGE_TO_BYTE_interface = type { float, float, float }
%INT_TO_BYTE_interface = type { i16 }
%TRUNC_interface = type { double }
%RANGE_TO_WORD_interface = type { float, float, float }
%SCALE_interface = type { float, float, float, float, float }
%SCALE_B_interface = type { i8, i8, i8, float, float }
%BYTE_TO_REAL_interface = type { i8 }
%SCALE_B2_interface = type { i8, i8, float, float, float, float, float, float }
%SCALE_B4_interface = type { i8, i8, i8, i8, float, float, float, float, float, float, float, float, float, float }
%SCALE_B8_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }
%SCALE_D_interface = type { i32, i32, i32, float, float }
%SCALE_R_interface = type { float, float, float, float, float }
%SCALE_X2_interface = type { i8, i8, float, float, float, float, float, float }
%SCALE_X4_interface = type { i8, i8, i8, i8, float, float, float, float, float, float, float, float, float, float }
%SCALE_X8_interface = type { i8, i8, i8, i8, i8, i8, i8, i8, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }
%EVEN_interface = type { i32 }
%STAIR_interface = type { float, float }
%REAL_TO_DINT_interface = type { float }
%WORD_TO_RANGE_interface = type { i16, float, float }
%LIST_ADD_interface = type { i8, [251 x i8], [251 x i8]*, [2 x i8] }
%CHR_TO_STRING_interface = type { i8, i8* }
%CONCAT_interface = type { [1024 x i8], [1024 x i8] }
%LIST_CLEAN_interface = type { i8, [251 x i8]*, [250 x i8]*, i16, i16, i8, i8 }
%LIST_GET_interface = type { i8, i16, [251 x i8]*, i16, i16, [250 x i8]*, [250 x i8]*, i16, i8 }
%LIST_INSERT_interface = type { i8, i16, [251 x i8], [251 x i8]*, [250 x i8]*, i16, i16, [2 x i8] }
%INSERT_interface = type { [1024 x i8], [1024 x i8], i16 }
%LIST_LEN_interface = type { i8, [251 x i8]*, [250 x i8]*, i16, i8 }
%LIST_RETRIEVE_interface = type { i8, i16, [251 x i8]*, i16, i16, i16, [250 x i8]*, [250 x i8]*, i16, i8 }
%LIST_RETRIEVE_LAST_interface = type { i8, [251 x i8]*, i16, i16, [250 x i8]*, i8 }
%BCDC_TO_INT_interface = type { i8 }
%BIT_COUNT_interface = type { i32 }
%BIT_LOAD_B_interface = type { i8, i8, i16, i8 }
%BIT_LOAD_B2_interface = type { i8, i8, i16, i16 }
%ROL_interface = type { i64, i16 }
%ROR_interface = type { i64, i16 }
%BIT_LOAD_DW_interface = type { i32, i8, i16, i32 }
%BIT_LOAD_DW2_interface = type { i32, i8, i16, i16 }
%BIT_LOAD_W_interface = type { i16, i8, i16, i16 }
%BIT_LOAD_W2_interface = type { i16, i8, i16, i16 }
%BIT_OF_DWORD_interface = type { i32, i16 }
%BIT_TOGGLE_B_interface = type { i8, i16 }
%BIT_TOGGLE_DW_interface = type { i32, i16 }
%BIT_TOGGLE_W_interface = type { i16, i16 }
%BYTE_OF_BIT_interface = type { i8, i8, i8, i8, i8, i8, i8, i8 }
%BOOL_TO_BYTE_interface = type { i8 }
%BYTE_OF_DWORD_interface = type { i32, i8 }
%BYTE_TO_GRAY_interface = type { i8 }
%CHECK_PARITY_interface = type { i32, i8 }
%CHK_REAL_interface = type { float, i32*, i32 }
%DW_TO_REAL_interface = type { i32, float* }
%DWORD_OF_BYTE_interface = type { i8, i8, i8, i8 }
%BYTE_TO_DWORD_interface = type { i8 }
%DWORD_OF_WORD_interface = type { i16, i16 }
%GRAY_TO_BYTE_interface = type { i8 }
%INT_TO_BCDC_interface = type { i16 }
%MUX_2_interface = type { i8, i8, i8 }
%MUX_4_interface = type { i8, i8, i8, i8, i8, i8 }
%PARITY_interface = type { i32 }
%REAL_TO_DW_interface = type { float, i32* }
%REFLECT_interface = type { i32, i16, i16 }
%BOOL_TO_DWORD_interface = type { i8 }
%REVERSE_interface = type { i8 }
%SHL1_interface = type { i32, i16, i32 }
%SHR1_interface = type { i32, i16, i32 }
%SWAP_BYTE_interface = type { i16 }
%SWAP_BYTE2_interface = type { i32 }
%WORD_OF_BYTE_interface = type { i8, i8 }
%BYTE_TO_WORD_interface = type { i8 }
%WORD_OF_DWORD_interface = type { i32, i8 }
%INC2_interface = type { i16, i16, i16, i16, i16 }
%CRC_GEN_interface = type { [32001 x i8]*, i16, i16, i32, i32, i8, i8, i32, i16, i16, i8, i16 }
%CODE_interface = type { [251 x i8], i16, i8* }
%_ARRAY_ABS_interface = type { [32001 x float]*, i16, i16, i16 }
%_ARRAY_ADD_interface = type { [32001 x float]*, i16, float, i16, i16 }
%_ARRAY_INIT_interface = type { [32001 x float]*, i16, float, i16, i16 }
%_ARRAY_MEDIAN_interface = type { [32001 x float]*, i16, i16, i16 }
%_ARRAY_SORT_interface = type { [32000 x float]*, i16, i16, [32 x i16], i16, i16, float, i16, i16, i8, i8, float }
%_ARRAY_MUL_interface = type { [32001 x float]*, i16, float, i16, i16 }
%_ARRAY_SHUFFLE_interface = type { [32001 x float]*, i16, float, i16, i16, i16 }
%RDM2_interface = type { i16, i16, i16 }
%ARRAY_AVG_interface = type { [32001 x float]*, i16, i16, i16 }
%UINT_TO_REAL_interface = type { i16 }
%ARRAY_GAV_interface = type { [32001 x float]*, i16, i16, i16 }
%SQRTN_interface = type { float, i16 }
%ARRAY_HAV_interface = type { [32001 x float]*, i16, i16, i16 }
%ARRAY_MAX_interface = type { [32001 x float]*, i16, i16, i16 }
%SIZEOF_interface = type { i64 }
%ARRAY_MIN_interface = type { [32001 x float]*, i16, i16, i16 }
%ARRAY_SDV_interface = type { [32001 x float]*, i16 }
%ARRAY_VAR_interface = type { [32001 x float]*, i16, float, i16, i16 }
%ARRAY_SPR_interface = type { [32001 x float]*, i16, i16, i16, float, float }
%ARRAY_SUM_interface = type { [32001 x float]*, i16, i16, i16 }
%ARRAY_TREND_interface = type { [32001 x float]*, i16, i16, i16, float, i16 }
%IS_SORTED_interface = type { [32001 x float]*, i16, i16, i16 }
%CABS_interface = type { %COMPLEX }
%HYPOT_interface = type { float, float }
%CACOS_interface = type { %COMPLEX, %COMPLEX }
%CACOSH_interface = type { %COMPLEX, %COMPLEX }
%CSQRT_interface = type { %COMPLEX, float }
%CLOG_interface = type { %COMPLEX }
%CADD_interface = type { %COMPLEX, %COMPLEX }
%CARG_interface = type { %COMPLEX }
%ATAN2_interface = type { float, float }
%CASIN_interface = type { %COMPLEX, %COMPLEX }
%CASINH_interface = type { %COMPLEX, %COMPLEX }
%CATAN_interface = type { %COMPLEX, float, float, float }
%ATAN_interface = type { double }
%CATANH_interface = type { %COMPLEX, float, float, float }
%CCON_interface = type { %COMPLEX }
%CCOS_interface = type { %COMPLEX }
%CCOSH_interface = type { %COMPLEX }
%CSET_interface = type { float, float }
%COSH_interface = type { float, float }
%COS_interface = type { i32 }
%SINH_interface = type { float }
%CDIV_interface = type { %COMPLEX, %COMPLEX, float }
%CEXP_interface = type { %COMPLEX, float }
%CINV_interface = type { %COMPLEX, float }
%CMUL_interface = type { %COMPLEX, %COMPLEX }
%CPOL_interface = type { float, float }
%CPOW_interface = type { %COMPLEX, %COMPLEX }
%CSIN_interface = type { %COMPLEX }
%CSINH_interface = type { %COMPLEX }
%SGN_interface = type { float }
%CSUB_interface = type { %COMPLEX, %COMPLEX }
%CTAN_interface = type { %COMPLEX, float, float, float }
%CTANH_interface = type { %COMPLEX, float, float, float }
%R2_ABS_interface = type { %REAL2 }
%R2_ADD2_interface = type { %REAL2, %REAL2 }
%R2_MUL_interface = type { %REAL2, float }
%F_LIN_interface = type { float, float, float }
%F_LIN2_interface = type { float, float, float, float, float }
%F_POLY_interface = type { float, [8 x float] }
%F_POWER_interface = type { float, float, float }
%F_QUAD_interface = type { float, float, float, float }
%LINEAR_INT_interface = type { float, [40 x float], i16, i16 }
%POLYNOM_INT_interface = type { float, [10 x float], i16, i16, i16, i16 }
%CIRCLE_A_interface = type { float, float }
%CIRCLE_C_interface = type { float, float }
%CIRCLE_SEG_interface = type { float, float }
%ACOS_interface = type { i32 }
%CONE_V_interface = type { float, float }
%ELLIPSE_A_interface = type { float, float }
%ELLIPSE_C_interface = type { float, float }
%SPHERE_V_interface = type { float }
%TRIANGLE_A_interface = type { float, float, float, float }
%RAD_interface = type { float }
%V3_ABS_interface = type { %VECTOR_3 }
%V3_ADD_interface = type { %VECTOR_3, %VECTOR_3 }
%V3_ANG_interface = type { %VECTOR_3, %VECTOR_3, float }
%V3_DPRO_interface = type { %VECTOR_3, %VECTOR_3 }
%V3_NORM_interface = type { %VECTOR_3, float }
%V3_SMUL_interface = type { %VECTOR_3, float }
%V3_NUL_interface = type { %VECTOR_3 }
%V3_PAR_interface = type { %VECTOR_3, %VECTOR_3 }
%V3_XPRO_interface = type { %VECTOR_3, %VECTOR_3 }
%V3_REV_interface = type { %VECTOR_3 }
%V3_SUB_interface = type { %VECTOR_3, %VECTOR_3 }
%V3_XANG_interface = type { %VECTOR_3, float }
%V3_YANG_interface = type { %VECTOR_3, float }
%V3_ZANG_interface = type { %VECTOR_3, float }
%ACOSH_interface = type { float }
%ACOTH_interface = type { float }
%AGDF_interface = type { float }
%ASINH_interface = type { float }
%ATANH_interface = type { float }
%BETA_interface = type { float, float }
%GAMMA_interface = type { float }
%BINOM_interface = type { i16, i16, i16 }
%CAUCHY_interface = type { float, float, float, float }
%CAUCHYCD_interface = type { float, float, float }
%CEIL_interface = type { float }
%CEIL2_interface = type { float }
%CMP_interface = type { float, float, i16, float }
%EXP10_interface = type { float }
%LOG_interface = type { i64 }
%COTH_interface = type { float }
%D_TRUNC_interface = type { float }
%DEG_interface = type { float }
%DIFFER_interface = type { float, float, float }
%ERF_interface = type { float, float, float }
%ERFC_interface = type { float }
%EXPN_interface = type { float, i16, i8 }
%FACT_interface = type { i16 }
%FIB_interface = type { i16, i32, i32 }
%FLOOR2_interface = type { float }
%GAUSS_interface = type { float, float, float, float, float }
%GAUSSCD_interface = type { float, float, float }
%GCD_interface = type { i32, i32, i32 }
%GDF_interface = type { float }
%GOLD_interface = type { float }
%INV_interface = type { float }
%LAMBERT_W_interface = type { float, float, i16, float, float, i32, float }
%LANGEVIN_interface = type { float }
%MAX3_interface = type { float, float, float }
%MIN3_interface = type { float, float, float }
%MUL_ADD_interface = type { float, float, float }
%NEGX_interface = type { float }
%INT_TO_DWORD_interface = type { i16 }
%RDMDW_interface = type { i32, float, float }
%REAL_TO_FRAC_interface = type { float, i16, i32, i8, i32, float, i32, i32, i32, i32 }
%RND_interface = type { float, i16, float }
%ROUND_interface = type { float, i16, float }
%SIGMOID_interface = type { float }
%SIGN_I_interface = type { i32 }
%SINC_interface = type { float }
%TANC_interface = type { float }
%TAN_interface = type { i32 }
%TANH_interface = type { float }
%WINDOW_interface = type { float, float, float }
%WINDOW2_interface = type { float, float, float }
%STATUS_TO_ESR_interface = type { i8, [11 x i8], i64, i64 }
%OSCAT_VERSION_interface = type { i8 }
%DATE_TO_DWORD_interface = type { i64 }
%BIN_TO_BYTE_interface = type { [13 x i8], i8*, i16, i8, i16 }
%BIN_TO_DWORD_interface = type { [41 x i8], i8*, i16, i8, i16 }
%BYTE_TO_STRB_interface = type { i8, i16, i8* }
%BYTE_TO_STRH_interface = type { i8, i8, i8* }
%CAPITALIZE_interface = type { [251 x i8], i8*, i16, i16, i8 }
%CHARCODE_interface = type { [11 x i8], [2 x i8], [11 x i8], i16, i16 }
%STRING_EQUAL_interface = type { [1025 x i8], [1025 x i8] }
%FIND_interface = type { [1024 x i8], [1024 x i8] }
%MID_interface = type { [1024 x i8], i16, i16 }
%CHARNAME_interface = type { i8, i16, i16 }
%LEFT_interface = type { [1024 x i8], i16 }
%CLEAN_interface = type { [251 x i8], [81 x i8], i16, i16 }
%DELETE_interface = type { [1024 x i8], i16, i16 }
%COUNT_CHAR_interface = type { [251 x i8], i8, i16, i8*, i16 }
%COUNT_SUBSTRING_interface = type { [81 x i8], [81 x i8], i16, i16 }
%REPLACE_interface = type { [1024 x i8], [1024 x i8], i16, i16 }
%DEC_TO_BYTE_interface = type { [11 x i8], i8*, i16, i8, i16 }
%DEC_TO_DWORD_interface = type { [21 x i8], i8*, i16, i8, i16 }
%DEC_TO_INT_interface = type { [11 x i8], i8*, i16, i8, i8, i16 }
%DEL_CHARS_interface = type { [251 x i8], [81 x i8], i16, i16 }
%DT_TO_STRF_interface = type { i64, i16, [81 x i8], i16, [2 x i8], [2 x i8], i16, i64, [11 x i8], i64, i16, i16, i16 }
%DT_TO_DATE_interface = type { i64 }
%DT_TO_TOD_interface = type { i64 }
%INT_TO_STRING_interface = type { i16 }
%RIGHT_interface = type { [1024 x i8], i16 }
%MONTH_TO_STRING_interface = type { i16, i16, i16, i16 }
%WEEKDAY_TO_STRING_interface = type { i16, i16, i16, i16 }
%HOUR_interface = type { i64 }
%DAY_OF_MONTH_interface = type { i64, i16 }
%MINUTE_interface = type { i64 }
%SECOND_interface = type { i64 }
%DWORD_TO_STRB_interface = type { i32, i8*, i16 }
%DWORD_TO_STRF_interface = type { i32, i16 }
%FIX_interface = type { [251 x i8], i16, i8, i16, i16, [251 x i8] }
%DWORD_TO_STRING_interface = type { i32 }
%DWORD_TO_STRH_interface = type { i32, i16, i8, i8* }
%EXEC_interface = type { [251 x i8], i16, float, float, [11 x i8] }
%UPPERCASE_interface = type { [251 x i8], i8*, i16, i16 }
%TRIM_interface = type { [251 x i8], i16 }
%FINDB_NONUM_interface = type { [251 x i8], i16, i8* }
%STRING_TO_REAL_interface = type { [81 x i8] }
%FINDB_NUM_interface = type { [251 x i8], i16, i8* }
%REAL_TO_STRING_interface = type { float }
%FILL_interface = type { i8, i16, i16, [2 x i8] }
%FIND_CHAR_interface = type { [251 x i8], i16, i16, [255 x i8]*, i16, i8 }
%FIND_CTRL_interface = type { [251 x i8], i16, i16, [255 x i8]*, i16, i8 }
%FIND_NONUM_interface = type { [251 x i8], i16, i16, [255 x i8]*, i16, i8 }
%FIND_NUM_interface = type { [251 x i8], i16, i16, [255 x i8]*, i16, i8 }
%FINDB_interface = type { [251 x i8], [251 x i8], i16, i16 }
%FINDP_interface = type { [251 x i8], [251 x i8], i16, i16, i16, i16, i16 }
%FLOAT_TO_REAL_interface = type { [21 x i8], [20 x i8]*, i16, i8, i16, i16, i32, i16 }
%FSTRING_TO_BYTE_interface = type { [13 x i8] }
%OCT_TO_BYTE_interface = type { [11 x i8], i8*, i16, i8, i16 }
%HEX_TO_BYTE_interface = type { [6 x i8], i8*, i16, i8, i16 }
%FSTRING_TO_DT_interface = type { [61 x i8], [61 x i8], [2 x i8], [2 x i8], [2 x i8], [21 x i8], i16, i16, i16, i16, i16, i16, i16 }
%SET_DT_interface = type { i16, i16, i16, i16, i16, i16 }
%STRING_TO_INT_interface = type { [81 x i8] }
%FSTRING_TO_MONTH_interface = type { [21 x i8], i16, i16 }
%FSTRING_TO_DWORD_interface = type { [41 x i8] }
%OCT_TO_DWORD_interface = type { [21 x i8], i8*, i16, i8, i16 }
%HEX_TO_DWORD_interface = type { [21 x i8], i8*, i16, i8, i16 }
%LOWERCASE_interface = type { [251 x i8], i8*, i16, i16 }
%FSTRING_TO_WEEK_interface = type { [61 x i8], i16, i16 }
%FSTRING_TO_WEEKDAY_interface = type { [21 x i8], i16, [3 x i8], i16, i16 }
%IS_ALNUM_interface = type { [251 x i8], i16, i8*, i16 }
%ISC_ALPHA_interface = type { i8 }
%ISC_NUM_interface = type { i8 }
%IS_ALPHA_interface = type { [251 x i8], i16, i8*, i16 }
%IS_CC_interface = type { [251 x i8], [251 x i8], i16, i16 }
%IS_CTRL_interface = type { [251 x i8], i16, i8*, i16 }
%ISC_CTRL_interface = type { i8 }
%IS_HEX_interface = type { [251 x i8], i16, i8*, i16 }
%ISC_HEX_interface = type { i8 }
%IS_LOWER_interface = type { [251 x i8], i16, i8*, i16 }
%ISC_LOWER_interface = type { i8 }
%IS_NCC_interface = type { [251 x i8], [251 x i8], i16, i16 }
%IS_NUM_interface = type { [251 x i8], i16, i8*, i16 }
%IS_UPPER_interface = type { [251 x i8], i16, i8*, i16 }
%ISC_UPPER_interface = type { i8 }
%TO_LOWER_interface = type { i8 }
%MIRROR_interface = type { [251 x i8], [255 x i8]*, i8*, i16, i16 }
%REAL_TO_STRF_interface = type { float, i16, [2 x i8], float, i16 }
%DINT_TO_STRING_interface = type { i32 }
%REPLACE_ALL_interface = type { [251 x i8], [251 x i8], [251 x i8], i16, i16, i16 }
%REPLACE_CHARS_interface = type { [251 x i8], [81 x i8], [81 x i8], i16, i16, [2 x i8], i16 }
%REPLACE_UML_interface = type { [251 x i8], i16, i8*, i8*, i8*, i8*, i8*, [3 x i8], i16 }
%TO_UML_interface = type { i8 }
%TRIM1_interface = type { [251 x i8], i16 }
%TRIME_interface = type { [251 x i8] }
%UTC_TO_LTIME_interface = type { i64, i8, i16, i16 }
%DAY_OF_DATE_interface = type { i64 }
%DST_interface = type { i64, i16, i32, i32, i32 }
%DINT_TO_TOD_interface = type { i32 }
%TOD_TO_DINT_interface = type { i64 }
%WORK_WEEK_interface = type { i64, i64, i16, i32, i16, i16, i16, i16 }
%DATE_ADD_interface = type { i64, i16, i16, i16, i16, i16, i16, i16 }
%UDINT_TO_DATE_interface = type { i32 }
%DATE_TO_UDINT_interface = type { i64 }
%SET_DATE_interface = type { i16, i16, i16, i16 }
%BOOL_TO_INT_interface = type { i8 }
%LEAP_OF_DATE_interface = type { i64 }
%DWORD_TO_INT_interface = type { i32 }
%UDINT_TO_INT_interface = type { i32 }
%DAY_TO_TIME_interface = type { float }
%DAYS_DELTA_interface = type { i64, i64 }
%DAYS_IN_MONTH_interface = type { i64 }
%DAYS_IN_YEAR_interface = type { i64 }
%TIME_TO_INT_interface = type { i64 }
%DT2_TO_SDT_interface = type { i64, i64 }
%TOD_TO_DWORD_interface = type { i64 }
%DT_TO_SDT_interface = type { i64, i64, i32 }
%EASTER_interface = type { i16, i16, i16, i16 }
%HOUR_OF_DT_interface = type { i64 }
%HOUR_TO_TIME_interface = type { float }
%HOUR_TO_TOD_interface = type { float }
%DWORD_TO_TOD_interface = type { i32 }
%JD2000_interface = type { i64 }
%LEAP_DAY_interface = type { i64 }
%LEAP_YEAR_interface = type { i16 }
%LTIME_TO_UTC_interface = type { i64, i8, i16 }
%UDINT_TO_DT_interface = type { i32 }
%DT_TO_UDINT_interface = type { i64 }
%MINUTE_OF_DT_interface = type { i64 }
%MINUTE_TO_TIME_interface = type { float }
%MONTH_BEGIN_interface = type { i64 }
%DWORD_TO_DATE_interface = type { i32 }
%MONTH_END_interface = type { i64 }
%PERIOD_interface = type { i64, i64, i64, i16, i16, i16 }
%PERIOD2_interface = type { [8 x i64], i64 }
%REFRACTION_interface = type { float }
%SDT_TO_DATE_interface = type { %SDT }
%SDT_TO_DT_interface = type { %SDT }
%SDT_TO_TOD_interface = type { %SDT }
%SECOND_OF_DT_interface = type { i64 }
%SECOND_TO_TIME_interface = type { float }
%SET_TOD_interface = type { i16, i16, float }
%SUN_MIDDAY_interface = type { float, i64, float, float }
%ASIN_interface = type { double }
%TIMECHECK_interface = type { i64, i64, i64 }
%YEAR_BEGIN_interface = type { i16 }
%YEAR_END_interface = type { i16 }
%ADR_interface = type { i64 }
%BOOL_TO_DATE_interface = type { i8 }
%BOOL_TO_DINT_interface = type { i8 }
%BOOL_TO_DT_interface = type { i8 }
%BOOL_TO_LREAL_interface = type { i8 }
%BOOL_TO_REAL_interface = type { i8 }
%BOOL_TO_SINT_interface = type { i8 }
%BOOL_TO_STRING_interface = type { i8 }
%BOOL_TO_TIME_interface = type { i8 }
%BOOL_TO_TOD_interface = type { i8 }
%BOOL_TO_UDINT_interface = type { i8 }
%BOOL_TO_USINT_interface = type { i8 }
%BOOL_TO_WORD_interface = type { i8 }
%BYTE_TO_BOOL_interface = type { i8 }
%BYTE_TO_DATE_interface = type { i8 }
%BYTE_TO_DINT_interface = type { i8 }
%BYTE_TO_DT_interface = type { i8 }
%BYTE_TO_INT_interface = type { i8 }
%BYTE_TO_LREAL_interface = type { i8 }
%BYTE_TO_SINT_interface = type { i8 }
%BYTE_TO_STRING_interface = type { i8 }
%BYTE_TO_TIME_interface = type { i8 }
%BYTE_TO_TOD_interface = type { i8 }
%BYTE_TO_UDINT_interface = type { i8 }
%BYTE_TO_UINT_interface = type { i8 }
%BYTE_TO_USINT_interface = type { i8 }
%DATE_TO_BOOL_interface = type { i64 }
%DATE_TO_BYTE_interface = type { i64 }
%DATE_TO_DINT_interface = type { i64 }
%DATE_TO_DT_interface = type { i64 }
%DATE_TO_INT_interface = type { i64 }
%DATE_TO_LREAL_interface = type { i64 }
%DATE_TO_REAL_interface = type { i64 }
%DATE_TO_SINT_interface = type { i64 }
%DATE_TO_STRING_interface = type { i64 }
%DATE_TO_TIME_interface = type { i64 }
%DATE_TO_TOD_interface = type { i64 }
%DATE_TO_UINT_interface = type { i64 }
%DATE_TO_USINT_interface = type { i64 }
%DATE_TO_WORD_interface = type { i64 }
%DINT_TO_BOOL_interface = type { i32 }
%DINT_TO_BYTE_interface = type { i32 }
%DINT_TO_DATE_interface = type { i32 }
%DINT_TO_DT_interface = type { i32 }
%DINT_TO_DWORD_interface = type { i32 }
%DINT_TO_LREAL_interface = type { i32 }
%DINT_TO_SINT_interface = type { i32 }
%DINT_TO_TIME_interface = type { i32 }
%DINT_TO_UDINT_interface = type { i32 }
%DINT_TO_UINT_interface = type { i32 }
%DINT_TO_USINT_interface = type { i32 }
%DT_TO_BOOL_interface = type { i64 }
%DT_TO_BYTE_interface = type { i64 }
%DT_TO_DINT_interface = type { i64 }
%DT_TO_INT_interface = type { i64 }
%DT_TO_LREAL_interface = type { i64 }
%DT_TO_REAL_interface = type { i64 }
%DT_TO_SINT_interface = type { i64 }
%DT_TO_STRING_interface = type { i64 }
%DT_TO_TIME_interface = type { i64 }
%DT_TO_UINT_interface = type { i64 }
%DT_TO_USINT_interface = type { i64 }
%DT_TO_WORD_interface = type { i64 }
%DWORD_TO_BOOL_interface = type { i32 }
%DWORD_TO_LREAL_interface = type { i32 }
%DWORD_TO_SINT_interface = type { i32 }
%DWORD_TO_UDINT_interface = type { i32 }
%DWORD_TO_UINT_interface = type { i32 }
%DWORD_TO_USINT_interface = type { i32 }
%INT_TO_BOOL_interface = type { i16 }
%INT_TO_DATE_interface = type { i16 }
%INT_TO_DT_interface = type { i16 }
%INT_TO_LREAL_interface = type { i16 }
%INT_TO_SINT_interface = type { i16 }
%INT_TO_TIME_interface = type { i16 }
%INT_TO_TOD_interface = type { i16 }
%INT_TO_UINT_interface = type { i16 }
%INT_TO_USINT_interface = type { i16 }
%INT_TO_WORD_interface = type { i16 }
%LREAL_TO_BOOL_interface = type { double }
%LREAL_TO_BYTE_interface = type { double }
%LREAL_TO_DATE_interface = type { double }
%LREAL_TO_DINT_interface = type { double }
%LREAL_TO_DT_interface = type { double }
%LREAL_TO_DWORD_interface = type { double }
%LREAL_TO_INT_interface = type { double }
%LREAL_TO_REAL_interface = type { double }
%LREAL_TO_SINT_interface = type { double }
%LREAL_TO_STRING_interface = type { double }
%LREAL_TO_TIME_interface = type { double }
%LREAL_TO_TOD_interface = type { double }
%LREAL_TO_UDINT_interface = type { double }
%LREAL_TO_UINT_interface = type { double }
%LREAL_TO_USINT_interface = type { double }
%LREAL_TO_WORD_interface = type { double }
%MOVE_interface = type { i64 }
%MUX_interface = type { i32, i64 }
%REAL_TO_BOOL_interface = type { float }
%REAL_TO_BYTE_interface = type { float }
%REAL_TO_DATE_interface = type { float }
%REAL_TO_DT_interface = type { float }
%REAL_TO_LREAL_interface = type { float }
%REAL_TO_SINT_interface = type { float }
%REAL_TO_TOD_interface = type { float }
%REAL_TO_UDINT_interface = type { float }
%REAL_TO_UINT_interface = type { float }
%REAL_TO_USINT_interface = type { float }
%REAL_TO_WORD_interface = type { float }
%SINT_TO_BOOL_interface = type { i8 }
%SINT_TO_BYTE_interface = type { i8 }
%SINT_TO_DATE_interface = type { i8 }
%SINT_TO_DINT_interface = type { i8 }
%SINT_TO_DT_interface = type { i8 }
%SINT_TO_DWORD_interface = type { i8 }
%SINT_TO_INT_interface = type { i8 }
%SINT_TO_LREAL_interface = type { i8 }
%SINT_TO_REAL_interface = type { i8 }
%SINT_TO_STRING_interface = type { i8 }
%SINT_TO_TIME_interface = type { i8 }
%SINT_TO_TOD_interface = type { i8 }
%SINT_TO_UDINT_interface = type { i8 }
%SINT_TO_UINT_interface = type { i8 }
%SINT_TO_USINT_interface = type { i8 }
%SINT_TO_WORD_interface = type { i8 }
%STRING_TO_BOOL_interface = type { [81 x i8] }
%STRING_TO_BYTE_interface = type { [81 x i8] }
%STRING_TO_DATE_interface = type { [81 x i8] }
%STRING_TO_DINT_interface = type { [81 x i8] }
%STRING_TO_DT_interface = type { [81 x i8] }
%STRING_TO_DWORD_interface = type { [81 x i8] }
%STRING_TO_LREAL_interface = type { [81 x i8] }
%STRING_TO_SINT_interface = type { [81 x i8] }
%STRING_TO_TIME_interface = type { [81 x i8] }
%STRING_TO_TOD_interface = type { [81 x i8] }
%STRING_TO_UDINT_interface = type { [81 x i8] }
%STRING_TO_UINT_interface = type { [81 x i8] }
%STRING_TO_USINT_interface = type { [81 x i8] }
%STRING_TO_WORD_interface = type { [81 x i8] }
%TIME_TO_BOOL_interface = type { i64 }
%TIME_TO_BYTE_interface = type { i64 }
%TIME_TO_DATE_interface = type { i64 }
%TIME_TO_DT_interface = type { i64 }
%TIME_TO_LREAL_interface = type { i64 }
%TIME_TO_SINT_interface = type { i64 }
%TIME_TO_STRING_interface = type { i64 }
%TIME_TO_TOD_interface = type { i64 }
%TIME_TO_UDINT_interface = type { i64 }
%TIME_TO_UINT_interface = type { i64 }
%TIME_TO_USINT_interface = type { i64 }
%TIME_TO_WORD_interface = type { i64 }
%TOD_TO_BOOL_interface = type { i64 }
%TOD_TO_BYTE_interface = type { i64 }
%TOD_TO_DATE_interface = type { i64 }
%TOD_TO_DT_interface = type { i64 }
%TOD_TO_INT_interface = type { i64 }
%TOD_TO_LREAL_interface = type { i64 }
%TOD_TO_REAL_interface = type { i64 }
%TOD_TO_SINT_interface = type { i64 }
%TOD_TO_STRING_interface = type { i64 }
%TOD_TO_TIME_interface = type { i64 }
%TOD_TO_UDINT_interface = type { i64 }
%TOD_TO_UINT_interface = type { i64 }
%TOD_TO_USINT_interface = type { i64 }
%TOD_TO_WORD_interface = type { i64 }
%TOLOWERCASE_interface = type { [1024 x i8] }
%TOUPPERCASE_interface = type { [1024 x i8] }
%UDINT_TO_BOOL_interface = type { i32 }
%UDINT_TO_BYTE_interface = type { i32 }
%UDINT_TO_DINT_interface = type { i32 }
%UDINT_TO_DWORD_interface = type { i32 }
%UDINT_TO_LREAL_interface = type { i32 }
%UDINT_TO_SINT_interface = type { i32 }
%UDINT_TO_STRING_interface = type { i32 }
%UDINT_TO_TIME_interface = type { i32 }
%UDINT_TO_TOD_interface = type { i32 }
%UDINT_TO_UINT_interface = type { i32 }
%UDINT_TO_USINT_interface = type { i32 }
%UDINT_TO_WORD_interface = type { i32 }
%UINT_TO_BOOL_interface = type { i16 }
%UINT_TO_BYTE_interface = type { i16 }
%UINT_TO_DATE_interface = type { i16 }
%UINT_TO_DINT_interface = type { i16 }
%UINT_TO_DT_interface = type { i16 }
%UINT_TO_DWORD_interface = type { i16 }
%UINT_TO_LREAL_interface = type { i16 }
%UINT_TO_SINT_interface = type { i16 }
%UINT_TO_STRING_interface = type { i16 }
%UINT_TO_TIME_interface = type { i16 }
%UINT_TO_TOD_interface = type { i16 }
%UINT_TO_UDINT_interface = type { i16 }
%UINT_TO_USINT_interface = type { i16 }
%UINT_TO_WORD_interface = type { i16 }
%USINT_TO_BOOL_interface = type { i8 }
%USINT_TO_BYTE_interface = type { i8 }
%USINT_TO_DATE_interface = type { i8 }
%USINT_TO_DINT_interface = type { i8 }
%USINT_TO_DT_interface = type { i8 }
%USINT_TO_DWORD_interface = type { i8 }
%USINT_TO_INT_interface = type { i8 }
%USINT_TO_LREAL_interface = type { i8 }
%USINT_TO_REAL_interface = type { i8 }
%USINT_TO_SINT_interface = type { i8 }
%USINT_TO_STRING_interface = type { i8 }
%USINT_TO_TIME_interface = type { i8 }
%USINT_TO_TOD_interface = type { i8 }
%USINT_TO_UDINT_interface = type { i8 }
%USINT_TO_UINT_interface = type { i8 }
%USINT_TO_WORD_interface = type { i8 }
%WORD_TO_BOOL_interface = type { i16 }
%WORD_TO_BYTE_interface = type { i16 }
%WORD_TO_DATE_interface = type { i16 }
%WORD_TO_DT_interface = type { i16 }
%WORD_TO_INT_interface = type { i16 }
%WORD_TO_LREAL_interface = type { i16 }
%WORD_TO_SINT_interface = type { i16 }
%WORD_TO_STRING_interface = type { i16 }
%WORD_TO_TIME_interface = type { i16 }
%WORD_TO_TOD_interface = type { i16 }
%WORD_TO_UDINT_interface = type { i16 }
%WORD_TO_UINT_interface = type { i16 }
%WORD_TO_USINT_interface = type { i16 }

@CALENDAR__init = unnamed_addr constant %CALENDAR zeroinitializer
@COMPLEX__init = unnamed_addr constant %COMPLEX zeroinitializer
@CONSTANTS_LANGUAGE__init = unnamed_addr constant %CONSTANTS_LANGUAGE { i16 1, i16 3, [21 x [11 x i8]] zeroinitializer, [21 x [3 x i8]] zeroinitializer, [36 x [11 x i8]] zeroinitializer, [36 x [4 x i8]] zeroinitializer, [48 x [4 x i8]] zeroinitializer }
@CONSTANTS_LOCATION__init = unnamed_addr constant %CONSTANTS_LOCATION { i16 1, i16 5, [5 x i16] [i16 2, i16 2, i16 3, i16 2, i16 2] }
@CONSTANTS_MATH__init = unnamed_addr constant %CONSTANTS_MATH { float 0x400921FB60000000, float 0x401921FB60000000, float 0x402921FB60000000, float 0x3FF921FB60000000, float 0x3FE921FB60000000, float 0x3FD45F3060000000, float 0x4005BF0A80000000, float 0x3FD78B5640000000, float 0x3FF6A09E60000000, [13 x i32] [i32 1, i32 1, i32 2, i32 6, i32 24, i32 120, i32 720, i32 5040, i32 40320, i32 362880, i32 3628800, i32 39916800, i32 479001600] }
@CONSTANTS_PHYS__init = unnamed_addr constant %CONSTANTS_PHYS { float 0x41B1DE7840000000, float 0x3C07A4DA00000000, float 0x40239D0140000000, float 0xC071126660000000, float 0x4020A10280000000, float 1.013250e+05 }
@CONSTANTS_SETUP__init = unnamed_addr constant %CONSTANTS_SETUP { i8 1, [4 x [254 x i8]] [[254 x i8] c";\22&quot;&&amp;<&lt;>&gt;\EF\BF\BD&euro;\EF\BF\BD&nbsp;\EF\BF\BD&iexcl;\EF\BF\BD&cent;\EF\BF\BD&pound;\EF\BF\BD&curren;\EF\BF\BD&yen;\EF\BF\BD&brvbar;\EF\BF\BD&sect;\EF\BF\BD&uml;\EF\BF\BD&copy;\EF\BF\BD&ordf;\EF\BF\BD&laquo;\EF\BF\BD&not;\EF\BF\BD&shy;\EF\BF\BD&reg;\EF\BF\BD&macr;\EF\BF\BD&deg;\EF\BF\BD&plusmn;\EF\BF\BD&sup2;\EF\BF\BD&sup3;\EF\BF\BD&acute;\EF\BF\BD&micro;\EF\BF\BD&para;\EF\BF\BD&midd\00", [254 x i8] c";\EF\BF\BD&frac34;\EF\BF\BD&iquest;\EF\BF\BD&Agrave;\EF\BF\BD&Aacute;\EF\BF\BD&Acirc;\EF\BF\BD&Atilde;\EF\BF\BD&Auml;\EF\BF\BD&Aring;\EF\BF\BD&AElig;\EF\BF\BD&Ccedil;\EF\BF\BD&Egrave;\EF\BF\BD&Eacute;\EF\BF\BD&Ecirc;\EF\BF\BD&Euml;\EF\BF\BD&Igrave;\EF\BF\BD&Iacute;\EF\BF\BD&Icirc;\EF\BF\BD&Iuml;\EF\BF\BD&ETH;\EF\BF\BD&Ntilde;\EF\BF\BD&Ograve;\EF\BF\BD&Oacute;\EF\BF\BD&Ocirc;\EF\BF\BD&Otilde;\EF\BF\BD\00", [254 x i8] c";\EF\BF\BD&Uuml;\EF\BF\BD&Yacute;\EF\BF\BD&THORN;\EF\BF\BD&szlig;\EF\BF\BD&agrave;\EF\BF\BD&aacute;\EF\BF\BD&acirc;\EF\BF\BD&atilde;\EF\BF\BD&auml;\EF\BF\BD&aring;\EF\BF\BD&aelig;\EF\BF\BD&ccedil;\EF\BF\BD&egrave;\EF\BF\BD&eacute;\EF\BF\BD&ecirc;\EF\BF\BD&euml;\EF\BF\BD&igrave;\EF\BF\BD&iacute;\EF\BF\BD&icirc;\EF\BF\BD&iuml;\EF\BF\BD&eth;\EF\BF\BD&ntilde;\EF\BF\BD&ograve;\EF\BF\BD&oacute;\EF\BF\BD&oc\00", [254 x i8] c";\EF\BF\BD&uacute;\EF\BF\BD&ucirc;\EF\BF\BD&uuml;\EF\BF\BD&yacute;\EF\BF\BD&thorn;\EF\BF\BD&yuml;\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00"], [12 x i16] [i16 0, i16 31, i16 59, i16 90, i16 120, i16 151, i16 181, i16 212, i16 243, i16 273, i16 304, i16 334], [9 x float] [float 1.000000e+00, float 1.000000e+01, float 1.000000e+02, float 1.000000e+03, float 1.000000e+04, float 1.000000e+04, float 1.000000e+05, float 1.000000e+06, float 1.000000e+07] }
@ESR_DATA__init = unnamed_addr constant %ESR_DATA zeroinitializer
@FRACTION__init = unnamed_addr constant %FRACTION zeroinitializer
@HOLIDAY_DATA__init = unnamed_addr constant %HOLIDAY_DATA zeroinitializer
@REAL2__init = unnamed_addr constant %REAL2 zeroinitializer
@SDT__init = unnamed_addr constant %SDT zeroinitializer
@TIMER_EVENT__init = unnamed_addr constant %TIMER_EVENT zeroinitializer
@VECTOR_3__init = unnamed_addr constant %VECTOR_3 zeroinitializer
@STRING_LENGTH = unnamed_addr constant i16 250
@LIST_LENGTH = unnamed_addr constant i16 250
@MATH = global %CONSTANTS_MATH { float 0x400921FB60000000, float 0x401921FB60000000, float 0x402921FB60000000, float 0x3FF921FB60000000, float 0x3FE921FB60000000, float 0x3FD45F3060000000, float 0x4005BF0A80000000, float 0x3FD78B5640000000, float 0x3FF6A09E60000000, [13 x i32] [i32 1, i32 1, i32 2, i32 6, i32 24, i32 120, i32 720, i32 5040, i32 40320, i32 362880, i32 3628800, i32 39916800, i32 479001600] }
@PHYS = global %CONSTANTS_PHYS { float 0x41B1DE7840000000, float 0x3C07A4DA00000000, float 0x40239D0140000000, float 0xC071126660000000, float 0x4020A10280000000, float 1.013250e+05 }
@LANGUAGE = global %CONSTANTS_LANGUAGE { i16 1, i16 3, [21 x [11 x i8]] zeroinitializer, [21 x [3 x i8]] zeroinitializer, [36 x [11 x i8]] zeroinitializer, [36 x [4 x i8]] zeroinitializer, [48 x [4 x i8]] zeroinitializer }
@SETUP = global %CONSTANTS_SETUP { i8 1, [4 x [254 x i8]] [[254 x i8] c";\22&quot;&&amp;<&lt;>&gt;\EF\BF\BD&euro;\EF\BF\BD&nbsp;\EF\BF\BD&iexcl;\EF\BF\BD&cent;\EF\BF\BD&pound;\EF\BF\BD&curren;\EF\BF\BD&yen;\EF\BF\BD&brvbar;\EF\BF\BD&sect;\EF\BF\BD&uml;\EF\BF\BD&copy;\EF\BF\BD&ordf;\EF\BF\BD&laquo;\EF\BF\BD&not;\EF\BF\BD&shy;\EF\BF\BD&reg;\EF\BF\BD&macr;\EF\BF\BD&deg;\EF\BF\BD&plusmn;\EF\BF\BD&sup2;\EF\BF\BD&sup3;\EF\BF\BD&acute;\EF\BF\BD&micro;\EF\BF\BD&para;\EF\BF\BD&midd\00", [254 x i8] c";\EF\BF\BD&frac34;\EF\BF\BD&iquest;\EF\BF\BD&Agrave;\EF\BF\BD&Aacute;\EF\BF\BD&Acirc;\EF\BF\BD&Atilde;\EF\BF\BD&Auml;\EF\BF\BD&Aring;\EF\BF\BD&AElig;\EF\BF\BD&Ccedil;\EF\BF\BD&Egrave;\EF\BF\BD&Eacute;\EF\BF\BD&Ecirc;\EF\BF\BD&Euml;\EF\BF\BD&Igrave;\EF\BF\BD&Iacute;\EF\BF\BD&Icirc;\EF\BF\BD&Iuml;\EF\BF\BD&ETH;\EF\BF\BD&Ntilde;\EF\BF\BD&Ograve;\EF\BF\BD&Oacute;\EF\BF\BD&Ocirc;\EF\BF\BD&Otilde;\EF\BF\BD\00", [254 x i8] c";\EF\BF\BD&Uuml;\EF\BF\BD&Yacute;\EF\BF\BD&THORN;\EF\BF\BD&szlig;\EF\BF\BD&agrave;\EF\BF\BD&aacute;\EF\BF\BD&acirc;\EF\BF\BD&atilde;\EF\BF\BD&auml;\EF\BF\BD&aring;\EF\BF\BD&aelig;\EF\BF\BD&ccedil;\EF\BF\BD&egrave;\EF\BF\BD&eacute;\EF\BF\BD&ecirc;\EF\BF\BD&euml;\EF\BF\BD&igrave;\EF\BF\BD&iacute;\EF\BF\BD&icirc;\EF\BF\BD&iuml;\EF\BF\BD&eth;\EF\BF\BD&ntilde;\EF\BF\BD&ograve;\EF\BF\BD&oacute;\EF\BF\BD&oc\00", [254 x i8] c";\EF\BF\BD&uacute;\EF\BF\BD&ucirc;\EF\BF\BD&uuml;\EF\BF\BD&yacute;\EF\BF\BD&thorn;\EF\BF\BD&yuml;\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00"], [12 x i16] [i16 0, i16 31, i16 59, i16 90, i16 120, i16 151, i16 181, i16 212, i16 243, i16 273, i16 304, i16 334], [9 x float] [float 1.000000e+00, float 1.000000e+01, float 1.000000e+02, float 1.000000e+03, float 1.000000e+04, float 1.000000e+04, float 1.000000e+05, float 1.000000e+06, float 1.000000e+07] }
@LOCATION = global %CONSTANTS_LOCATION { i16 1, i16 5, [5 x i16] [i16 2, i16 2, i16 3, i16 2, i16 2] }
@DRIVER_1__init = unnamed_addr constant %DRIVER_1_interface zeroinitializer
@DRIVER_4__init = unnamed_addr constant %DRIVER_4_interface zeroinitializer
@DRIVER_4C__init = unnamed_addr constant %DRIVER_4C_interface { i8 0, i8 0, i64 0, [7 x i8] c"\01\03\07\0F\00\00\00", i16 0, i8 0, i8 0, i8 0, i8 0, %TON_interface zeroinitializer, i8 0 }
@FLOW_CONTROL__init = unnamed_addr constant %FLOW_CONTROL_interface { i8 0, i8 0, i8 0, i8 0, i64 3600000000000, i64 82800000000000, i8 0, i8 0, %TP_1D_interface zeroinitializer }
@FT_Profile__init = unnamed_addr constant %FT_Profile_interface { float 1.000000e+00, float 0.000000e+00, float 1.000000e+00, i8 0, float 0.000000e+00, i64 0, float 0.000000e+00, i64 0, float 0.000000e+00, i64 0, float 0.000000e+00, i64 0, float 0.000000e+00, i64 0, float 0.000000e+00, i64 0, float 0.000000e+00, i64 0, float 0.000000e+00, float 0.000000e+00, i8 0, i64 0, i64 0, i8 0, i8 0, i64 0, i64 0, i64 0, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00 }
@INC_DEC__init = unnamed_addr constant %INC_DEC_interface zeroinitializer
@INTERLOCK__init = unnamed_addr constant %INTERLOCK_interface zeroinitializer
@INTERLOCK_4__init = unnamed_addr constant %INTERLOCK_4_interface zeroinitializer
@MANUAL_1__init = unnamed_addr constant %MANUAL_1_interface zeroinitializer
@MANUAL_2__init = unnamed_addr constant %MANUAL_2_interface zeroinitializer
@MANUAL_4__init = unnamed_addr constant %MANUAL_4_interface zeroinitializer
@PARSET__init = unnamed_addr constant %PARSET_interface zeroinitializer
@PARSET2__init = unnamed_addr constant %PARSET2_interface zeroinitializer
@SIGNAL__init = unnamed_addr constant %SIGNAL_interface { i8 0, i8 0, i64 0, i8 0, i32 0, i8 0, i8 1 }
@SIGNAL_4__init = unnamed_addr constant %SIGNAL_4_interface { i8 0, i8 0, i8 0, i8 0, i64 0, i8 -1, i8 -16, i8 -86, i8 -96, i8 0, %SIGNAL_interface { i8 0, i8 0, i64 0, i8 0, i32 0, i8 0, i8 1 } }
@SRAMP__init = unnamed_addr constant %SRAMP_interface zeroinitializer
@TUNE__init = unnamed_addr constant %TUNE_interface { i8 0, i8 0, i8 0, i8 0, float 0x3FB99999A0000000, float 0.000000e+00, float 1.000000e+02, float 0.000000e+00, float 1.000000e+02, i64 500000000, i64 2000000000, float 2.000000e+00, float 1.000000e+01, float 0.000000e+00, i32 0, i32 0, i32 0, i16 0, i8 0, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00 }
@TUNE2__init = unnamed_addr constant %TUNE2_interface { i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, float 0x3FB99999A0000000, float 5.000000e+00, float 0.000000e+00, float 1.000000e+02, float 0.000000e+00, float 1.000000e+02, i64 500000000, float 2.000000e+00, float 1.000000e+01, float 0.000000e+00, i32 0, i32 0, i16 0, i8 0, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00 }
@CONTROL_SET1__init = unnamed_addr constant %CONTROL_SET1_interface { float 0.000000e+00, float 0.000000e+00, i8 0, i8 0, float 5.000000e-01, float 0x3FDCCCCCC0000000, float 0x3FEA8F5C20000000, float 0x3FE3333340000000, float 5.000000e-01, float 1.250000e-01, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00 }
@CONTROL_SET2__init = unnamed_addr constant %CONTROL_SET2_interface { float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, i8 0, i8 0, float 1.000000e+00, float 0x3FECCCCCC0000000, float 0x400AA3D700000000, float 0x3FF3333340000000, float 2.000000e+00, float 5.000000e-01, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00 }
@CTRL_OUT__init = unnamed_addr constant %CTRL_OUT_interface zeroinitializer
@CTRL_PI__init = unnamed_addr constant %CTRL_PI_interface { float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, i8 0, i8 0, float 1.000000e+00, float 1.000000e+00, float -1.000000e+03, float 1.000000e+03, float 0.000000e+00, float 0.000000e+00, i8 0, %FT_PIWL_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0xC7D2CED320000000, float 0x47D2CED320000000, i8 0, float 0.000000e+00, i8 0, i8 0, i32 0, float 0.000000e+00, i32 0, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00 }, %CTRL_OUT_interface zeroinitializer }
@CTRL_PID__init = unnamed_addr constant %CTRL_PID_interface { float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, i8 0, i8 0, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float -1.000000e+03, float 1.000000e+03, float 0.000000e+00, float 0.000000e+00, i8 0, %FT_PIDWL_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0xC7D2CED320000000, float 0x47D2CED320000000, i8 0, float 0.000000e+00, i8 0, %FT_PIWL_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0xC7D2CED320000000, float 0x47D2CED320000000, i8 0, float 0.000000e+00, i8 0, i8 0, i32 0, float 0.000000e+00, i32 0, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00 }, %FT_DERIV_interface { float 0.000000e+00, float 1.000000e+00, i8 1, float 0.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0, float 0.000000e+00 } }, %CTRL_OUT_interface zeroinitializer }
@CTRL_PWM__init = unnamed_addr constant %CTRL_PWM_interface { float 0.000000e+00, float 0.000000e+00, i8 0, float 0.000000e+00, i8 0, %PWM_DC_interface { float 0.000000e+00, float 0.000000e+00, i8 0, %CLK_PRG_interface { i64 10000000, i8 0, i8 0, i64 0, i64 0 }, %TP_X_interface zeroinitializer, float 0.000000e+00 } }
@DEAD_BAND_A__init = unnamed_addr constant %DEAD_BAND_A_interface { float 0.000000e+00, i64 0, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, %FT_PT1_interface { float 0.000000e+00, i64 0, float 1.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0 }, %FT_PT1_interface { float 0.000000e+00, i64 0, float 1.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0 } }
@DEAD_ZONE2__init = unnamed_addr constant %DEAD_ZONE2_interface zeroinitializer
@FT_DERIV__init = unnamed_addr constant %FT_DERIV_interface { float 0.000000e+00, float 1.000000e+00, i8 1, float 0.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0, float 0.000000e+00 }
@FT_IMP__init = unnamed_addr constant %FT_IMP_interface { float 0.000000e+00, i64 0, float 1.000000e+00, float 0.000000e+00, %FT_PT1_interface { float 0.000000e+00, i64 0, float 1.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0 } }
@FT_INT__init = unnamed_addr constant %FT_INT_interface { float 0.000000e+00, float 1.000000e+00, i8 1, i8 0, float 0xC79E17B840000000, float 0x479E17B840000000, float 0.000000e+00, i8 0, %INTEGRATE_interface { i8 1, float 0.000000e+00, float 1.000000e+00, float* null, float 0.000000e+00, i8 0, i32 0, i32 0 } }
@FT_INT2__init = unnamed_addr constant %FT_INT2_interface { float 0.000000e+00, float 1.000000e+00, i8 1, i8 0, float 0xC7D2CED320000000, float 0x47D2CED320000000, float 0.000000e+00, i8 0, %INTEGRATE_interface { i8 1, float 0.000000e+00, float 1.000000e+00, float* null, float 0.000000e+00, i8 0, i32 0, i32 0 }, float 0.000000e+00, %REAL2 zeroinitializer }
@FT_PD__init = unnamed_addr constant %FT_PD_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0.000000e+00, %FT_DERIV_interface { float 0.000000e+00, float 1.000000e+00, i8 1, float 0.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0, float 0.000000e+00 } }
@FT_PDT1__init = unnamed_addr constant %FT_PDT1_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0.000000e+00, %FT_DERIV_interface { float 0.000000e+00, float 1.000000e+00, i8 1, float 0.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0, float 0.000000e+00 }, %FT_PT1_interface { float 0.000000e+00, i64 0, float 1.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0 } }
@FT_PI__init = unnamed_addr constant %FT_PI_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0xC7D2CED320000000, float 0x47D2CED320000000, i8 1, i8 0, float 0.000000e+00, i8 0, %FT_INT_interface { float 0.000000e+00, float 1.000000e+00, i8 1, i8 0, float 0xC79E17B840000000, float 0x479E17B840000000, float 0.000000e+00, i8 0, %INTEGRATE_interface { i8 1, float 0.000000e+00, float 1.000000e+00, float* null, float 0.000000e+00, i8 0, i32 0, i32 0 } } }
@FT_PID__init = unnamed_addr constant %FT_PID_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0xC7D2CED320000000, float 0x47D2CED320000000, i8 1, i8 0, float 0.000000e+00, i8 0, %FT_INT_interface { float 0.000000e+00, float 1.000000e+00, i8 1, i8 0, float 0xC79E17B840000000, float 0x479E17B840000000, float 0.000000e+00, i8 0, %INTEGRATE_interface { i8 1, float 0.000000e+00, float 1.000000e+00, float* null, float 0.000000e+00, i8 0, i32 0, i32 0 } }, %FT_DERIV_interface { float 0.000000e+00, float 1.000000e+00, i8 1, float 0.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0, float 0.000000e+00 } }
@FT_PIDW__init = unnamed_addr constant %FT_PIDW_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0xC7D2CED320000000, float 0x47D2CED320000000, i8 0, float 0.000000e+00, i8 0, %INTEGRATE_interface { i8 1, float 0.000000e+00, float 1.000000e+00, float* null, float 0.000000e+00, i8 0, i32 0, i32 0 }, %FT_DERIV_interface { float 0.000000e+00, float 1.000000e+00, i8 1, float 0.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0, float 0.000000e+00 }, float 0.000000e+00 }
@FT_PIDWL__init = unnamed_addr constant %FT_PIDWL_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0xC7D2CED320000000, float 0x47D2CED320000000, i8 0, float 0.000000e+00, i8 0, %FT_PIWL_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0xC7D2CED320000000, float 0x47D2CED320000000, i8 0, float 0.000000e+00, i8 0, i8 0, i32 0, float 0.000000e+00, i32 0, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00 }, %FT_DERIV_interface { float 0.000000e+00, float 1.000000e+00, i8 1, float 0.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0, float 0.000000e+00 } }
@FT_PIW__init = unnamed_addr constant %FT_PIW_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0xC7D2CED320000000, float 0x47D2CED320000000, i8 0, float 0.000000e+00, i8 0, %FT_INT_interface { float 0.000000e+00, float 1.000000e+00, i8 1, i8 0, float 0xC79E17B840000000, float 0x479E17B840000000, float 0.000000e+00, i8 0, %INTEGRATE_interface { i8 1, float 0.000000e+00, float 1.000000e+00, float* null, float 0.000000e+00, i8 0, i32 0, i32 0 } } }
@FT_PIWL__init = unnamed_addr constant %FT_PIWL_interface { float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0xC7D2CED320000000, float 0x47D2CED320000000, i8 0, float 0.000000e+00, i8 0, i8 0, i32 0, float 0.000000e+00, i32 0, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00 }
@FT_PT1__init = unnamed_addr constant %FT_PT1_interface { float 0.000000e+00, i64 0, float 1.000000e+00, float 0.000000e+00, i32 0, i32 0, i8 0 }
@FT_PT2__init = unnamed_addr constant %FT_PT2_interface { float 0.000000e+00, i64 0, float 0.000000e+00, float 1.000000e+00, float 0.000000e+00, i8 0, %INTEGRATE_interface { i8 1, float 0.000000e+00, float 1.000000e+00, float* null, float 0.000000e+00, i8 0, i32 0, i32 0 }, %INTEGRATE_interface { i8 1, float 0.000000e+00, float 1.000000e+00, float* null, float 0.000000e+00, i8 0, i32 0, i32 0 }, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00 }
@FT_TN16__init = unnamed_addr constant %FT_TN16_interface { float 0.000000e+00, i64 0, float 0.000000e+00, i8 0, i16 16, [16 x float] zeroinitializer, i16 0, i64 0, i64 0, i8 0 }
@FT_TN64__init = unnamed_addr constant %FT_TN64_interface { float 0.000000e+00, i64 0, float 0.000000e+00, i8 0, i16 64, [64 x float] zeroinitializer, i16 0, i64 0, i64 0, i8 0 }
@FT_TN8__init = unnamed_addr constant %FT_TN8_interface { float 0.000000e+00, i64 0, float 0.000000e+00, i8 0, i16 8, [8 x float] zeroinitializer, i16 0, i64 0, i64 0, i8 0 }
@HYST__init = unnamed_addr constant %HYST_interface zeroinitializer
@HYST_1__init = unnamed_addr constant %HYST_1_interface zeroinitializer
@HYST_2__init = unnamed_addr constant %HYST_2_interface zeroinitializer
@HYST_3__init = unnamed_addr constant %HYST_3_interface zeroinitializer
@INTEGRATE__init = unnamed_addr constant %INTEGRATE_interface { i8 1, float 0.000000e+00, float 1.000000e+00, float* null, float 0.000000e+00, i8 0, i32 0, i32 0 }
@ASTRO__init = unnamed_addr constant %ASTRO_interface zeroinitializer
@ENERGY__init = unnamed_addr constant %ENERGY_interface zeroinitializer
@LENGTH__init = unnamed_addr constant %LENGTH_interface zeroinitializer
@PRESSURE__init = unnamed_addr constant %PRESSURE_interface zeroinitializer
@SPEED__init = unnamed_addr constant %SPEED_interface zeroinitializer
@TEMPERATURE__init = unnamed_addr constant %TEMPERATURE_interface { float 0.000000e+00, float 0xC071126660000000, float 0xC07CBAB860000000, float 0xC06B50A3E0000000, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00 }
@ALARM_2__init = unnamed_addr constant %ALARM_2_interface zeroinitializer
@BAR_GRAPH__init = unnamed_addr constant %BAR_GRAPH_interface zeroinitializer
@CALIBRATE__init = unnamed_addr constant %CALIBRATE_interface { float 0.000000e+00, i8 0, i8 0, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 1.000000e+00 }
@CYCLE_TIME__init = unnamed_addr constant %CYCLE_TIME_interface zeroinitializer
@DT_SIMU__init = unnamed_addr constant %DT_SIMU_interface { i64 0, float 1.000000e+00, i64 0, i32 0, i8 0, i32 0, i32 0, i32 0 }
@FLOW_METER__init = unnamed_addr constant %FLOW_METER_interface { float 0.000000e+00, i8 0, i8 0, i8 0, i64 1000000000, float 0.000000e+00, float* null, i32* null, i64 0, i64 0, %INTEGRATE_interface { i8 1, float 0.000000e+00, float 1.000000e+00, float* null, float 0.000000e+00, i8 0, i32 0, i32 0 }, i8 0, i8 0, i16 0, float 0.000000e+00, i32 0 }
@M_D__init = unnamed_addr constant %M_D_interface { i8 0, i8 0, i64 864000000000000, i8 0, i64 0, i64 0, i8 0, i8 0, i64 0, i64 0, i8 0 }
@M_T__init = unnamed_addr constant %M_T_interface { i8 0, i64 864000000000000, i8 0, i64 0, i64 0, i8 0, i64 0, i64 0 }
@M_TX__init = unnamed_addr constant %M_TX_interface { i8 0, i64 864000000000000, i8 0, i64 0, i64 0, float 0.000000e+00, float 0.000000e+00, i64 0, i8 0, i64 0, i64 0, i64 0, i8 0, i8 0, i8 0 }
@METER__init = unnamed_addr constant %METER_interface { float 0.000000e+00, float 0.000000e+00, i8 0, i8 0, float 1.000000e+00, i8 0, float* null, %REAL2 zeroinitializer, float 0.000000e+00, float 0.000000e+00, i32 0, i32 0, float 0.000000e+00, i8 0 }
@METER_STAT__init = unnamed_addr constant %METER_STAT_interface zeroinitializer
@ONTIME__init = unnamed_addr constant %ONTIME_interface zeroinitializer
@TC_MS__init = unnamed_addr constant %TC_MS_interface zeroinitializer
@TC_S__init = unnamed_addr constant %TC_S_interface zeroinitializer
@TC_US__init = unnamed_addr constant %TC_US_interface zeroinitializer
@_RMP_B__init = unnamed_addr constant %_RMP_B_interface { i8 0, i8 1, i64 0, i8* null, i64 0, i64 0, i64 0, i8 0, i8 0, i8 0 }
@_RMP_NEXT__init = unnamed_addr constant %_RMP_NEXT_interface { i8 1, i8 0, i64 0, i64 0, i64 0, i8 0, i8 0, i8 0, i8* null, %_RMP_B_interface { i8 0, i8 1, i64 0, i8* null, i64 0, i64 0, i64 0, i8 0, i8 0, i8 0 }, %TREND_DW_interface zeroinitializer, %TP_interface zeroinitializer, i8 0, i8 0 }
@_RMP_W__init = unnamed_addr constant %_RMP_W_interface { i8 0, i8 1, i64 0, i16* null, i32 0, i32 0, i32 0, i8 0, i8 0 }
@GEN_PULSE__init = unnamed_addr constant %GEN_PULSE_interface { i8 1, i64 0, i64 0, i8 0, i64 0, i64 0, i8 0 }
@GEN_PW2__init = unnamed_addr constant %GEN_PW2_interface zeroinitializer
@GEN_RDM__init = unnamed_addr constant %GEN_RDM_interface { i64 0, float 1.000000e+00, float 0.000000e+00, i8 0, float 0.000000e+00, i64 0, i64 0, i8 0 }
@GEN_RDT__init = unnamed_addr constant %GEN_RDT_interface { i8 1, i64 1000000000, i64 1200000000, i64 100000000, i8 0, %TON_interface zeroinitializer, %TOF_interface zeroinitializer, i64 0, float 0.000000e+00 }
@GEN_RMP__init = unnamed_addr constant %GEN_RMP_interface { i64 1000000000, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00, i8 0, float 0.000000e+00, i64 0, i64 0, i8 0, float 0.000000e+00, float 0.000000e+00 }
@GEN_SIN__init = unnamed_addr constant %GEN_SIN_interface { i64 0, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00, i8 0, float 0.000000e+00, i64 0, i64 0, i8 0, float 0.000000e+00 }
@GEN_SQR__init = unnamed_addr constant %GEN_SQR_interface { i64 0, float 1.000000e+00, float 0.000000e+00, float 5.000000e-01, float 0.000000e+00, i8 0, float 0.000000e+00, i64 0, i64 0, i8 0 }
@PWM_DC__init = unnamed_addr constant %PWM_DC_interface { float 0.000000e+00, float 0.000000e+00, i8 0, %CLK_PRG_interface { i64 10000000, i8 0, i8 0, i64 0, i64 0 }, %TP_X_interface zeroinitializer, float 0.000000e+00 }
@PWM_PW__init = unnamed_addr constant %PWM_PW_interface { float 0.000000e+00, i64 0, i8 0, %CLK_PRG_interface { i64 10000000, i8 0, i8 0, i64 0, i64 0 }, %TP_X_interface zeroinitializer }
@RMP_B__init = unnamed_addr constant %RMP_B_interface { i8 0, i64 0, i8 1, i8 1, i8 0, i8 0, i8 0, i8 0, i8 0, %_RMP_B_interface { i8 0, i8 1, i64 0, i8* null, i64 0, i64 0, i64 0, i8 0, i8 0, i8 0 } }
@RMP_SOFT__init = unnamed_addr constant %RMP_SOFT_interface { i8 0, i8 0, i64 0, i64 0, i8 0, %_RMP_B_interface { i8 0, i8 1, i64 0, i8* null, i64 0, i64 0, i64 0, i8 0, i8 0, i8 0 }, i8 0 }
@RMP_W__init = unnamed_addr constant %RMP_W_interface { i8 0, i64 0, i8 1, i8 1, i8 0, i16 0, i8 0, i8 0, i8 0, %_RMP_W_interface { i8 0, i8 1, i64 0, i16* null, i32 0, i32 0, i32 0, i8 0, i8 0 } }
@AIN1__init = unnamed_addr constant %AIN1_interface { i32 0, i16 255, i16 255, i8 0, i32 0, i16 255, i8 0, i32 0, i16 0, i16 31, float 0.000000e+00, float 1.000000e+01, i32 0, i32 -1, float 0.000000e+00, float 1.000000e+01, float 0.000000e+00, i8 0, i8 0, i8 0, i32 0 }
@DELAY__init = unnamed_addr constant %DELAY_interface zeroinitializer
@DELAY_4__init = unnamed_addr constant %DELAY_4_interface zeroinitializer
@FADE__init = unnamed_addr constant %FADE_interface { float 0.000000e+00, float 0.000000e+00, i8 0, i64 0, i8 0, float 0.000000e+00, %RMP_W_interface { i8 0, i64 0, i8 1, i8 1, i8 0, i16 0, i8 0, i8 0, i8 0, %_RMP_W_interface { i8 0, i8 1, i64 0, i16* null, i32 0, i32 0, i32 0, i8 0, i8 0 } } }
@FILTER_DW__init = unnamed_addr constant %FILTER_DW_interface zeroinitializer
@FILTER_I__init = unnamed_addr constant %FILTER_I_interface zeroinitializer
@FILTER_MAV_DW__init = unnamed_addr constant %FILTER_MAV_DW_interface zeroinitializer
@FILTER_MAV_W__init = unnamed_addr constant %FILTER_MAV_W_interface zeroinitializer
@FILTER_W__init = unnamed_addr constant %FILTER_W_interface zeroinitializer
@FILTER_WAV__init = unnamed_addr constant %FILTER_WAV_interface zeroinitializer
@SEL2_OF_3__init = unnamed_addr constant %SEL2_OF_3_interface zeroinitializer
@SEL2_OF_3B__init = unnamed_addr constant %SEL2_OF_3B_interface zeroinitializer
@SH__init = unnamed_addr constant %SH_interface zeroinitializer
@SH_1__init = unnamed_addr constant %SH_1_interface zeroinitializer
@SH_2__init = unnamed_addr constant %SH_2_interface { float 0.000000e+00, i64 0, i16 16, i16 0, float 0.000000e+00, i8 0, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, i16 0, [16 x float] zeroinitializer, [16 x float] zeroinitializer, i64 0, i16 0, i16 0, float 0.000000e+00, i16 0, i64 0, i16 0 }
@SH_T__init = unnamed_addr constant %SH_T_interface zeroinitializer
@STAIR2__init = unnamed_addr constant %STAIR2_interface zeroinitializer
@TREND__init = unnamed_addr constant %TREND_interface zeroinitializer
@TREND_DW__init = unnamed_addr constant %TREND_DW_interface zeroinitializer
@LIST_NEXT__init = unnamed_addr constant %LIST_NEXT_interface { i8 0, i8 0, [251 x i8]* null, [251 x i8] zeroinitializer, i8 0, i16 1, [250 x i8]* null, [250 x i8]* null, i8 0, i16 0 }
@COUNT_BR__init = unnamed_addr constant %COUNT_BR_interface { i8 0, i8 0, i8 0, i8 0, i8 1, i8 -1, i8 0, i8 0, i8 0, i8 0 }
@COUNT_DR__init = unnamed_addr constant %COUNT_DR_interface { i8 0, i32 0, i8 0, i8 0, i32 1, i32 -1, i8 0, i32 0, i8 0, i8 0 }
@FF_D2E__init = unnamed_addr constant %FF_D2E_interface zeroinitializer
@FF_D4E__init = unnamed_addr constant %FF_D4E_interface zeroinitializer
@FF_DRE__init = unnamed_addr constant %FF_DRE_interface zeroinitializer
@FF_JKE__init = unnamed_addr constant %FF_JKE_interface zeroinitializer
@FF_RSE__init = unnamed_addr constant %FF_RSE_interface zeroinitializer
@SELECT_8__init = unnamed_addr constant %SELECT_8_interface zeroinitializer
@SHR_4E__init = unnamed_addr constant %SHR_4E_interface zeroinitializer
@SHR_4UDE__init = unnamed_addr constant %SHR_4UDE_interface zeroinitializer
@SHR_8PLE__init = unnamed_addr constant %SHR_8PLE_interface { i8 0, i8 0, i8 0, i8 1, i8 0, i8 0, i8 0, i8 1, i8 0 }
@SHR_8UDE__init = unnamed_addr constant %SHR_8UDE_interface zeroinitializer
@TOGGLE__init = unnamed_addr constant %TOGGLE_interface zeroinitializer
@LTCH__init = unnamed_addr constant %LTCH_interface zeroinitializer
@LTCH_4__init = unnamed_addr constant %LTCH_4_interface zeroinitializer
@STORE_8__init = unnamed_addr constant %STORE_8_interface zeroinitializer
@BYTE_TO_BITS__init = unnamed_addr constant %BYTE_TO_BITS_interface zeroinitializer
@DEC_2__init = unnamed_addr constant %DEC_2_interface zeroinitializer
@DEC_4__init = unnamed_addr constant %DEC_4_interface zeroinitializer
@DEC_8__init = unnamed_addr constant %DEC_8_interface zeroinitializer
@A_TRIG__init = unnamed_addr constant %A_TRIG_interface zeroinitializer
@B_TRIG__init = unnamed_addr constant %B_TRIG_interface zeroinitializer
@CLICK_CNT__init = unnamed_addr constant %CLICK_CNT_interface { i8 0, i16 0, i64 0, i8 0, %TP_interface zeroinitializer, i8 0, i16 -1 }
@CLICK_DEC__init = unnamed_addr constant %CLICK_DEC_interface { i8 0, i64 0, i8 0, i8 0, i8 0, i8 0, %TP_interface zeroinitializer, i8 0, i16 -1 }
@CLK_DIV__init = unnamed_addr constant %CLK_DIV_interface zeroinitializer
@CLK_N__init = unnamed_addr constant %CLK_N_interface zeroinitializer
@CLK_PRG__init = unnamed_addr constant %CLK_PRG_interface { i64 10000000, i8 0, i8 0, i64 0, i64 0 }
@CLK_PULSE__init = unnamed_addr constant %CLK_PULSE_interface zeroinitializer
@CYCLE_4__init = unnamed_addr constant %CYCLE_4_interface { i8 1, i64 0, i64 0, i64 0, i64 0, i8 0, i16 0, i8 0, i16 0, i64 0, i64 0, i8 0 }
@D_TRIG__init = unnamed_addr constant %D_TRIG_interface zeroinitializer
@GEN_BIT__init = unnamed_addr constant %GEN_BIT_interface { i32 0, i32 0, i32 0, i32 0, i8 0, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i16 0, i8 0, i32 0, i32 0, i32 0, i32 0, i16 1 }
@GEN_SQ__init = unnamed_addr constant %GEN_SQ_interface zeroinitializer
@SCHEDULER__init = unnamed_addr constant %SCHEDULER_interface zeroinitializer
@SCHEDULER_2__init = unnamed_addr constant %SCHEDULER_2_interface zeroinitializer
@SEQUENCE_4__init = unnamed_addr constant %SEQUENCE_4_interface { i8 1, i8 1, i8 1, i8 1, i8 0, i8 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i16 -1, i8 0, i64 0, i8 0, i64 0, i8 0 }
@SEQUENCE_64__init = unnamed_addr constant %SEQUENCE_64_interface { i8 0, i16 0, [64 x i64] zeroinitializer, i8 0, i16 -1, i8 0, i64 0, i8 0, i64 0 }
@SEQUENCE_8__init = unnamed_addr constant %SEQUENCE_8_interface { i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 0, i8 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i16 -1, i8 0, i64 0, i8 0, i64 0, i8 0 }
@TMAX__init = unnamed_addr constant %TMAX_interface zeroinitializer
@TMIN__init = unnamed_addr constant %TMIN_interface zeroinitializer
@TOF_1__init = unnamed_addr constant %TOF_1_interface zeroinitializer
@TONOF__init = unnamed_addr constant %TONOF_interface zeroinitializer
@TP_1__init = unnamed_addr constant %TP_1_interface zeroinitializer
@TP_1D__init = unnamed_addr constant %TP_1D_interface zeroinitializer
@TP_X__init = unnamed_addr constant %TP_X_interface zeroinitializer
@FIFO_16__init = unnamed_addr constant %FIFO_16_interface { i32 0, i8 1, i8 0, i8 0, i8 0, i32 0, i8 1, i8 0, [17 x i32] zeroinitializer, i16 0, i16 0, i16 16 }
@FIFO_32__init = unnamed_addr constant %FIFO_32_interface { i32 0, i8 1, i8 0, i8 0, i8 0, i32 0, i8 1, i8 0, [33 x i32] zeroinitializer, i16 0, i16 0, i16 32 }
@STACK_16__init = unnamed_addr constant %STACK_16_interface { i32 0, i8 1, i8 0, i8 0, i8 0, i32 0, i8 1, i8 0, [16 x i32] zeroinitializer, i16 0, i16 15 }
@STACK_32__init = unnamed_addr constant %STACK_32_interface { i32 0, i8 1, i8 0, i8 0, i8 0, i32 0, i8 1, i8 0, [32 x i32] zeroinitializer, i16 0, i16 31 }
@MATRIX__init = unnamed_addr constant %MATRIX_interface { i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 1, i8 0, i8 0, i8 0, i8 0, [4 x i8] zeroinitializer, [4 x i8] zeroinitializer, i16 0, i8 0 }
@PIN_CODE__init = unnamed_addr constant %PIN_CODE_interface { i8 0, i8 0, [9 x i8] zeroinitializer, i8 0, i16 1 }
@FT_AVG__init = unnamed_addr constant %FT_AVG_interface { float 0.000000e+00, i8 1, i16 32, i8 0, float 0.000000e+00, %DELAY_interface zeroinitializer, i16 0, i8 0 }
@FT_MIN_MAX__init = unnamed_addr constant %FT_MIN_MAX_interface zeroinitializer
@FT_RMP__init = unnamed_addr constant %FT_RMP_interface { i8 1, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, i8 0, i8 0, i64 0, i64 0, i8 0 }
@ESR_COLLECT__init = unnamed_addr constant %ESR_COLLECT_interface { [4 x %ESR_DATA] zeroinitializer, [4 x %ESR_DATA] zeroinitializer, [4 x %ESR_DATA] zeroinitializer, [4 x %ESR_DATA] zeroinitializer, [4 x %ESR_DATA] zeroinitializer, [4 x %ESR_DATA] zeroinitializer, [4 x %ESR_DATA] zeroinitializer, [4 x %ESR_DATA] zeroinitializer, i8 0, i16* null, [32 x %ESR_DATA] zeroinitializer, i16 3, i16 32, i16 -1 }
@ESR_MON_B8__init = unnamed_addr constant %ESR_MON_B8_interface zeroinitializer
@ESR_MON_R4__init = unnamed_addr constant %ESR_MON_R4_interface zeroinitializer
@ESR_MON_X8__init = unnamed_addr constant %ESR_MON_X8_interface { i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 0, i8 3, [11 x i8] zeroinitializer, [11 x i8] zeroinitializer, [11 x i8] zeroinitializer, [11 x i8] zeroinitializer, [11 x i8] zeroinitializer, [11 x i8] zeroinitializer, [11 x i8] zeroinitializer, [11 x i8] zeroinitializer, i8 0, [4 x %ESR_DATA]* null, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 0, i16 0 }
@MESSAGE_4R__init = unnamed_addr constant %MESSAGE_4R_interface { [251 x i8] zeroinitializer, [251 x i8] zeroinitializer, [251 x i8] zeroinitializer, [251 x i8] zeroinitializer, i16 3, i8 1, i8 1, i64 3000000000, [251 x i8] zeroinitializer, i16 0, i8 0, %TON_interface zeroinitializer, i8 0 }
@MESSAGE_8__init = unnamed_addr constant %MESSAGE_8_interface zeroinitializer
@TICKER__init = unnamed_addr constant %TICKER_interface zeroinitializer
@CALENDAR_CALC__init = unnamed_addr constant %CALENDAR_CALC_interface { i8 0, float 0xBFEAAAAAA0000000, %CALENDAR* null, [30 x %HOLIDAY_DATA]* null, i64 0, i32 0, %HOLIDAY_interface { i64 0, i16 0, i8 0, i8 0, i8 0, [30 x %HOLIDAY_DATA]* null, i16 29, i8 0, [31 x i8] zeroinitializer, i64 0, i64 0, i16 0, i16 0, i64 0, i16 0, i16 0 }, %SUN_TIME_interface { float 0.000000e+00, float 0.000000e+00, i64 0, float 0xBFEAAAAAA0000000, i64 0, i64 0, i64 0, float 0.000000e+00, float 0.000000e+00, i64 0, float 0.000000e+00 }, i16 0, i64 0, %SUN_POS_interface zeroinitializer, i64 0 }
@DCF77__init = unnamed_addr constant %DCF77_interface { i8 0, i8 0, i64 0, i8 0, i64 120000000000, i16 1, i8 1, i8 0, i8 0, i16 0, i8 1, i64 0, i64 0, i16 0, i8 0, i64 0, i64 0, i16 0, i8 0, i64 0, i64 0, i64 0, [59 x i8] zeroinitializer, i16 0, i16 0, i64 0, i16 0, i16 0, i16 0, i16 0, i16 0, i64 0, i64 0, i64 0, i8 0 }
@EVENTS__init = unnamed_addr constant %EVENTS_interface { i64 0, i8 0, i8 0, [31 x i8] zeroinitializer, i16 0, i64 0, i16 49, i32 0, i16 0, i32 0, %HOLIDAY_DATA zeroinitializer, i8 0, [31 x i8] zeroinitializer, [50 x %HOLIDAY_DATA]* null }
@HOLIDAY__init = unnamed_addr constant %HOLIDAY_interface { i64 0, i16 0, i8 0, i8 0, i8 0, [30 x %HOLIDAY_DATA]* null, i16 29, i8 0, [31 x i8] zeroinitializer, i64 0, i64 0, i16 0, i16 0, i64 0, i16 0, i16 0 }
@RTC_2__init = unnamed_addr constant %RTC_2_interface zeroinitializer
@RTC_MS__init = unnamed_addr constant %RTC_MS_interface zeroinitializer
@SUN_POS__init = unnamed_addr constant %SUN_POS_interface zeroinitializer
@SUN_TIME__init = unnamed_addr constant %SUN_TIME_interface { float 0.000000e+00, float 0.000000e+00, i64 0, float 0xBFEAAAAAA0000000, i64 0, i64 0, i64 0, float 0.000000e+00, float 0.000000e+00, i64 0, float 0.000000e+00 }
@CTD__init = unnamed_addr constant %CTD_interface zeroinitializer
@CTU__init = unnamed_addr constant %CTU_interface zeroinitializer
@CTUD__init = unnamed_addr constant %CTUD_interface zeroinitializer
@F_TRIG__init = unnamed_addr constant %F_TRIG_interface zeroinitializer
@R_TRIG__init = unnamed_addr constant %R_TRIG_interface zeroinitializer
@RS__init = unnamed_addr constant %RS_interface zeroinitializer
@SR__init = unnamed_addr constant %SR_interface zeroinitializer
@TOF__init = unnamed_addr constant %TOF_interface zeroinitializer
@TON__init = unnamed_addr constant %TON_interface zeroinitializer
@TP__init = unnamed_addr constant %TP_interface zeroinitializer
@DT_TO_STRF.FILL__init = unnamed_addr constant [2 x i8] c"0\00"
@DT_TO_STRF.BLANK__init = unnamed_addr constant [2 x i8] c" \00"
@FSTRING_TO_DT.ignore__init = unnamed_addr constant [2 x i8] c"*\00"
@FSTRING_TO_DT.fchar__init = unnamed_addr constant [2 x i8] c"#\00"
@utf08_literal_0 = unnamed_addr constant [1 x i8] zeroinitializer
@utf08_literal_1 = unnamed_addr constant [2 x i8] c" \00"
@utf08_literal_2 = unnamed_addr constant [3 x i8] c"  \00"
@utf08_literal_3 = unnamed_addr constant [2 x i8] c"#\00"
@utf08_literal_4 = unnamed_addr constant [2 x i8] c"&\00"
@utf08_literal_5 = unnamed_addr constant [2 x i8] c"*\00"
@utf08_literal_6 = unnamed_addr constant [2 x i8] c"+\00"
@utf08_literal_7 = unnamed_addr constant [2 x i8] c",\00"
@utf08_literal_8 = unnamed_addr constant [2 x i8] c"-\00"
@utf08_literal_9 = unnamed_addr constant [2 x i8] c".\00"
@utf08_literal_10 = unnamed_addr constant [3 x i8] c".0\00"
@utf08_literal_11 = unnamed_addr constant [2 x i8] c"/\00"
@utf08_literal_12 = unnamed_addr constant [2 x i8] c"0\00"
@utf08_literal_13 = unnamed_addr constant [3 x i8] c"00\00"
@utf08_literal_14 = unnamed_addr constant [11 x i8] c"0123456789\00"
@utf08_literal_15 = unnamed_addr constant [4 x i8] c"16#\00"
@utf08_literal_16 = unnamed_addr constant [3 x i8] c"2#\00"
@utf08_literal_17 = unnamed_addr constant [3 x i8] c"8#\00"
@utf08_literal_18 = unnamed_addr constant [2 x i8] c";\00"
@utf08_literal_19 = unnamed_addr constant [3 x i8] c"AM\00"
@utf08_literal_20 = unnamed_addr constant [3 x i8] c"Ae\00"
@utf08_literal_21 = unnamed_addr constant [4 x i8] c"COS\00"
@utf08_literal_22 = unnamed_addr constant [2 x i8] c"D\00"
@utf08_literal_23 = unnamed_addr constant [6 x i8] c"ERROR\00"
@utf08_literal_24 = unnamed_addr constant [2 x i8] c"M\00"
@utf08_literal_25 = unnamed_addr constant [2 x i8] c"N\00"
@utf08_literal_26 = unnamed_addr constant [3 x i8] c"Oe\00"
@utf08_literal_27 = unnamed_addr constant [3 x i8] c"PM\00"
@utf08_literal_28 = unnamed_addr constant [4 x i8] c"SIN\00"
@utf08_literal_29 = unnamed_addr constant [5 x i8] c"SQRT\00"
@utf08_literal_30 = unnamed_addr constant [4 x i8] c"TAN\00"
@utf08_literal_31 = unnamed_addr constant [3 x i8] c"Ue\00"
@utf08_literal_32 = unnamed_addr constant [2 x i8] c"Y\00"
@utf08_literal_33 = unnamed_addr constant [2 x i8] c"^\00"
@utf08_literal_34 = unnamed_addr constant [3 x i8] c"ae\00"
@utf08_literal_35 = unnamed_addr constant [2 x i8] c"h\00"
@utf08_literal_36 = unnamed_addr constant [2 x i8] c"m\00"
@utf08_literal_37 = unnamed_addr constant [3 x i8] c"oe\00"
@utf08_literal_38 = unnamed_addr constant [2 x i8] c"s\00"
@utf08_literal_39 = unnamed_addr constant [3 x i8] c"ss\00"
@utf08_literal_40 = unnamed_addr constant [3 x i8] c"ue\00"

declare i8 @_BUFFER_CLEAR(%_BUFFER_CLEAR_interface*)

declare i8 @_BUFFER_INIT(%_BUFFER_INIT_interface*)

define i16 @_BUFFER_INSERT(%_BUFFER_INSERT_interface* %0) {
entry:
  %STR = getelementptr inbounds %_BUFFER_INSERT_interface, %_BUFFER_INSERT_interface* %0, i32 0, i32 0
  %POS = getelementptr inbounds %_BUFFER_INSERT_interface, %_BUFFER_INSERT_interface* %0, i32 0, i32 1
  %PT = getelementptr inbounds %_BUFFER_INSERT_interface, %_BUFFER_INSERT_interface* %0, i32 0, i32 2
  %SIZE = getelementptr inbounds %_BUFFER_INSERT_interface, %_BUFFER_INSERT_interface* %0, i32 0, i32 3
  %end = getelementptr inbounds %_BUFFER_INSERT_interface, %_BUFFER_INSERT_interface* %0, i32 0, i32 4
  %lx = getelementptr inbounds %_BUFFER_INSERT_interface, %_BUFFER_INSERT_interface* %0, i32 0, i32 5
  %i = getelementptr inbounds %_BUFFER_INSERT_interface, %_BUFFER_INSERT_interface* %0, i32 0, i32 6
  %_BUFFER_INSERT = alloca i16, align 2
  store i16 0, i16* %end, align 2
  store i16 0, i16* %lx, align 2
  store i16 0, i16* %i, align 2
  store i16 0, i16* %_BUFFER_INSERT, align 2
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %lx, align 2
  %load_pos = load i16, i16* %POS, align 2
  %4 = sext i16 %load_pos to i32
  %load_lx = load i16, i16* %lx, align 2
  %5 = sext i16 %load_lx to i32
  %tmpVar = add i32 %4, %5
  %6 = trunc i32 %tmpVar to i16
  store i16 %6, i16* %end, align 2
  %UINT_TO_INT_instance = alloca %UINT_TO_INT_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %7 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance, i32 0, i32 0
  %load_size = load i16, i16* %SIZE, align 2
  store i16 %load_size, i16* %7, align 2
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %8 = sext i16 %call6 to i32
  %tmpVar7 = sub i32 %8, 1
  %9 = trunc i32 %tmpVar7 to i16
  store i16 %9, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue5
  %load_i = load i16, i16* %i, align 2
  %load_i9 = load i16, i16* %i, align 2
  %load_end = load i16, i16* %end, align 2
  %tmpVar10 = icmp sle i16 %load_i9, %load_end
  %10 = icmp ne i1 %tmpVar10, false
  br i1 %10, label %18, label %19

for_body:                                         ; preds = %16
  %deref = load [32768 x i8]*, [32768 x i8]** %PT, align 8
  %load_i34 = load i16, i16* %i, align 2
  %11 = sext i16 %load_i34 to i32
  %tmpVar35 = mul i32 1, %11
  %tmpVar36 = add i32 %tmpVar35, 0
  %tmpVar37 = getelementptr inbounds [32768 x i8], [32768 x i8]* %deref, i32 0, i32 %tmpVar36
  %deref38 = load [32768 x i8]*, [32768 x i8]** %PT, align 8
  %load_i39 = load i16, i16* %i, align 2
  %12 = sext i16 %load_i39 to i32
  %load_lx40 = load i16, i16* %lx, align 2
  %13 = sext i16 %load_lx40 to i32
  %tmpVar41 = sub i32 %12, %13
  %tmpVar42 = mul i32 1, %tmpVar41
  %tmpVar43 = add i32 %tmpVar42, 0
  %tmpVar44 = getelementptr inbounds [32768 x i8], [32768 x i8]* %deref38, i32 0, i32 %tmpVar43
  %load_tmpVar = load i8, i8* %tmpVar44, align 1
  store i8 %load_tmpVar, i8* %tmpVar37, align 1
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar45 = add i16 %load_i, -1
  store i16 %tmpVar45, i16* %i, align 2
  br label %condition_check

continue8:                                        ; preds = %16
  %_STRING_TO_BUFFER_instance = alloca %_STRING_TO_BUFFER_interface, align 8
  br label %input46

14:                                               ; preds = %19
  %load_i21 = load i16, i16* %i, align 2
  %load_end22 = load i16, i16* %end, align 2
  %tmpVar23 = icmp sge i16 %load_i21, %load_end22
  %15 = icmp ne i1 %tmpVar23, false
  br i1 %15, label %25, label %26

16:                                               ; preds = %26, %19
  %17 = phi i1 [ %20, %19 ], [ %27, %26 ]
  br i1 %17, label %for_body, label %continue8

18:                                               ; preds = %condition_check
  %load_i11 = load i16, i16* %i, align 2
  %UINT_TO_INT_instance12 = alloca %UINT_TO_INT_interface, align 8
  br label %input13

19:                                               ; preds = %continue16, %condition_check
  %20 = phi i1 [ %tmpVar10, %condition_check ], [ %tmpVar20, %continue16 ]
  %21 = icmp ne i1 %20, false
  br i1 %21, label %16, label %14

input13:                                          ; preds = %18
  %22 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance12, i32 0, i32 0
  %load_size17 = load i16, i16* %SIZE, align 2
  store i16 %load_size17, i16* %22, align 2
  br label %call14

call14:                                           ; preds = %input13
  %call18 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance12)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %23 = sext i16 %call18 to i32
  %tmpVar19 = sub i32 %23, 1
  %24 = trunc i32 %tmpVar19 to i16
  %tmpVar20 = icmp sge i16 %load_i11, %24
  br label %19

25:                                               ; preds = %14
  %load_i24 = load i16, i16* %i, align 2
  %UINT_TO_INT_instance25 = alloca %UINT_TO_INT_interface, align 8
  br label %input26

26:                                               ; preds = %continue29, %14
  %27 = phi i1 [ %tmpVar23, %14 ], [ %tmpVar33, %continue29 ]
  br label %16

input26:                                          ; preds = %25
  %28 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance25, i32 0, i32 0
  %load_size30 = load i16, i16* %SIZE, align 2
  store i16 %load_size30, i16* %28, align 2
  br label %call27

call27:                                           ; preds = %input26
  %call31 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance25)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  %29 = sext i16 %call31 to i32
  %tmpVar32 = sub i32 %29, 1
  %30 = trunc i32 %tmpVar32 to i16
  %tmpVar33 = icmp sle i16 %load_i24, %30
  br label %26

input46:                                          ; preds = %continue8
  %31 = getelementptr inbounds %_STRING_TO_BUFFER_interface, %_STRING_TO_BUFFER_interface* %_STRING_TO_BUFFER_instance, i32 0, i32 0
  %32 = bitcast [251 x i8]* %31 to i8*
  %33 = bitcast [251 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %32, i8* align 1 %33, i32 250, i1 false)
  %34 = getelementptr inbounds %_STRING_TO_BUFFER_interface, %_STRING_TO_BUFFER_interface* %_STRING_TO_BUFFER_instance, i32 0, i32 1
  %load_pos50 = load i16, i16* %POS, align 2
  store i16 %load_pos50, i16* %34, align 2
  %35 = getelementptr inbounds %_STRING_TO_BUFFER_interface, %_STRING_TO_BUFFER_interface* %_STRING_TO_BUFFER_instance, i32 0, i32 2
  %load_PT = load [32768 x i8]*, [32768 x i8]** %PT, align 8
  store [32768 x i8]* %load_PT, [32768 x i8]** %35, align 8
  %36 = getelementptr inbounds %_STRING_TO_BUFFER_interface, %_STRING_TO_BUFFER_interface* %_STRING_TO_BUFFER_instance, i32 0, i32 3
  %load_size51 = load i16, i16* %SIZE, align 2
  store i16 %load_size51, i16* %36, align 2
  br label %call47

call47:                                           ; preds = %input46
  %call52 = call i16 @_STRING_TO_BUFFER(%_STRING_TO_BUFFER_interface* %_STRING_TO_BUFFER_instance)
  br label %output48

output48:                                         ; preds = %call47
  br label %continue49

continue49:                                       ; preds = %output48
  store i16 %call52, i16* %_BUFFER_INSERT, align 2
  %_BUFFER_INSERT_ret = load i16, i16* %_BUFFER_INSERT, align 2
  ret i16 %_BUFFER_INSERT_ret
}

define i8 @_BUFFER_UPPERCASE(%_BUFFER_UPPERCASE_interface* %0) {
entry:
  %PT = getelementptr inbounds %_BUFFER_UPPERCASE_interface, %_BUFFER_UPPERCASE_interface* %0, i32 0, i32 0
  %SIZE = getelementptr inbounds %_BUFFER_UPPERCASE_interface, %_BUFFER_UPPERCASE_interface* %0, i32 0, i32 1
  %pos = getelementptr inbounds %_BUFFER_UPPERCASE_interface, %_BUFFER_UPPERCASE_interface* %0, i32 0, i32 2
  %_BUFFER_UPPERCASE = alloca i8, align 1
  store i16 0, i16* %pos, align 2
  store i8 0, i8* %_BUFFER_UPPERCASE, align 1
  store i16 0, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %entry, %continue5
  %load_pos = load i16, i16* %pos, align 2
  %1 = sext i16 %load_pos to i32
  %load_size = load i16, i16* %SIZE, align 2
  %2 = sext i16 %load_size to i32
  %tmpVar = icmp slt i32 %1, %2
  br i1 %tmpVar, label %while_body, label %continue

while_body:                                       ; preds = %condition_check
  %deref = load [32001 x i8]*, [32001 x i8]** %PT, align 8
  %load_pos1 = load i16, i16* %pos, align 2
  %3 = sext i16 %load_pos1 to i32
  %tmpVar2 = mul i32 1, %3
  %tmpVar3 = add i32 %tmpVar2, 0
  %tmpVar4 = getelementptr inbounds [32001 x i8], [32001 x i8]* %deref, i32 0, i32 %tmpVar3
  %TO_UPPER_instance = alloca %TO_UPPER_interface, align 8
  br label %input

continue:                                         ; preds = %condition_check
  store i8 1, i8* %_BUFFER_UPPERCASE, align 1
  %_BUFFER_UPPERCASE_ret = load i8, i8* %_BUFFER_UPPERCASE, align 1
  ret i8 %_BUFFER_UPPERCASE_ret

input:                                            ; preds = %while_body
  %4 = getelementptr inbounds %TO_UPPER_interface, %TO_UPPER_interface* %TO_UPPER_instance, i32 0, i32 0
  %deref6 = load [32001 x i8]*, [32001 x i8]** %PT, align 8
  %load_pos7 = load i16, i16* %pos, align 2
  %5 = sext i16 %load_pos7 to i32
  %tmpVar8 = mul i32 1, %5
  %tmpVar9 = add i32 %tmpVar8, 0
  %tmpVar10 = getelementptr inbounds [32001 x i8], [32001 x i8]* %deref6, i32 0, i32 %tmpVar9
  %load_tmpVar = load i8, i8* %tmpVar10, align 1
  store i8 %load_tmpVar, i8* %4, align 1
  br label %call

call:                                             ; preds = %input
  %call11 = call i8 @TO_UPPER(%TO_UPPER_interface* %TO_UPPER_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue5

continue5:                                        ; preds = %output
  store i8 %call11, i8* %tmpVar4, align 1
  %load_pos12 = load i16, i16* %pos, align 2
  %6 = sext i16 %load_pos12 to i32
  %tmpVar13 = add i32 %6, 1
  %7 = trunc i32 %tmpVar13 to i16
  store i16 %7, i16* %pos, align 2
  br label %condition_check
}

declare i16 @_STRING_TO_BUFFER(%_STRING_TO_BUFFER_interface*)

declare i16 @BUFFER_COMP(%BUFFER_COMP_interface*)

declare i16 @BUFFER_SEARCH(%BUFFER_SEARCH_interface*)

declare [251 x i8] @BUFFER_TO_STRING(%BUFFER_TO_STRING_interface*)

define void @DRIVER_1(%DRIVER_1_interface* %0) {
entry:
  %Toggle_Mode = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %0, i32 0, i32 0
  %Timeout = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %0, i32 0, i32 1
  %SET = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %0, i32 0, i32 2
  %IN = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %0, i32 0, i32 3
  %RST = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %0, i32 0, i32 4
  %Q = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %0, i32 0, i32 5
  %off = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %0, i32 0, i32 6
  %edge = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %0, i32 0, i32 7
  %Q1 = getelementptr inbounds %TON_interface, %TON_interface* %off, i32 0, i32 2
  %load_ = load i8, i8* %Q1, align 1
  %1 = icmp ne i8 %load_, 0
  br i1 %1, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q, align 1
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  %load_rst = load i8, i8* %RST, align 1
  %2 = icmp ne i8 %load_rst, 0
  br i1 %2, label %condition_body4, label %branch

condition_body4:                                  ; preds = %continue
  store i8 0, i8* %Q, align 1
  br label %continue3

branch:                                           ; preds = %continue
  %load_set = load i8, i8* %SET, align 1
  %3 = icmp ne i8 %load_set, 0
  br i1 %3, label %condition_body5, label %branch2

condition_body5:                                  ; preds = %branch
  store i8 1, i8* %Q, align 1
  br label %continue3

branch2:                                          ; preds = %branch
  %load_IN = load i8, i8* %IN, align 1
  %4 = zext i8 %load_IN to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %7, label %9

condition_body6:                                  ; preds = %9
  %load_toggle_mode = load i8, i8* %Toggle_Mode, align 1
  %6 = icmp ne i8 %load_toggle_mode, 0
  br i1 %6, label %condition_body8, label %else

continue3:                                        ; preds = %continue7, %9, %condition_body5, %condition_body4
  %load_in = load i8, i8* %IN, align 1
  store i8 %load_in, i8* %edge, align 1
  %load_timeout = load i64, i64* %Timeout, align 4
  %tmpVar12 = icmp sgt i64 %load_timeout, 0
  br i1 %tmpVar12, label %condition_body11, label %continue10

7:                                                ; preds = %branch2
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar = xor i8 %load_edge, -1
  %8 = zext i8 %tmpVar to i32
  br label %9

9:                                                ; preds = %7, %branch2
  %10 = phi i32 [ %4, %branch2 ], [ %8, %7 ]
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %condition_body6, label %continue3

condition_body8:                                  ; preds = %condition_body6
  %load_Q = load i8, i8* %Q, align 1
  %tmpVar9 = xor i8 %load_Q, -1
  store i8 %tmpVar9, i8* %Q, align 1
  br label %continue7

else:                                             ; preds = %condition_body6
  store i8 1, i8* %Q, align 1
  br label %continue7

continue7:                                        ; preds = %else, %condition_body8
  br label %continue3

condition_body11:                                 ; preds = %continue3
  br label %input

continue10:                                       ; preds = %continue13, %continue3
  ret void

input:                                            ; preds = %condition_body11
  %12 = getelementptr inbounds %TON_interface, %TON_interface* %off, i32 0, i32 0
  %load_Q14 = load i8, i8* %Q, align 1
  store i8 %load_Q14, i8* %12, align 1
  %13 = getelementptr inbounds %TON_interface, %TON_interface* %off, i32 0, i32 1
  %load_Timeout = load i64, i64* %Timeout, align 4
  store i64 %load_Timeout, i64* %13, align 4
  br label %call

call:                                             ; preds = %input
  call void @TON(%TON_interface* %off)
  br label %output

output:                                           ; preds = %call
  br label %continue13

continue13:                                       ; preds = %output
  br label %continue10
}

define void @DRIVER_4(%DRIVER_4_interface* %0) {
entry:
  %Toggle_Mode = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 0
  %Timeout = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 1
  %SET = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 2
  %IN0 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 3
  %IN1 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 4
  %IN2 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 5
  %IN3 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 6
  %RST = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 7
  %Q0 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 8
  %Q1 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 9
  %Q2 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 10
  %Q3 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 11
  %d0 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 12
  %d1 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 13
  %d2 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 14
  %d3 = getelementptr inbounds %DRIVER_4_interface, %DRIVER_4_interface* %0, i32 0, i32 15
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d0, i32 0, i32 2
  %load_set = load i8, i8* %SET, align 1
  store i8 %load_set, i8* %1, align 1
  %2 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d0, i32 0, i32 3
  %load_in0 = load i8, i8* %IN0, align 1
  store i8 %load_in0, i8* %2, align 1
  %3 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d0, i32 0, i32 4
  %load_rst = load i8, i8* %RST, align 1
  store i8 %load_rst, i8* %3, align 1
  %4 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d0, i32 0, i32 0
  %load_toggle_mode = load i8, i8* %Toggle_Mode, align 1
  store i8 %load_toggle_mode, i8* %4, align 1
  %5 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d0, i32 0, i32 1
  %load_timeout = load i64, i64* %Timeout, align 4
  store i64 %load_timeout, i64* %5, align 4
  br label %call

call:                                             ; preds = %input
  call void @DRIVER_1(%DRIVER_1_interface* %d0)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  br label %input1

input1:                                           ; preds = %continue
  %6 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d1, i32 0, i32 2
  %load_set5 = load i8, i8* %SET, align 1
  store i8 %load_set5, i8* %6, align 1
  %7 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d1, i32 0, i32 3
  %load_in1 = load i8, i8* %IN1, align 1
  store i8 %load_in1, i8* %7, align 1
  %8 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d1, i32 0, i32 4
  %load_rst6 = load i8, i8* %RST, align 1
  store i8 %load_rst6, i8* %8, align 1
  %9 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d1, i32 0, i32 0
  %load_toggle_mode7 = load i8, i8* %Toggle_Mode, align 1
  store i8 %load_toggle_mode7, i8* %9, align 1
  %10 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d1, i32 0, i32 1
  %load_timeout8 = load i64, i64* %Timeout, align 4
  store i64 %load_timeout8, i64* %10, align 4
  br label %call2

call2:                                            ; preds = %input1
  call void @DRIVER_1(%DRIVER_1_interface* %d1)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  br label %input9

input9:                                           ; preds = %continue4
  %11 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d2, i32 0, i32 2
  %load_set13 = load i8, i8* %SET, align 1
  store i8 %load_set13, i8* %11, align 1
  %12 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d2, i32 0, i32 3
  %load_in2 = load i8, i8* %IN2, align 1
  store i8 %load_in2, i8* %12, align 1
  %13 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d2, i32 0, i32 4
  %load_rst14 = load i8, i8* %RST, align 1
  store i8 %load_rst14, i8* %13, align 1
  %14 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d2, i32 0, i32 0
  %load_toggle_mode15 = load i8, i8* %Toggle_Mode, align 1
  store i8 %load_toggle_mode15, i8* %14, align 1
  %15 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d2, i32 0, i32 1
  %load_timeout16 = load i64, i64* %Timeout, align 4
  store i64 %load_timeout16, i64* %15, align 4
  br label %call10

call10:                                           ; preds = %input9
  call void @DRIVER_1(%DRIVER_1_interface* %d2)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  br label %input17

input17:                                          ; preds = %continue12
  %16 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d3, i32 0, i32 2
  %load_set21 = load i8, i8* %SET, align 1
  store i8 %load_set21, i8* %16, align 1
  %17 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d3, i32 0, i32 3
  %load_in3 = load i8, i8* %IN3, align 1
  store i8 %load_in3, i8* %17, align 1
  %18 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d3, i32 0, i32 4
  %load_rst22 = load i8, i8* %RST, align 1
  store i8 %load_rst22, i8* %18, align 1
  %19 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d3, i32 0, i32 0
  %load_toggle_mode23 = load i8, i8* %Toggle_Mode, align 1
  store i8 %load_toggle_mode23, i8* %19, align 1
  %20 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d3, i32 0, i32 1
  %load_timeout24 = load i64, i64* %Timeout, align 4
  store i64 %load_timeout24, i64* %20, align 4
  br label %call18

call18:                                           ; preds = %input17
  call void @DRIVER_1(%DRIVER_1_interface* %d3)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %Q = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d0, i32 0, i32 5
  %load_ = load i8, i8* %Q, align 1
  store i8 %load_, i8* %Q0, align 1
  %Q25 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d1, i32 0, i32 5
  %load_26 = load i8, i8* %Q25, align 1
  store i8 %load_26, i8* %Q1, align 1
  %Q27 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d2, i32 0, i32 5
  %load_28 = load i8, i8* %Q27, align 1
  store i8 %load_28, i8* %Q2, align 1
  %Q29 = getelementptr inbounds %DRIVER_1_interface, %DRIVER_1_interface* %d3, i32 0, i32 5
  %load_30 = load i8, i8* %Q29, align 1
  store i8 %load_30, i8* %Q3, align 1
  ret void
}

define void @DRIVER_4C(%DRIVER_4C_interface* %0) {
entry:
  %IN = getelementptr inbounds %DRIVER_4C_interface, %DRIVER_4C_interface* %0, i32 0, i32 0
  %RST = getelementptr inbounds %DRIVER_4C_interface, %DRIVER_4C_interface* %0, i32 0, i32 1
  %Timeout = getelementptr inbounds %DRIVER_4C_interface, %DRIVER_4C_interface* %0, i32 0, i32 2
  %SX = getelementptr inbounds %DRIVER_4C_interface, %DRIVER_4C_interface* %0, i32 0, i32 3
  %SN = getelementptr inbounds %DRIVER_4C_interface, %DRIVER_4C_interface* %0, i32 0, i32 4
  %Q0 = getelementptr inbounds %DRIVER_4C_interface, %DRIVER_4C_interface* %0, i32 0, i32 5
  %Q1 = getelementptr inbounds %DRIVER_4C_interface, %DRIVER_4C_interface* %0, i32 0, i32 6
  %Q2 = getelementptr inbounds %DRIVER_4C_interface, %DRIVER_4C_interface* %0, i32 0, i32 7
  %Q3 = getelementptr inbounds %DRIVER_4C_interface, %DRIVER_4C_interface* %0, i32 0, i32 8
  %off = getelementptr inbounds %DRIVER_4C_interface, %DRIVER_4C_interface* %0, i32 0, i32 9
  %edge = getelementptr inbounds %DRIVER_4C_interface, %DRIVER_4C_interface* %0, i32 0, i32 10
  %load_RST = load i8, i8* %RST, align 1
  %1 = zext i8 %load_RST to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %13, label %11

condition_body:                                   ; preds = %13
  store i16 0, i16* %SN, align 2
  br label %continue

branch:                                           ; preds = %13
  %load_IN = load i8, i8* %IN, align 1
  %3 = zext i8 %load_IN to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %16, label %18

condition_body1:                                  ; preds = %18
  %load_SN = load i16, i16* %SN, align 2
  %5 = sext i16 %load_SN to i32
  %tmpVar2 = add i32 %5, 1
  %6 = trunc i32 %tmpVar2 to i16
  store i16 %6, i16* %SN, align 2
  %load_SN5 = load i16, i16* %SN, align 2
  %7 = sext i16 %load_SN5 to i32
  %tmpVar6 = icmp sgt i32 %7, 7
  %8 = zext i1 %tmpVar6 to i32
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %26, label %21

continue:                                         ; preds = %continue3, %18, %condition_body
  %load_in = load i8, i8* %IN, align 1
  store i8 %load_in, i8* %edge, align 1
  %load_SN14 = load i16, i16* %SN, align 2
  %10 = sext i16 %load_SN14 to i32
  %tmpVar15 = icmp sgt i32 %10, 0
  br i1 %tmpVar15, label %condition_body13, label %else

11:                                               ; preds = %entry
  %Q = getelementptr inbounds %TON_interface, %TON_interface* %off, i32 0, i32 2
  %load_ = load i8, i8* %Q, align 1
  %12 = zext i8 %load_ to i32
  br label %13

13:                                               ; preds = %11, %entry
  %14 = phi i32 [ %1, %entry ], [ %12, %11 ]
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %condition_body, label %branch

16:                                               ; preds = %branch
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar = xor i8 %load_edge, -1
  %17 = zext i8 %tmpVar to i32
  br label %18

18:                                               ; preds = %16, %branch
  %19 = phi i32 [ %3, %branch ], [ %17, %16 ]
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %condition_body1, label %continue

condition_body4:                                  ; preds = %26
  store i16 0, i16* %SN, align 2
  br label %continue3

continue3:                                        ; preds = %condition_body4, %26
  br label %continue

21:                                               ; preds = %condition_body1
  %load_SN7 = load i16, i16* %SN, align 2
  %22 = sub i16 %load_SN7, 1
  %23 = sext i16 %22 to i32
  %tmpVar8 = mul i32 1, %23
  %tmpVar9 = add i32 %tmpVar8, 0
  %tmpVar10 = getelementptr inbounds [7 x i8], [7 x i8]* %SX, i32 0, i32 %tmpVar9
  %load_tmpVar = load i8, i8* %tmpVar10, align 1
  %24 = zext i8 %load_tmpVar to i32
  %tmpVar11 = icmp eq i32 %24, 0
  %25 = zext i1 %tmpVar11 to i32
  br label %26

26:                                               ; preds = %21, %condition_body1
  %27 = phi i32 [ %8, %condition_body1 ], [ %25, %21 ]
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %condition_body4, label %continue3

condition_body13:                                 ; preds = %continue
  %load_SN16 = load i16, i16* %SN, align 2
  %29 = sub i16 %load_SN16, 1
  %30 = sext i16 %29 to i32
  %tmpVar17 = mul i32 1, %30
  %tmpVar18 = add i32 %tmpVar17, 0
  %tmpVar19 = getelementptr inbounds [7 x i8], [7 x i8]* %SX, i32 0, i32 %tmpVar18
  %load_tmpVar20 = load i8, i8* %tmpVar19, align 1
  %shift = lshr i8 %load_tmpVar20, 0
  store i8 %shift, i8* %Q0, align 1
  %load_SN21 = load i16, i16* %SN, align 2
  %31 = sub i16 %load_SN21, 1
  %32 = sext i16 %31 to i32
  %tmpVar22 = mul i32 1, %32
  %tmpVar23 = add i32 %tmpVar22, 0
  %tmpVar24 = getelementptr inbounds [7 x i8], [7 x i8]* %SX, i32 0, i32 %tmpVar23
  %load_tmpVar25 = load i8, i8* %tmpVar24, align 1
  %shift26 = lshr i8 %load_tmpVar25, 1
  store i8 %shift26, i8* %Q1, align 1
  %load_SN27 = load i16, i16* %SN, align 2
  %33 = sub i16 %load_SN27, 1
  %34 = sext i16 %33 to i32
  %tmpVar28 = mul i32 1, %34
  %tmpVar29 = add i32 %tmpVar28, 0
  %tmpVar30 = getelementptr inbounds [7 x i8], [7 x i8]* %SX, i32 0, i32 %tmpVar29
  %load_tmpVar31 = load i8, i8* %tmpVar30, align 1
  %shift32 = lshr i8 %load_tmpVar31, 2
  store i8 %shift32, i8* %Q2, align 1
  %load_SN33 = load i16, i16* %SN, align 2
  %35 = sub i16 %load_SN33, 1
  %36 = sext i16 %35 to i32
  %tmpVar34 = mul i32 1, %36
  %tmpVar35 = add i32 %tmpVar34, 0
  %tmpVar36 = getelementptr inbounds [7 x i8], [7 x i8]* %SX, i32 0, i32 %tmpVar35
  %load_tmpVar37 = load i8, i8* %tmpVar36, align 1
  %shift38 = lshr i8 %load_tmpVar37, 3
  store i8 %shift38, i8* %Q3, align 1
  br label %continue12

else:                                             ; preds = %continue
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  br label %continue12

continue12:                                       ; preds = %else, %condition_body13
  %load_timeout = load i64, i64* %Timeout, align 4
  %tmpVar41 = icmp sgt i64 %load_timeout, 0
  br i1 %tmpVar41, label %condition_body40, label %continue39

condition_body40:                                 ; preds = %continue12
  br label %input

continue39:                                       ; preds = %continue42, %continue12
  ret void

input:                                            ; preds = %condition_body40
  %37 = getelementptr inbounds %TON_interface, %TON_interface* %off, i32 0, i32 0
  %load_SN43 = load i16, i16* %SN, align 2
  %38 = sext i16 %load_SN43 to i32
  %tmpVar44 = icmp sgt i32 %38, 0
  %39 = zext i1 %tmpVar44 to i8
  store i8 %39, i8* %37, align 1
  %40 = getelementptr inbounds %TON_interface, %TON_interface* %off, i32 0, i32 1
  %load_Timeout = load i64, i64* %Timeout, align 4
  store i64 %load_Timeout, i64* %40, align 4
  br label %call

call:                                             ; preds = %input
  call void @TON(%TON_interface* %off)
  br label %output

output:                                           ; preds = %call
  br label %continue42

continue42:                                       ; preds = %output
  br label %continue39
}

define void @FLOW_CONTROL(%FLOW_CONTROL_interface* %0) {
entry:
  %IN = getelementptr inbounds %FLOW_CONTROL_interface, %FLOW_CONTROL_interface* %0, i32 0, i32 0
  %REQ = getelementptr inbounds %FLOW_CONTROL_interface, %FLOW_CONTROL_interface* %0, i32 0, i32 1
  %ENQ = getelementptr inbounds %FLOW_CONTROL_interface, %FLOW_CONTROL_interface* %0, i32 0, i32 2
  %RST = getelementptr inbounds %FLOW_CONTROL_interface, %FLOW_CONTROL_interface* %0, i32 0, i32 3
  %T_AUTO = getelementptr inbounds %FLOW_CONTROL_interface, %FLOW_CONTROL_interface* %0, i32 0, i32 4
  %T_DELAY = getelementptr inbounds %FLOW_CONTROL_interface, %FLOW_CONTROL_interface* %0, i32 0, i32 5
  %Q = getelementptr inbounds %FLOW_CONTROL_interface, %FLOW_CONTROL_interface* %0, i32 0, i32 6
  %STATUS = getelementptr inbounds %FLOW_CONTROL_interface, %FLOW_CONTROL_interface* %0, i32 0, i32 7
  %timer = getelementptr inbounds %FLOW_CONTROL_interface, %FLOW_CONTROL_interface* %0, i32 0, i32 8
  store i8 100, i8* %STATUS, align 1
  %load_RST = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_RST, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q, align 1
  br label %input

branch:                                           ; preds = %entry
  %load_ENQ = load i8, i8* %ENQ, align 1
  %2 = icmp ne i8 %load_ENQ, 0
  br i1 %2, label %condition_body3, label %continue

condition_body3:                                  ; preds = %branch
  %load_IN = load i8, i8* %IN, align 1
  %3 = icmp ne i8 %load_IN, 0
  br i1 %3, label %condition_body5, label %continue4

continue:                                         ; preds = %continue6, %branch, %continue1
  br label %input9

input:                                            ; preds = %condition_body
  %4 = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %timer, i32 0, i32 3
  store i8 1, i8* %4, align 1
  br label %call

call:                                             ; preds = %input
  call void @TP_1D(%TP_1D_interface* %timer)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %RST2 = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %timer, i32 0, i32 3
  store i8 0, i8* %RST2, align 1
  store i8 103, i8* %STATUS, align 1
  br label %continue

condition_body5:                                  ; preds = %condition_body3
  store i8 101, i8* %STATUS, align 1
  br label %continue4

continue4:                                        ; preds = %condition_body5, %condition_body3
  %load_REQ = load i8, i8* %REQ, align 1
  %5 = icmp ne i8 %load_REQ, 0
  br i1 %5, label %condition_body7, label %continue6

condition_body7:                                  ; preds = %continue4
  %PT1 = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %timer, i32 0, i32 1
  %load_T_AUTO = load i64, i64* %T_AUTO, align 4
  store i64 %load_T_AUTO, i64* %PT1, align 4
  %PTD = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %timer, i32 0, i32 2
  %load_T_DELAY = load i64, i64* %T_DELAY, align 4
  store i64 %load_T_DELAY, i64* %PTD, align 4
  %IN8 = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %timer, i32 0, i32 0
  store i8 1, i8* %IN8, align 1
  store i8 102, i8* %STATUS, align 1
  br label %continue6

continue6:                                        ; preds = %condition_body7, %continue4
  br label %continue

input9:                                           ; preds = %continue
  br label %call10

call10:                                           ; preds = %input9
  call void @TP_1D(%TP_1D_interface* %timer)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  %IN13 = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %timer, i32 0, i32 0
  store i8 0, i8* %IN13, align 1
  store i8 0, i8* %Q, align 1
  ret void
}

define void @FT_Profile(%FT_Profile_interface* %0) {
entry:
  %K = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 0
  %O = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 1
  %M = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 2
  %E = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 3
  %value_0 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 4
  %time_1 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 5
  %value_1 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 6
  %time_2 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 7
  %value_2 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 8
  %time_3 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 9
  %value_3 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 10
  %time_10 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 11
  %value_10 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 12
  %time_11 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 13
  %value_11 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 14
  %time_12 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 15
  %value_12 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 16
  %time_13 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 17
  %value_13 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 18
  %Y = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 19
  %RUN = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 20
  %ET = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 21
  %tx = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 22
  %edge = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 23
  %state = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 24
  %ta = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 25
  %tb = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 26
  %t0 = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 27
  %temp = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 28
  %va = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 29
  %vb = getelementptr inbounds %FT_Profile_interface, %FT_Profile_interface* %0, i32 0, i32 30
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_E = load i8, i8* %E, align 1
  %2 = zext i8 %load_E to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %5, label %7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %7
  store i8 1, i8* %RUN, align 1
  store i64 0, i64* %ET, align 4
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %t0, align 4
  %load_tx8 = load i64, i64* %tx, align 4
  store i64 %load_tx8, i64* %ta, align 4
  %MULTIME_instance = alloca %MULTIME_interface, align 8
  br label %input9

continue7:                                        ; preds = %continue12, %7
  %load_E15 = load i8, i8* %E, align 1
  store i8 %load_E15, i8* %edge, align 1
  %load_run = load i8, i8* %RUN, align 1
  %4 = icmp ne i8 %load_run, 0
  br i1 %4, label %condition_body17, label %continue16

5:                                                ; preds = %continue
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar = xor i8 %load_edge, -1
  %6 = zext i8 %tmpVar to i32
  br label %7

7:                                                ; preds = %5, %continue
  %8 = phi i32 [ %2, %continue ], [ %6, %5 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body, label %continue7

input9:                                           ; preds = %condition_body
  %10 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance, i32 0, i32 0
  %load_time_1 = load i64, i64* %time_1, align 4
  store i64 %load_time_1, i64* %10, align 4
  %11 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance, i32 0, i32 1
  %load_M = load float, float* %M, align 4
  store float %load_M, float* %11, align 4
  br label %call10

call10:                                           ; preds = %input9
  %call13 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  store i64 %call13, i64* %tb, align 4
  %load_value_0 = load float, float* %value_0, align 4
  store float %load_value_0, float* %va, align 4
  %load_value_1 = load float, float* %value_1, align 4
  store float %load_value_1, float* %vb, align 4
  %load_value_014 = load float, float* %value_0, align 4
  store float %load_value_014, float* %temp, align 4
  store i8 1, i8* %state, align 1
  br label %continue7

condition_body17:                                 ; preds = %continue7
  %load_state = load i8, i8* %state, align 1
  switch i8 %load_state, label %else [
    i8 1, label %case
    i8 2, label %case59
    i8 3, label %case105
    i8 4, label %case151
    i8 5, label %case201
    i8 6, label %case207
    i8 7, label %case253
    i8 8, label %case299
  ]

continue16:                                       ; preds = %continue18, %continue7
  ret void

case:                                             ; preds = %condition_body17
  %load_tx22 = load i64, i64* %tx, align 4
  %load_ta = load i64, i64* %ta, align 4
  %tmpVar23 = sub i64 %load_tx22, %load_ta
  %load_tb = load i64, i64* %tb, align 4
  %tmpVar24 = icmp sge i64 %tmpVar23, %load_tb
  br i1 %tmpVar24, label %condition_body21, label %else19

case59:                                           ; preds = %condition_body17
  %load_tx63 = load i64, i64* %tx, align 4
  %load_ta64 = load i64, i64* %ta, align 4
  %tmpVar65 = sub i64 %load_tx63, %load_ta64
  %load_tb66 = load i64, i64* %tb, align 4
  %tmpVar67 = icmp sge i64 %tmpVar65, %load_tb66
  br i1 %tmpVar67, label %condition_body62, label %else60

case105:                                          ; preds = %condition_body17
  %load_tx109 = load i64, i64* %tx, align 4
  %load_ta110 = load i64, i64* %ta, align 4
  %tmpVar111 = sub i64 %load_tx109, %load_ta110
  %load_tb112 = load i64, i64* %tb, align 4
  %tmpVar113 = icmp sge i64 %tmpVar111, %load_tb112
  br i1 %tmpVar113, label %condition_body108, label %else106

case151:                                          ; preds = %condition_body17
  %load_tx155 = load i64, i64* %tx, align 4
  %load_ta156 = load i64, i64* %ta, align 4
  %tmpVar157 = sub i64 %load_tx155, %load_ta156
  %load_tb158 = load i64, i64* %tb, align 4
  %tmpVar159 = icmp sge i64 %tmpVar157, %load_tb158
  br i1 %tmpVar159, label %condition_body154, label %else152

case201:                                          ; preds = %condition_body17
  %load_E205 = load i8, i8* %E, align 1
  %12 = icmp ne i8 %load_E205, 0
  br i1 %12, label %condition_body204, label %else202

case207:                                          ; preds = %condition_body17
  %load_tx211 = load i64, i64* %tx, align 4
  %load_ta212 = load i64, i64* %ta, align 4
  %tmpVar213 = sub i64 %load_tx211, %load_ta212
  %load_tb214 = load i64, i64* %tb, align 4
  %tmpVar215 = icmp sge i64 %tmpVar213, %load_tb214
  br i1 %tmpVar215, label %condition_body210, label %else208

case253:                                          ; preds = %condition_body17
  %load_tx257 = load i64, i64* %tx, align 4
  %load_ta258 = load i64, i64* %ta, align 4
  %tmpVar259 = sub i64 %load_tx257, %load_ta258
  %load_tb260 = load i64, i64* %tb, align 4
  %tmpVar261 = icmp sge i64 %tmpVar259, %load_tb260
  br i1 %tmpVar261, label %condition_body256, label %else254

case299:                                          ; preds = %condition_body17
  %load_tx303 = load i64, i64* %tx, align 4
  %load_ta304 = load i64, i64* %ta, align 4
  %tmpVar305 = sub i64 %load_tx303, %load_ta304
  %load_tb306 = load i64, i64* %tb, align 4
  %tmpVar307 = icmp sge i64 %tmpVar305, %load_tb306
  br i1 %tmpVar307, label %condition_body302, label %else300

else:                                             ; preds = %condition_body17
  br label %continue18

continue18:                                       ; preds = %else, %continue301, %continue255, %continue209, %continue203, %continue153, %continue107, %continue61, %continue20
  %load_temp = load float, float* %temp, align 4
  %load_K = load float, float* %K, align 4
  %tmpVar332 = fmul float %load_temp, %load_K
  %load_O = load float, float* %O, align 4
  %tmpVar333 = fadd float %tmpVar332, %load_O
  store float %tmpVar333, float* %Y, align 4
  %load_tx334 = load i64, i64* %tx, align 4
  %load_t0 = load i64, i64* %t0, align 4
  %tmpVar335 = sub i64 %load_tx334, %load_t0
  store i64 %tmpVar335, i64* %ET, align 4
  br label %continue16

condition_body21:                                 ; preds = %case
  %load_ta25 = load i64, i64* %ta, align 4
  %load_tb26 = load i64, i64* %tb, align 4
  %tmpVar27 = add i64 %load_ta25, %load_tb26
  store i64 %tmpVar27, i64* %ta, align 4
  %MULTIME_instance28 = alloca %MULTIME_interface, align 8
  br label %input29

else19:                                           ; preds = %case
  %load_vb = load float, float* %vb, align 4
  %load_va = load float, float* %va, align 4
  %tmpVar39 = fsub float %load_vb, %load_va
  %TIME_TO_REAL_instance = alloca %TIME_TO_REAL_interface, align 8
  br label %input40

continue20:                                       ; preds = %continue53, %continue32
  br label %continue18

input29:                                          ; preds = %condition_body21
  %13 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance28, i32 0, i32 0
  %load_time_2 = load i64, i64* %time_2, align 4
  %load_time_133 = load i64, i64* %time_1, align 4
  %tmpVar34 = sub i64 %load_time_2, %load_time_133
  store i64 %tmpVar34, i64* %13, align 4
  %14 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance28, i32 0, i32 1
  %load_M35 = load float, float* %M, align 4
  store float %load_M35, float* %14, align 4
  br label %call30

call30:                                           ; preds = %input29
  %call36 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance28)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  store i64 %call36, i64* %tb, align 4
  %load_value_137 = load float, float* %value_1, align 4
  store float %load_value_137, float* %va, align 4
  %load_value_2 = load float, float* %value_2, align 4
  store float %load_value_2, float* %vb, align 4
  %load_value_138 = load float, float* %value_1, align 4
  store float %load_value_138, float* %temp, align 4
  store i8 2, i8* %state, align 1
  br label %continue20

input40:                                          ; preds = %else19
  %15 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance, i32 0, i32 0
  %load_tx44 = load i64, i64* %tx, align 4
  %load_ta45 = load i64, i64* %ta, align 4
  %tmpVar46 = sub i64 %load_tx44, %load_ta45
  store i64 %tmpVar46, i64* %15, align 4
  br label %call41

call41:                                           ; preds = %input40
  %call47 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance)
  br label %output42

output42:                                         ; preds = %call41
  br label %continue43

continue43:                                       ; preds = %output42
  %tmpVar48 = fmul float %tmpVar39, %call47
  %TIME_TO_REAL_instance49 = alloca %TIME_TO_REAL_interface, align 8
  br label %input50

input50:                                          ; preds = %continue43
  %16 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance49, i32 0, i32 0
  %load_tb54 = load i64, i64* %tb, align 4
  store i64 %load_tb54, i64* %16, align 4
  br label %call51

call51:                                           ; preds = %input50
  %call55 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance49)
  br label %output52

output52:                                         ; preds = %call51
  br label %continue53

continue53:                                       ; preds = %output52
  %tmpVar56 = fdiv float %tmpVar48, %call55
  %load_va57 = load float, float* %va, align 4
  %tmpVar58 = fadd float %tmpVar56, %load_va57
  store float %tmpVar58, float* %temp, align 4
  br label %continue20

condition_body62:                                 ; preds = %case59
  %load_ta68 = load i64, i64* %ta, align 4
  %load_tb69 = load i64, i64* %tb, align 4
  %tmpVar70 = add i64 %load_ta68, %load_tb69
  store i64 %tmpVar70, i64* %ta, align 4
  %MULTIME_instance71 = alloca %MULTIME_interface, align 8
  br label %input72

else60:                                           ; preds = %case59
  %load_vb82 = load float, float* %vb, align 4
  %load_va83 = load float, float* %va, align 4
  %tmpVar84 = fsub float %load_vb82, %load_va83
  %TIME_TO_REAL_instance85 = alloca %TIME_TO_REAL_interface, align 8
  br label %input86

continue61:                                       ; preds = %continue99, %continue75
  br label %continue18

input72:                                          ; preds = %condition_body62
  %17 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance71, i32 0, i32 0
  %load_time_3 = load i64, i64* %time_3, align 4
  %load_time_276 = load i64, i64* %time_2, align 4
  %tmpVar77 = sub i64 %load_time_3, %load_time_276
  store i64 %tmpVar77, i64* %17, align 4
  %18 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance71, i32 0, i32 1
  %load_M78 = load float, float* %M, align 4
  store float %load_M78, float* %18, align 4
  br label %call73

call73:                                           ; preds = %input72
  %call79 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance71)
  br label %output74

output74:                                         ; preds = %call73
  br label %continue75

continue75:                                       ; preds = %output74
  store i64 %call79, i64* %tb, align 4
  %load_value_280 = load float, float* %value_2, align 4
  store float %load_value_280, float* %va, align 4
  %load_value_3 = load float, float* %value_3, align 4
  store float %load_value_3, float* %vb, align 4
  %load_value_281 = load float, float* %value_2, align 4
  store float %load_value_281, float* %temp, align 4
  store i8 3, i8* %state, align 1
  br label %continue61

input86:                                          ; preds = %else60
  %19 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance85, i32 0, i32 0
  %load_tx90 = load i64, i64* %tx, align 4
  %load_ta91 = load i64, i64* %ta, align 4
  %tmpVar92 = sub i64 %load_tx90, %load_ta91
  store i64 %tmpVar92, i64* %19, align 4
  br label %call87

call87:                                           ; preds = %input86
  %call93 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance85)
  br label %output88

output88:                                         ; preds = %call87
  br label %continue89

continue89:                                       ; preds = %output88
  %tmpVar94 = fmul float %tmpVar84, %call93
  %TIME_TO_REAL_instance95 = alloca %TIME_TO_REAL_interface, align 8
  br label %input96

input96:                                          ; preds = %continue89
  %20 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance95, i32 0, i32 0
  %load_tb100 = load i64, i64* %tb, align 4
  store i64 %load_tb100, i64* %20, align 4
  br label %call97

call97:                                           ; preds = %input96
  %call101 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance95)
  br label %output98

output98:                                         ; preds = %call97
  br label %continue99

continue99:                                       ; preds = %output98
  %tmpVar102 = fdiv float %tmpVar94, %call101
  %load_va103 = load float, float* %va, align 4
  %tmpVar104 = fadd float %tmpVar102, %load_va103
  store float %tmpVar104, float* %temp, align 4
  br label %continue61

condition_body108:                                ; preds = %case105
  %load_ta114 = load i64, i64* %ta, align 4
  %load_tb115 = load i64, i64* %tb, align 4
  %tmpVar116 = add i64 %load_ta114, %load_tb115
  store i64 %tmpVar116, i64* %ta, align 4
  %MULTIME_instance117 = alloca %MULTIME_interface, align 8
  br label %input118

else106:                                          ; preds = %case105
  %load_vb128 = load float, float* %vb, align 4
  %load_va129 = load float, float* %va, align 4
  %tmpVar130 = fsub float %load_vb128, %load_va129
  %TIME_TO_REAL_instance131 = alloca %TIME_TO_REAL_interface, align 8
  br label %input132

continue107:                                      ; preds = %continue145, %continue121
  br label %continue18

input118:                                         ; preds = %condition_body108
  %21 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance117, i32 0, i32 0
  %load_time_10 = load i64, i64* %time_10, align 4
  %load_time_3122 = load i64, i64* %time_3, align 4
  %tmpVar123 = sub i64 %load_time_10, %load_time_3122
  store i64 %tmpVar123, i64* %21, align 4
  %22 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance117, i32 0, i32 1
  %load_M124 = load float, float* %M, align 4
  store float %load_M124, float* %22, align 4
  br label %call119

call119:                                          ; preds = %input118
  %call125 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance117)
  br label %output120

output120:                                        ; preds = %call119
  br label %continue121

continue121:                                      ; preds = %output120
  store i64 %call125, i64* %tb, align 4
  %load_value_3126 = load float, float* %value_3, align 4
  store float %load_value_3126, float* %va, align 4
  %load_value_10 = load float, float* %value_10, align 4
  store float %load_value_10, float* %vb, align 4
  %load_value_3127 = load float, float* %value_3, align 4
  store float %load_value_3127, float* %temp, align 4
  store i8 4, i8* %state, align 1
  br label %continue107

input132:                                         ; preds = %else106
  %23 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance131, i32 0, i32 0
  %load_tx136 = load i64, i64* %tx, align 4
  %load_ta137 = load i64, i64* %ta, align 4
  %tmpVar138 = sub i64 %load_tx136, %load_ta137
  store i64 %tmpVar138, i64* %23, align 4
  br label %call133

call133:                                          ; preds = %input132
  %call139 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance131)
  br label %output134

output134:                                        ; preds = %call133
  br label %continue135

continue135:                                      ; preds = %output134
  %tmpVar140 = fmul float %tmpVar130, %call139
  %TIME_TO_REAL_instance141 = alloca %TIME_TO_REAL_interface, align 8
  br label %input142

input142:                                         ; preds = %continue135
  %24 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance141, i32 0, i32 0
  %load_tb146 = load i64, i64* %tb, align 4
  store i64 %load_tb146, i64* %24, align 4
  br label %call143

call143:                                          ; preds = %input142
  %call147 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance141)
  br label %output144

output144:                                        ; preds = %call143
  br label %continue145

continue145:                                      ; preds = %output144
  %tmpVar148 = fdiv float %tmpVar140, %call147
  %load_va149 = load float, float* %va, align 4
  %tmpVar150 = fadd float %tmpVar148, %load_va149
  store float %tmpVar150, float* %temp, align 4
  br label %continue107

condition_body154:                                ; preds = %case151
  %load_ta160 = load i64, i64* %ta, align 4
  %load_tb161 = load i64, i64* %tb, align 4
  %tmpVar162 = add i64 %load_ta160, %load_tb161
  store i64 %tmpVar162, i64* %ta, align 4
  %MULTIME_instance163 = alloca %MULTIME_interface, align 8
  br label %input164

else152:                                          ; preds = %case151
  %load_vb178 = load float, float* %vb, align 4
  %load_va179 = load float, float* %va, align 4
  %tmpVar180 = fsub float %load_vb178, %load_va179
  %TIME_TO_REAL_instance181 = alloca %TIME_TO_REAL_interface, align 8
  br label %input182

continue153:                                      ; preds = %continue195, %continue175
  br label %continue18

input164:                                         ; preds = %condition_body154
  %25 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance163, i32 0, i32 0
  %load_time_11 = load i64, i64* %time_11, align 4
  %load_time_10168 = load i64, i64* %time_10, align 4
  %tmpVar169 = sub i64 %load_time_11, %load_time_10168
  store i64 %tmpVar169, i64* %25, align 4
  %26 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance163, i32 0, i32 1
  %load_M170 = load float, float* %M, align 4
  store float %load_M170, float* %26, align 4
  br label %call165

call165:                                          ; preds = %input164
  %call171 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance163)
  br label %output166

output166:                                        ; preds = %call165
  br label %continue167

continue167:                                      ; preds = %output166
  store i64 %call171, i64* %tb, align 4
  %load_value_10172 = load float, float* %value_10, align 4
  store float %load_value_10172, float* %va, align 4
  %load_value_11 = load float, float* %value_11, align 4
  store float %load_value_11, float* %vb, align 4
  %load_value_10173 = load float, float* %value_10, align 4
  store float %load_value_10173, float* %temp, align 4
  %load_E177 = load i8, i8* %E, align 1
  %27 = icmp ne i8 %load_E177, 0
  br i1 %27, label %condition_body176, label %else174

condition_body176:                                ; preds = %continue167
  store i8 5, i8* %state, align 1
  br label %continue175

else174:                                          ; preds = %continue167
  store i8 6, i8* %state, align 1
  br label %continue175

continue175:                                      ; preds = %else174, %condition_body176
  br label %continue153

input182:                                         ; preds = %else152
  %28 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance181, i32 0, i32 0
  %load_tx186 = load i64, i64* %tx, align 4
  %load_ta187 = load i64, i64* %ta, align 4
  %tmpVar188 = sub i64 %load_tx186, %load_ta187
  store i64 %tmpVar188, i64* %28, align 4
  br label %call183

call183:                                          ; preds = %input182
  %call189 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance181)
  br label %output184

output184:                                        ; preds = %call183
  br label %continue185

continue185:                                      ; preds = %output184
  %tmpVar190 = fmul float %tmpVar180, %call189
  %TIME_TO_REAL_instance191 = alloca %TIME_TO_REAL_interface, align 8
  br label %input192

input192:                                         ; preds = %continue185
  %29 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance191, i32 0, i32 0
  %load_tb196 = load i64, i64* %tb, align 4
  store i64 %load_tb196, i64* %29, align 4
  br label %call193

call193:                                          ; preds = %input192
  %call197 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance191)
  br label %output194

output194:                                        ; preds = %call193
  br label %continue195

continue195:                                      ; preds = %output194
  %tmpVar198 = fdiv float %tmpVar190, %call197
  %load_va199 = load float, float* %va, align 4
  %tmpVar200 = fadd float %tmpVar198, %load_va199
  store float %tmpVar200, float* %temp, align 4
  br label %continue153

condition_body204:                                ; preds = %case201
  %load_tx206 = load i64, i64* %tx, align 4
  store i64 %load_tx206, i64* %ta, align 4
  br label %continue203

else202:                                          ; preds = %case201
  store i8 6, i8* %state, align 1
  br label %continue203

continue203:                                      ; preds = %else202, %condition_body204
  br label %continue18

condition_body210:                                ; preds = %case207
  %load_ta216 = load i64, i64* %ta, align 4
  %load_tb217 = load i64, i64* %tb, align 4
  %tmpVar218 = add i64 %load_ta216, %load_tb217
  store i64 %tmpVar218, i64* %ta, align 4
  %MULTIME_instance219 = alloca %MULTIME_interface, align 8
  br label %input220

else208:                                          ; preds = %case207
  %load_vb230 = load float, float* %vb, align 4
  %load_va231 = load float, float* %va, align 4
  %tmpVar232 = fsub float %load_vb230, %load_va231
  %TIME_TO_REAL_instance233 = alloca %TIME_TO_REAL_interface, align 8
  br label %input234

continue209:                                      ; preds = %continue247, %continue223
  br label %continue18

input220:                                         ; preds = %condition_body210
  %30 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance219, i32 0, i32 0
  %load_time_12 = load i64, i64* %time_12, align 4
  %load_time_11224 = load i64, i64* %time_11, align 4
  %tmpVar225 = sub i64 %load_time_12, %load_time_11224
  store i64 %tmpVar225, i64* %30, align 4
  %31 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance219, i32 0, i32 1
  %load_M226 = load float, float* %M, align 4
  store float %load_M226, float* %31, align 4
  br label %call221

call221:                                          ; preds = %input220
  %call227 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance219)
  br label %output222

output222:                                        ; preds = %call221
  br label %continue223

continue223:                                      ; preds = %output222
  store i64 %call227, i64* %tb, align 4
  %load_value_11228 = load float, float* %value_11, align 4
  store float %load_value_11228, float* %va, align 4
  %load_value_12 = load float, float* %value_12, align 4
  store float %load_value_12, float* %vb, align 4
  %load_value_11229 = load float, float* %value_11, align 4
  store float %load_value_11229, float* %temp, align 4
  store i8 7, i8* %state, align 1
  br label %continue209

input234:                                         ; preds = %else208
  %32 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance233, i32 0, i32 0
  %load_tx238 = load i64, i64* %tx, align 4
  %load_ta239 = load i64, i64* %ta, align 4
  %tmpVar240 = sub i64 %load_tx238, %load_ta239
  store i64 %tmpVar240, i64* %32, align 4
  br label %call235

call235:                                          ; preds = %input234
  %call241 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance233)
  br label %output236

output236:                                        ; preds = %call235
  br label %continue237

continue237:                                      ; preds = %output236
  %tmpVar242 = fmul float %tmpVar232, %call241
  %TIME_TO_REAL_instance243 = alloca %TIME_TO_REAL_interface, align 8
  br label %input244

input244:                                         ; preds = %continue237
  %33 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance243, i32 0, i32 0
  %load_tb248 = load i64, i64* %tb, align 4
  store i64 %load_tb248, i64* %33, align 4
  br label %call245

call245:                                          ; preds = %input244
  %call249 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance243)
  br label %output246

output246:                                        ; preds = %call245
  br label %continue247

continue247:                                      ; preds = %output246
  %tmpVar250 = fdiv float %tmpVar242, %call249
  %load_va251 = load float, float* %va, align 4
  %tmpVar252 = fadd float %tmpVar250, %load_va251
  store float %tmpVar252, float* %temp, align 4
  br label %continue209

condition_body256:                                ; preds = %case253
  %load_ta262 = load i64, i64* %ta, align 4
  %load_tb263 = load i64, i64* %tb, align 4
  %tmpVar264 = add i64 %load_ta262, %load_tb263
  store i64 %tmpVar264, i64* %ta, align 4
  %MULTIME_instance265 = alloca %MULTIME_interface, align 8
  br label %input266

else254:                                          ; preds = %case253
  %load_vb276 = load float, float* %vb, align 4
  %load_va277 = load float, float* %va, align 4
  %tmpVar278 = fsub float %load_vb276, %load_va277
  %TIME_TO_REAL_instance279 = alloca %TIME_TO_REAL_interface, align 8
  br label %input280

continue255:                                      ; preds = %continue293, %continue269
  br label %continue18

input266:                                         ; preds = %condition_body256
  %34 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance265, i32 0, i32 0
  %load_time_13 = load i64, i64* %time_13, align 4
  %load_time_12270 = load i64, i64* %time_12, align 4
  %tmpVar271 = sub i64 %load_time_13, %load_time_12270
  store i64 %tmpVar271, i64* %34, align 4
  %35 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance265, i32 0, i32 1
  %load_M272 = load float, float* %M, align 4
  store float %load_M272, float* %35, align 4
  br label %call267

call267:                                          ; preds = %input266
  %call273 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance265)
  br label %output268

output268:                                        ; preds = %call267
  br label %continue269

continue269:                                      ; preds = %output268
  store i64 %call273, i64* %tb, align 4
  %load_value_12274 = load float, float* %value_12, align 4
  store float %load_value_12274, float* %va, align 4
  %load_value_13 = load float, float* %value_13, align 4
  store float %load_value_13, float* %vb, align 4
  %load_value_12275 = load float, float* %value_12, align 4
  store float %load_value_12275, float* %temp, align 4
  store i8 8, i8* %state, align 1
  br label %continue255

input280:                                         ; preds = %else254
  %36 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance279, i32 0, i32 0
  %load_tx284 = load i64, i64* %tx, align 4
  %load_ta285 = load i64, i64* %ta, align 4
  %tmpVar286 = sub i64 %load_tx284, %load_ta285
  store i64 %tmpVar286, i64* %36, align 4
  br label %call281

call281:                                          ; preds = %input280
  %call287 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance279)
  br label %output282

output282:                                        ; preds = %call281
  br label %continue283

continue283:                                      ; preds = %output282
  %tmpVar288 = fmul float %tmpVar278, %call287
  %TIME_TO_REAL_instance289 = alloca %TIME_TO_REAL_interface, align 8
  br label %input290

input290:                                         ; preds = %continue283
  %37 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance289, i32 0, i32 0
  %load_tb294 = load i64, i64* %tb, align 4
  store i64 %load_tb294, i64* %37, align 4
  br label %call291

call291:                                          ; preds = %input290
  %call295 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance289)
  br label %output292

output292:                                        ; preds = %call291
  br label %continue293

continue293:                                      ; preds = %output292
  %tmpVar296 = fdiv float %tmpVar288, %call295
  %load_va297 = load float, float* %va, align 4
  %tmpVar298 = fadd float %tmpVar296, %load_va297
  store float %tmpVar298, float* %temp, align 4
  br label %continue255

condition_body302:                                ; preds = %case299
  %load_value_13308 = load float, float* %value_13, align 4
  store float %load_value_13308, float* %temp, align 4
  store i8 0, i8* %RUN, align 1
  br label %continue301

else300:                                          ; preds = %case299
  %load_vb309 = load float, float* %vb, align 4
  %load_va310 = load float, float* %va, align 4
  %tmpVar311 = fsub float %load_vb309, %load_va310
  %TIME_TO_REAL_instance312 = alloca %TIME_TO_REAL_interface, align 8
  br label %input313

continue301:                                      ; preds = %continue326, %condition_body302
  br label %continue18

input313:                                         ; preds = %else300
  %38 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance312, i32 0, i32 0
  %load_tx317 = load i64, i64* %tx, align 4
  %load_ta318 = load i64, i64* %ta, align 4
  %tmpVar319 = sub i64 %load_tx317, %load_ta318
  store i64 %tmpVar319, i64* %38, align 4
  br label %call314

call314:                                          ; preds = %input313
  %call320 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance312)
  br label %output315

output315:                                        ; preds = %call314
  br label %continue316

continue316:                                      ; preds = %output315
  %tmpVar321 = fmul float %tmpVar311, %call320
  %TIME_TO_REAL_instance322 = alloca %TIME_TO_REAL_interface, align 8
  br label %input323

input323:                                         ; preds = %continue316
  %39 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance322, i32 0, i32 0
  %load_tb327 = load i64, i64* %tb, align 4
  store i64 %load_tb327, i64* %39, align 4
  br label %call324

call324:                                          ; preds = %input323
  %call328 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance322)
  br label %output325

output325:                                        ; preds = %call324
  br label %continue326

continue326:                                      ; preds = %output325
  %tmpVar329 = fdiv float %tmpVar321, %call328
  %load_va330 = load float, float* %va, align 4
  %tmpVar331 = fadd float %tmpVar329, %load_va330
  store float %tmpVar331, float* %temp, align 4
  br label %continue301
}

define void @INC_DEC(%INC_DEC_interface* %0) {
entry:
  %CHa = getelementptr inbounds %INC_DEC_interface, %INC_DEC_interface* %0, i32 0, i32 0
  %CHb = getelementptr inbounds %INC_DEC_interface, %INC_DEC_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %INC_DEC_interface, %INC_DEC_interface* %0, i32 0, i32 2
  %dir = getelementptr inbounds %INC_DEC_interface, %INC_DEC_interface* %0, i32 0, i32 3
  %cnt = getelementptr inbounds %INC_DEC_interface, %INC_DEC_interface* %0, i32 0, i32 4
  %edgea = getelementptr inbounds %INC_DEC_interface, %INC_DEC_interface* %0, i32 0, i32 5
  %clk = getelementptr inbounds %INC_DEC_interface, %INC_DEC_interface* %0, i32 0, i32 6
  %clka = getelementptr inbounds %INC_DEC_interface, %INC_DEC_interface* %0, i32 0, i32 7
  %clkb = getelementptr inbounds %INC_DEC_interface, %INC_DEC_interface* %0, i32 0, i32 8
  %edgeb = getelementptr inbounds %INC_DEC_interface, %INC_DEC_interface* %0, i32 0, i32 9
  %axb = getelementptr inbounds %INC_DEC_interface, %INC_DEC_interface* %0, i32 0, i32 10
  %load_cha = load i8, i8* %CHa, align 1
  %1 = zext i8 %load_cha to i32
  %load_chb = load i8, i8* %CHb, align 1
  %2 = zext i8 %load_chb to i32
  %tmpVar = xor i32 %1, %2
  store i32 %tmpVar, i8* %axb, align 4
  %load_cha1 = load i8, i8* %CHa, align 1
  %3 = zext i8 %load_cha1 to i32
  %load_edgea = load i8, i8* %edgea, align 1
  %4 = zext i8 %load_edgea to i32
  %tmpVar2 = xor i32 %3, %4
  store i32 %tmpVar2, i8* %clka, align 4
  %load_cha3 = load i8, i8* %CHa, align 1
  store i8 %load_cha3, i8* %edgea, align 1
  %load_chb4 = load i8, i8* %CHb, align 1
  %5 = zext i8 %load_chb4 to i32
  %load_edgeb = load i8, i8* %edgeb, align 1
  %6 = zext i8 %load_edgeb to i32
  %tmpVar5 = xor i32 %5, %6
  store i32 %tmpVar5, i8* %clkb, align 4
  %load_chb6 = load i8, i8* %CHb, align 1
  store i8 %load_chb6, i8* %edgeb, align 1
  %load_clka = load i8, i8* %clka, align 1
  %7 = zext i8 %load_clka to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %11, label %9

9:                                                ; preds = %entry
  %load_clkb = load i8, i8* %clkb, align 1
  %10 = zext i8 %load_clkb to i32
  br label %11

11:                                               ; preds = %9, %entry
  %12 = phi i32 [ %7, %entry ], [ %10, %9 ]
  store i32 %12, i8* %clk, align 4
  %load_axb = load i8, i8* %axb, align 1
  %13 = zext i8 %load_axb to i32
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %17, label %19

condition_body:                                   ; preds = %19
  store i8 1, i8* %dir, align 1
  br label %continue

continue:                                         ; preds = %condition_body, %19
  %load_axb10 = load i8, i8* %axb, align 1
  %15 = zext i8 %load_axb10 to i32
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %24, label %26

17:                                               ; preds = %11
  %load_clka7 = load i8, i8* %clka, align 1
  %18 = zext i8 %load_clka7 to i32
  br label %19

19:                                               ; preds = %17, %11
  %20 = phi i32 [ %13, %11 ], [ %18, %17 ]
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %condition_body, label %continue

condition_body9:                                  ; preds = %26
  store i8 0, i8* %dir, align 1
  br label %continue8

continue8:                                        ; preds = %condition_body9, %26
  %load_clk = load i8, i8* %clk, align 1
  %22 = zext i8 %load_clk to i32
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %33, label %35

24:                                               ; preds = %continue
  %load_clkb11 = load i8, i8* %clkb, align 1
  %25 = zext i8 %load_clkb11 to i32
  br label %26

26:                                               ; preds = %24, %continue
  %27 = phi i32 [ %15, %continue ], [ %25, %24 ]
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %condition_body9, label %continue8

condition_body13:                                 ; preds = %35
  %load_cnt = load i16, i16* %cnt, align 2
  %29 = sext i16 %load_cnt to i32
  %tmpVar14 = add i32 %29, 1
  %30 = trunc i32 %tmpVar14 to i16
  store i16 %30, i16* %cnt, align 2
  br label %continue12

continue12:                                       ; preds = %condition_body13, %35
  %load_clk17 = load i8, i8* %clk, align 1
  %31 = zext i8 %load_clk17 to i32
  %32 = icmp ne i32 %31, 0
  br i1 %32, label %41, label %43

33:                                               ; preds = %continue8
  %load_dir = load i8, i8* %dir, align 1
  %34 = zext i8 %load_dir to i32
  br label %35

35:                                               ; preds = %33, %continue8
  %36 = phi i32 [ %22, %continue8 ], [ %34, %33 ]
  %37 = icmp ne i32 %36, 0
  br i1 %37, label %condition_body13, label %continue12

condition_body16:                                 ; preds = %43
  %load_cnt20 = load i16, i16* %cnt, align 2
  %38 = sext i16 %load_cnt20 to i32
  %tmpVar21 = sub i32 %38, 1
  %39 = trunc i32 %tmpVar21 to i16
  store i16 %39, i16* %cnt, align 2
  br label %continue15

continue15:                                       ; preds = %condition_body16, %43
  %load_rst = load i8, i8* %RST, align 1
  %40 = icmp ne i8 %load_rst, 0
  br i1 %40, label %condition_body23, label %continue22

41:                                               ; preds = %continue12
  %load_dir18 = load i8, i8* %dir, align 1
  %tmpVar19 = xor i8 %load_dir18, -1
  %42 = zext i8 %tmpVar19 to i32
  br label %43

43:                                               ; preds = %41, %continue12
  %44 = phi i32 [ %31, %continue12 ], [ %42, %41 ]
  %45 = icmp ne i32 %44, 0
  br i1 %45, label %condition_body16, label %continue15

condition_body23:                                 ; preds = %continue15
  store i16 0, i16* %cnt, align 2
  br label %continue22

continue22:                                       ; preds = %condition_body23, %continue15
  ret void
}

define void @INTERLOCK(%INTERLOCK_interface* %0) {
entry:
  %I1 = getelementptr inbounds %INTERLOCK_interface, %INTERLOCK_interface* %0, i32 0, i32 0
  %I2 = getelementptr inbounds %INTERLOCK_interface, %INTERLOCK_interface* %0, i32 0, i32 1
  %TL = getelementptr inbounds %INTERLOCK_interface, %INTERLOCK_interface* %0, i32 0, i32 2
  %Q1 = getelementptr inbounds %INTERLOCK_interface, %INTERLOCK_interface* %0, i32 0, i32 3
  %Q2 = getelementptr inbounds %INTERLOCK_interface, %INTERLOCK_interface* %0, i32 0, i32 4
  %T1 = getelementptr inbounds %INTERLOCK_interface, %INTERLOCK_interface* %0, i32 0, i32 5
  %T2 = getelementptr inbounds %INTERLOCK_interface, %INTERLOCK_interface* %0, i32 0, i32 6
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %TOF_interface, %TOF_interface* %T1, i32 0, i32 0
  %load_I1 = load i8, i8* %I1, align 1
  store i8 %load_I1, i8* %1, align 1
  %2 = getelementptr inbounds %TOF_interface, %TOF_interface* %T1, i32 0, i32 1
  %load_TL = load i64, i64* %TL, align 4
  store i64 %load_TL, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  call void @TOF(%TOF_interface* %T1)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  br label %input1

input1:                                           ; preds = %continue
  %3 = getelementptr inbounds %TOF_interface, %TOF_interface* %T2, i32 0, i32 0
  %load_I2 = load i8, i8* %I2, align 1
  store i8 %load_I2, i8* %3, align 1
  %4 = getelementptr inbounds %TOF_interface, %TOF_interface* %T2, i32 0, i32 1
  %load_TL5 = load i64, i64* %TL, align 4
  store i64 %load_TL5, i64* %4, align 4
  br label %call2

call2:                                            ; preds = %input1
  call void @TOF(%TOF_interface* %T2)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %load_I16 = load i8, i8* %I1, align 1
  %5 = zext i8 %load_I16 to i32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %7, label %9

7:                                                ; preds = %continue4
  %Q = getelementptr inbounds %TOF_interface, %TOF_interface* %T2, i32 0, i32 2
  %load_ = load i8, i8* %Q, align 1
  %tmpVar = xor i8 %load_, -1
  %8 = zext i8 %tmpVar to i32
  br label %9

9:                                                ; preds = %7, %continue4
  %10 = phi i32 [ %5, %continue4 ], [ %8, %7 ]
  store i32 %10, i8* %Q1, align 4
  %load_I27 = load i8, i8* %I2, align 1
  %11 = zext i8 %load_I27 to i32
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %13, label %15

13:                                               ; preds = %9
  %Q8 = getelementptr inbounds %TOF_interface, %TOF_interface* %T1, i32 0, i32 2
  %load_9 = load i8, i8* %Q8, align 1
  %tmpVar10 = xor i8 %load_9, -1
  %14 = zext i8 %tmpVar10 to i32
  br label %15

15:                                               ; preds = %13, %9
  %16 = phi i32 [ %11, %9 ], [ %14, %13 ]
  store i32 %16, i8* %Q2, align 4
  ret void
}

define void @INTERLOCK_4(%INTERLOCK_4_interface* %0) {
entry:
  %I0 = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 0
  %I1 = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 1
  %I2 = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 2
  %I3 = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 3
  %E = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 4
  %MODE = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 5
  %OUT = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 6
  %TP = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 7
  %in = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 8
  %last = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 9
  %old = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 10
  %lmode = getelementptr inbounds %INTERLOCK_4_interface, %INTERLOCK_4_interface* %0, i32 0, i32 11
  %load_E = load i8, i8* %E, align 1
  %1 = icmp ne i8 %load_E, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_mode = load i16, i16* %MODE, align 2
  %2 = sext i16 %load_mode to i32
  %load_lmode = load i16, i16* %lmode, align 2
  %3 = sext i16 %load_lmode to i32
  %tmpVar = icmp ne i32 %2, %3
  br i1 %tmpVar, label %condition_body2, label %continue1

else:                                             ; preds = %entry
  store i8 0, i8* %OUT, align 1
  store i8 0, i8* %last, align 1
  store i8 0, i8* %old, align 1
  store i16 0, i16* %lmode, align 2
  store i8 0, i8* %TP, align 1
  br label %continue

continue:                                         ; preds = %else, %continue13
  ret void

condition_body2:                                  ; preds = %condition_body
  store i8 0, i8* %OUT, align 1
  store i8 0, i8* %last, align 1
  store i8 0, i8* %old, align 1
  %load_mode3 = load i16, i16* %MODE, align 2
  store i16 %load_mode3, i16* %lmode, align 2
  br label %continue1

continue1:                                        ; preds = %condition_body2, %condition_body
  %4 = load i8, i8* %in, align 1
  %erase = and i8 %4, -2
  %load_I0 = load i8, i8* %I0, align 1
  %value = shl i8 %load_I0, 0
  %or = or i8 %erase, %value
  store i8 %or, i8* %in, align 1
  %5 = load i8, i8* %in, align 1
  %erase4 = and i8 %5, -3
  %load_I1 = load i8, i8* %I1, align 1
  %value5 = shl i8 %load_I1, 1
  %or6 = or i8 %erase4, %value5
  store i8 %or6, i8* %in, align 1
  %6 = load i8, i8* %in, align 1
  %erase7 = and i8 %6, -5
  %load_I2 = load i8, i8* %I2, align 1
  %value8 = shl i8 %load_I2, 2
  %or9 = or i8 %erase7, %value8
  store i8 %or9, i8* %in, align 1
  %7 = load i8, i8* %in, align 1
  %erase10 = and i8 %7, -9
  %load_I3 = load i8, i8* %I3, align 1
  %value11 = shl i8 %load_I3, 3
  %or12 = or i8 %erase10, %value11
  store i8 %or12, i8* %in, align 1
  %load_in = load i8, i8* %in, align 1
  %8 = zext i8 %load_in to i32
  %load_last = load i8, i8* %last, align 1
  %9 = zext i8 %load_last to i32
  %tmpVar15 = icmp ne i32 %8, %9
  br i1 %tmpVar15, label %condition_body14, label %continue13

condition_body14:                                 ; preds = %continue1
  %load_mode17 = load i16, i16* %MODE, align 2
  switch i16 %load_mode17, label %else18 [
    i16 0, label %case
    i16 1, label %case20
    i16 2, label %case33
    i16 3, label %case52
  ]

continue13:                                       ; preds = %continue16, %continue1
  %load_out72 = load i8, i8* %OUT, align 1
  %10 = zext i8 %load_out72 to i32
  %load_old = load i8, i8* %old, align 1
  %11 = zext i8 %load_old to i32
  %tmpVar73 = icmp ne i32 %10, %11
  %12 = zext i1 %tmpVar73 to i8
  store i8 %12, i8* %TP, align 1
  %load_out74 = load i8, i8* %OUT, align 1
  store i8 %load_out74, i8* %old, align 1
  br label %continue

case:                                             ; preds = %condition_body14
  %load_in19 = load i8, i8* %in, align 1
  store i8 %load_in19, i8* %OUT, align 1
  br label %continue16

case20:                                           ; preds = %condition_body14
  %load_in25 = load i8, i8* %in, align 1
  %shift = lshr i8 %load_in25, 3
  %13 = icmp ne i8 %shift, 0
  br i1 %13, label %condition_body24, label %branch

case33:                                           ; preds = %condition_body14
  %load_in34 = load i8, i8* %in, align 1
  %14 = zext i8 %load_in34 to i32
  %load_last35 = load i8, i8* %last, align 1
  %15 = zext i8 %load_last35 to i32
  %tmpVar36 = xor i32 %14, %15
  %16 = icmp ne i32 %tmpVar36, 0
  br i1 %16, label %21, label %23

case52:                                           ; preds = %condition_body14
  %load_out = load i8, i8* %OUT, align 1
  %17 = zext i8 %load_out to i32
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %29, label %31

else18:                                           ; preds = %condition_body14
  br label %continue16

continue16:                                       ; preds = %else18, %continue53, %continue41, %continue23, %case
  %load_in71 = load i8, i8* %in, align 1
  store i8 %load_in71, i8* %last, align 1
  br label %continue13

condition_body24:                                 ; preds = %case20
  store i8 8, i8* %OUT, align 1
  br label %continue23

branch:                                           ; preds = %case20
  %load_in27 = load i8, i8* %in, align 1
  %shift28 = lshr i8 %load_in27, 2
  %19 = icmp ne i8 %shift28, 0
  br i1 %19, label %condition_body26, label %branch21

condition_body26:                                 ; preds = %branch
  store i8 4, i8* %OUT, align 1
  br label %continue23

branch21:                                         ; preds = %branch
  %load_in30 = load i8, i8* %in, align 1
  %shift31 = lshr i8 %load_in30, 1
  %20 = icmp ne i8 %shift31, 0
  br i1 %20, label %condition_body29, label %else22

condition_body29:                                 ; preds = %branch21
  store i8 2, i8* %OUT, align 1
  br label %continue23

else22:                                           ; preds = %branch21
  %load_in32 = load i8, i8* %in, align 1
  store i8 %load_in32, i8* %OUT, align 1
  br label %continue23

continue23:                                       ; preds = %else22, %condition_body29, %condition_body26, %condition_body24
  br label %continue16

21:                                               ; preds = %case33
  %load_in37 = load i8, i8* %in, align 1
  %22 = zext i8 %load_in37 to i32
  br label %23

23:                                               ; preds = %21, %case33
  %24 = phi i32 [ %tmpVar36, %case33 ], [ %22, %21 ]
  store i32 %24, i8* %last, align 4
  %load_last43 = load i8, i8* %last, align 1
  %shift44 = lshr i8 %load_last43, 3
  %25 = icmp ne i8 %shift44, 0
  br i1 %25, label %condition_body42, label %branch38

condition_body42:                                 ; preds = %23
  store i8 8, i8* %OUT, align 1
  br label %continue41

branch38:                                         ; preds = %23
  %load_last46 = load i8, i8* %last, align 1
  %shift47 = lshr i8 %load_last46, 2
  %26 = icmp ne i8 %shift47, 0
  br i1 %26, label %condition_body45, label %branch39

condition_body45:                                 ; preds = %branch38
  store i8 4, i8* %OUT, align 1
  br label %continue41

branch39:                                         ; preds = %branch38
  %load_last49 = load i8, i8* %last, align 1
  %shift50 = lshr i8 %load_last49, 1
  %27 = icmp ne i8 %shift50, 0
  br i1 %27, label %condition_body48, label %else40

condition_body48:                                 ; preds = %branch39
  store i8 2, i8* %OUT, align 1
  br label %continue41

else40:                                           ; preds = %branch39
  %load_last51 = load i8, i8* %last, align 1
  store i8 %load_last51, i8* %OUT, align 1
  br label %continue41

continue41:                                       ; preds = %else40, %condition_body48, %condition_body45, %condition_body42
  br label %continue16

condition_body54:                                 ; preds = %31
  %load_in62 = load i8, i8* %in, align 1
  %shift63 = lshr i8 %load_in62, 3
  %28 = icmp ne i8 %shift63, 0
  br i1 %28, label %condition_body61, label %branch57

continue53:                                       ; preds = %continue60, %31
  br label %continue16

29:                                               ; preds = %case52
  %load_in55 = load i8, i8* %in, align 1
  %30 = zext i8 %load_in55 to i32
  br label %31

31:                                               ; preds = %29, %case52
  %32 = phi i32 [ %17, %case52 ], [ %30, %29 ]
  %tmpVar56 = icmp eq i32 %32, 0
  br i1 %tmpVar56, label %condition_body54, label %continue53

condition_body61:                                 ; preds = %condition_body54
  store i8 8, i8* %OUT, align 1
  br label %continue60

branch57:                                         ; preds = %condition_body54
  %load_in65 = load i8, i8* %in, align 1
  %shift66 = lshr i8 %load_in65, 2
  %33 = icmp ne i8 %shift66, 0
  br i1 %33, label %condition_body64, label %branch58

condition_body64:                                 ; preds = %branch57
  store i8 4, i8* %OUT, align 1
  br label %continue60

branch58:                                         ; preds = %branch57
  %load_in68 = load i8, i8* %in, align 1
  %shift69 = lshr i8 %load_in68, 1
  %34 = icmp ne i8 %shift69, 0
  br i1 %34, label %condition_body67, label %else59

condition_body67:                                 ; preds = %branch58
  store i8 2, i8* %OUT, align 1
  br label %continue60

else59:                                           ; preds = %branch58
  %load_in70 = load i8, i8* %in, align 1
  store i8 %load_in70, i8* %OUT, align 1
  br label %continue60

continue60:                                       ; preds = %else59, %condition_body67, %condition_body64, %condition_body61
  br label %continue53
}

define i8 @MANUAL(%MANUAL_interface* %0) {
entry:
  %IN = getelementptr inbounds %MANUAL_interface, %MANUAL_interface* %0, i32 0, i32 0
  %ON = getelementptr inbounds %MANUAL_interface, %MANUAL_interface* %0, i32 0, i32 1
  %OFF = getelementptr inbounds %MANUAL_interface, %MANUAL_interface* %0, i32 0, i32 2
  %MANUAL = alloca i8, align 1
  store i8 0, i8* %MANUAL, align 1
  %load_OFF = load i8, i8* %OFF, align 1
  %tmpVar = xor i8 %load_OFF, -1
  %1 = zext i8 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %3, label %6

3:                                                ; preds = %entry
  %load_IN = load i8, i8* %IN, align 1
  %4 = zext i8 %load_IN to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %10, label %8

6:                                                ; preds = %10, %entry
  %7 = phi i32 [ %1, %entry ], [ %11, %10 ]
  store i32 %7, i8* %MANUAL, align 4
  %MANUAL_ret = load i8, i8* %MANUAL, align 1
  ret i8 %MANUAL_ret

8:                                                ; preds = %3
  %load_ON = load i8, i8* %ON, align 1
  %9 = zext i8 %load_ON to i32
  br label %10

10:                                               ; preds = %8, %3
  %11 = phi i32 [ %4, %3 ], [ %9, %8 ]
  br label %6
}

define void @MANUAL_1(%MANUAL_1_interface* %0) {
entry:
  %IN = getelementptr inbounds %MANUAL_1_interface, %MANUAL_1_interface* %0, i32 0, i32 0
  %MAN = getelementptr inbounds %MANUAL_1_interface, %MANUAL_1_interface* %0, i32 0, i32 1
  %M_I = getelementptr inbounds %MANUAL_1_interface, %MANUAL_1_interface* %0, i32 0, i32 2
  %SET = getelementptr inbounds %MANUAL_1_interface, %MANUAL_1_interface* %0, i32 0, i32 3
  %RST = getelementptr inbounds %MANUAL_1_interface, %MANUAL_1_interface* %0, i32 0, i32 4
  %Q = getelementptr inbounds %MANUAL_1_interface, %MANUAL_1_interface* %0, i32 0, i32 5
  %STATUS = getelementptr inbounds %MANUAL_1_interface, %MANUAL_1_interface* %0, i32 0, i32 6
  %S_edge = getelementptr inbounds %MANUAL_1_interface, %MANUAL_1_interface* %0, i32 0, i32 7
  %r_edge = getelementptr inbounds %MANUAL_1_interface, %MANUAL_1_interface* %0, i32 0, i32 8
  %edge = getelementptr inbounds %MANUAL_1_interface, %MANUAL_1_interface* %0, i32 0, i32 9
  %load_man = load i8, i8* %MAN, align 1
  %tmpVar = xor i8 %load_man, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  %load_IN = load i8, i8* %IN, align 1
  store i8 %load_IN, i8* %Q, align 1
  store i8 100, i8* %STATUS, align 1
  store i8 0, i8* %edge, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_s_edge = load i8, i8* %S_edge, align 1
  %tmpVar4 = xor i8 %load_s_edge, -1
  %2 = zext i8 %tmpVar4 to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %7, label %9

condition_body3:                                  ; preds = %9
  store i8 1, i8* %Q, align 1
  store i8 1, i8* %edge, align 1
  store i8 101, i8* %STATUS, align 1
  br label %continue

branch1:                                          ; preds = %9
  %load_r_edge = load i8, i8* %r_edge, align 1
  %tmpVar6 = xor i8 %load_r_edge, -1
  %4 = zext i8 %tmpVar6 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %12, label %14

condition_body5:                                  ; preds = %14
  store i8 0, i8* %Q, align 1
  store i8 1, i8* %edge, align 1
  store i8 102, i8* %STATUS, align 1
  br label %continue

branch2:                                          ; preds = %14
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar8 = xor i8 %load_edge, -1
  %6 = icmp ne i8 %tmpVar8, 0
  br i1 %6, label %condition_body7, label %continue

condition_body7:                                  ; preds = %branch2
  %load_M_I = load i8, i8* %M_I, align 1
  store i8 %load_M_I, i8* %Q, align 1
  store i8 103, i8* %STATUS, align 1
  br label %continue

continue:                                         ; preds = %condition_body7, %branch2, %condition_body5, %condition_body3, %condition_body
  %load_SET = load i8, i8* %SET, align 1
  store i8 %load_SET, i8* %S_edge, align 1
  %load_RST = load i8, i8* %RST, align 1
  store i8 %load_RST, i8* %r_edge, align 1
  ret void

7:                                                ; preds = %branch
  %load_set = load i8, i8* %SET, align 1
  %8 = zext i8 %load_set to i32
  br label %9

9:                                                ; preds = %7, %branch
  %10 = phi i32 [ %2, %branch ], [ %8, %7 ]
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %condition_body3, label %branch1

12:                                               ; preds = %branch1
  %load_rst = load i8, i8* %RST, align 1
  %13 = zext i8 %load_rst to i32
  br label %14

14:                                               ; preds = %12, %branch1
  %15 = phi i32 [ %4, %branch1 ], [ %13, %12 ]
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %condition_body5, label %branch2
}

define void @MANUAL_2(%MANUAL_2_interface* %0) {
entry:
  %IN = getelementptr inbounds %MANUAL_2_interface, %MANUAL_2_interface* %0, i32 0, i32 0
  %ENA = getelementptr inbounds %MANUAL_2_interface, %MANUAL_2_interface* %0, i32 0, i32 1
  %ON = getelementptr inbounds %MANUAL_2_interface, %MANUAL_2_interface* %0, i32 0, i32 2
  %OFF = getelementptr inbounds %MANUAL_2_interface, %MANUAL_2_interface* %0, i32 0, i32 3
  %MAN = getelementptr inbounds %MANUAL_2_interface, %MANUAL_2_interface* %0, i32 0, i32 4
  %Q = getelementptr inbounds %MANUAL_2_interface, %MANUAL_2_interface* %0, i32 0, i32 5
  %STATUS = getelementptr inbounds %MANUAL_2_interface, %MANUAL_2_interface* %0, i32 0, i32 6
  %load_ena = load i8, i8* %ENA, align 1
  %1 = icmp ne i8 %load_ena, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_ON = load i8, i8* %ON, align 1
  %tmpVar = xor i8 %load_ON, -1
  %2 = zext i8 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %8, label %10

else:                                             ; preds = %entry
  store i8 0, i8* %Q, align 1
  store i8 104, i8* %STATUS, align 1
  br label %continue

continue:                                         ; preds = %else, %continue3
  ret void

condition_body4:                                  ; preds = %10
  %load_IN = load i8, i8* %IN, align 1
  store i8 %load_IN, i8* %Q, align 1
  store i8 100, i8* %STATUS, align 1
  br label %continue3

branch:                                           ; preds = %10
  %load_on = load i8, i8* %ON, align 1
  %4 = zext i8 %load_on to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %13, label %15

condition_body6:                                  ; preds = %15
  store i8 1, i8* %Q, align 1
  store i8 101, i8* %STATUS, align 1
  br label %continue3

branch1:                                          ; preds = %15
  %load_on9 = load i8, i8* %ON, align 1
  %tmpVar10 = xor i8 %load_on9, -1
  %6 = zext i8 %tmpVar10 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %18, label %20

condition_body8:                                  ; preds = %20
  store i8 0, i8* %Q, align 1
  store i8 102, i8* %STATUS, align 1
  br label %continue3

else2:                                            ; preds = %20
  %load_MAN = load i8, i8* %MAN, align 1
  store i8 %load_MAN, i8* %Q, align 1
  store i8 103, i8* %STATUS, align 1
  br label %continue3

continue3:                                        ; preds = %else2, %condition_body8, %condition_body6, %condition_body4
  br label %continue

8:                                                ; preds = %condition_body
  %load_OFF = load i8, i8* %OFF, align 1
  %tmpVar5 = xor i8 %load_OFF, -1
  %9 = zext i8 %tmpVar5 to i32
  br label %10

10:                                               ; preds = %8, %condition_body
  %11 = phi i32 [ %2, %condition_body ], [ %9, %8 ]
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %condition_body4, label %branch

13:                                               ; preds = %branch
  %load_off = load i8, i8* %OFF, align 1
  %tmpVar7 = xor i8 %load_off, -1
  %14 = zext i8 %tmpVar7 to i32
  br label %15

15:                                               ; preds = %13, %branch
  %16 = phi i32 [ %4, %branch ], [ %14, %13 ]
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %condition_body6, label %branch1

18:                                               ; preds = %branch1
  %load_off11 = load i8, i8* %OFF, align 1
  %19 = zext i8 %load_off11 to i32
  br label %20

20:                                               ; preds = %18, %branch1
  %21 = phi i32 [ %6, %branch1 ], [ %19, %18 ]
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %condition_body8, label %else2
}

define void @MANUAL_4(%MANUAL_4_interface* %0) {
entry:
  %I0 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 0
  %I1 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 1
  %I2 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 2
  %I3 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 3
  %MAN = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 4
  %STP = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 5
  %M0 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 6
  %M1 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 7
  %M2 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 8
  %M3 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 9
  %Q0 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 10
  %Q1 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 11
  %Q2 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 12
  %Q3 = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 13
  %STATUS = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 14
  %edge = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 15
  %pos = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 16
  %tog = getelementptr inbounds %MANUAL_4_interface, %MANUAL_4_interface* %0, i32 0, i32 17
  %load_man = load i8, i8* %MAN, align 1
  %1 = icmp ne i8 %load_man, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_TOG = load i8, i8* %tog, align 1
  %tmpVar = xor i8 %load_TOG, -1
  %2 = icmp ne i8 %tmpVar, 0
  br i1 %2, label %condition_body2, label %continue1

else:                                             ; preds = %entry
  %load_I0 = load i8, i8* %I0, align 1
  store i8 %load_I0, i8* %Q0, align 1
  %load_I1 = load i8, i8* %I1, align 1
  store i8 %load_I1, i8* %Q1, align 1
  %load_I2 = load i8, i8* %I2, align 1
  store i8 %load_I2, i8* %Q2, align 1
  %load_I3 = load i8, i8* %I3, align 1
  store i8 %load_I3, i8* %Q3, align 1
  store i8 100, i8* %STATUS, align 1
  store i8 0, i8* %tog, align 1
  store i16 0, i16* %pos, align 2
  br label %continue

continue:                                         ; preds = %else, %continue3
  %load_STP14 = load i8, i8* %STP, align 1
  store i8 %load_STP14, i8* %edge, align 1
  ret void

condition_body2:                                  ; preds = %condition_body
  %load_M0 = load i8, i8* %M0, align 1
  store i8 %load_M0, i8* %Q0, align 1
  %load_M1 = load i8, i8* %M1, align 1
  store i8 %load_M1, i8* %Q1, align 1
  %load_M2 = load i8, i8* %M2, align 1
  store i8 %load_M2, i8* %Q2, align 1
  %load_M3 = load i8, i8* %M3, align 1
  store i8 %load_M3, i8* %Q3, align 1
  store i8 101, i8* %STATUS, align 1
  br label %continue1

continue1:                                        ; preds = %condition_body2, %condition_body
  %load_STP = load i8, i8* %STP, align 1
  %3 = zext i8 %load_STP to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %5, label %7

condition_body4:                                  ; preds = %7
  store i8 1, i8* %tog, align 1
  %load_pos = load i16, i16* %pos, align 2
  switch i16 %load_pos, label %else7 [
    i16 0, label %case
    i16 1, label %case8
    i16 2, label %case9
    i16 3, label %case10
  ]

continue3:                                        ; preds = %continue11, %7
  br label %continue

5:                                                ; preds = %continue1
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar5 = xor i8 %load_edge, -1
  %6 = zext i8 %tmpVar5 to i32
  br label %7

7:                                                ; preds = %5, %continue1
  %8 = phi i32 [ %3, %continue1 ], [ %6, %5 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body4, label %continue3

case:                                             ; preds = %condition_body4
  store i8 1, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i8 110, i8* %STATUS, align 1
  br label %continue6

case8:                                            ; preds = %condition_body4
  store i8 0, i8* %Q0, align 1
  store i8 1, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i8 111, i8* %STATUS, align 1
  br label %continue6

case9:                                            ; preds = %condition_body4
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 1, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i8 112, i8* %STATUS, align 1
  br label %continue6

case10:                                           ; preds = %condition_body4
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 1, i8* %Q3, align 1
  store i8 113, i8* %STATUS, align 1
  br label %continue6

else7:                                            ; preds = %condition_body4
  br label %continue6

continue6:                                        ; preds = %else7, %case10, %case9, %case8, %case
  %INC_instance = alloca %INC_interface, align 8
  br label %input

input:                                            ; preds = %continue6
  %10 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance, i32 0, i32 0
  %load_pos12 = load i16, i16* %pos, align 2
  store i16 %load_pos12, i16* %10, align 2
  %11 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance, i32 0, i32 1
  store i16 1, i16* %11, align 2
  %12 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance, i32 0, i32 2
  store i16 3, i16* %12, align 2
  br label %call

call:                                             ; preds = %input
  %call13 = call i16 @INC(%INC_interface* %INC_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue11

continue11:                                       ; preds = %output
  store i16 %call13, i16* %pos, align 2
  br label %continue3
}

define void @PARSET(%PARSET_interface* %0) {
entry:
  %A0 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 0
  %A1 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 1
  %X01 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 2
  %X02 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 3
  %X03 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 4
  %X04 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 5
  %X11 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 6
  %X12 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 7
  %X13 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 8
  %X14 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 9
  %X21 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 10
  %X22 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 11
  %X23 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 12
  %X24 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 13
  %X31 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 14
  %X32 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 15
  %X33 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 16
  %X34 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 17
  %TC = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 18
  %P1 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 19
  %P2 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 20
  %P3 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 21
  %P4 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 22
  %X = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 23
  %S1 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 24
  %S2 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 25
  %S3 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 26
  %S4 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 27
  %tx = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 28
  %last = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 29
  %start = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 30
  %set = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 31
  %init = getelementptr inbounds %PARSET_interface, %PARSET_interface* %0, i32 0, i32 32
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %continue2

condition_body:                                   ; preds = %continue
  %2 = load i8, i8* %set, align 1
  %erase = and i8 %2, -2
  %load_A0 = load i8, i8* %A0, align 1
  %tmpVar3 = xor i8 %load_A0, -1
  %value = shl i8 %tmpVar3, 0
  %or = or i8 %erase, %value
  store i8 %or, i8* %set, align 1
  store i8 1, i8* %init, align 1
  %tmpVar4 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 0
  %load_X01 = load float, float* %X01, align 4
  store float %load_X01, float* %tmpVar4, align 4
  %tmpVar5 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 1
  %load_X02 = load float, float* %X02, align 4
  store float %load_X02, float* %tmpVar5, align 4
  %tmpVar6 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 2
  %load_X03 = load float, float* %X03, align 4
  store float %load_X03, float* %tmpVar6, align 4
  %tmpVar7 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 3
  %load_X04 = load float, float* %X04, align 4
  store float %load_X04, float* %tmpVar7, align 4
  %tmpVar8 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 4
  %load_X11 = load float, float* %X11, align 4
  store float %load_X11, float* %tmpVar8, align 4
  %tmpVar9 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 5
  %load_X12 = load float, float* %X12, align 4
  store float %load_X12, float* %tmpVar9, align 4
  %tmpVar10 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 6
  %load_X13 = load float, float* %X13, align 4
  store float %load_X13, float* %tmpVar10, align 4
  %tmpVar11 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 7
  %load_X14 = load float, float* %X14, align 4
  store float %load_X14, float* %tmpVar11, align 4
  %tmpVar12 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 8
  %load_X21 = load float, float* %X21, align 4
  store float %load_X21, float* %tmpVar12, align 4
  %tmpVar13 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 9
  %load_X22 = load float, float* %X22, align 4
  store float %load_X22, float* %tmpVar13, align 4
  %tmpVar14 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 10
  %load_X23 = load float, float* %X23, align 4
  store float %load_X23, float* %tmpVar14, align 4
  %tmpVar15 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 11
  %load_X24 = load float, float* %X24, align 4
  store float %load_X24, float* %tmpVar15, align 4
  %tmpVar16 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 12
  %load_X31 = load float, float* %X31, align 4
  store float %load_X31, float* %tmpVar16, align 4
  %tmpVar17 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 13
  %load_X32 = load float, float* %X32, align 4
  store float %load_X32, float* %tmpVar17, align 4
  %tmpVar18 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 14
  %load_X33 = load float, float* %X33, align 4
  store float %load_X33, float* %tmpVar18, align 4
  %tmpVar19 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 15
  %load_X34 = load float, float* %X34, align 4
  store float %load_X34, float* %tmpVar19, align 4
  %load_X0120 = load float, float* %X01, align 4
  store float %load_X0120, float* %P1, align 4
  %load_X0221 = load float, float* %X02, align 4
  store float %load_X0221, float* %P2, align 4
  %load_X0322 = load float, float* %X03, align 4
  store float %load_X0322, float* %P3, align 4
  %load_X0423 = load float, float* %X04, align 4
  store float %load_X0423, float* %P4, align 4
  br label %continue2

continue2:                                        ; preds = %condition_body, %continue
  %load_A026 = load i8, i8* %A0, align 1
  %3 = zext i8 %load_A026 to i32
  %load_set = load i8, i8* %set, align 1
  %shift = lshr i8 %load_set, 0
  %4 = zext i8 %shift to i32
  %tmpVar27 = xor i32 %3, %4
  %5 = icmp ne i32 %tmpVar27, 0
  br i1 %5, label %18, label %15

condition_body25:                                 ; preds = %18
  %6 = load i8, i8* %set, align 1
  %erase31 = and i8 %6, -2
  %load_A032 = load i8, i8* %A0, align 1
  %value33 = shl i8 %load_A032, 0
  %or34 = or i8 %erase31, %value33
  store i8 %or34, i8* %set, align 1
  %7 = load i8, i8* %set, align 1
  %erase35 = and i8 %7, -3
  %load_A136 = load i8, i8* %A1, align 1
  %value37 = shl i8 %load_A136, 1
  %or38 = or i8 %erase35, %value37
  store i8 %or38, i8* %set, align 1
  %load_tc = load i64, i64* %TC, align 4
  %tmpVar41 = icmp sgt i64 %load_tc, 0
  br i1 %tmpVar41, label %condition_body40, label %continue39

branch:                                           ; preds = %18
  %load_start = load i8, i8* %start, align 1
  %8 = zext i8 %load_start to i32
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %33, label %34

condition_body123:                                ; preds = %34
  %load_set134 = load i8, i8* %set, align 1
  %10 = zext i8 %load_set134 to i32
  %tmpVar135 = mul i32 4, %10
  %tmpVar136 = add i32 %tmpVar135, 0
  %tmpVar137 = add i32 0, %tmpVar136
  %tmpVar138 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar137
  %load_tmpVar139 = load float, float* %tmpVar138, align 4
  %load_S1 = load float, float* %S1, align 4
  %DWORD_TO_REAL_instance140 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input141

else:                                             ; preds = %34
  store i8 0, i8* %start, align 1
  %load_set233 = load i8, i8* %set, align 1
  %11 = zext i8 %load_set233 to i32
  %tmpVar234 = mul i32 4, %11
  %tmpVar235 = add i32 %tmpVar234, 0
  %tmpVar236 = add i32 0, %tmpVar235
  %tmpVar237 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar236
  %load_tmpVar238 = load float, float* %tmpVar237, align 4
  store float %load_tmpVar238, float* %P1, align 4
  %load_set239 = load i8, i8* %set, align 1
  %12 = zext i8 %load_set239 to i32
  %tmpVar240 = mul i32 4, %12
  %tmpVar241 = add i32 %tmpVar240, 0
  %tmpVar242 = add i32 1, %tmpVar241
  %tmpVar243 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar242
  %load_tmpVar244 = load float, float* %tmpVar243, align 4
  store float %load_tmpVar244, float* %P2, align 4
  %load_set245 = load i8, i8* %set, align 1
  %13 = zext i8 %load_set245 to i32
  %tmpVar246 = mul i32 4, %13
  %tmpVar247 = add i32 %tmpVar246, 0
  %tmpVar248 = add i32 2, %tmpVar247
  %tmpVar249 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar248
  %load_tmpVar250 = load float, float* %tmpVar249, align 4
  store float %load_tmpVar250, float* %P3, align 4
  %load_set251 = load i8, i8* %set, align 1
  %14 = zext i8 %load_set251 to i32
  %tmpVar252 = mul i32 4, %14
  %tmpVar253 = add i32 %tmpVar252, 0
  %tmpVar254 = add i32 3, %tmpVar253
  %tmpVar255 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar254
  %load_tmpVar256 = load float, float* %tmpVar255, align 4
  store float %load_tmpVar256, float* %P4, align 4
  br label %continue24

continue24:                                       ; preds = %else, %continue218, %continue39
  ret void

15:                                               ; preds = %continue2
  %load_A1 = load i8, i8* %A1, align 1
  %16 = zext i8 %load_A1 to i32
  %load_set28 = load i8, i8* %set, align 1
  %shift29 = lshr i8 %load_set28, 1
  %17 = zext i8 %shift29 to i32
  %tmpVar30 = xor i32 %16, %17
  br label %18

18:                                               ; preds = %15, %continue2
  %19 = phi i32 [ %tmpVar27, %continue2 ], [ %tmpVar30, %15 ]
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %condition_body25, label %branch

condition_body40:                                 ; preds = %condition_body25
  store i8 1, i8* %start, align 1
  %load_tx = load i32, i32* %tx, align 4
  store i32 %load_tx, i32* %last, align 4
  %load_set42 = load i8, i8* %set, align 1
  %21 = zext i8 %load_set42 to i32
  %tmpVar43 = mul i32 4, %21
  %tmpVar44 = add i32 %tmpVar43, 0
  %tmpVar45 = add i32 0, %tmpVar44
  %tmpVar46 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar45
  %load_tmpVar = load float, float* %tmpVar46, align 4
  %load_P1 = load float, float* %P1, align 4
  %tmpVar47 = fsub float %load_tmpVar, %load_P1
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input48

continue39:                                       ; preds = %continue113, %condition_body25
  br label %continue24

input48:                                          ; preds = %condition_body40
  %22 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input52

call49:                                           ; preds = %continue55
  %call58 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output50

output50:                                         ; preds = %call49
  br label %continue51

continue51:                                       ; preds = %output50
  %tmpVar59 = fdiv float %tmpVar47, %call58
  store float %tmpVar59, float* %S1, align 4
  %load_set60 = load i8, i8* %set, align 1
  %23 = zext i8 %load_set60 to i32
  %tmpVar61 = mul i32 4, %23
  %tmpVar62 = add i32 %tmpVar61, 0
  %tmpVar63 = add i32 1, %tmpVar62
  %tmpVar64 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar63
  %load_tmpVar65 = load float, float* %tmpVar64, align 4
  %load_P2 = load float, float* %P2, align 4
  %tmpVar66 = fsub float %load_tmpVar65, %load_P2
  %DWORD_TO_REAL_instance67 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input68

input52:                                          ; preds = %input48
  %24 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_tc56 = load i64, i64* %TC, align 4
  store i64 %load_tc56, i64* %24, align 4
  br label %call53

call53:                                           ; preds = %input52
  %call57 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output54

output54:                                         ; preds = %call53
  br label %continue55

continue55:                                       ; preds = %output54
  store i32 %call57, i32* %22, align 4
  br label %call49

input68:                                          ; preds = %continue51
  %25 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance67, i32 0, i32 0
  %TIME_TO_DWORD_instance72 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input73

call69:                                           ; preds = %continue76
  %call79 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance67)
  br label %output70

output70:                                         ; preds = %call69
  br label %continue71

continue71:                                       ; preds = %output70
  %tmpVar80 = fdiv float %tmpVar66, %call79
  store float %tmpVar80, float* %S2, align 4
  %load_set81 = load i8, i8* %set, align 1
  %26 = zext i8 %load_set81 to i32
  %tmpVar82 = mul i32 4, %26
  %tmpVar83 = add i32 %tmpVar82, 0
  %tmpVar84 = add i32 2, %tmpVar83
  %tmpVar85 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar84
  %load_tmpVar86 = load float, float* %tmpVar85, align 4
  %load_P3 = load float, float* %P3, align 4
  %tmpVar87 = fsub float %load_tmpVar86, %load_P3
  %DWORD_TO_REAL_instance88 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input89

input73:                                          ; preds = %input68
  %27 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance72, i32 0, i32 0
  %load_tc77 = load i64, i64* %TC, align 4
  store i64 %load_tc77, i64* %27, align 4
  br label %call74

call74:                                           ; preds = %input73
  %call78 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance72)
  br label %output75

output75:                                         ; preds = %call74
  br label %continue76

continue76:                                       ; preds = %output75
  store i32 %call78, i32* %25, align 4
  br label %call69

input89:                                          ; preds = %continue71
  %28 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance88, i32 0, i32 0
  %TIME_TO_DWORD_instance93 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input94

call90:                                           ; preds = %continue97
  %call100 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance88)
  br label %output91

output91:                                         ; preds = %call90
  br label %continue92

continue92:                                       ; preds = %output91
  %tmpVar101 = fdiv float %tmpVar87, %call100
  store float %tmpVar101, float* %S3, align 4
  %load_set102 = load i8, i8* %set, align 1
  %29 = zext i8 %load_set102 to i32
  %tmpVar103 = mul i32 4, %29
  %tmpVar104 = add i32 %tmpVar103, 0
  %tmpVar105 = add i32 3, %tmpVar104
  %tmpVar106 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar105
  %load_tmpVar107 = load float, float* %tmpVar106, align 4
  %load_P4 = load float, float* %P4, align 4
  %tmpVar108 = fsub float %load_tmpVar107, %load_P4
  %DWORD_TO_REAL_instance109 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input110

input94:                                          ; preds = %input89
  %30 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance93, i32 0, i32 0
  %load_tc98 = load i64, i64* %TC, align 4
  store i64 %load_tc98, i64* %30, align 4
  br label %call95

call95:                                           ; preds = %input94
  %call99 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance93)
  br label %output96

output96:                                         ; preds = %call95
  br label %continue97

continue97:                                       ; preds = %output96
  store i32 %call99, i32* %28, align 4
  br label %call90

input110:                                         ; preds = %continue92
  %31 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance109, i32 0, i32 0
  %TIME_TO_DWORD_instance114 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input115

call111:                                          ; preds = %continue118
  %call121 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance109)
  br label %output112

output112:                                        ; preds = %call111
  br label %continue113

continue113:                                      ; preds = %output112
  %tmpVar122 = fdiv float %tmpVar108, %call121
  store float %tmpVar122, float* %S4, align 4
  br label %continue39

input115:                                         ; preds = %input110
  %32 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance114, i32 0, i32 0
  %load_tc119 = load i64, i64* %TC, align 4
  store i64 %load_tc119, i64* %32, align 4
  br label %call116

call116:                                          ; preds = %input115
  %call120 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance114)
  br label %output117

output117:                                        ; preds = %call116
  br label %continue118

continue118:                                      ; preds = %output117
  store i32 %call120, i32* %31, align 4
  br label %call111

33:                                               ; preds = %branch
  %load_tx124 = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar125 = sub i32 %load_tx124, %load_last
  %TIME_TO_DWORD_instance126 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input127

34:                                               ; preds = %continue130, %branch
  %35 = phi i32 [ %8, %branch ], [ %38, %continue130 ]
  %36 = icmp ne i32 %35, 0
  br i1 %36, label %condition_body123, label %else

input127:                                         ; preds = %33
  %37 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance126, i32 0, i32 0
  %load_tc131 = load i64, i64* %TC, align 4
  store i64 %load_tc131, i64* %37, align 4
  br label %call128

call128:                                          ; preds = %input127
  %call132 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance126)
  br label %output129

output129:                                        ; preds = %call128
  br label %continue130

continue130:                                      ; preds = %output129
  %tmpVar133 = icmp slt i32 %tmpVar125, %call132
  %38 = zext i1 %tmpVar133 to i32
  br label %34

input141:                                         ; preds = %condition_body123
  %39 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance140, i32 0, i32 0
  %TIME_TO_DWORD_instance145 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input146

call142:                                          ; preds = %continue149
  %call155 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance140)
  br label %output143

output143:                                        ; preds = %call142
  br label %continue144

continue144:                                      ; preds = %output143
  %tmpVar156 = fmul float %load_S1, %call155
  %tmpVar157 = fsub float %load_tmpVar139, %tmpVar156
  store float %tmpVar157, float* %P1, align 4
  %load_set158 = load i8, i8* %set, align 1
  %40 = zext i8 %load_set158 to i32
  %tmpVar159 = mul i32 4, %40
  %tmpVar160 = add i32 %tmpVar159, 0
  %tmpVar161 = add i32 1, %tmpVar160
  %tmpVar162 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar161
  %load_tmpVar163 = load float, float* %tmpVar162, align 4
  %load_S2 = load float, float* %S2, align 4
  %DWORD_TO_REAL_instance164 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input165

input146:                                         ; preds = %input141
  %41 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance145, i32 0, i32 0
  %load_Tc = load i64, i64* %TC, align 4
  store i64 %load_Tc, i64* %41, align 4
  br label %call147

call147:                                          ; preds = %input146
  %call150 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance145)
  br label %output148

output148:                                        ; preds = %call147
  br label %continue149

continue149:                                      ; preds = %output148
  %load_tx151 = load i32, i32* %tx, align 4
  %tmpVar152 = sub i32 %call150, %load_tx151
  %load_last153 = load i32, i32* %last, align 4
  %tmpVar154 = add i32 %tmpVar152, %load_last153
  store i32 %tmpVar154, i32* %39, align 4
  br label %call142

input165:                                         ; preds = %continue144
  %42 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance164, i32 0, i32 0
  %TIME_TO_DWORD_instance169 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input170

call166:                                          ; preds = %continue173
  %call180 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance164)
  br label %output167

output167:                                        ; preds = %call166
  br label %continue168

continue168:                                      ; preds = %output167
  %tmpVar181 = fmul float %load_S2, %call180
  %tmpVar182 = fsub float %load_tmpVar163, %tmpVar181
  store float %tmpVar182, float* %P2, align 4
  %load_set183 = load i8, i8* %set, align 1
  %43 = zext i8 %load_set183 to i32
  %tmpVar184 = mul i32 4, %43
  %tmpVar185 = add i32 %tmpVar184, 0
  %tmpVar186 = add i32 2, %tmpVar185
  %tmpVar187 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar186
  %load_tmpVar188 = load float, float* %tmpVar187, align 4
  %load_S3 = load float, float* %S3, align 4
  %DWORD_TO_REAL_instance189 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input190

input170:                                         ; preds = %input165
  %44 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance169, i32 0, i32 0
  %load_Tc174 = load i64, i64* %TC, align 4
  store i64 %load_Tc174, i64* %44, align 4
  br label %call171

call171:                                          ; preds = %input170
  %call175 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance169)
  br label %output172

output172:                                        ; preds = %call171
  br label %continue173

continue173:                                      ; preds = %output172
  %load_tx176 = load i32, i32* %tx, align 4
  %tmpVar177 = sub i32 %call175, %load_tx176
  %load_last178 = load i32, i32* %last, align 4
  %tmpVar179 = add i32 %tmpVar177, %load_last178
  store i32 %tmpVar179, i32* %42, align 4
  br label %call166

input190:                                         ; preds = %continue168
  %45 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance189, i32 0, i32 0
  %TIME_TO_DWORD_instance194 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input195

call191:                                          ; preds = %continue198
  %call205 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance189)
  br label %output192

output192:                                        ; preds = %call191
  br label %continue193

continue193:                                      ; preds = %output192
  %tmpVar206 = fmul float %load_S3, %call205
  %tmpVar207 = fsub float %load_tmpVar188, %tmpVar206
  store float %tmpVar207, float* %P3, align 4
  %load_set208 = load i8, i8* %set, align 1
  %46 = zext i8 %load_set208 to i32
  %tmpVar209 = mul i32 4, %46
  %tmpVar210 = add i32 %tmpVar209, 0
  %tmpVar211 = add i32 3, %tmpVar210
  %tmpVar212 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar211
  %load_tmpVar213 = load float, float* %tmpVar212, align 4
  %load_S4 = load float, float* %S4, align 4
  %DWORD_TO_REAL_instance214 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input215

input195:                                         ; preds = %input190
  %47 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance194, i32 0, i32 0
  %load_Tc199 = load i64, i64* %TC, align 4
  store i64 %load_Tc199, i64* %47, align 4
  br label %call196

call196:                                          ; preds = %input195
  %call200 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance194)
  br label %output197

output197:                                        ; preds = %call196
  br label %continue198

continue198:                                      ; preds = %output197
  %load_tx201 = load i32, i32* %tx, align 4
  %tmpVar202 = sub i32 %call200, %load_tx201
  %load_last203 = load i32, i32* %last, align 4
  %tmpVar204 = add i32 %tmpVar202, %load_last203
  store i32 %tmpVar204, i32* %45, align 4
  br label %call191

input215:                                         ; preds = %continue193
  %48 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance214, i32 0, i32 0
  %TIME_TO_DWORD_instance219 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input220

call216:                                          ; preds = %continue223
  %call230 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance214)
  br label %output217

output217:                                        ; preds = %call216
  br label %continue218

continue218:                                      ; preds = %output217
  %tmpVar231 = fmul float %load_S4, %call230
  %tmpVar232 = fsub float %load_tmpVar213, %tmpVar231
  store float %tmpVar232, float* %P4, align 4
  br label %continue24

input220:                                         ; preds = %input215
  %49 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance219, i32 0, i32 0
  %load_Tc224 = load i64, i64* %TC, align 4
  store i64 %load_Tc224, i64* %49, align 4
  br label %call221

call221:                                          ; preds = %input220
  %call225 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance219)
  br label %output222

output222:                                        ; preds = %call221
  br label %continue223

continue223:                                      ; preds = %output222
  %load_tx226 = load i32, i32* %tx, align 4
  %tmpVar227 = sub i32 %call225, %load_tx226
  %load_last228 = load i32, i32* %last, align 4
  %tmpVar229 = add i32 %tmpVar227, %load_last228
  store i32 %tmpVar229, i32* %48, align 4
  br label %call216
}

define void @PARSET2(%PARSET2_interface* %0) {
entry:
  %X = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 0
  %X01 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 1
  %X02 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 2
  %X03 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 3
  %X04 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 4
  %X11 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 5
  %X12 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 6
  %X13 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 7
  %X14 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 8
  %X21 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 9
  %X22 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 10
  %X23 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 11
  %X24 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 12
  %X31 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 13
  %X32 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 14
  %X33 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 15
  %X34 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 16
  %L1 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 17
  %L2 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 18
  %L3 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 19
  %TC = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 20
  %P1 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 21
  %P2 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 22
  %P3 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 23
  %P4 = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 24
  %Pset = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 25
  %init = getelementptr inbounds %PARSET2_interface, %PARSET2_interface* %0, i32 0, i32 26
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  store i8 1, i8* %init, align 1
  br label %input

continue:                                         ; preds = %continue1, %entry
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input5

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 18
  %load_TC = load i64, i64* %TC, align 4
  store i64 %load_TC, i64* %2, align 4
  %3 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 2
  %load_X01 = load float, float* %X01, align 4
  store float %load_X01, float* %3, align 4
  %4 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 3
  %load_X02 = load float, float* %X02, align 4
  store float %load_X02, float* %4, align 4
  %5 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 4
  %load_X03 = load float, float* %X03, align 4
  store float %load_X03, float* %5, align 4
  %6 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 5
  %load_X04 = load float, float* %X04, align 4
  store float %load_X04, float* %6, align 4
  %7 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 6
  %load_X11 = load float, float* %X11, align 4
  store float %load_X11, float* %7, align 4
  %8 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 7
  %load_X12 = load float, float* %X12, align 4
  store float %load_X12, float* %8, align 4
  %9 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 8
  %load_X13 = load float, float* %X13, align 4
  store float %load_X13, float* %9, align 4
  %10 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 9
  %load_X14 = load float, float* %X14, align 4
  store float %load_X14, float* %10, align 4
  %11 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 10
  %load_X21 = load float, float* %X21, align 4
  store float %load_X21, float* %11, align 4
  %12 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 11
  %load_X22 = load float, float* %X22, align 4
  store float %load_X22, float* %12, align 4
  %13 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 12
  %load_X23 = load float, float* %X23, align 4
  store float %load_X23, float* %13, align 4
  %14 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 13
  %load_X24 = load float, float* %X24, align 4
  store float %load_X24, float* %14, align 4
  %15 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 14
  %load_X31 = load float, float* %X31, align 4
  store float %load_X31, float* %15, align 4
  %16 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 15
  %load_X32 = load float, float* %X32, align 4
  store float %load_X32, float* %16, align 4
  %17 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 16
  %load_X33 = load float, float* %X33, align 4
  store float %load_X33, float* %17, align 4
  %18 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 17
  %load_X34 = load float, float* %X34, align 4
  store float %load_X34, float* %18, align 4
  br label %call

call:                                             ; preds = %input
  call void @PARSET(%PARSET_interface* %Pset)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  br label %continue

condition_body4:                                  ; preds = %continue8
  br label %input11

branch:                                           ; preds = %continue8
  %ABS_instance16 = alloca %ABS_interface, align 8
  br label %input17

condition_body15:                                 ; preds = %continue20
  br label %input28

branch2:                                          ; preds = %continue20
  %ABS_instance33 = alloca %ABS_interface, align 8
  br label %input34

condition_body32:                                 ; preds = %continue37
  br label %input40

else:                                             ; preds = %continue37
  br label %input44

continue3:                                        ; preds = %continue47, %continue43, %continue31, %continue14
  %P148 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 19
  %load_ = load float, float* %P148, align 4
  store float %load_, float* %P1, align 4
  %P249 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 20
  %load_50 = load float, float* %P249, align 4
  store float %load_50, float* %P2, align 4
  %P351 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 21
  %load_52 = load float, float* %P351, align 4
  store float %load_52, float* %P3, align 4
  %P453 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 22
  %load_54 = load float, float* %P453, align 4
  store float %load_54, float* %P4, align 4
  ret void

input5:                                           ; preds = %continue
  %19 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  %20 = fptoui float %load_X to i64
  store i64 %20, i64* %19, align 4
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %21 = uitofp i64 %call9 to double
  %load_L1 = load float, float* %L1, align 4
  %22 = fpext float %load_L1 to double
  %tmpVar10 = fcmp olt double %21, %22
  br i1 %tmpVar10, label %condition_body4, label %branch

input11:                                          ; preds = %condition_body4
  %23 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 0
  store i8 0, i8* %23, align 1
  %24 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 1
  store i8 0, i8* %24, align 1
  br label %call12

call12:                                           ; preds = %input11
  call void @PARSET(%PARSET_interface* %Pset)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  br label %continue3

input17:                                          ; preds = %branch
  %25 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance16, i32 0, i32 0
  %load_X25 = load float, float* %X, align 4
  %26 = fptoui float %load_X25 to i64
  store i64 %26, i64* %25, align 4
  br label %call18

call18:                                           ; preds = %input17
  %call26 = call i64 @ABS(%ABS_interface* %ABS_instance16)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %27 = uitofp i64 %call26 to double
  %load_L2 = load float, float* %L2, align 4
  %28 = fpext float %load_L2 to double
  %tmpVar27 = fcmp olt double %27, %28
  br i1 %tmpVar27, label %condition_body15, label %branch2

input28:                                          ; preds = %condition_body15
  %29 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 0
  store i8 1, i8* %29, align 1
  %30 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 1
  store i8 0, i8* %30, align 1
  br label %call29

call29:                                           ; preds = %input28
  call void @PARSET(%PARSET_interface* %Pset)
  br label %output30

output30:                                         ; preds = %call29
  br label %continue31

continue31:                                       ; preds = %output30
  br label %continue3

input34:                                          ; preds = %branch2
  %31 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance33, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %32 = fptoui float %load_x to i64
  store i64 %32, i64* %31, align 4
  br label %call35

call35:                                           ; preds = %input34
  %call38 = call i64 @ABS(%ABS_interface* %ABS_instance33)
  br label %output36

output36:                                         ; preds = %call35
  br label %continue37

continue37:                                       ; preds = %output36
  %33 = uitofp i64 %call38 to double
  %load_L3 = load float, float* %L3, align 4
  %34 = fpext float %load_L3 to double
  %tmpVar39 = fcmp olt double %33, %34
  br i1 %tmpVar39, label %condition_body32, label %else

input40:                                          ; preds = %condition_body32
  %35 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 0
  store i8 0, i8* %35, align 1
  %36 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 1
  store i8 1, i8* %36, align 1
  br label %call41

call41:                                           ; preds = %input40
  call void @PARSET(%PARSET_interface* %Pset)
  br label %output42

output42:                                         ; preds = %call41
  br label %continue43

continue43:                                       ; preds = %output42
  br label %continue3

input44:                                          ; preds = %else
  %37 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 0
  store i8 1, i8* %37, align 1
  %38 = getelementptr inbounds %PARSET_interface, %PARSET_interface* %Pset, i32 0, i32 1
  store i8 1, i8* %38, align 1
  br label %call45

call45:                                           ; preds = %input44
  call void @PARSET(%PARSET_interface* %Pset)
  br label %output46

output46:                                         ; preds = %call45
  br label %continue47

continue47:                                       ; preds = %output46
  br label %continue3
}

define void @SIGNAL(%SIGNAL_interface* %0) {
entry:
  %IN = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %0, i32 0, i32 0
  %SIG = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %0, i32 0, i32 1
  %TS = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %0, i32 0, i32 4
  %step = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %0, i32 0, i32 5
  %one = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %0, i32 0, i32 6
  %load_in = load i8, i8* %IN, align 1
  %1 = icmp ne i8 %load_in, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

else:                                             ; preds = %entry
  store i8 0, i8* %Q, align 1
  br label %continue

continue:                                         ; preds = %else, %25
  ret void

input:                                            ; preds = %condition_body
  br label %call

call:                                             ; preds = %input
  %call2 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store i32 %call2, i32* %tx, align 4
  %load_ts = load i64, i64* %TS, align 4
  %tmpVar = icmp sgt i64 %load_ts, 0
  br i1 %tmpVar, label %condition_body5, label %else3

condition_body5:                                  ; preds = %continue1
  %DWORD_TO_BYTE_instance = alloca %DWORD_TO_BYTE_interface, align 8
  br label %input6

else3:                                            ; preds = %continue1
  %DWORD_TO_BYTE_instance18 = alloca %DWORD_TO_BYTE_interface, align 8
  br label %input19

continue4:                                        ; preds = %continue22, %continue9
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input30

input6:                                           ; preds = %condition_body5
  %2 = getelementptr inbounds %DWORD_TO_BYTE_interface, %DWORD_TO_BYTE_interface* %DWORD_TO_BYTE_instance, i32 0, i32 0
  %load_tx = load i32, i32* %tx, align 4
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input10

call7:                                            ; preds = %4
  %call17 = call i8 @DWORD_TO_BYTE(%DWORD_TO_BYTE_interface* %DWORD_TO_BYTE_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  store i8 %call17, i8* %step, align 1
  br label %continue4

3:                                                ; preds = %continue13
  br label %4

4:                                                ; preds = %3, %continue13
  %5 = phi i32 [ %tmpVar16, %continue13 ], [ 7, %3 ]
  store i32 %5, i32* %2, align 4
  br label %call7

input10:                                          ; preds = %input6
  %6 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_ts14 = load i64, i64* %TS, align 4
  store i64 %load_ts14, i64* %6, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call15 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %tmpVar16 = sdiv i32 %load_tx, %call15
  %7 = icmp ne i32 %tmpVar16, 0
  br i1 %7, label %3, label %4

input19:                                          ; preds = %else3
  %8 = getelementptr inbounds %DWORD_TO_BYTE_interface, %DWORD_TO_BYTE_interface* %DWORD_TO_BYTE_instance18, i32 0, i32 0
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input23

call20:                                           ; preds = %10
  %call29 = call i8 @DWORD_TO_BYTE(%DWORD_TO_BYTE_interface* %DWORD_TO_BYTE_instance18)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  store i8 %call29, i8* %step, align 1
  br label %continue4

9:                                                ; preds = %continue26
  br label %10

10:                                               ; preds = %9, %continue26
  %11 = phi i64 [ %call28, %continue26 ], [ 7, %9 ]
  store i64 %11, i32* %8, align 4
  br label %call20

input23:                                          ; preds = %input19
  %12 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_tx27 = load i32, i32* %tx, align 4
  %13 = zext i32 %load_tx27 to i64
  store i64 %13, i64* %12, align 4
  %14 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 7, i16* %14, align 2
  br label %call24

call24:                                           ; preds = %input23
  %call28 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %15 = icmp ne i64 %call28, 0
  br i1 %15, label %9, label %10

input30:                                          ; preds = %continue4
  %16 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_one = load i8, i8* %one, align 1
  %17 = zext i8 %load_one to i64
  store i64 %17, i64* %16, align 4
  %18 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_step = load i8, i8* %step, align 1
  %19 = zext i8 %load_step to i16
  store i16 %19, i16* %18, align 2
  br label %call31

call31:                                           ; preds = %input30
  %call34 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output32

output32:                                         ; preds = %call31
  br label %continue33

continue33:                                       ; preds = %output32
  %20 = trunc i64 %call34 to i8
  store i8 %20, i8* %step, align 1
  %load_step35 = load i8, i8* %step, align 1
  %21 = zext i8 %load_step35 to i32
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %23, label %25

23:                                               ; preds = %continue33
  %load_sig = load i8, i8* %SIG, align 1
  %24 = zext i8 %load_sig to i32
  br label %25

25:                                               ; preds = %23, %continue33
  %26 = phi i32 [ %21, %continue33 ], [ %24, %23 ]
  %tmpVar36 = icmp sgt i32 %26, 0
  %27 = zext i1 %tmpVar36 to i8
  store i8 %27, i8* %Q, align 1
  br label %continue
}

define void @SIGNAL_4(%SIGNAL_4_interface* %0) {
entry:
  %IN1 = getelementptr inbounds %SIGNAL_4_interface, %SIGNAL_4_interface* %0, i32 0, i32 0
  %IN2 = getelementptr inbounds %SIGNAL_4_interface, %SIGNAL_4_interface* %0, i32 0, i32 1
  %IN3 = getelementptr inbounds %SIGNAL_4_interface, %SIGNAL_4_interface* %0, i32 0, i32 2
  %IN4 = getelementptr inbounds %SIGNAL_4_interface, %SIGNAL_4_interface* %0, i32 0, i32 3
  %TS = getelementptr inbounds %SIGNAL_4_interface, %SIGNAL_4_interface* %0, i32 0, i32 4
  %S1 = getelementptr inbounds %SIGNAL_4_interface, %SIGNAL_4_interface* %0, i32 0, i32 5
  %S2 = getelementptr inbounds %SIGNAL_4_interface, %SIGNAL_4_interface* %0, i32 0, i32 6
  %S3 = getelementptr inbounds %SIGNAL_4_interface, %SIGNAL_4_interface* %0, i32 0, i32 7
  %S4 = getelementptr inbounds %SIGNAL_4_interface, %SIGNAL_4_interface* %0, i32 0, i32 8
  %Q = getelementptr inbounds %SIGNAL_4_interface, %SIGNAL_4_interface* %0, i32 0, i32 9
  %sig = getelementptr inbounds %SIGNAL_4_interface, %SIGNAL_4_interface* %0, i32 0, i32 10
  %load_in1 = load i8, i8* %IN1, align 1
  %1 = icmp ne i8 %load_in1, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  br label %input

branch:                                           ; preds = %entry
  %load_in2 = load i8, i8* %IN2, align 1
  %2 = icmp ne i8 %load_in2, 0
  br i1 %2, label %condition_body4, label %branch1

condition_body4:                                  ; preds = %branch
  br label %input5

branch1:                                          ; preds = %branch
  %load_in3 = load i8, i8* %IN3, align 1
  %3 = icmp ne i8 %load_in3, 0
  br i1 %3, label %condition_body10, label %branch2

condition_body10:                                 ; preds = %branch1
  br label %input11

branch2:                                          ; preds = %branch1
  %load_in4 = load i8, i8* %IN4, align 1
  %4 = icmp ne i8 %load_in4, 0
  br i1 %4, label %condition_body16, label %else

condition_body16:                                 ; preds = %branch2
  br label %input17

else:                                             ; preds = %branch2
  br label %input22

continue:                                         ; preds = %continue25, %continue20, %continue14, %continue8, %continue3
  %Q26 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 3
  %load_ = load i8, i8* %Q26, align 1
  store i8 %load_, i8* %Q, align 1
  ret void

input:                                            ; preds = %condition_body
  %5 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 0
  store i8 1, i8* %5, align 1
  %6 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 1
  %load_s1 = load i8, i8* %S1, align 1
  store i8 %load_s1, i8* %6, align 1
  %7 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 2
  %load_TS = load i64, i64* %TS, align 4
  store i64 %load_TS, i64* %7, align 4
  br label %call

call:                                             ; preds = %input
  call void @SIGNAL(%SIGNAL_interface* %sig)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  br label %continue

input5:                                           ; preds = %condition_body4
  %8 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 0
  store i8 1, i8* %8, align 1
  %9 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 1
  %load_s2 = load i8, i8* %S2, align 1
  store i8 %load_s2, i8* %9, align 1
  %10 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 2
  %load_TS9 = load i64, i64* %TS, align 4
  store i64 %load_TS9, i64* %10, align 4
  br label %call6

call6:                                            ; preds = %input5
  call void @SIGNAL(%SIGNAL_interface* %sig)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  br label %continue

input11:                                          ; preds = %condition_body10
  %11 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 0
  store i8 1, i8* %11, align 1
  %12 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 1
  %load_s3 = load i8, i8* %S3, align 1
  store i8 %load_s3, i8* %12, align 1
  %13 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 2
  %load_TS15 = load i64, i64* %TS, align 4
  store i64 %load_TS15, i64* %13, align 4
  br label %call12

call12:                                           ; preds = %input11
  call void @SIGNAL(%SIGNAL_interface* %sig)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  br label %continue

input17:                                          ; preds = %condition_body16
  %14 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 0
  store i8 1, i8* %14, align 1
  %15 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 1
  %load_s4 = load i8, i8* %S4, align 1
  store i8 %load_s4, i8* %15, align 1
  %16 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 2
  %load_TS21 = load i64, i64* %TS, align 4
  store i64 %load_TS21, i64* %16, align 4
  br label %call18

call18:                                           ; preds = %input17
  call void @SIGNAL(%SIGNAL_interface* %sig)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  br label %continue

input22:                                          ; preds = %else
  %17 = getelementptr inbounds %SIGNAL_interface, %SIGNAL_interface* %sig, i32 0, i32 0
  store i8 0, i8* %17, align 1
  br label %call23

call23:                                           ; preds = %input22
  call void @SIGNAL(%SIGNAL_interface* %sig)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  br label %continue
}

define void @SRAMP(%SRAMP_interface* %0) {
entry:
  %X = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 0
  %A_UP = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 1
  %A_DN = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 2
  %VU_MAX = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 3
  %VD_MAX = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 4
  %LIMIT_HIGH = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 5
  %LIMIT_LOW = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 6
  %RST = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 7
  %Y = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 8
  %V = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 9
  %cycle_time = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 10
  %init = getelementptr inbounds %SRAMP_interface, %SRAMP_interface* %0, i32 0, i32 11
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  call void @TC_S(%TC_S_interface* %cycle_time)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %MAX_instance = alloca %MAX_interface, align 8
  br label %input1

input1:                                           ; preds = %continue
  %1 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 0
  store i64 0, i64* %1, align 4
  %2 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 1
  %load_A_UP = load float, float* %A_UP, align 4
  %3 = fptoui float %load_A_UP to i64
  store i64 %3, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i64 @MAX(%MAX_interface* %MAX_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %4 = uitofp i64 %call5 to float
  store float %4, float* %A_UP, align 4
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input6

input6:                                           ; preds = %continue4
  %5 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  store i64 0, i64* %5, align 4
  %6 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_A_dn = load float, float* %A_DN, align 4
  %7 = fptoui float %load_A_dn to i64
  store i64 %7, i64* %6, align 4
  br label %call7

call7:                                            ; preds = %input6
  %call10 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %8 = uitofp i64 %call10 to float
  store float %8, float* %A_DN, align 4
  %MAX_instance11 = alloca %MAX_interface, align 8
  br label %input12

input12:                                          ; preds = %continue9
  %9 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance11, i32 0, i32 0
  store i64 0, i64* %9, align 4
  %10 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance11, i32 0, i32 1
  %load_VU_max = load float, float* %VU_MAX, align 4
  %11 = fptoui float %load_VU_max to i64
  store i64 %11, i64* %10, align 4
  br label %call13

call13:                                           ; preds = %input12
  %call16 = call i64 @MAX(%MAX_interface* %MAX_instance11)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %12 = uitofp i64 %call16 to float
  store float %12, float* %VU_MAX, align 4
  %MIN_instance17 = alloca %MIN_interface, align 8
  br label %input18

input18:                                          ; preds = %continue15
  %13 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance17, i32 0, i32 0
  store i64 0, i64* %13, align 4
  %14 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance17, i32 0, i32 1
  %load_VD_MAX = load float, float* %VD_MAX, align 4
  %15 = fptoui float %load_VD_MAX to i64
  store i64 %15, i64* %14, align 4
  br label %call19

call19:                                           ; preds = %input18
  %call22 = call i64 @MIN(%MIN_interface* %MIN_instance17)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %16 = uitofp i64 %call22 to float
  store float %16, float* %VD_MAX, align 4
  %load_rst = load i8, i8* %RST, align 1
  %17 = zext i8 %load_rst to i32
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %21, label %19

condition_body:                                   ; preds = %21
  store i8 1, i8* %init, align 1
  store float 0.000000e+00, float* %Y, align 4
  store float 0.000000e+00, float* %V, align 4
  br label %continue25

branch:                                           ; preds = %21
  %load_X = load float, float* %X, align 4
  %load_Y = load float, float* %Y, align 4
  %tmpVar27 = fcmp oeq float %load_X, %load_Y
  br i1 %tmpVar27, label %condition_body26, label %branch23

condition_body26:                                 ; preds = %branch
  store float 0.000000e+00, float* %V, align 4
  br label %continue25

branch23:                                         ; preds = %branch
  %load_X29 = load float, float* %X, align 4
  %load_Y30 = load float, float* %Y, align 4
  %tmpVar31 = fcmp ogt float %load_X29, %load_Y30
  br i1 %tmpVar31, label %condition_body28, label %branch24

condition_body28:                                 ; preds = %branch23
  %MIN_instance32 = alloca %MIN_interface, align 8
  br label %input33

branch24:                                         ; preds = %branch23
  %load_X78 = load float, float* %X, align 4
  %load_Y79 = load float, float* %Y, align 4
  %tmpVar80 = fcmp olt float %load_X78, %load_Y79
  br i1 %tmpVar80, label %condition_body77, label %continue25

condition_body77:                                 ; preds = %branch24
  %MAX_instance81 = alloca %MAX_interface, align 8
  br label %input82

continue25:                                       ; preds = %continue117, %branch24, %continue61, %condition_body26, %condition_body
  ret void

19:                                               ; preds = %continue21
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %20 = zext i8 %tmpVar to i32
  br label %21

21:                                               ; preds = %19, %continue21
  %22 = phi i32 [ %17, %continue21 ], [ %20, %19 ]
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %condition_body, label %branch

input33:                                          ; preds = %condition_body28
  %24 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance32, i32 0, i32 0
  %load_v = load float, float* %V, align 4
  %load_A_UP37 = load float, float* %A_UP, align 4
  %TC = getelementptr inbounds %TC_S_interface, %TC_S_interface* %cycle_time, i32 0, i32 0
  %load_ = load float, float* %TC, align 4
  %tmpVar38 = fmul float %load_A_UP37, %load_
  %tmpVar39 = fadd float %load_v, %tmpVar38
  %25 = fptoui float %tmpVar39 to i64
  store i64 %25, i64* %24, align 4
  %26 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance32, i32 0, i32 1
  %load_vu_max = load float, float* %VU_MAX, align 4
  %27 = fptoui float %load_vu_max to i64
  store i64 %27, i64* %26, align 4
  br label %call34

call34:                                           ; preds = %input33
  %call40 = call i64 @MIN(%MIN_interface* %MIN_instance32)
  br label %output35

output35:                                         ; preds = %call34
  br label %continue36

continue36:                                       ; preds = %output35
  %28 = uitofp i64 %call40 to float
  store float %28, float* %V, align 4
  %MIN_instance41 = alloca %MIN_interface, align 8
  br label %input42

input42:                                          ; preds = %continue36
  %29 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance41, i32 0, i32 0
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input46

call43:                                           ; preds = %continue49
  %call57 = call i64 @MIN(%MIN_interface* %MIN_instance41)
  br label %output44

output44:                                         ; preds = %call43
  br label %continue45

continue45:                                       ; preds = %output44
  %30 = uitofp i64 %call57 to float
  store float %30, float* %V, align 4
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input58

input46:                                          ; preds = %input42
  %31 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_Y50 = load float, float* %Y, align 4
  %load_X51 = load float, float* %X, align 4
  %tmpVar52 = fsub float %load_Y50, %load_X51
  %tmpVar53 = fmul float %tmpVar52, 2.000000e+00
  %load_A_DN = load float, float* %A_DN, align 4
  %tmpVar54 = fmul float %tmpVar53, %load_A_DN
  %32 = fptosi float %tmpVar54 to i32
  store i32 %32, i32* %31, align 4
  br label %call47

call47:                                           ; preds = %input46
  %call55 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output48

output48:                                         ; preds = %call47
  br label %continue49

continue49:                                       ; preds = %output48
  %33 = fptoui double %call55 to i64
  store i64 %33, i64* %29, align 4
  %34 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance41, i32 0, i32 1
  %load_v56 = load float, float* %V, align 4
  %35 = fptoui float %load_v56 to i64
  store i64 %35, i64* %34, align 4
  br label %call43

input58:                                          ; preds = %continue45
  %36 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_limit_low = load float, float* %LIMIT_LOW, align 4
  %37 = fptoui float %load_limit_low to i64
  store i64 %37, i64* %36, align 4
  %38 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_y = load float, float* %Y, align 4
  %39 = fpext float %load_y to double
  %MIN_instance62 = alloca %MIN_interface, align 8
  br label %input63

call59:                                           ; preds = %continue66
  %call76 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output60

output60:                                         ; preds = %call59
  br label %continue61

continue61:                                       ; preds = %output60
  %40 = uitofp i64 %call76 to float
  store float %40, float* %Y, align 4
  br label %continue25

input63:                                          ; preds = %input58
  %41 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance62, i32 0, i32 0
  %load_v67 = load float, float* %V, align 4
  %TC68 = getelementptr inbounds %TC_S_interface, %TC_S_interface* %cycle_time, i32 0, i32 0
  %load_69 = load float, float* %TC68, align 4
  %tmpVar70 = fmul float %load_v67, %load_69
  %42 = fptoui float %tmpVar70 to i64
  store i64 %42, i64* %41, align 4
  %43 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance62, i32 0, i32 1
  %load_X71 = load float, float* %X, align 4
  %load_Y72 = load float, float* %Y, align 4
  %tmpVar73 = fsub float %load_X71, %load_Y72
  %44 = fptoui float %tmpVar73 to i64
  store i64 %44, i64* %43, align 4
  br label %call64

call64:                                           ; preds = %input63
  %call74 = call i64 @MIN(%MIN_interface* %MIN_instance62)
  br label %output65

output65:                                         ; preds = %call64
  br label %continue66

continue66:                                       ; preds = %output65
  %45 = uitofp i64 %call74 to double
  %tmpVar75 = fadd double %39, %45
  %46 = fptoui double %tmpVar75 to i64
  store i64 %46, i64* %38, align 4
  %47 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_limit_high = load float, float* %LIMIT_HIGH, align 4
  %48 = fptoui float %load_limit_high to i64
  store i64 %48, i64* %47, align 4
  br label %call59

input82:                                          ; preds = %condition_body77
  %49 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance81, i32 0, i32 0
  %load_v86 = load float, float* %V, align 4
  %load_A_DN87 = load float, float* %A_DN, align 4
  %TC88 = getelementptr inbounds %TC_S_interface, %TC_S_interface* %cycle_time, i32 0, i32 0
  %load_89 = load float, float* %TC88, align 4
  %tmpVar90 = fmul float %load_A_DN87, %load_89
  %tmpVar91 = fadd float %load_v86, %tmpVar90
  %50 = fptoui float %tmpVar91 to i64
  store i64 %50, i64* %49, align 4
  %51 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance81, i32 0, i32 1
  %load_vd_max = load float, float* %VD_MAX, align 4
  %52 = fptoui float %load_vd_max to i64
  store i64 %52, i64* %51, align 4
  br label %call83

call83:                                           ; preds = %input82
  %call92 = call i64 @MAX(%MAX_interface* %MAX_instance81)
  br label %output84

output84:                                         ; preds = %call83
  br label %continue85

continue85:                                       ; preds = %output84
  %53 = uitofp i64 %call92 to float
  store float %53, float* %V, align 4
  %MAX_instance93 = alloca %MAX_interface, align 8
  br label %input94

input94:                                          ; preds = %continue85
  %54 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance93, i32 0, i32 0
  %SQRT_instance98 = alloca %SQRT_interface, align 8
  br label %input99

call95:                                           ; preds = %continue102
  %call112 = call i64 @MAX(%MAX_interface* %MAX_instance93)
  br label %output96

output96:                                         ; preds = %call95
  br label %continue97

continue97:                                       ; preds = %output96
  %55 = uitofp i64 %call112 to float
  store float %55, float* %V, align 4
  %LIMIT_instance113 = alloca %LIMIT_interface, align 8
  br label %input114

input99:                                          ; preds = %input94
  %56 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance98, i32 0, i32 0
  %load_Y103 = load float, float* %Y, align 4
  %load_X104 = load float, float* %X, align 4
  %tmpVar105 = fsub float %load_Y103, %load_X104
  %tmpVar106 = fmul float %tmpVar105, 2.000000e+00
  %load_A_UP107 = load float, float* %A_UP, align 4
  %tmpVar108 = fmul float %tmpVar106, %load_A_UP107
  %57 = fptosi float %tmpVar108 to i32
  store i32 %57, i32* %56, align 4
  br label %call100

call100:                                          ; preds = %input99
  %call109 = call double @SQRT(%SQRT_interface* %SQRT_instance98)
  br label %output101

output101:                                        ; preds = %call100
  br label %continue102

continue102:                                      ; preds = %output101
  %tmpVar110 = fneg double %call109
  %58 = fptoui double %tmpVar110 to i64
  store i64 %58, i64* %54, align 4
  %59 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance93, i32 0, i32 1
  %load_v111 = load float, float* %V, align 4
  %60 = fptoui float %load_v111 to i64
  store i64 %60, i64* %59, align 4
  br label %call95

input114:                                         ; preds = %continue97
  %61 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance113, i32 0, i32 0
  %load_limit_low118 = load float, float* %LIMIT_LOW, align 4
  %62 = fptoui float %load_limit_low118 to i64
  store i64 %62, i64* %61, align 4
  %63 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance113, i32 0, i32 1
  %load_y119 = load float, float* %Y, align 4
  %64 = fpext float %load_y119 to double
  %MAX_instance120 = alloca %MAX_interface, align 8
  br label %input121

call115:                                          ; preds = %continue124
  %call135 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance113)
  br label %output116

output116:                                        ; preds = %call115
  br label %continue117

continue117:                                      ; preds = %output116
  %65 = uitofp i64 %call135 to float
  store float %65, float* %Y, align 4
  br label %continue25

input121:                                         ; preds = %input114
  %66 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance120, i32 0, i32 0
  %load_v125 = load float, float* %V, align 4
  %TC126 = getelementptr inbounds %TC_S_interface, %TC_S_interface* %cycle_time, i32 0, i32 0
  %load_127 = load float, float* %TC126, align 4
  %tmpVar128 = fmul float %load_v125, %load_127
  %67 = fptoui float %tmpVar128 to i64
  store i64 %67, i64* %66, align 4
  %68 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance120, i32 0, i32 1
  %load_X129 = load float, float* %X, align 4
  %load_Y130 = load float, float* %Y, align 4
  %tmpVar131 = fsub float %load_X129, %load_Y130
  %69 = fptoui float %tmpVar131 to i64
  store i64 %69, i64* %68, align 4
  br label %call122

call122:                                          ; preds = %input121
  %call132 = call i64 @MAX(%MAX_interface* %MAX_instance120)
  br label %output123

output123:                                        ; preds = %call122
  br label %continue124

continue124:                                      ; preds = %output123
  %70 = uitofp i64 %call132 to double
  %tmpVar133 = fadd double %64, %70
  %71 = fptoui double %tmpVar133 to i64
  store i64 %71, i64* %63, align 4
  %72 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance113, i32 0, i32 2
  %load_limit_high134 = load float, float* %LIMIT_HIGH, align 4
  %73 = fptoui float %load_limit_high134 to i64
  store i64 %73, i64* %72, align 4
  br label %call115
}

define void @TUNE(%TUNE_interface* %0) {
entry:
  %SET = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 0
  %SU = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 1
  %SD = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 2
  %RST = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 3
  %SS = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 4
  %Limit_L = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 5
  %LIMIT_H = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 6
  %RST_val = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 7
  %SET_val = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 8
  %T1 = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 9
  %T2 = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 10
  %S1 = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 11
  %S2 = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 12
  %Y = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 13
  %tx = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 14
  %start = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 15
  %start2 = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 16
  %state = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 17
  %in = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 18
  %step = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 19
  %SPEED = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 20
  %Y_start = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 21
  %Y_start2 = getelementptr inbounds %TUNE_interface, %TUNE_interface* %0, i32 0, i32 22
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %continue
  %load_RST_val = load float, float* %RST_val, align 4
  store float %load_RST_val, float* %Y, align 4
  store i16 0, i16* %state, align 2
  br label %continue5

branch:                                           ; preds = %continue
  %load_set = load i8, i8* %SET, align 1
  %2 = icmp ne i8 %load_set, 0
  br i1 %2, label %condition_body6, label %branch2

condition_body6:                                  ; preds = %branch
  %load_SET_val = load float, float* %SET_val, align 4
  store float %load_SET_val, float* %Y, align 4
  store i16 0, i16* %state, align 2
  br label %continue5

branch2:                                          ; preds = %branch
  %load_state = load i16, i16* %state, align 2
  %3 = sext i16 %load_state to i32
  %tmpVar = icmp sgt i32 %3, 0
  br i1 %tmpVar, label %condition_body7, label %branch3

condition_body7:                                  ; preds = %branch2
  %load_state10 = load i16, i16* %state, align 2
  %4 = sext i16 %load_state10 to i32
  %tmpVar11 = icmp eq i32 %4, 1
  br i1 %tmpVar11, label %condition_body9, label %else

branch3:                                          ; preds = %branch2
  %load_su88 = load i8, i8* %SU, align 1
  %5 = icmp ne i8 %load_su88, 0
  br i1 %5, label %condition_body87, label %branch4

condition_body87:                                 ; preds = %branch3
  store i16 1, i16* %state, align 2
  %load_tx89 = load i32, i32* %tx, align 4
  store i32 %load_tx89, i32* %start, align 4
  %load_ss = load float, float* %SS, align 4
  store float %load_ss, float* %step, align 4
  store float 1.000000e+03, float* %SPEED, align 4
  %load_Y90 = load float, float* %Y, align 4
  store float %load_Y90, float* %Y_start, align 4
  br label %continue5

branch4:                                          ; preds = %branch3
  %load_sd92 = load i8, i8* %SD, align 1
  %6 = icmp ne i8 %load_sd92, 0
  br i1 %6, label %condition_body91, label %continue5

condition_body91:                                 ; preds = %branch4
  store i16 2, i16* %state, align 2
  %load_tx93 = load i32, i32* %tx, align 4
  store i32 %load_tx93, i32* %start, align 4
  %load_ss94 = load float, float* %SS, align 4
  %tmpVar95 = fneg float %load_ss94
  store float %tmpVar95, float* %step, align 4
  store float -1.000000e+03, float* %SPEED, align 4
  %load_Y96 = load float, float* %Y, align 4
  store float %load_Y96, float* %Y_start, align 4
  br label %continue5

continue5:                                        ; preds = %condition_body91, %branch4, %condition_body87, %continue15, %condition_body6, %condition_body
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input97

condition_body9:                                  ; preds = %condition_body7
  %load_su = load i8, i8* %SU, align 1
  store i8 %load_su, i8* %in, align 1
  br label %continue8

else:                                             ; preds = %condition_body7
  %load_sd = load i8, i8* %SD, align 1
  store i8 %load_sd, i8* %in, align 1
  br label %continue8

continue8:                                        ; preds = %else, %condition_body9
  %load_in = load i8, i8* %in, align 1
  %tmpVar17 = xor i8 %load_in, -1
  %7 = zext i8 %tmpVar17 to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %14, label %15

condition_body16:                                 ; preds = %15
  %load_Y_start = load float, float* %Y_start, align 4
  %load_step = load float, float* %step, align 4
  %tmpVar25 = fadd float %load_Y_start, %load_step
  store float %tmpVar25, float* %Y, align 4
  store i16 0, i16* %state, align 2
  br label %continue15

branch12:                                         ; preds = %15
  %load_in27 = load i8, i8* %in, align 1
  %9 = zext i8 %load_in27 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %20, label %21

condition_body26:                                 ; preds = %21
  %load_Y_start2 = load float, float* %Y_start2, align 4
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input38

branch13:                                         ; preds = %21
  %load_in49 = load i8, i8* %in, align 1
  %11 = zext i8 %load_in49 to i32
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %27, label %28

condition_body48:                                 ; preds = %28
  %load_Y_start61 = load float, float* %Y_start, align 4
  %DWORD_TO_REAL_instance62 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input63

branch14:                                         ; preds = %28
  %load_in85 = load i8, i8* %in, align 1
  %tmpVar86 = xor i8 %load_in85, -1
  %13 = icmp ne i8 %tmpVar86, 0
  br i1 %13, label %condition_body84, label %continue15

condition_body84:                                 ; preds = %branch14
  store i16 0, i16* %state, align 2
  br label %continue15

continue15:                                       ; preds = %condition_body84, %branch14, %continue66, %continue41, %condition_body16
  br label %continue5

14:                                               ; preds = %continue8
  %load_tx = load i32, i32* %tx, align 4
  %load_start = load i32, i32* %start, align 4
  %tmpVar18 = sub i32 %load_tx, %load_start
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input19

15:                                               ; preds = %continue22, %continue8
  %16 = phi i32 [ %7, %continue8 ], [ %19, %continue22 ]
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %condition_body16, label %branch12

input19:                                          ; preds = %14
  %18 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_T1 = load i64, i64* %T1, align 4
  store i64 %load_T1, i64* %18, align 4
  br label %call20

call20:                                           ; preds = %input19
  %call23 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  %tmpVar24 = icmp sle i32 %tmpVar18, %call23
  %19 = zext i1 %tmpVar24 to i32
  br label %15

20:                                               ; preds = %branch12
  %load_tx28 = load i32, i32* %tx, align 4
  %load_start29 = load i32, i32* %start, align 4
  %tmpVar30 = sub i32 %load_tx28, %load_start29
  %TIME_TO_DWORD_instance31 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input32

21:                                               ; preds = %continue35, %branch12
  %22 = phi i32 [ %9, %branch12 ], [ %25, %continue35 ]
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %condition_body26, label %branch13

input32:                                          ; preds = %20
  %24 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance31, i32 0, i32 0
  %load_T2 = load i64, i64* %T2, align 4
  store i64 %load_T2, i64* %24, align 4
  br label %call33

call33:                                           ; preds = %input32
  %call36 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance31)
  br label %output34

output34:                                         ; preds = %call33
  br label %continue35

continue35:                                       ; preds = %output34
  %tmpVar37 = icmp sge i32 %tmpVar30, %call36
  %25 = zext i1 %tmpVar37 to i32
  br label %21

input38:                                          ; preds = %condition_body26
  %26 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_tx42 = load i32, i32* %tx, align 4
  %load_start2 = load i32, i32* %start2, align 4
  %tmpVar43 = sub i32 %load_tx42, %load_start2
  store i32 %tmpVar43, i32* %26, align 4
  br label %call39

call39:                                           ; preds = %input38
  %call44 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output40

output40:                                         ; preds = %call39
  br label %continue41

continue41:                                       ; preds = %output40
  %load_s2 = load float, float* %S2, align 4
  %tmpVar45 = fmul float %call44, %load_s2
  %load_speed = load float, float* %SPEED, align 4
  %tmpVar46 = fdiv float %tmpVar45, %load_speed
  %tmpVar47 = fadd float %load_Y_start2, %tmpVar46
  store float %tmpVar47, float* %Y, align 4
  br label %continue15

27:                                               ; preds = %branch13
  %load_tx50 = load i32, i32* %tx, align 4
  %load_start51 = load i32, i32* %start, align 4
  %tmpVar52 = sub i32 %load_tx50, %load_start51
  %TIME_TO_DWORD_instance53 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input54

28:                                               ; preds = %continue57, %branch13
  %29 = phi i32 [ %11, %branch13 ], [ %32, %continue57 ]
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %condition_body48, label %branch14

input54:                                          ; preds = %27
  %31 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance53, i32 0, i32 0
  %load_T158 = load i64, i64* %T1, align 4
  store i64 %load_T158, i64* %31, align 4
  br label %call55

call55:                                           ; preds = %input54
  %call59 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance53)
  br label %output56

output56:                                         ; preds = %call55
  br label %continue57

continue57:                                       ; preds = %output56
  %tmpVar60 = icmp sge i32 %tmpVar52, %call59
  %32 = zext i1 %tmpVar60 to i32
  br label %28

input63:                                          ; preds = %condition_body48
  %33 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance62, i32 0, i32 0
  %load_tx67 = load i32, i32* %tx, align 4
  %load_start68 = load i32, i32* %start, align 4
  %tmpVar69 = sub i32 %load_tx67, %load_start68
  %TIME_TO_DWORD_instance70 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input71

call64:                                           ; preds = %continue74
  %call78 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance62)
  br label %output65

output65:                                         ; preds = %call64
  br label %continue66

continue66:                                       ; preds = %output65
  %load_S1 = load float, float* %S1, align 4
  %tmpVar79 = fmul float %call78, %load_S1
  %load_speed80 = load float, float* %SPEED, align 4
  %tmpVar81 = fdiv float %tmpVar79, %load_speed80
  %tmpVar82 = fadd float %load_Y_start61, %tmpVar81
  store float %tmpVar82, float* %Y, align 4
  %load_tx83 = load i32, i32* %tx, align 4
  store i32 %load_tx83, i32* %start2, align 4
  %load_Y = load float, float* %Y, align 4
  store float %load_Y, float* %Y_start2, align 4
  br label %continue15

input71:                                          ; preds = %input63
  %34 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance70, i32 0, i32 0
  %load_T175 = load i64, i64* %T1, align 4
  store i64 %load_T175, i64* %34, align 4
  br label %call72

call72:                                           ; preds = %input71
  %call76 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance70)
  br label %output73

output73:                                         ; preds = %call72
  br label %continue74

continue74:                                       ; preds = %output73
  %tmpVar77 = sub i32 %tmpVar69, %call76
  store i32 %tmpVar77, i32* %33, align 4
  br label %call64

input97:                                          ; preds = %continue5
  %35 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_LIMIT_L = load float, float* %Limit_L, align 4
  %36 = fptoui float %load_LIMIT_L to i64
  store i64 %36, i64* %35, align 4
  %37 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_Y101 = load float, float* %Y, align 4
  %38 = fptoui float %load_Y101 to i64
  store i64 %38, i64* %37, align 4
  %39 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_LIMIT_H = load float, float* %LIMIT_H, align 4
  %40 = fptoui float %load_LIMIT_H to i64
  store i64 %40, i64* %39, align 4
  br label %call98

call98:                                           ; preds = %input97
  %call102 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output99

output99:                                         ; preds = %call98
  br label %continue100

continue100:                                      ; preds = %output99
  %41 = uitofp i64 %call102 to float
  store float %41, float* %Y, align 4
  ret void
}

define void @TUNE2(%TUNE2_interface* %0) {
entry:
  %SET = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 0
  %SU = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 1
  %SD = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 2
  %FU = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 3
  %FD = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 4
  %RST = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 5
  %SS = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 6
  %FS = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 7
  %Limit_L = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 8
  %LIMIT_H = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 9
  %RST_val = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 10
  %SET_val = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 11
  %TR = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 12
  %S1 = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 13
  %S2 = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 14
  %Y = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 15
  %tx = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 16
  %start = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 17
  %state = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 18
  %in = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 19
  %step = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 20
  %SPEED = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 21
  %Y_start = getelementptr inbounds %TUNE2_interface, %TUNE2_interface* %0, i32 0, i32 22
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %continue
  %load_RST_val = load float, float* %RST_val, align 4
  store float %load_RST_val, float* %Y, align 4
  store i16 0, i16* %state, align 2
  br label %continue7

branch:                                           ; preds = %continue
  %load_set = load i8, i8* %SET, align 1
  %2 = icmp ne i8 %load_set, 0
  br i1 %2, label %condition_body8, label %branch2

condition_body8:                                  ; preds = %branch
  %load_SET_val = load float, float* %SET_val, align 4
  store float %load_SET_val, float* %Y, align 4
  store i16 0, i16* %state, align 2
  br label %continue7

branch2:                                          ; preds = %branch
  %load_state = load i16, i16* %state, align 2
  %3 = sext i16 %load_state to i32
  %tmpVar = icmp sgt i32 %3, 0
  br i1 %tmpVar, label %condition_body9, label %branch3

condition_body9:                                  ; preds = %branch2
  %load_state11 = load i16, i16* %state, align 2
  switch i16 %load_state11, label %else [
    i16 1, label %case
    i16 2, label %case12
    i16 3, label %case13
    i16 4, label %case14
  ]

branch3:                                          ; preds = %branch2
  %load_su64 = load i8, i8* %SU, align 1
  %4 = icmp ne i8 %load_su64, 0
  br i1 %4, label %condition_body63, label %branch4

condition_body63:                                 ; preds = %branch3
  store i16 1, i16* %state, align 2
  %load_tx65 = load i32, i32* %tx, align 4
  store i32 %load_tx65, i32* %start, align 4
  %load_ss = load float, float* %SS, align 4
  store float %load_ss, float* %step, align 4
  %load_s1 = load float, float* %S1, align 4
  %tmpVar66 = fmul float %load_s1, 0x3F50624DE0000000
  store float %tmpVar66, float* %SPEED, align 4
  %load_Y = load float, float* %Y, align 4
  store float %load_Y, float* %Y_start, align 4
  br label %continue7

branch4:                                          ; preds = %branch3
  %load_sd68 = load i8, i8* %SD, align 1
  %5 = icmp ne i8 %load_sd68, 0
  br i1 %5, label %condition_body67, label %branch5

condition_body67:                                 ; preds = %branch4
  store i16 2, i16* %state, align 2
  %load_tx69 = load i32, i32* %tx, align 4
  store i32 %load_tx69, i32* %start, align 4
  %load_ss70 = load float, float* %SS, align 4
  %tmpVar71 = fneg float %load_ss70
  store float %tmpVar71, float* %step, align 4
  %load_s172 = load float, float* %S1, align 4
  %tmpVar73 = fneg float %load_s172
  %tmpVar74 = fmul float %tmpVar73, 0x3F50624DE0000000
  store float %tmpVar74, float* %SPEED, align 4
  %load_Y75 = load float, float* %Y, align 4
  store float %load_Y75, float* %Y_start, align 4
  br label %continue7

branch5:                                          ; preds = %branch4
  %load_fu77 = load i8, i8* %FU, align 1
  %6 = icmp ne i8 %load_fu77, 0
  br i1 %6, label %condition_body76, label %branch6

condition_body76:                                 ; preds = %branch5
  store i16 3, i16* %state, align 2
  %load_tx78 = load i32, i32* %tx, align 4
  store i32 %load_tx78, i32* %start, align 4
  %load_fs = load float, float* %FS, align 4
  store float %load_fs, float* %step, align 4
  %load_s2 = load float, float* %S2, align 4
  %tmpVar79 = fmul float %load_s2, 0x3F50624DE0000000
  store float %tmpVar79, float* %SPEED, align 4
  %load_Y80 = load float, float* %Y, align 4
  store float %load_Y80, float* %Y_start, align 4
  br label %continue7

branch6:                                          ; preds = %branch5
  %load_fd82 = load i8, i8* %FD, align 1
  %7 = icmp ne i8 %load_fd82, 0
  br i1 %7, label %condition_body81, label %continue7

condition_body81:                                 ; preds = %branch6
  store i16 4, i16* %state, align 2
  %load_tx83 = load i32, i32* %tx, align 4
  store i32 %load_tx83, i32* %start, align 4
  %load_fs84 = load float, float* %FS, align 4
  %tmpVar85 = fneg float %load_fs84
  store float %tmpVar85, float* %step, align 4
  %load_s286 = load float, float* %S2, align 4
  %tmpVar87 = fneg float %load_s286
  %tmpVar88 = fmul float %tmpVar87, 0x3F50624DE0000000
  store float %tmpVar88, float* %SPEED, align 4
  %load_Y89 = load float, float* %Y, align 4
  store float %load_Y89, float* %Y_start, align 4
  br label %continue7

continue7:                                        ; preds = %condition_body81, %branch6, %condition_body76, %condition_body67, %condition_body63, %continue17, %condition_body8, %condition_body
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input90

case:                                             ; preds = %condition_body9
  %load_su = load i8, i8* %SU, align 1
  store i8 %load_su, i8* %in, align 1
  br label %continue10

case12:                                           ; preds = %condition_body9
  %load_sd = load i8, i8* %SD, align 1
  store i8 %load_sd, i8* %in, align 1
  br label %continue10

case13:                                           ; preds = %condition_body9
  %load_fu = load i8, i8* %FU, align 1
  store i8 %load_fu, i8* %in, align 1
  br label %continue10

case14:                                           ; preds = %condition_body9
  %load_fd = load i8, i8* %FD, align 1
  store i8 %load_fd, i8* %in, align 1
  br label %continue10

else:                                             ; preds = %condition_body9
  br label %continue10

continue10:                                       ; preds = %else, %case14, %case13, %case12, %case
  %load_in = load i8, i8* %in, align 1
  %tmpVar19 = xor i8 %load_in, -1
  %8 = zext i8 %tmpVar19 to i32
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %13, label %14

condition_body18:                                 ; preds = %14
  %load_Y_start = load float, float* %Y_start, align 4
  %load_step = load float, float* %step, align 4
  %tmpVar27 = fadd float %load_Y_start, %load_step
  store float %tmpVar27, float* %Y, align 4
  store i16 0, i16* %state, align 2
  br label %continue17

branch15:                                         ; preds = %14
  %load_in29 = load i8, i8* %in, align 1
  %10 = zext i8 %load_in29 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %19, label %20

condition_body28:                                 ; preds = %20
  %load_Y_start41 = load float, float* %Y_start, align 4
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input42

branch16:                                         ; preds = %20
  %load_in61 = load i8, i8* %in, align 1
  %tmpVar62 = xor i8 %load_in61, -1
  %12 = icmp ne i8 %tmpVar62, 0
  br i1 %12, label %condition_body60, label %continue17

condition_body60:                                 ; preds = %branch16
  store i16 0, i16* %state, align 2
  br label %continue17

continue17:                                       ; preds = %condition_body60, %branch16, %continue45, %condition_body18
  br label %continue7

13:                                               ; preds = %continue10
  %load_tx = load i32, i32* %tx, align 4
  %load_start = load i32, i32* %start, align 4
  %tmpVar20 = sub i32 %load_tx, %load_start
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input21

14:                                               ; preds = %continue24, %continue10
  %15 = phi i32 [ %8, %continue10 ], [ %18, %continue24 ]
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %condition_body18, label %branch15

input21:                                          ; preds = %13
  %17 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_TR = load i64, i64* %TR, align 4
  store i64 %load_TR, i64* %17, align 4
  br label %call22

call22:                                           ; preds = %input21
  %call25 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %tmpVar26 = icmp sle i32 %tmpVar20, %call25
  %18 = zext i1 %tmpVar26 to i32
  br label %14

19:                                               ; preds = %branch15
  %load_tx30 = load i32, i32* %tx, align 4
  %load_start31 = load i32, i32* %start, align 4
  %tmpVar32 = sub i32 %load_tx30, %load_start31
  %TIME_TO_DWORD_instance33 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input34

20:                                               ; preds = %continue37, %branch15
  %21 = phi i32 [ %10, %branch15 ], [ %24, %continue37 ]
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %condition_body28, label %branch16

input34:                                          ; preds = %19
  %23 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance33, i32 0, i32 0
  %load_TR38 = load i64, i64* %TR, align 4
  store i64 %load_TR38, i64* %23, align 4
  br label %call35

call35:                                           ; preds = %input34
  %call39 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance33)
  br label %output36

output36:                                         ; preds = %call35
  br label %continue37

continue37:                                       ; preds = %output36
  %tmpVar40 = icmp sge i32 %tmpVar32, %call39
  %24 = zext i1 %tmpVar40 to i32
  br label %20

input42:                                          ; preds = %condition_body28
  %25 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_tx46 = load i32, i32* %tx, align 4
  %load_start47 = load i32, i32* %start, align 4
  %tmpVar48 = sub i32 %load_tx46, %load_start47
  %TIME_TO_DWORD_instance49 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input50

call43:                                           ; preds = %continue53
  %call57 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output44

output44:                                         ; preds = %call43
  br label %continue45

continue45:                                       ; preds = %output44
  %load_speed = load float, float* %SPEED, align 4
  %tmpVar58 = fmul float %call57, %load_speed
  %tmpVar59 = fadd float %load_Y_start41, %tmpVar58
  store float %tmpVar59, float* %Y, align 4
  br label %continue17

input50:                                          ; preds = %input42
  %26 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance49, i32 0, i32 0
  %load_TR54 = load i64, i64* %TR, align 4
  store i64 %load_TR54, i64* %26, align 4
  br label %call51

call51:                                           ; preds = %input50
  %call55 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance49)
  br label %output52

output52:                                         ; preds = %call51
  br label %continue53

continue53:                                       ; preds = %output52
  %tmpVar56 = sub i32 %tmpVar48, %call55
  store i32 %tmpVar56, i32* %25, align 4
  br label %call43

input90:                                          ; preds = %continue7
  %27 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_LIMIT_L = load float, float* %Limit_L, align 4
  %28 = fptoui float %load_LIMIT_L to i64
  store i64 %28, i64* %27, align 4
  %29 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_Y94 = load float, float* %Y, align 4
  %30 = fptoui float %load_Y94 to i64
  store i64 %30, i64* %29, align 4
  %31 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_LIMIT_H = load float, float* %LIMIT_H, align 4
  %32 = fptoui float %load_LIMIT_H to i64
  store i64 %32, i64* %31, align 4
  br label %call91

call91:                                           ; preds = %input90
  %call95 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output92

output92:                                         ; preds = %call91
  br label %continue93

continue93:                                       ; preds = %output92
  %33 = uitofp i64 %call95 to float
  store float %33, float* %Y, align 4
  ret void
}

define i8 @BAND_B(%BAND_B_interface* %0) {
entry:
  %X = getelementptr inbounds %BAND_B_interface, %BAND_B_interface* %0, i32 0, i32 0
  %B = getelementptr inbounds %BAND_B_interface, %BAND_B_interface* %0, i32 0, i32 1
  %BAND_B = alloca i8, align 1
  store i8 0, i8* %BAND_B, align 1
  %load_X = load i8, i8* %X, align 1
  %1 = zext i8 %load_X to i32
  %load_B = load i8, i8* %B, align 1
  %2 = zext i8 %load_B to i32
  %tmpVar = icmp slt i32 %1, %2
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %BAND_B, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_X2 = load i8, i8* %X, align 1
  %3 = zext i8 %load_X2 to i32
  %load_B3 = load i8, i8* %B, align 1
  %4 = zext i8 %load_B3 to i32
  %tmpVar4 = sub i32 255, %4
  %tmpVar5 = icmp sgt i32 %3, %tmpVar4
  br i1 %tmpVar5, label %condition_body1, label %else

condition_body1:                                  ; preds = %branch
  store i8 -1, i8* %BAND_B, align 1
  br label %continue

else:                                             ; preds = %branch
  %load_X6 = load i8, i8* %X, align 1
  store i8 %load_X6, i8* %BAND_B, align 1
  br label %continue

continue:                                         ; preds = %else, %condition_body1, %condition_body
  %BAND_B_ret = load i8, i8* %BAND_B, align 1
  ret i8 %BAND_B_ret
}

define void @CONTROL_SET1(%CONTROL_SET1_interface* %0) {
entry:
  %Kt = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 0
  %Tt = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 1
  %PI = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 2
  %PID = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 3
  %P_K = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 4
  %PI_K = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 5
  %PI_TN = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 6
  %PID_K = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 7
  %PID_TN = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 8
  %PID_TV = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 9
  %KP = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 10
  %TN = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 11
  %TV = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 12
  %KI = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 13
  %KD = getelementptr inbounds %CONTROL_SET1_interface, %CONTROL_SET1_interface* %0, i32 0, i32 14
  %load_pi = load i8, i8* %PI, align 1
  %1 = zext i8 %load_pi to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %5, label %7

condition_body:                                   ; preds = %7
  store float 0.000000e+00, float* %KP, align 4
  store float 0.000000e+00, float* %TN, align 4
  store float 0.000000e+00, float* %TV, align 4
  br label %continue

branch:                                           ; preds = %7
  %load_PID3 = load i8, i8* %PID, align 1
  %3 = icmp ne i8 %load_PID3, 0
  br i1 %3, label %condition_body2, label %branch1

condition_body2:                                  ; preds = %branch
  %load_PID_K = load float, float* %PID_K, align 4
  %load_Kt = load float, float* %Kt, align 4
  %tmpVar = fmul float %load_PID_K, %load_Kt
  store float %tmpVar, float* %KP, align 4
  %load_PID_TN = load float, float* %PID_TN, align 4
  %load_Tt = load float, float* %Tt, align 4
  %tmpVar4 = fmul float %load_PID_TN, %load_Tt
  store float %tmpVar4, float* %TN, align 4
  %load_PID_TV = load float, float* %PID_TV, align 4
  %load_Tt5 = load float, float* %Tt, align 4
  %tmpVar6 = fmul float %load_PID_TV, %load_Tt5
  store float %tmpVar6, float* %TV, align 4
  br label %continue

branch1:                                          ; preds = %branch
  %load_PI = load i8, i8* %PI, align 1
  %4 = icmp ne i8 %load_PI, 0
  br i1 %4, label %condition_body7, label %else

condition_body7:                                  ; preds = %branch1
  %load_PI_K = load float, float* %PI_K, align 4
  %load_Kt8 = load float, float* %Kt, align 4
  %tmpVar9 = fmul float %load_PI_K, %load_Kt8
  store float %tmpVar9, float* %KP, align 4
  %load_PI_TN = load float, float* %PI_TN, align 4
  %load_Tt10 = load float, float* %Tt, align 4
  %tmpVar11 = fmul float %load_PI_TN, %load_Tt10
  store float %tmpVar11, float* %TN, align 4
  br label %continue

else:                                             ; preds = %branch1
  %load_P_K = load float, float* %P_K, align 4
  %load_Kt12 = load float, float* %Kt, align 4
  %tmpVar13 = fmul float %load_P_K, %load_Kt12
  store float %tmpVar13, float* %KP, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body7, %condition_body2, %condition_body
  %load_tn = load float, float* %TN, align 4
  %tmpVar17 = fcmp ogt float %load_tn, 0.000000e+00
  br i1 %tmpVar17, label %condition_body16, label %else14

5:                                                ; preds = %entry
  %load_PID = load i8, i8* %PID, align 1
  %6 = zext i8 %load_PID to i32
  br label %7

7:                                                ; preds = %5, %entry
  %8 = phi i32 [ %1, %entry ], [ %6, %5 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body, label %branch

condition_body16:                                 ; preds = %continue
  %load_KP = load float, float* %KP, align 4
  %load_TN = load float, float* %TN, align 4
  %tmpVar18 = fdiv float %load_KP, %load_TN
  store float %tmpVar18, float* %KI, align 4
  br label %continue15

else14:                                           ; preds = %continue
  store float 0.000000e+00, float* %KI, align 4
  br label %continue15

continue15:                                       ; preds = %else14, %condition_body16
  %load_KP19 = load float, float* %KP, align 4
  %load_TV = load float, float* %TV, align 4
  %tmpVar20 = fmul float %load_KP19, %load_TV
  store float %tmpVar20, float* %KD, align 4
  ret void
}

define void @CONTROL_SET2(%CONTROL_SET2_interface* %0) {
entry:
  %KS = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 0
  %TU = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 1
  %TG = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 2
  %PI = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 3
  %PID = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 4
  %P_K = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 5
  %PI_K = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 6
  %PI_TN = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 7
  %PID_K = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 8
  %PID_TN = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 9
  %PID_TV = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 10
  %KP = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 11
  %TN = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 12
  %TV = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 13
  %KI = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 14
  %KD = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 15
  %TX = getelementptr inbounds %CONTROL_SET2_interface, %CONTROL_SET2_interface* %0, i32 0, i32 16
  %load_TU = load float, float* %TU, align 4
  %tmpVar = fcmp ogt float %load_TU, 0.000000e+00
  %1 = zext i1 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %5, label %7

condition_body:                                   ; preds = %7
  %load_TG = load float, float* %TG, align 4
  %load_TU2 = load float, float* %TU, align 4
  %tmpVar3 = fdiv float %load_TG, %load_TU2
  %load_KS4 = load float, float* %KS, align 4
  %tmpVar5 = fdiv float %tmpVar3, %load_KS4
  store float %tmpVar5, float* %TX, align 4
  br label %continue

continue:                                         ; preds = %condition_body, %7
  %load_pi = load i8, i8* %PI, align 1
  %3 = zext i8 %load_pi to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %12, label %14

5:                                                ; preds = %entry
  %load_KS = load float, float* %KS, align 4
  %tmpVar1 = fcmp ogt float %load_KS, 0.000000e+00
  %6 = zext i1 %tmpVar1 to i32
  br label %7

7:                                                ; preds = %5, %entry
  %8 = phi i32 [ %1, %entry ], [ %6, %5 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body, label %continue

condition_body8:                                  ; preds = %14
  store float 0.000000e+00, float* %KP, align 4
  store float 0.000000e+00, float* %TN, align 4
  store float 0.000000e+00, float* %TV, align 4
  br label %continue7

branch:                                           ; preds = %14
  %load_PID10 = load i8, i8* %PID, align 1
  %10 = icmp ne i8 %load_PID10, 0
  br i1 %10, label %condition_body9, label %branch6

condition_body9:                                  ; preds = %branch
  %load_PID_K = load float, float* %PID_K, align 4
  %load_TX = load float, float* %TX, align 4
  %tmpVar11 = fmul float %load_PID_K, %load_TX
  store float %tmpVar11, float* %KP, align 4
  %load_PID_TN = load float, float* %PID_TN, align 4
  %load_TU12 = load float, float* %TU, align 4
  %tmpVar13 = fmul float %load_PID_TN, %load_TU12
  store float %tmpVar13, float* %TN, align 4
  %load_PID_TV = load float, float* %PID_TV, align 4
  %load_TU14 = load float, float* %TU, align 4
  %tmpVar15 = fmul float %load_PID_TV, %load_TU14
  store float %tmpVar15, float* %TV, align 4
  br label %continue7

branch6:                                          ; preds = %branch
  %load_PI = load i8, i8* %PI, align 1
  %11 = icmp ne i8 %load_PI, 0
  br i1 %11, label %condition_body16, label %else

condition_body16:                                 ; preds = %branch6
  %load_PI_K = load float, float* %PI_K, align 4
  %load_TX17 = load float, float* %TX, align 4
  %tmpVar18 = fmul float %load_PI_K, %load_TX17
  store float %tmpVar18, float* %KP, align 4
  %load_PI_TN = load float, float* %PI_TN, align 4
  %load_TU19 = load float, float* %TU, align 4
  %tmpVar20 = fmul float %load_PI_TN, %load_TU19
  store float %tmpVar20, float* %TN, align 4
  br label %continue7

else:                                             ; preds = %branch6
  %load_P_K = load float, float* %P_K, align 4
  %load_TX21 = load float, float* %TX, align 4
  %tmpVar22 = fmul float %load_P_K, %load_TX21
  store float %tmpVar22, float* %KP, align 4
  br label %continue7

continue7:                                        ; preds = %else, %condition_body16, %condition_body9, %condition_body8
  %load_TN = load float, float* %TN, align 4
  %tmpVar26 = fcmp ogt float %load_TN, 0.000000e+00
  br i1 %tmpVar26, label %condition_body25, label %else23

12:                                               ; preds = %continue
  %load_PID = load i8, i8* %PID, align 1
  %13 = zext i8 %load_PID to i32
  br label %14

14:                                               ; preds = %12, %continue
  %15 = phi i32 [ %3, %continue ], [ %13, %12 ]
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %condition_body8, label %branch

condition_body25:                                 ; preds = %continue7
  %load_KP = load float, float* %KP, align 4
  %load_TN27 = load float, float* %TN, align 4
  %tmpVar28 = fdiv float %load_KP, %load_TN27
  store float %tmpVar28, float* %KI, align 4
  br label %continue24

else23:                                           ; preds = %continue7
  store float 0.000000e+00, float* %KI, align 4
  br label %continue24

continue24:                                       ; preds = %else23, %condition_body25
  %load_KP29 = load float, float* %KP, align 4
  %load_TV = load float, float* %TV, align 4
  %tmpVar30 = fmul float %load_KP29, %load_TV
  store float %tmpVar30, float* %KD, align 4
  ret void
}

define float @CTRL_IN(%CTRL_IN_interface* %0) {
entry:
  %SET_POINT = getelementptr inbounds %CTRL_IN_interface, %CTRL_IN_interface* %0, i32 0, i32 0
  %ACTUAL = getelementptr inbounds %CTRL_IN_interface, %CTRL_IN_interface* %0, i32 0, i32 1
  %NOISE = getelementptr inbounds %CTRL_IN_interface, %CTRL_IN_interface* %0, i32 0, i32 2
  %CTRL_IN = alloca float, align 4
  store float 0.000000e+00, float* %CTRL_IN, align 4
  %DEAD_ZONE_instance = alloca %DEAD_ZONE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DEAD_ZONE_interface, %DEAD_ZONE_interface* %DEAD_ZONE_instance, i32 0, i32 0
  %load_SET_POINT = load float, float* %SET_POINT, align 4
  %load_ACTUAL = load float, float* %ACTUAL, align 4
  %tmpVar = fsub float %load_SET_POINT, %load_ACTUAL
  store float %tmpVar, float* %1, align 4
  %2 = getelementptr inbounds %DEAD_ZONE_interface, %DEAD_ZONE_interface* %DEAD_ZONE_instance, i32 0, i32 1
  %load_NOISE = load float, float* %NOISE, align 4
  store float %load_NOISE, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @DEAD_ZONE(%DEAD_ZONE_interface* %DEAD_ZONE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call1, float* %CTRL_IN, align 4
  %CTRL_IN_ret = load float, float* %CTRL_IN, align 4
  ret float %CTRL_IN_ret
}

define void @CTRL_OUT(%CTRL_OUT_interface* %0) {
entry:
  %CI = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %0, i32 0, i32 0
  %OFFSET = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %0, i32 0, i32 1
  %MAN_IN = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %0, i32 0, i32 2
  %LIM_L = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %0, i32 0, i32 3
  %LIM_H = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %0, i32 0, i32 4
  %MANUAL = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %0, i32 0, i32 5
  %Y = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %0, i32 0, i32 6
  %LIM = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %0, i32 0, i32 7
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_MANUAL = load i8, i8* %MANUAL, align 1
  store i8 %load_MANUAL, i8* %1, align 1
  %2 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_CI = load float, float* %CI, align 4
  %3 = fptoui float %load_CI to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_MAN_IN = load float, float* %MAN_IN, align 4
  %5 = fptoui float %load_MAN_IN to i64
  store i64 %5, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %6 = uitofp i64 %call1 to double
  %load_OFFSET = load float, float* %OFFSET, align 4
  %7 = fpext float %load_OFFSET to double
  %tmpVar = fadd double %6, %7
  %8 = fptrunc double %tmpVar to float
  store float %8, float* %Y, align 4
  %load_Y = load float, float* %Y, align 4
  %load_LIM_L = load float, float* %LIM_L, align 4
  %tmpVar3 = fcmp ogt float %load_Y, %load_LIM_L
  %9 = zext i1 %tmpVar3 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %11, label %13

condition_body:                                   ; preds = %13
  store i8 0, i8* %LIM, align 1
  br label %continue2

else:                                             ; preds = %13
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input6

continue2:                                        ; preds = %continue9, %condition_body
  ret void

11:                                               ; preds = %continue
  %load_Y4 = load float, float* %Y, align 4
  %load_LIM_H = load float, float* %LIM_H, align 4
  %tmpVar5 = fcmp olt float %load_Y4, %load_LIM_H
  %12 = zext i1 %tmpVar5 to i32
  br label %13

13:                                               ; preds = %11, %continue
  %14 = phi i32 [ %9, %continue ], [ %12, %11 ]
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %condition_body, label %else

input6:                                           ; preds = %else
  %16 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_LIM_L10 = load float, float* %LIM_L, align 4
  %17 = fptoui float %load_LIM_L10 to i64
  store i64 %17, i64* %16, align 4
  %18 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_Y11 = load float, float* %Y, align 4
  %19 = fptoui float %load_Y11 to i64
  store i64 %19, i64* %18, align 4
  %20 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_LIM_H12 = load float, float* %LIM_H, align 4
  %21 = fptoui float %load_LIM_H12 to i64
  store i64 %21, i64* %20, align 4
  br label %call7

call7:                                            ; preds = %input6
  %call13 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %22 = uitofp i64 %call13 to float
  store float %22, float* %Y, align 4
  store i8 1, i8* %LIM, align 1
  br label %continue2
}

define void @CTRL_PI(%CTRL_PI_interface* %0) {
entry:
  %ACT = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 0
  %SET = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 1
  %SUP = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 2
  %OFS = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 3
  %M_I = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 4
  %MAN = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 5
  %RST = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 6
  %KP = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 7
  %KI = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 8
  %LL = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 9
  %LH = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 10
  %Y = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 11
  %DIFF = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 12
  %LIM = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 13
  %pi = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 14
  %co = getelementptr inbounds %CTRL_PI_interface, %CTRL_PI_interface* %0, i32 0, i32 15
  %CTRL_IN_instance = alloca %CTRL_IN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %CTRL_IN_interface, %CTRL_IN_interface* %CTRL_IN_instance, i32 0, i32 0
  %load_SET = load float, float* %SET, align 4
  store float %load_SET, float* %1, align 4
  %2 = getelementptr inbounds %CTRL_IN_interface, %CTRL_IN_interface* %CTRL_IN_instance, i32 0, i32 1
  %load_ACT = load float, float* %ACT, align 4
  store float %load_ACT, float* %2, align 4
  %3 = getelementptr inbounds %CTRL_IN_interface, %CTRL_IN_interface* %CTRL_IN_instance, i32 0, i32 2
  %load_SUP = load float, float* %SUP, align 4
  store float %load_SUP, float* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @CTRL_IN(%CTRL_IN_interface* %CTRL_IN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call1, float* %DIFF, align 4
  br label %input2

input2:                                           ; preds = %continue
  %4 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %pi, i32 0, i32 0
  %load_DIFF = load float, float* %DIFF, align 4
  store float %load_DIFF, float* %4, align 4
  %5 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %pi, i32 0, i32 1
  %load_KP = load float, float* %KP, align 4
  store float %load_KP, float* %5, align 4
  %6 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %pi, i32 0, i32 2
  %load_KI = load float, float* %KI, align 4
  store float %load_KI, float* %6, align 4
  %7 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %pi, i32 0, i32 3
  %load_LL = load float, float* %LL, align 4
  store float %load_LL, float* %7, align 4
  %8 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %pi, i32 0, i32 4
  %load_LH = load float, float* %LH, align 4
  store float %load_LH, float* %8, align 4
  %9 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %pi, i32 0, i32 5
  %load_RST = load i8, i8* %RST, align 1
  store i8 %load_RST, i8* %9, align 1
  br label %call3

call3:                                            ; preds = %input2
  call void @FT_PIWL(%FT_PIWL_interface* %pi)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  br label %input6

input6:                                           ; preds = %continue5
  %10 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 0
  %Y10 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %pi, i32 0, i32 6
  %load_ = load float, float* %Y10, align 4
  store float %load_, float* %10, align 4
  %11 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 1
  %load_OFS = load float, float* %OFS, align 4
  store float %load_OFS, float* %11, align 4
  %12 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 2
  %load_M_I = load float, float* %M_I, align 4
  store float %load_M_I, float* %12, align 4
  %13 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 3
  %load_LL11 = load float, float* %LL, align 4
  store float %load_LL11, float* %13, align 4
  %14 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 4
  %load_LH12 = load float, float* %LH, align 4
  store float %load_LH12, float* %14, align 4
  %15 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 5
  %load_MAN = load i8, i8* %MAN, align 1
  store i8 %load_MAN, i8* %15, align 1
  br label %call7

call7:                                            ; preds = %input6
  call void @CTRL_OUT(%CTRL_OUT_interface* %co)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %Y13 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 6
  %load_14 = load float, float* %Y13, align 4
  store float %load_14, float* %Y, align 4
  %LIM15 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 7
  %load_16 = load i8, i8* %LIM15, align 1
  store i8 %load_16, i8* %LIM, align 1
  ret void
}

define void @CTRL_PID(%CTRL_PID_interface* %0) {
entry:
  %ACT = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 0
  %SET = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 1
  %SUP = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 2
  %OFS = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 3
  %M_I = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 4
  %MAN = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 5
  %RST = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 6
  %KP = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 7
  %TN = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 8
  %TV = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 9
  %LL = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 10
  %LH = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 11
  %Y = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 12
  %DIFF = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 13
  %LIM = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 14
  %pid = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 15
  %co = getelementptr inbounds %CTRL_PID_interface, %CTRL_PID_interface* %0, i32 0, i32 16
  %CTRL_IN_instance = alloca %CTRL_IN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %CTRL_IN_interface, %CTRL_IN_interface* %CTRL_IN_instance, i32 0, i32 0
  %load_SET = load float, float* %SET, align 4
  store float %load_SET, float* %1, align 4
  %2 = getelementptr inbounds %CTRL_IN_interface, %CTRL_IN_interface* %CTRL_IN_instance, i32 0, i32 1
  %load_ACT = load float, float* %ACT, align 4
  store float %load_ACT, float* %2, align 4
  %3 = getelementptr inbounds %CTRL_IN_interface, %CTRL_IN_interface* %CTRL_IN_instance, i32 0, i32 2
  %load_SUP = load float, float* %SUP, align 4
  store float %load_SUP, float* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @CTRL_IN(%CTRL_IN_interface* %CTRL_IN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call1, float* %DIFF, align 4
  br label %input2

input2:                                           ; preds = %continue
  %4 = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %pid, i32 0, i32 0
  %load_DIFF = load float, float* %DIFF, align 4
  store float %load_DIFF, float* %4, align 4
  %5 = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %pid, i32 0, i32 1
  %load_KP = load float, float* %KP, align 4
  store float %load_KP, float* %5, align 4
  %6 = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %pid, i32 0, i32 2
  %load_TN = load float, float* %TN, align 4
  store float %load_TN, float* %6, align 4
  %7 = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %pid, i32 0, i32 3
  %load_TV = load float, float* %TV, align 4
  store float %load_TV, float* %7, align 4
  %8 = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %pid, i32 0, i32 4
  %load_LL = load float, float* %LL, align 4
  store float %load_LL, float* %8, align 4
  %9 = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %pid, i32 0, i32 5
  %load_LH = load float, float* %LH, align 4
  store float %load_LH, float* %9, align 4
  %10 = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %pid, i32 0, i32 6
  %load_RST = load i8, i8* %RST, align 1
  store i8 %load_RST, i8* %10, align 1
  br label %call3

call3:                                            ; preds = %input2
  call void @FT_PIDWL(%FT_PIDWL_interface* %pid)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  br label %input6

input6:                                           ; preds = %continue5
  %11 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 0
  %Y10 = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %pid, i32 0, i32 7
  %load_ = load float, float* %Y10, align 4
  store float %load_, float* %11, align 4
  %12 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 1
  %load_OFS = load float, float* %OFS, align 4
  store float %load_OFS, float* %12, align 4
  %13 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 2
  %load_M_I = load float, float* %M_I, align 4
  store float %load_M_I, float* %13, align 4
  %14 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 3
  %load_LL11 = load float, float* %LL, align 4
  store float %load_LL11, float* %14, align 4
  %15 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 4
  %load_LH12 = load float, float* %LH, align 4
  store float %load_LH12, float* %15, align 4
  %16 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 5
  %load_MAN = load i8, i8* %MAN, align 1
  store i8 %load_MAN, i8* %16, align 1
  br label %call7

call7:                                            ; preds = %input6
  call void @CTRL_OUT(%CTRL_OUT_interface* %co)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %Y13 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 6
  %load_14 = load float, float* %Y13, align 4
  store float %load_14, float* %Y, align 4
  %LIM15 = getelementptr inbounds %CTRL_OUT_interface, %CTRL_OUT_interface* %co, i32 0, i32 7
  %load_16 = load i8, i8* %LIM15, align 1
  store i8 %load_16, i8* %LIM, align 1
  ret void
}

define void @CTRL_PWM(%CTRL_PWM_interface* %0) {
entry:
  %CI = getelementptr inbounds %CTRL_PWM_interface, %CTRL_PWM_interface* %0, i32 0, i32 0
  %MAN_IN = getelementptr inbounds %CTRL_PWM_interface, %CTRL_PWM_interface* %0, i32 0, i32 1
  %MANUAL = getelementptr inbounds %CTRL_PWM_interface, %CTRL_PWM_interface* %0, i32 0, i32 2
  %F = getelementptr inbounds %CTRL_PWM_interface, %CTRL_PWM_interface* %0, i32 0, i32 3
  %Q = getelementptr inbounds %CTRL_PWM_interface, %CTRL_PWM_interface* %0, i32 0, i32 4
  %PW = getelementptr inbounds %CTRL_PWM_interface, %CTRL_PWM_interface* %0, i32 0, i32 5
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %PWM_DC_interface, %PWM_DC_interface* %PW, i32 0, i32 0
  %load_F = load float, float* %F, align 4
  store float %load_F, float* %1, align 4
  %2 = getelementptr inbounds %PWM_DC_interface, %PWM_DC_interface* %PW, i32 0, i32 1
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  call void @PWM_DC(%PWM_DC_interface* %PW)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %Q6 = getelementptr inbounds %PWM_DC_interface, %PWM_DC_interface* %PW, i32 0, i32 2
  %load_ = load i8, i8* %Q6, align 1
  store i8 %load_, i8* %Q, align 1
  ret void

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_MANUAL = load i8, i8* %MANUAL, align 1
  store i8 %load_MANUAL, i8* %3, align 1
  %4 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_CI = load float, float* %CI, align 4
  %5 = fptoui float %load_CI to i64
  store i64 %5, i64* %4, align 4
  %6 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_MAN_IN = load float, float* %MAN_IN, align 4
  %7 = fptoui float %load_MAN_IN to i64
  store i64 %7, i64* %6, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %8 = uitofp i64 %call5 to float
  store float %8, float* %2, align 4
  br label %call
}

define float @DEAD_BAND(%DEAD_BAND_interface* %0) {
entry:
  %X = getelementptr inbounds %DEAD_BAND_interface, %DEAD_BAND_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %DEAD_BAND_interface, %DEAD_BAND_interface* %0, i32 0, i32 1
  %DEAD_BAND = alloca float, align 4
  store float 0.000000e+00, float* %DEAD_BAND, align 4
  %load_X = load float, float* %X, align 4
  %load_L = load float, float* %L, align 4
  %tmpVar = fcmp ogt float %load_X, %load_L
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  %load_X1 = load float, float* %X, align 4
  %load_L2 = load float, float* %L, align 4
  %tmpVar3 = fsub float %load_X1, %load_L2
  store float %tmpVar3, float* %DEAD_BAND, align 4
  br label %continue

branch:                                           ; preds = %entry
  %load_X5 = load float, float* %X, align 4
  %load_L6 = load float, float* %L, align 4
  %tmpVar7 = fneg float %load_L6
  %tmpVar8 = fcmp olt float %load_X5, %tmpVar7
  br i1 %tmpVar8, label %condition_body4, label %else

condition_body4:                                  ; preds = %branch
  %load_X9 = load float, float* %X, align 4
  %load_L10 = load float, float* %L, align 4
  %tmpVar11 = fadd float %load_X9, %load_L10
  store float %tmpVar11, float* %DEAD_BAND, align 4
  br label %continue

else:                                             ; preds = %branch
  store float 0.000000e+00, float* %DEAD_BAND, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body4, %condition_body
  %DEAD_BAND_ret = load float, float* %DEAD_BAND, align 4
  ret float %DEAD_BAND_ret
}

define void @DEAD_BAND_A(%DEAD_BAND_A_interface* %0) {
entry:
  %X = getelementptr inbounds %DEAD_BAND_A_interface, %DEAD_BAND_A_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %DEAD_BAND_A_interface, %DEAD_BAND_A_interface* %0, i32 0, i32 1
  %KL = getelementptr inbounds %DEAD_BAND_A_interface, %DEAD_BAND_A_interface* %0, i32 0, i32 2
  %LM = getelementptr inbounds %DEAD_BAND_A_interface, %DEAD_BAND_A_interface* %0, i32 0, i32 3
  %Y = getelementptr inbounds %DEAD_BAND_A_interface, %DEAD_BAND_A_interface* %0, i32 0, i32 4
  %L = getelementptr inbounds %DEAD_BAND_A_interface, %DEAD_BAND_A_interface* %0, i32 0, i32 5
  %tp1 = getelementptr inbounds %DEAD_BAND_A_interface, %DEAD_BAND_A_interface* %0, i32 0, i32 6
  %tp2 = getelementptr inbounds %DEAD_BAND_A_interface, %DEAD_BAND_A_interface* %0, i32 0, i32 7
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %tp1, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %1, align 4
  %2 = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %tp1, i32 0, i32 1
  %load_T = load i64, i64* %T, align 4
  store i64 %load_T, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  call void @FT_PT1(%FT_PT1_interface* %tp1)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  br label %input1

input1:                                           ; preds = %continue
  %3 = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %tp2, i32 0, i32 0
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input5
  %4 = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %tp2, i32 0, i32 1
  %MULTIME_instance = alloca %MULTIME_interface, align 8
  br label %input11

call2:                                            ; preds = %continue14
  call void @FT_PT1(%FT_PT1_interface* %tp2)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input17

input5:                                           ; preds = %input1
  %5 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %out = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %tp1, i32 0, i32 3
  %load_ = load float, float* %out, align 4
  %load_X9 = load float, float* %X, align 4
  %tmpVar = fsub float %load_, %load_X9
  %6 = fptoui float %tmpVar to i64
  store i64 %6, i64* %5, align 4
  br label %call6

call6:                                            ; preds = %input5
  %call10 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %7 = uitofp i64 %call10 to float
  store float %7, float* %3, align 4

input11:                                          ; preds = %input1
  %8 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance, i32 0, i32 0
  %load_T15 = load i64, i64* %T, align 4
  store i64 %load_T15, i64* %8, align 4
  %9 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance, i32 0, i32 1
  store float 4.000000e+00, float* %9, align 4
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  store i64 %call16, i64* %4, align 4
  br label %call2

input17:                                          ; preds = %continue4
  %10 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_KL = load float, float* %KL, align 4
  %out21 = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %tp2, i32 0, i32 3
  %load_22 = load float, float* %out21, align 4
  %tmpVar23 = fmul float %load_KL, %load_22
  %11 = fptoui float %tmpVar23 to i64
  store i64 %11, i64* %10, align 4
  %12 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_LM = load float, float* %LM, align 4
  %13 = fptoui float %load_LM to i64
  store i64 %13, i64* %12, align 4
  br label %call18

call18:                                           ; preds = %input17
  %call24 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %14 = uitofp i64 %call24 to float
  store float %14, float* %L, align 4
  %load_X26 = load float, float* %X, align 4
  %load_L = load float, float* %L, align 4
  %tmpVar27 = fcmp ogt float %load_X26, %load_L
  br i1 %tmpVar27, label %condition_body, label %branch

condition_body:                                   ; preds = %continue20
  %load_X28 = load float, float* %X, align 4
  %load_L29 = load float, float* %L, align 4
  %tmpVar30 = fsub float %load_X28, %load_L29
  store float %tmpVar30, float* %Y, align 4
  br label %continue25

branch:                                           ; preds = %continue20
  %load_X32 = load float, float* %X, align 4
  %load_L33 = load float, float* %L, align 4
  %tmpVar34 = fneg float %load_L33
  %tmpVar35 = fcmp olt float %load_X32, %tmpVar34
  br i1 %tmpVar35, label %condition_body31, label %else

condition_body31:                                 ; preds = %branch
  %load_X36 = load float, float* %X, align 4
  %load_L37 = load float, float* %L, align 4
  %tmpVar38 = fadd float %load_X36, %load_L37
  store float %tmpVar38, float* %Y, align 4
  br label %continue25

else:                                             ; preds = %branch
  store float 0.000000e+00, float* %Y, align 4
  br label %continue25

continue25:                                       ; preds = %else, %condition_body31, %condition_body
  ret void
}

define float @DEAD_ZONE(%DEAD_ZONE_interface* %0) {
entry:
  %X = getelementptr inbounds %DEAD_ZONE_interface, %DEAD_ZONE_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %DEAD_ZONE_interface, %DEAD_ZONE_interface* %0, i32 0, i32 1
  %DEAD_ZONE = alloca float, align 4
  store float 0.000000e+00, float* %DEAD_ZONE, align 4
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input

condition_body:                                   ; preds = %continue1
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %DEAD_ZONE, align 4
  br label %continue

else:                                             ; preds = %continue1
  store float 0.000000e+00, float* %DEAD_ZONE, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body
  %DEAD_ZONE_ret = load float, float* %DEAD_ZONE, align 4
  ret float %DEAD_ZONE_ret

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %2 = fptoui float %load_x to i64
  store i64 %2, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %3 = uitofp i64 %call2 to double
  %load_L = load float, float* %L, align 4
  %4 = fpext float %load_L to double
  %tmpVar = fcmp ogt double %3, %4
  br i1 %tmpVar, label %condition_body, label %else
}

define void @DEAD_ZONE2(%DEAD_ZONE2_interface* %0) {
entry:
  %X = getelementptr inbounds %DEAD_ZONE2_interface, %DEAD_ZONE2_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %DEAD_ZONE2_interface, %DEAD_ZONE2_interface* %0, i32 0, i32 1
  %Y = getelementptr inbounds %DEAD_ZONE2_interface, %DEAD_ZONE2_interface* %0, i32 0, i32 2
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input

condition_body:                                   ; preds = %continue1
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %Y, align 4
  br label %continue

branch:                                           ; preds = %continue1
  %load_Y = load float, float* %Y, align 4
  %tmpVar4 = fcmp ogt float %load_Y, 0.000000e+00
  br i1 %tmpVar4, label %condition_body3, label %else

condition_body3:                                  ; preds = %branch
  %load_L5 = load float, float* %L, align 4
  store float %load_L5, float* %Y, align 4
  br label %continue

else:                                             ; preds = %branch
  %load_L6 = load float, float* %L, align 4
  %tmpVar7 = fneg float %load_L6
  store float %tmpVar7, float* %Y, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body3, %condition_body
  ret void

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %2 = fptoui float %load_x to i64
  store i64 %2, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %3 = uitofp i64 %call2 to double
  %load_L = load float, float* %L, align 4
  %4 = fpext float %load_L to double
  %tmpVar = fcmp ogt double %3, %4
  br i1 %tmpVar, label %condition_body, label %branch
}

define void @FT_DERIV(%FT_DERIV_interface* %0) {
entry:
  %in = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %0, i32 0, i32 0
  %K = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %0, i32 0, i32 1
  %run = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %0, i32 0, i32 2
  %out = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %0, i32 0, i32 3
  %old = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %0, i32 0, i32 4
  %tx = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %0, i32 0, i32 5
  %last = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %0, i32 0, i32 6
  %init = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %0, i32 0, i32 7
  %tc = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %0, i32 0, i32 8
  %T_PLC_US_instance = alloca %T_PLC_US_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_US(%T_PLC_US_interface* %T_PLC_US_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %1 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_tx = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar = sub i32 %load_tx, %load_last
  store i32 %tmpVar, i32* %1, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store float %call6, float* %tc, align 4
  %load_tx7 = load i32, i32* %tx, align 4
  store i32 %load_tx7, i32* %last, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar9 = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar9, 0
  br i1 %2, label %condition_body, label %branch

condition_body:                                   ; preds = %continue5
  store i8 1, i8* %init, align 1
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %old, align 4
  br label %continue8

branch:                                           ; preds = %continue5
  %load_run = load i8, i8* %run, align 1
  %3 = zext i8 %load_run to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %5, label %7

condition_body10:                                 ; preds = %7
  %load_in12 = load float, float* %in, align 4
  %load_old = load float, float* %old, align 4
  %tmpVar13 = fsub float %load_in12, %load_old
  %load_tc14 = load float, float* %tc, align 4
  %tmpVar15 = fdiv float %tmpVar13, %load_tc14
  %tmpVar16 = fmul float %tmpVar15, 1.000000e+06
  %load_K = load float, float* %K, align 4
  %tmpVar17 = fmul float %tmpVar16, %load_K
  store float %tmpVar17, float* %out, align 4
  %load_in18 = load float, float* %in, align 4
  store float %load_in18, float* %old, align 4
  br label %continue8

else:                                             ; preds = %7
  store float 0.000000e+00, float* %out, align 4
  br label %continue8

continue8:                                        ; preds = %else, %condition_body10, %condition_body
  ret void

5:                                                ; preds = %branch
  %load_tc = load float, float* %tc, align 4
  %tmpVar11 = fcmp ogt float %load_tc, 0.000000e+00
  %6 = zext i1 %tmpVar11 to i32
  br label %7

7:                                                ; preds = %5, %branch
  %8 = phi i32 [ %3, %branch ], [ %6, %5 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body10, label %else
}

define void @FT_IMP(%FT_IMP_interface* %0) {
entry:
  %in = getelementptr inbounds %FT_IMP_interface, %FT_IMP_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %FT_IMP_interface, %FT_IMP_interface* %0, i32 0, i32 1
  %K = getelementptr inbounds %FT_IMP_interface, %FT_IMP_interface* %0, i32 0, i32 2
  %out = getelementptr inbounds %FT_IMP_interface, %FT_IMP_interface* %0, i32 0, i32 3
  %t1 = getelementptr inbounds %FT_IMP_interface, %FT_IMP_interface* %0, i32 0, i32 4
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %t1, i32 0, i32 0
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %1, align 4
  %2 = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %t1, i32 0, i32 1
  %load_T = load i64, i64* %T, align 4
  store i64 %load_T, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  call void @FT_PT1(%FT_PT1_interface* %t1)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_in1 = load float, float* %in, align 4
  %out2 = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %t1, i32 0, i32 3
  %load_ = load float, float* %out2, align 4
  %tmpVar = fsub float %load_in1, %load_
  %load_K = load float, float* %K, align 4
  %tmpVar3 = fmul float %tmpVar, %load_K
  store float %tmpVar3, float* %out, align 4
  ret void
}

define void @FT_INT(%FT_INT_interface* %0) {
entry:
  %IN = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %0, i32 0, i32 0
  %K = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %0, i32 0, i32 1
  %RUN = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %0, i32 0, i32 2
  %RST = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %0, i32 0, i32 3
  %OUT_MIN = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %0, i32 0, i32 4
  %OUT_MAX = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %0, i32 0, i32 5
  %OUT = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %0, i32 0, i32 6
  %LIM = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %0, i32 0, i32 7
  %INTeg = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %0, i32 0, i32 8
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  store float 0.000000e+00, float* %OUT, align 4
  br label %continue

else:                                             ; preds = %entry
  br label %input

continue:                                         ; preds = %continue1, %condition_body
  %load_out5 = load float, float* %OUT, align 4
  %load_OUT_MAX = load float, float* %OUT_MAX, align 4
  %tmpVar = fcmp oge float %load_out5, %load_OUT_MAX
  br i1 %tmpVar, label %condition_body4, label %branch

input:                                            ; preds = %else
  %2 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %INTeg, i32 0, i32 1
  %load_IN = load float, float* %IN, align 4
  store float %load_IN, float* %2, align 4
  %3 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %INTeg, i32 0, i32 0
  %load_RUN = load i8, i8* %RUN, align 1
  store i8 %load_RUN, i8* %3, align 1
  %4 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %INTeg, i32 0, i32 2
  %load_K = load float, float* %K, align 4
  store float %load_K, float* %4, align 4
  %5 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %INTeg, i32 0, i32 3
  %load_out = load float, float* %OUT, align 4
  store float %load_out, float** %5, align 4
  br label %call

call:                                             ; preds = %input
  call void @INTEGRATE(%INTEGRATE_interface* %INTeg)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  br label %continue

condition_body4:                                  ; preds = %continue
  %load_out_max = load float, float* %OUT_MAX, align 4
  store float %load_out_max, float* %OUT, align 4
  store i8 1, i8* %LIM, align 1
  br label %continue3

branch:                                           ; preds = %continue
  %load_out7 = load float, float* %OUT, align 4
  %load_out_min = load float, float* %OUT_MIN, align 4
  %tmpVar8 = fcmp ole float %load_out7, %load_out_min
  br i1 %tmpVar8, label %condition_body6, label %else2

condition_body6:                                  ; preds = %branch
  %load_out_min9 = load float, float* %OUT_MIN, align 4
  store float %load_out_min9, float* %OUT, align 4
  store i8 1, i8* %LIM, align 1
  br label %continue3

else2:                                            ; preds = %branch
  store i8 0, i8* %LIM, align 1
  br label %continue3

continue3:                                        ; preds = %else2, %condition_body6, %condition_body4
  ret void
}

define void @FT_INT2(%FT_INT2_interface* %0) {
entry:
  %IN = getelementptr inbounds %FT_INT2_interface, %FT_INT2_interface* %0, i32 0, i32 0
  %K = getelementptr inbounds %FT_INT2_interface, %FT_INT2_interface* %0, i32 0, i32 1
  %RUN = getelementptr inbounds %FT_INT2_interface, %FT_INT2_interface* %0, i32 0, i32 2
  %RST = getelementptr inbounds %FT_INT2_interface, %FT_INT2_interface* %0, i32 0, i32 3
  %OUT_MIN = getelementptr inbounds %FT_INT2_interface, %FT_INT2_interface* %0, i32 0, i32 4
  %OUT_MAX = getelementptr inbounds %FT_INT2_interface, %FT_INT2_interface* %0, i32 0, i32 5
  %OUT = getelementptr inbounds %FT_INT2_interface, %FT_INT2_interface* %0, i32 0, i32 6
  %LIM = getelementptr inbounds %FT_INT2_interface, %FT_INT2_interface* %0, i32 0, i32 7
  %integ = getelementptr inbounds %FT_INT2_interface, %FT_INT2_interface* %0, i32 0, i32 8
  %ix = getelementptr inbounds %FT_INT2_interface, %FT_INT2_interface* %0, i32 0, i32 9
  %val = getelementptr inbounds %FT_INT2_interface, %FT_INT2_interface* %0, i32 0, i32 10
  %load_RST = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_RST, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %R2_SET_instance = alloca %R2_SET_interface, align 8
  br label %input

else:                                             ; preds = %entry
  br label %input3

continue:                                         ; preds = %continue10, %continue1
  %load_out = load float, float* %OUT, align 4
  %load_OUT_MIN = load float, float* %OUT_MIN, align 4
  %tmpVar = fcmp ogt float %load_out, %load_OUT_MIN
  %2 = zext i1 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %11, label %13

input:                                            ; preds = %condition_body
  %4 = getelementptr inbounds %R2_SET_interface, %R2_SET_interface* %R2_SET_instance, i32 0, i32 0
  store float 0.000000e+00, float* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call %REAL2 @R2_SET(%R2_SET_interface* %R2_SET_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store %REAL2 %call2, %REAL2* %val, align 4
  store float 0.000000e+00, float* %OUT, align 4
  br label %continue

input3:                                           ; preds = %else
  %5 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %integ, i32 0, i32 1
  %load_IN = load float, float* %IN, align 4
  store float %load_IN, float* %5, align 4
  %6 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %integ, i32 0, i32 0
  %load_RUN = load i8, i8* %RUN, align 1
  store i8 %load_RUN, i8* %6, align 1
  %7 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %integ, i32 0, i32 2
  %load_K = load float, float* %K, align 4
  store float %load_K, float* %7, align 4
  %8 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %integ, i32 0, i32 3
  %load_ix = load float, float* %ix, align 4
  store float %load_ix, float** %8, align 4
  br label %call4

call4:                                            ; preds = %input3
  call void @INTEGRATE(%INTEGRATE_interface* %integ)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %R2_ADD_instance = alloca %R2_ADD_interface, align 8
  br label %input7

input7:                                           ; preds = %continue6
  %9 = getelementptr inbounds %R2_ADD_interface, %R2_ADD_interface* %R2_ADD_instance, i32 0, i32 0
  %load_val = load %REAL2, %REAL2* %val, align 4
  store %REAL2 %load_val, %REAL2* %9, align 4
  %10 = getelementptr inbounds %R2_ADD_interface, %R2_ADD_interface* %R2_ADD_instance, i32 0, i32 1
  %load_ix11 = load float, float* %ix, align 4
  store float %load_ix11, float* %10, align 4
  br label %call8

call8:                                            ; preds = %input7
  %call12 = call %REAL2 @R2_ADD(%R2_ADD_interface* %R2_ADD_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  store %REAL2 %call12, %REAL2* %val, align 4
  store float 0.000000e+00, float* %ix, align 4
  %RX = getelementptr inbounds %REAL2, %REAL2* %val, i32 0, i32 1
  %load_ = load float, float* %RX, align 4
  store float %load_, float* %OUT, align 4
  br label %continue

condition_body15:                                 ; preds = %13
  store i8 0, i8* %LIM, align 1
  br label %continue14

else13:                                           ; preds = %13
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input18

continue14:                                       ; preds = %continue29, %condition_body15
  ret void

11:                                               ; preds = %continue
  %load_out16 = load float, float* %OUT, align 4
  %load_OUT_MAX = load float, float* %OUT_MAX, align 4
  %tmpVar17 = fcmp olt float %load_out16, %load_OUT_MAX
  %12 = zext i1 %tmpVar17 to i32
  br label %13

13:                                               ; preds = %11, %continue
  %14 = phi i32 [ %2, %continue ], [ %12, %11 ]
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %condition_body15, label %else13

input18:                                          ; preds = %else13
  %16 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_OUT_MIN22 = load float, float* %OUT_MIN, align 4
  %17 = fptoui float %load_OUT_MIN22 to i64
  store i64 %17, i64* %16, align 4
  %18 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_OUT = load float, float* %OUT, align 4
  %19 = fptoui float %load_OUT to i64
  store i64 %19, i64* %18, align 4
  %20 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_OUT_MAX23 = load float, float* %OUT_MAX, align 4
  %21 = fptoui float %load_OUT_MAX23 to i64
  store i64 %21, i64* %20, align 4
  br label %call19

call19:                                           ; preds = %input18
  %call24 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %22 = uitofp i64 %call24 to float
  store float %22, float* %OUT, align 4
  %R2_SET_instance25 = alloca %R2_SET_interface, align 8
  br label %input26

input26:                                          ; preds = %continue21
  %23 = getelementptr inbounds %R2_SET_interface, %R2_SET_interface* %R2_SET_instance25, i32 0, i32 0
  %load_OUT30 = load float, float* %OUT, align 4
  store float %load_OUT30, float* %23, align 4
  br label %call27

call27:                                           ; preds = %input26
  %call31 = call %REAL2 @R2_SET(%R2_SET_interface* %R2_SET_instance25)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  store %REAL2 %call31, %REAL2* %val, align 4
  store i8 1, i8* %LIM, align 1
  br label %continue14
}

define void @FT_PD(%FT_PD_interface* %0) {
entry:
  %IN = getelementptr inbounds %FT_PD_interface, %FT_PD_interface* %0, i32 0, i32 0
  %KP = getelementptr inbounds %FT_PD_interface, %FT_PD_interface* %0, i32 0, i32 1
  %TV = getelementptr inbounds %FT_PD_interface, %FT_PD_interface* %0, i32 0, i32 2
  %Y = getelementptr inbounds %FT_PD_interface, %FT_PD_interface* %0, i32 0, i32 3
  %diff = getelementptr inbounds %FT_PD_interface, %FT_PD_interface* %0, i32 0, i32 4
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 0
  %load_IN = load float, float* %IN, align 4
  store float %load_IN, float* %1, align 4
  %2 = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 1
  %load_TV = load float, float* %TV, align 4
  store float %load_TV, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  call void @FT_DERIV(%FT_DERIV_interface* %diff)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_KP = load float, float* %KP, align 4
  %out = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 3
  %load_ = load float, float* %out, align 4
  %load_IN1 = load float, float* %IN, align 4
  %tmpVar = fadd float %load_, %load_IN1
  %tmpVar2 = fmul float %load_KP, %tmpVar
  store float %tmpVar2, float* %Y, align 4
  ret void
}

define void @FT_PDT1(%FT_PDT1_interface* %0) {
entry:
  %IN = getelementptr inbounds %FT_PDT1_interface, %FT_PDT1_interface* %0, i32 0, i32 0
  %KP = getelementptr inbounds %FT_PDT1_interface, %FT_PDT1_interface* %0, i32 0, i32 1
  %TV = getelementptr inbounds %FT_PDT1_interface, %FT_PDT1_interface* %0, i32 0, i32 2
  %T1 = getelementptr inbounds %FT_PDT1_interface, %FT_PDT1_interface* %0, i32 0, i32 3
  %Y = getelementptr inbounds %FT_PDT1_interface, %FT_PDT1_interface* %0, i32 0, i32 4
  %diff = getelementptr inbounds %FT_PDT1_interface, %FT_PDT1_interface* %0, i32 0, i32 5
  %TP = getelementptr inbounds %FT_PDT1_interface, %FT_PDT1_interface* %0, i32 0, i32 6
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 0
  %load_IN = load float, float* %IN, align 4
  store float %load_IN, float* %1, align 4
  %2 = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 1
  %load_TV = load float, float* %TV, align 4
  store float %load_TV, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  call void @FT_DERIV(%FT_DERIV_interface* %diff)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  br label %input1

input1:                                           ; preds = %continue
  %3 = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %TP, i32 0, i32 0
  %out = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 3
  %load_ = load float, float* %out, align 4
  store float %load_, float* %3, align 4
  %4 = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %TP, i32 0, i32 1
  %REAL_TO_TIME_instance = alloca %REAL_TO_TIME_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  call void @FT_PT1(%FT_PT1_interface* %TP)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %load_KP = load float, float* %KP, align 4
  %out10 = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %TP, i32 0, i32 3
  %load_11 = load float, float* %out10, align 4
  %load_IN12 = load float, float* %IN, align 4
  %tmpVar = fadd float %load_11, %load_IN12
  %tmpVar13 = fmul float %load_KP, %tmpVar
  store float %tmpVar13, float* %Y, align 4
  ret void

input5:                                           ; preds = %input1
  %5 = getelementptr inbounds %REAL_TO_TIME_interface, %REAL_TO_TIME_interface* %REAL_TO_TIME_instance, i32 0, i32 0
  %load_T1 = load float, float* %T1, align 4
  store float %load_T1, float* %5, align 4
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i64 @REAL_TO_TIME(%REAL_TO_TIME_interface* %REAL_TO_TIME_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  store i64 %call9, i64* %4, align 4
  br label %call2
}

define void @FT_PI(%FT_PI_interface* %0) {
entry:
  %IN = getelementptr inbounds %FT_PI_interface, %FT_PI_interface* %0, i32 0, i32 0
  %KP = getelementptr inbounds %FT_PI_interface, %FT_PI_interface* %0, i32 0, i32 1
  %KI = getelementptr inbounds %FT_PI_interface, %FT_PI_interface* %0, i32 0, i32 2
  %ILIM_L = getelementptr inbounds %FT_PI_interface, %FT_PI_interface* %0, i32 0, i32 3
  %ILIM_H = getelementptr inbounds %FT_PI_interface, %FT_PI_interface* %0, i32 0, i32 4
  %IEN = getelementptr inbounds %FT_PI_interface, %FT_PI_interface* %0, i32 0, i32 5
  %RST = getelementptr inbounds %FT_PI_interface, %FT_PI_interface* %0, i32 0, i32 6
  %Y = getelementptr inbounds %FT_PI_interface, %FT_PI_interface* %0, i32 0, i32 7
  %LIM = getelementptr inbounds %FT_PI_interface, %FT_PI_interface* %0, i32 0, i32 8
  %integ = getelementptr inbounds %FT_PI_interface, %FT_PI_interface* %0, i32 0, i32 9
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 0
  %load_IN = load float, float* %IN, align 4
  store float %load_IN, float* %1, align 4
  %2 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 1
  %load_KI = load float, float* %KI, align 4
  store float %load_KI, float* %2, align 4
  %3 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 2
  %load_IEN = load i8, i8* %IEN, align 1
  store i8 %load_IEN, i8* %3, align 1
  %4 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 3
  %load_RST = load i8, i8* %RST, align 1
  store i8 %load_RST, i8* %4, align 1
  %5 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 4
  %load_ILIM_L = load float, float* %ILIM_L, align 4
  store float %load_ILIM_L, float* %5, align 4
  %6 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 5
  %load_ILIM_H = load float, float* %ILIM_H, align 4
  store float %load_ILIM_H, float* %6, align 4
  br label %call

call:                                             ; preds = %input
  call void @FT_INT(%FT_INT_interface* %integ)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %LIM1 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 7
  %load_ = load i8, i8* %LIM1, align 1
  store i8 %load_, i8* %LIM, align 1
  %load_KP = load float, float* %KP, align 4
  %load_IN2 = load float, float* %IN, align 4
  %tmpVar = fmul float %load_KP, %load_IN2
  %Out = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 6
  %load_3 = load float, float* %Out, align 4
  %tmpVar4 = fadd float %tmpVar, %load_3
  store float %tmpVar4, float* %Y, align 4
  ret void
}

define void @FT_PID(%FT_PID_interface* %0) {
entry:
  %IN = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 0
  %KP = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 1
  %TN = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 2
  %TV = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 3
  %ILIM_L = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 4
  %ILIM_H = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 5
  %IEN = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 6
  %RST = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 7
  %Y = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 8
  %LIM = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 9
  %integ = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 10
  %diff = getelementptr inbounds %FT_PID_interface, %FT_PID_interface* %0, i32 0, i32 11
  %load_TN = load float, float* %TN, align 4
  %tmpVar = fcmp ogt float %load_TN, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  br label %input

else:                                             ; preds = %entry
  br label %input4

continue:                                         ; preds = %continue7, %continue1
  br label %input8

input:                                            ; preds = %condition_body
  %1 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 0
  %load_IN = load float, float* %IN, align 4
  store float %load_IN, float* %1, align 4
  %2 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 1
  %load_TN2 = load float, float* %TN, align 4
  %tmpVar3 = fdiv float 1.000000e+00, %load_TN2
  store float %tmpVar3, float* %2, align 4
  %3 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 2
  %load_IEN = load i8, i8* %IEN, align 1
  store i8 %load_IEN, i8* %3, align 1
  %4 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 3
  %load_RST = load i8, i8* %RST, align 1
  store i8 %load_RST, i8* %4, align 1
  %5 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 4
  %load_ILIM_L = load float, float* %ILIM_L, align 4
  store float %load_ILIM_L, float* %5, align 4
  %6 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 5
  %load_ILIM_H = load float, float* %ILIM_H, align 4
  store float %load_ILIM_H, float* %6, align 4
  br label %call

call:                                             ; preds = %input
  call void @FT_INT(%FT_INT_interface* %integ)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  br label %continue

input4:                                           ; preds = %else
  %7 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 3
  store i8 0, i8* %7, align 1
  br label %call5

call5:                                            ; preds = %input4
  call void @FT_INT(%FT_INT_interface* %integ)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  br label %continue

input8:                                           ; preds = %continue
  %8 = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 0
  %load_IN12 = load float, float* %IN, align 4
  store float %load_IN12, float* %8, align 4
  %9 = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 1
  %load_TV = load float, float* %TV, align 4
  store float %load_TV, float* %9, align 4
  br label %call9

call9:                                            ; preds = %input8
  call void @FT_DERIV(%FT_DERIV_interface* %diff)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %load_KP = load float, float* %KP, align 4
  %Out = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 6
  %load_ = load float, float* %Out, align 4
  %out = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 3
  %load_13 = load float, float* %out, align 4
  %tmpVar14 = fadd float %load_, %load_13
  %load_IN15 = load float, float* %IN, align 4
  %tmpVar16 = fadd float %tmpVar14, %load_IN15
  %tmpVar17 = fmul float %load_KP, %tmpVar16
  store float %tmpVar17, float* %Y, align 4
  %LIM18 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 7
  %load_19 = load i8, i8* %LIM18, align 1
  store i8 %load_19, i8* %LIM, align 1
  ret void
}

define void @FT_PIDW(%FT_PIDW_interface* %0) {
entry:
  %IN = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 0
  %KP = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 1
  %TN = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 2
  %TV = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 3
  %LIM_L = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 4
  %LIM_H = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 5
  %RST = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 6
  %Y = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 7
  %LIM = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 8
  %integ = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 9
  %diff = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 10
  %YI = getelementptr inbounds %FT_PIDW_interface, %FT_PIDW_interface* %0, i32 0, i32 11
  %load_tn = load float, float* %TN, align 4
  %tmpVar = fcmp oeq float %load_tn, 0.000000e+00
  %1 = zext i1 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %5, label %3

condition_body:                                   ; preds = %5
  br label %input

else:                                             ; preds = %5
  br label %input2

continue:                                         ; preds = %continue5, %continue1
  %load_KP = load float, float* %KP, align 4
  %load_IN9 = load float, float* %IN, align 4
  %load_YI10 = load float, float* %YI, align 4
  %tmpVar11 = fadd float %load_IN9, %load_YI10
  %tmpVar12 = fmul float %load_KP, %tmpVar11
  store float %tmpVar12, float* %Y, align 4
  br label %input13

3:                                                ; preds = %entry
  %load_rst = load i8, i8* %RST, align 1
  %4 = zext i8 %load_rst to i32
  br label %5

5:                                                ; preds = %3, %entry
  %6 = phi i32 [ %1, %entry ], [ %4, %3 ]
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %condition_body, label %else

input:                                            ; preds = %condition_body
  %8 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %integ, i32 0, i32 0
  store i8 0, i8* %8, align 1
  %9 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %integ, i32 0, i32 3
  %load_YI = load float, float* %YI, align 4
  store float %load_YI, float** %9, align 4
  br label %call

call:                                             ; preds = %input
  call void @INTEGRATE(%INTEGRATE_interface* %integ)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store float 0.000000e+00, float* %YI, align 4
  br label %continue

input2:                                           ; preds = %else
  %10 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %integ, i32 0, i32 1
  %load_IN = load float, float* %IN, align 4
  store float %load_IN, float* %10, align 4
  %11 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %integ, i32 0, i32 2
  %load_TN = load float, float* %TN, align 4
  %tmpVar6 = fdiv float 1.000000e+00, %load_TN
  store float %tmpVar6, float* %11, align 4
  %12 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %integ, i32 0, i32 0
  %load_LIM = load i8, i8* %LIM, align 1
  %tmpVar7 = xor i8 %load_LIM, -1
  store i8 %tmpVar7, i8* %12, align 1
  %13 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %integ, i32 0, i32 3
  %load_YI8 = load float, float* %YI, align 4
  store float %load_YI8, float** %13, align 4
  br label %call3

call3:                                            ; preds = %input2
  call void @INTEGRATE(%INTEGRATE_interface* %integ)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  br label %continue

input13:                                          ; preds = %continue
  %14 = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 0
  %load_IN17 = load float, float* %IN, align 4
  store float %load_IN17, float* %14, align 4
  %15 = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 1
  %load_TV = load float, float* %TV, align 4
  store float %load_TV, float* %15, align 4
  br label %call14

call14:                                           ; preds = %input13
  call void @FT_DERIV(%FT_DERIV_interface* %diff)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %load_Y = load float, float* %Y, align 4
  %load_LIM_L = load float, float* %LIM_L, align 4
  %tmpVar21 = fcmp ogt float %load_Y, %load_LIM_L
  %16 = zext i1 %tmpVar21 to i32
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %18, label %20

condition_body20:                                 ; preds = %20
  store i8 0, i8* %LIM, align 1
  br label %continue19

else18:                                           ; preds = %20
  store i8 1, i8* %LIM, align 1
  br label %continue19

continue19:                                       ; preds = %else18, %condition_body20
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input24

18:                                               ; preds = %continue16
  %load_Y22 = load float, float* %Y, align 4
  %load_LIM_H = load float, float* %LIM_H, align 4
  %tmpVar23 = fcmp olt float %load_Y22, %load_LIM_H
  %19 = zext i1 %tmpVar23 to i32
  br label %20

20:                                               ; preds = %18, %continue16
  %21 = phi i32 [ %16, %continue16 ], [ %19, %18 ]
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %condition_body20, label %else18

input24:                                          ; preds = %continue19
  %23 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_LIM_L28 = load float, float* %LIM_L, align 4
  %24 = fptoui float %load_LIM_L28 to i64
  store i64 %24, i64* %23, align 4
  %25 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_Y29 = load float, float* %Y, align 4
  %load_KP30 = load float, float* %KP, align 4
  %out = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 3
  %load_ = load float, float* %out, align 4
  %tmpVar31 = fmul float %load_KP30, %load_
  %tmpVar32 = fadd float %load_Y29, %tmpVar31
  %26 = fptoui float %tmpVar32 to i64
  store i64 %26, i64* %25, align 4
  %27 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_LIM_H33 = load float, float* %LIM_H, align 4
  %28 = fptoui float %load_LIM_H33 to i64
  store i64 %28, i64* %27, align 4
  br label %call25

call25:                                           ; preds = %input24
  %call34 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output26

output26:                                         ; preds = %call25
  br label %continue27

continue27:                                       ; preds = %output26
  %29 = uitofp i64 %call34 to float
  store float %29, float* %Y, align 4
  ret void
}

define void @FT_PIDWL(%FT_PIDWL_interface* %0) {
entry:
  %IN = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %0, i32 0, i32 0
  %KP = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %0, i32 0, i32 1
  %TN = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %0, i32 0, i32 2
  %TV = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %0, i32 0, i32 3
  %LIM_L = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %0, i32 0, i32 4
  %LIM_H = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %0, i32 0, i32 5
  %RST = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %0, i32 0, i32 6
  %Y = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %0, i32 0, i32 7
  %LIM = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %0, i32 0, i32 8
  %piwl = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %0, i32 0, i32 9
  %diff = getelementptr inbounds %FT_PIDWL_interface, %FT_PIDWL_interface* %0, i32 0, i32 10
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  br label %input

else:                                             ; preds = %entry
  %load_TN = load float, float* %TN, align 4
  %tmpVar = fcmp oeq float %load_TN, 0.000000e+00
  br i1 %tmpVar, label %condition_body5, label %else3

continue:                                         ; preds = %continue33, %continue1
  ret void

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 5
  store i8 1, i8* %2, align 1
  br label %call

call:                                             ; preds = %input
  call void @FT_PIWL(%FT_PIWL_interface* %piwl)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %RST2 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 5
  store i8 0, i8* %RST2, align 1
  br label %continue

condition_body5:                                  ; preds = %else
  br label %input6

else3:                                            ; preds = %else
  br label %input11

continue4:                                        ; preds = %continue14, %continue9
  br label %input22

input6:                                           ; preds = %condition_body5
  %3 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 0
  %load_IN = load float, float* %IN, align 4
  %load_KP = load float, float* %KP, align 4
  %tmpVar10 = fmul float %load_IN, %load_KP
  store float %tmpVar10, float* %3, align 4
  %4 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 1
  store float 1.000000e+00, float* %4, align 4
  %5 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 2
  store float 0.000000e+00, float* %5, align 4
  %6 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 3
  %load_LIM_L = load float, float* %LIM_L, align 4
  store float %load_LIM_L, float* %6, align 4
  %7 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 4
  %load_LIM_H = load float, float* %LIM_H, align 4
  store float %load_LIM_H, float* %7, align 4
  br label %call7

call7:                                            ; preds = %input6
  call void @FT_PIWL(%FT_PIWL_interface* %piwl)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  br label %continue4

input11:                                          ; preds = %else3
  %8 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 0
  %load_IN15 = load float, float* %IN, align 4
  %load_KP16 = load float, float* %KP, align 4
  %tmpVar17 = fmul float %load_IN15, %load_KP16
  store float %tmpVar17, float* %8, align 4
  %9 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 1
  store float 1.000000e+00, float* %9, align 4
  %10 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 2
  %load_TN18 = load float, float* %TN, align 4
  %tmpVar19 = fdiv float 1.000000e+00, %load_TN18
  store float %tmpVar19, float* %10, align 4
  %11 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 3
  %load_LIM_L20 = load float, float* %LIM_L, align 4
  store float %load_LIM_L20, float* %11, align 4
  %12 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 4
  %load_LIM_H21 = load float, float* %LIM_H, align 4
  store float %load_LIM_H21, float* %12, align 4
  br label %call12

call12:                                           ; preds = %input11
  call void @FT_PIWL(%FT_PIWL_interface* %piwl)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  br label %continue4

input22:                                          ; preds = %continue4
  %13 = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 0
  %load_IN26 = load float, float* %IN, align 4
  store float %load_IN26, float* %13, align 4
  %14 = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 1
  %load_KP27 = load float, float* %KP, align 4
  %load_TV = load float, float* %TV, align 4
  %tmpVar28 = fmul float %load_KP27, %load_TV
  store float %tmpVar28, float* %14, align 4
  br label %call23

call23:                                           ; preds = %input22
  call void @FT_DERIV(%FT_DERIV_interface* %diff)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %Y29 = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %piwl, i32 0, i32 6
  %load_ = load float, float* %Y29, align 4
  %out = getelementptr inbounds %FT_DERIV_interface, %FT_DERIV_interface* %diff, i32 0, i32 3
  %load_30 = load float, float* %out, align 4
  %tmpVar31 = fadd float %load_, %load_30
  store float %tmpVar31, float* %Y, align 4
  %load_Y = load float, float* %Y, align 4
  %load_LIM_L35 = load float, float* %LIM_L, align 4
  %tmpVar36 = fcmp olt float %load_Y, %load_LIM_L35
  br i1 %tmpVar36, label %condition_body34, label %branch

condition_body34:                                 ; preds = %continue25
  store i8 1, i8* %LIM, align 1
  %load_LIM_L37 = load float, float* %LIM_L, align 4
  store float %load_LIM_L37, float* %Y, align 4
  br label %continue33

branch:                                           ; preds = %continue25
  %load_Y39 = load float, float* %Y, align 4
  %load_LIM_H40 = load float, float* %LIM_H, align 4
  %tmpVar41 = fcmp ogt float %load_Y39, %load_LIM_H40
  br i1 %tmpVar41, label %condition_body38, label %else32

condition_body38:                                 ; preds = %branch
  store i8 1, i8* %LIM, align 1
  %load_LIM_H42 = load float, float* %LIM_H, align 4
  store float %load_LIM_H42, float* %Y, align 4
  br label %continue33

else32:                                           ; preds = %branch
  store i8 0, i8* %LIM, align 1
  br label %continue33

continue33:                                       ; preds = %else32, %condition_body38, %condition_body34
  br label %continue
}

define void @FT_PIW(%FT_PIW_interface* %0) {
entry:
  %IN = getelementptr inbounds %FT_PIW_interface, %FT_PIW_interface* %0, i32 0, i32 0
  %KP = getelementptr inbounds %FT_PIW_interface, %FT_PIW_interface* %0, i32 0, i32 1
  %KI = getelementptr inbounds %FT_PIW_interface, %FT_PIW_interface* %0, i32 0, i32 2
  %LIM_L = getelementptr inbounds %FT_PIW_interface, %FT_PIW_interface* %0, i32 0, i32 3
  %LIM_H = getelementptr inbounds %FT_PIW_interface, %FT_PIW_interface* %0, i32 0, i32 4
  %RST = getelementptr inbounds %FT_PIW_interface, %FT_PIW_interface* %0, i32 0, i32 5
  %Y = getelementptr inbounds %FT_PIW_interface, %FT_PIW_interface* %0, i32 0, i32 6
  %LIM = getelementptr inbounds %FT_PIW_interface, %FT_PIW_interface* %0, i32 0, i32 7
  %integ = getelementptr inbounds %FT_PIW_interface, %FT_PIW_interface* %0, i32 0, i32 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 0
  %load_IN = load float, float* %IN, align 4
  store float %load_IN, float* %1, align 4
  %2 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 1
  %load_KI = load float, float* %KI, align 4
  store float %load_KI, float* %2, align 4
  %3 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 2
  %load_LIM = load i8, i8* %LIM, align 1
  %tmpVar = xor i8 %load_LIM, -1
  store i8 %tmpVar, i8* %3, align 1
  %4 = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 3
  %load_RST = load i8, i8* %RST, align 1
  store i8 %load_RST, i8* %4, align 1
  br label %call

call:                                             ; preds = %input
  call void @FT_INT(%FT_INT_interface* %integ)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_KP = load float, float* %KP, align 4
  %load_IN1 = load float, float* %IN, align 4
  %tmpVar2 = fmul float %load_KP, %load_IN1
  %Out = getelementptr inbounds %FT_INT_interface, %FT_INT_interface* %integ, i32 0, i32 6
  %load_ = load float, float* %Out, align 4
  %tmpVar3 = fadd float %tmpVar2, %load_
  store float %tmpVar3, float* %Y, align 4
  %load_Y = load float, float* %Y, align 4
  %load_LIM_L = load float, float* %LIM_L, align 4
  %tmpVar5 = fcmp olt float %load_Y, %load_LIM_L
  br i1 %tmpVar5, label %condition_body, label %branch

condition_body:                                   ; preds = %continue
  %load_LIM_L6 = load float, float* %LIM_L, align 4
  store float %load_LIM_L6, float* %Y, align 4
  store i8 1, i8* %LIM, align 1
  br label %continue4

branch:                                           ; preds = %continue
  %load_Y8 = load float, float* %Y, align 4
  %load_LIM_H = load float, float* %LIM_H, align 4
  %tmpVar9 = fcmp ogt float %load_Y8, %load_LIM_H
  br i1 %tmpVar9, label %condition_body7, label %else

condition_body7:                                  ; preds = %branch
  %load_LIM_H10 = load float, float* %LIM_H, align 4
  store float %load_LIM_H10, float* %Y, align 4
  store i8 1, i8* %LIM, align 1
  br label %continue4

else:                                             ; preds = %branch
  store i8 0, i8* %LIM, align 1
  br label %continue4

continue4:                                        ; preds = %else, %condition_body7, %condition_body
  ret void
}

define void @FT_PIWL(%FT_PIWL_interface* %0) {
entry:
  %IN = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 0
  %KP = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 1
  %KI = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 2
  %LIM_L = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 3
  %LIM_H = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 4
  %RST = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 5
  %Y = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 6
  %LIM = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 7
  %init = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 8
  %tx = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 9
  %tc = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 10
  %t_last = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 11
  %in_last = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 12
  %i = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 13
  %p = getelementptr inbounds %FT_PIWL_interface, %FT_PIWL_interface* %0, i32 0, i32 14
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = zext i8 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %5, label %3

condition_body:                                   ; preds = %5
  store i8 1, i8* %init, align 1
  %load_in = load float, float* %IN, align 4
  store float %load_in, float* %in_last, align 4
  %T_PLC_US_instance = alloca %T_PLC_US_interface, align 8
  br label %input

else:                                             ; preds = %5
  %T_PLC_US_instance3 = alloca %T_PLC_US_interface, align 8
  br label %input4

continue:                                         ; preds = %continue27, %continue1
  ret void

3:                                                ; preds = %entry
  %load_RST = load i8, i8* %RST, align 1
  %4 = zext i8 %load_RST to i32
  br label %5

5:                                                ; preds = %3, %entry
  %6 = phi i32 [ %1, %entry ], [ %4, %3 ]
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %condition_body, label %else

input:                                            ; preds = %condition_body
  br label %call

call:                                             ; preds = %input
  %call2 = call i32 @T_PLC_US(%T_PLC_US_interface* %T_PLC_US_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store i32 %call2, i32* %t_last, align 4
  store float 0.000000e+00, float* %i, align 4
  store float 0.000000e+00, float* %tc, align 4
  br label %continue

input4:                                           ; preds = %else
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call i32 @T_PLC_US(%T_PLC_US_interface* %T_PLC_US_instance3)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  store i32 %call8, i32* %tx, align 4
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input9

input9:                                           ; preds = %continue7
  %8 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_tx = load i32, i32* %tx, align 4
  %load_t_last = load i32, i32* %t_last, align 4
  %tmpVar13 = sub i32 %load_tx, %load_t_last
  store i32 %tmpVar13, i32* %8, align 4
  br label %call10

call10:                                           ; preds = %input9
  %call14 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  store float %call14, float* %tc, align 4
  %load_tx15 = load i32, i32* %tx, align 4
  store i32 %load_tx15, i32* %t_last, align 4
  %load_KP = load float, float* %KP, align 4
  %load_IN = load float, float* %IN, align 4
  %tmpVar16 = fmul float %load_KP, %load_IN
  store float %tmpVar16, float* %p, align 4
  %load_IN17 = load float, float* %IN, align 4
  %load_in_last = load float, float* %in_last, align 4
  %tmpVar18 = fadd float %load_IN17, %load_in_last
  %tmpVar19 = fmul float %tmpVar18, 0x3EA0C6F7A0000000
  %load_KI = load float, float* %KI, align 4
  %tmpVar20 = fmul float %tmpVar19, %load_KI
  %load_tc = load float, float* %tc, align 4
  %tmpVar21 = fmul float %tmpVar20, %load_tc
  %load_i = load float, float* %i, align 4
  %tmpVar22 = fadd float %tmpVar21, %load_i
  store float %tmpVar22, float* %i, align 4
  %load_IN23 = load float, float* %IN, align 4
  store float %load_IN23, float* %in_last, align 4
  %load_p = load float, float* %p, align 4
  %load_i24 = load float, float* %i, align 4
  %tmpVar25 = fadd float %load_p, %load_i24
  store float %tmpVar25, float* %Y, align 4
  %load_Y = load float, float* %Y, align 4
  %load_LIM_H = load float, float* %LIM_H, align 4
  %tmpVar29 = fcmp oge float %load_Y, %load_LIM_H
  br i1 %tmpVar29, label %condition_body28, label %branch

condition_body28:                                 ; preds = %continue12
  %load_LIM_H30 = load float, float* %LIM_H, align 4
  store float %load_LIM_H30, float* %Y, align 4
  %load_ki = load float, float* %KI, align 4
  %tmpVar34 = fcmp one float %load_ki, 0.000000e+00
  br i1 %tmpVar34, label %condition_body33, label %else31

branch:                                           ; preds = %continue12
  %load_Y39 = load float, float* %Y, align 4
  %load_LIM_L = load float, float* %LIM_L, align 4
  %tmpVar40 = fcmp ole float %load_Y39, %load_LIM_L
  br i1 %tmpVar40, label %condition_body38, label %else26

condition_body38:                                 ; preds = %branch
  %load_LIM_L41 = load float, float* %LIM_L, align 4
  store float %load_LIM_L41, float* %Y, align 4
  %load_ki45 = load float, float* %KI, align 4
  %tmpVar46 = fcmp one float %load_ki45, 0.000000e+00
  br i1 %tmpVar46, label %condition_body44, label %else42

else26:                                           ; preds = %branch
  store i8 0, i8* %LIM, align 1
  br label %continue27

continue27:                                       ; preds = %else26, %continue43, %continue32
  br label %continue

condition_body33:                                 ; preds = %condition_body28
  %load_LIM_H35 = load float, float* %LIM_H, align 4
  %load_p36 = load float, float* %p, align 4
  %tmpVar37 = fsub float %load_LIM_H35, %load_p36
  store float %tmpVar37, float* %i, align 4
  br label %continue32

else31:                                           ; preds = %condition_body28
  store float 0.000000e+00, float* %i, align 4
  br label %continue32

continue32:                                       ; preds = %else31, %condition_body33
  store i8 1, i8* %LIM, align 1
  br label %continue27

condition_body44:                                 ; preds = %condition_body38
  %load_LIM_L47 = load float, float* %LIM_L, align 4
  %load_p48 = load float, float* %p, align 4
  %tmpVar49 = fsub float %load_LIM_L47, %load_p48
  store float %tmpVar49, float* %i, align 4
  br label %continue43

else42:                                           ; preds = %condition_body38
  store float 0.000000e+00, float* %i, align 4
  br label %continue43

continue43:                                       ; preds = %else42, %condition_body44
  store i8 1, i8* %LIM, align 1
  br label %continue27
}

define void @FT_PT1(%FT_PT1_interface* %0) {
entry:
  %in = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %0, i32 0, i32 1
  %K = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %0, i32 0, i32 2
  %out = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %0, i32 0, i32 3
  %last = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %0, i32 0, i32 4
  %tx = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %0, i32 0, i32 5
  %init = getelementptr inbounds %FT_PT1_interface, %FT_PT1_interface* %0, i32 0, i32 6
  %T_PLC_US_instance = alloca %T_PLC_US_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_US(%T_PLC_US_interface* %T_PLC_US_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = zext i8 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %5, label %3

condition_body:                                   ; preds = %5
  store i8 1, i8* %init, align 1
  %load_K = load float, float* %K, align 4
  %load_in = load float, float* %in, align 4
  %tmpVar4 = fmul float %load_K, %load_in
  store float %tmpVar4, float* %out, align 4
  br label %continue2

else:                                             ; preds = %5
  %load_out = load float, float* %out, align 4
  %load_in5 = load float, float* %in, align 4
  %load_K6 = load float, float* %K, align 4
  %tmpVar7 = fmul float %load_in5, %load_K6
  %load_out8 = load float, float* %out, align 4
  %tmpVar9 = fsub float %tmpVar7, %load_out8
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input10

continue2:                                        ; preds = %continue26, %condition_body
  %load_tx = load i32, i32* %tx, align 4
  store i32 %load_tx, i32* %last, align 4
  ret void

3:                                                ; preds = %continue
  %load_T = load i64, i64* %T, align 4
  %tmpVar3 = icmp eq i64 %load_T, 0
  %4 = zext i1 %tmpVar3 to i32
  br label %5

5:                                                ; preds = %3, %continue
  %6 = phi i32 [ %1, %continue ], [ %4, %3 ]
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %condition_body, label %else

input10:                                          ; preds = %else
  %8 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_Tx = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar14 = sub i32 %load_Tx, %load_last
  store i32 %tmpVar14, i32* %8, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call15 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %tmpVar16 = fmul float %tmpVar9, %call15
  %TIME_TO_REAL_instance = alloca %TIME_TO_REAL_interface, align 8
  br label %input17

input17:                                          ; preds = %continue13
  %9 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance, i32 0, i32 0
  %load_T21 = load i64, i64* %T, align 4
  store i64 %load_T21, i64* %9, align 4
  br label %call18

call18:                                           ; preds = %input17
  %call22 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %tmpVar23 = fdiv float %tmpVar16, %call22
  %tmpVar24 = fmul float %tmpVar23, 0x3F50624DE0000000
  %tmpVar25 = fadd float %load_out, %tmpVar24
  store float %tmpVar25, float* %out, align 4
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input28

condition_body27:                                 ; preds = %continue31
  store float 0.000000e+00, float* %out, align 4
  br label %continue26

continue26:                                       ; preds = %condition_body27, %continue31
  br label %continue2

input28:                                          ; preds = %continue20
  %10 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_out32 = load float, float* %out, align 4
  %11 = fptoui float %load_out32 to i64
  store i64 %11, i64* %10, align 4
  br label %call29

call29:                                           ; preds = %input28
  %call33 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output30

output30:                                         ; preds = %call29
  br label %continue31

continue31:                                       ; preds = %output30
  %12 = uitofp i64 %call33 to double
  %tmpVar34 = fcmp olt double %12, 0x3BC79CA10C924223
  br i1 %tmpVar34, label %condition_body27, label %continue26
}

define void @FT_PT2(%FT_PT2_interface* %0) {
entry:
  %in = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 1
  %D = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 2
  %K = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 3
  %out = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 4
  %init = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 5
  %int1 = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 6
  %int2 = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 7
  %tn = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 8
  %I1 = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 9
  %I2 = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 10
  %tn2 = getelementptr inbounds %FT_PT2_interface, %FT_PT2_interface* %0, i32 0, i32 11
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = zext i8 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %5, label %3

condition_body:                                   ; preds = %5
  store i8 1, i8* %init, align 1
  %load_K = load float, float* %K, align 4
  %load_in = load float, float* %in, align 4
  %tmpVar2 = fmul float %load_K, %load_in
  store float %tmpVar2, float* %out, align 4
  %load_out = load float, float* %out, align 4
  store float %load_out, float* %I2, align 4
  br label %continue

else:                                             ; preds = %5
  %TIME_TO_REAL_instance = alloca %TIME_TO_REAL_interface, align 8
  br label %input

continue:                                         ; preds = %continue28, %condition_body
  ret void

3:                                                ; preds = %entry
  %load_T = load i64, i64* %T, align 4
  %tmpVar1 = icmp eq i64 %load_T, 0
  %4 = zext i1 %tmpVar1 to i32
  br label %5

5:                                                ; preds = %3, %entry
  %6 = phi i32 [ %1, %entry ], [ %4, %3 ]
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %condition_body, label %else

input:                                            ; preds = %else
  %8 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance, i32 0, i32 0
  %load_T4 = load i64, i64* %T, align 4
  store i64 %load_T4, i64* %8, align 4
  br label %call

call:                                             ; preds = %input
  %call5 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  %tmpVar6 = fmul float %call5, 0x3F50624DE0000000
  store float %tmpVar6, float* %tn, align 4
  %load_TN = load float, float* %tn, align 4
  %load_TN7 = load float, float* %tn, align 4
  %tmpVar8 = fmul float %load_TN, %load_TN7
  store float %tmpVar8, float* %tn2, align 4
  br label %input9

input9:                                           ; preds = %continue3
  %9 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %int1, i32 0, i32 1
  %load_in13 = load float, float* %in, align 4
  %load_K14 = load float, float* %K, align 4
  %tmpVar15 = fmul float %load_in13, %load_K14
  %load_tn2 = load float, float* %tn2, align 4
  %tmpVar16 = fdiv float %tmpVar15, %load_tn2
  %load_I1 = load float, float* %I1, align 4
  %tmpVar17 = fmul float %load_I1, 5.000000e-01
  %load_D = load float, float* %D, align 4
  %tmpVar18 = fmul float %tmpVar17, %load_D
  %load_TN19 = load float, float* %tn, align 4
  %tmpVar20 = fdiv float %tmpVar18, %load_TN19
  %tmpVar21 = fsub float %tmpVar16, %tmpVar20
  %load_I2 = load float, float* %I2, align 4
  %load_TN2 = load float, float* %tn2, align 4
  %tmpVar22 = fdiv float %load_I2, %load_TN2
  %tmpVar23 = fsub float %tmpVar21, %tmpVar22
  store float %tmpVar23, float* %9, align 4
  %10 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %int1, i32 0, i32 3
  %load_I124 = load float, float* %I1, align 4
  store float %load_I124, float** %10, align 4
  br label %call10

call10:                                           ; preds = %input9
  call void @INTEGRATE(%INTEGRATE_interface* %int1)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  br label %input25

input25:                                          ; preds = %continue12
  %11 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %int2, i32 0, i32 1
  %load_I129 = load float, float* %I1, align 4
  store float %load_I129, float* %11, align 4
  %12 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %int2, i32 0, i32 3
  %load_I230 = load float, float* %I2, align 4
  store float %load_I230, float** %12, align 4
  br label %call26

call26:                                           ; preds = %input25
  call void @INTEGRATE(%INTEGRATE_interface* %int2)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  %load_I231 = load float, float* %I2, align 4
  store float %load_I231, float* %out, align 4
  br label %continue
}

define void @FT_TN16(%FT_TN16_interface* %0) {
entry:
  %in = getelementptr inbounds %FT_TN16_interface, %FT_TN16_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %FT_TN16_interface, %FT_TN16_interface* %0, i32 0, i32 1
  %out = getelementptr inbounds %FT_TN16_interface, %FT_TN16_interface* %0, i32 0, i32 2
  %trig = getelementptr inbounds %FT_TN16_interface, %FT_TN16_interface* %0, i32 0, i32 3
  %length = getelementptr inbounds %FT_TN16_interface, %FT_TN16_interface* %0, i32 0, i32 4
  %X = getelementptr inbounds %FT_TN16_interface, %FT_TN16_interface* %0, i32 0, i32 5
  %cnt = getelementptr inbounds %FT_TN16_interface, %FT_TN16_interface* %0, i32 0, i32 6
  %last = getelementptr inbounds %FT_TN16_interface, %FT_TN16_interface* %0, i32 0, i32 7
  %tx = getelementptr inbounds %FT_TN16_interface, %FT_TN16_interface* %0, i32 0, i32 8
  %init = getelementptr inbounds %FT_TN16_interface, %FT_TN16_interface* %0, i32 0, i32 9
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  store i8 0, i8* %trig, align 1
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar, 0
  br i1 %2, label %condition_body, label %branch

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  %load_cnt = load i16, i16* %cnt, align 2
  %3 = sext i16 %load_cnt to i32
  %tmpVar8 = mul i32 1, %3
  %tmpVar9 = add i32 %tmpVar8, 0
  %tmpVar10 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar9
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %tmpVar10, align 4
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  br label %continue7

branch:                                           ; preds = %continue
  %load_tx12 = load i64, i64* %tx, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar13 = sub i64 %load_tx12, %load_last
  %load_T = load i64, i64* %T, align 4
  %load_length = load i16, i16* %length, align 2
  %4 = sext i16 %load_length to i64
  %tmpVar14 = sdiv i64 %load_T, %4
  %tmpVar15 = icmp sge i64 %tmpVar13, %tmpVar14
  br i1 %tmpVar15, label %condition_body11, label %continue7

condition_body11:                                 ; preds = %branch
  %load_cnt18 = load i16, i16* %cnt, align 2
  %5 = sext i16 %load_cnt18 to i32
  %load_length19 = load i16, i16* %length, align 2
  %6 = sext i16 %load_length19 to i32
  %tmpVar20 = sub i32 %6, 1
  %tmpVar21 = icmp eq i32 %5, %tmpVar20
  br i1 %tmpVar21, label %condition_body17, label %else

continue7:                                        ; preds = %continue16, %branch, %condition_body
  ret void

condition_body17:                                 ; preds = %condition_body11
  store i16 0, i16* %cnt, align 2
  br label %continue16

else:                                             ; preds = %condition_body11
  %load_cnt22 = load i16, i16* %cnt, align 2
  %7 = sext i16 %load_cnt22 to i32
  %tmpVar23 = add i32 %7, 1
  %8 = trunc i32 %tmpVar23 to i16
  store i16 %8, i16* %cnt, align 2
  br label %continue16

continue16:                                       ; preds = %else, %condition_body17
  %load_cnt24 = load i16, i16* %cnt, align 2
  %9 = sext i16 %load_cnt24 to i32
  %tmpVar25 = mul i32 1, %9
  %tmpVar26 = add i32 %tmpVar25, 0
  %tmpVar27 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar26
  %load_tmpVar = load float, float* %tmpVar27, align 4
  store float %load_tmpVar, float* %out, align 4
  %load_cnt28 = load i16, i16* %cnt, align 2
  %10 = sext i16 %load_cnt28 to i32
  %tmpVar29 = mul i32 1, %10
  %tmpVar30 = add i32 %tmpVar29, 0
  %tmpVar31 = getelementptr inbounds [16 x float], [16 x float]* %X, i32 0, i32 %tmpVar30
  %load_in32 = load float, float* %in, align 4
  store float %load_in32, float* %tmpVar31, align 4
  %load_tx33 = load i64, i64* %tx, align 4
  store i64 %load_tx33, i64* %last, align 4
  store i8 1, i8* %trig, align 1
  br label %continue7
}

define void @FT_TN64(%FT_TN64_interface* %0) {
entry:
  %in = getelementptr inbounds %FT_TN64_interface, %FT_TN64_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %FT_TN64_interface, %FT_TN64_interface* %0, i32 0, i32 1
  %out = getelementptr inbounds %FT_TN64_interface, %FT_TN64_interface* %0, i32 0, i32 2
  %trig = getelementptr inbounds %FT_TN64_interface, %FT_TN64_interface* %0, i32 0, i32 3
  %length = getelementptr inbounds %FT_TN64_interface, %FT_TN64_interface* %0, i32 0, i32 4
  %X = getelementptr inbounds %FT_TN64_interface, %FT_TN64_interface* %0, i32 0, i32 5
  %cnt = getelementptr inbounds %FT_TN64_interface, %FT_TN64_interface* %0, i32 0, i32 6
  %last = getelementptr inbounds %FT_TN64_interface, %FT_TN64_interface* %0, i32 0, i32 7
  %tx = getelementptr inbounds %FT_TN64_interface, %FT_TN64_interface* %0, i32 0, i32 8
  %init = getelementptr inbounds %FT_TN64_interface, %FT_TN64_interface* %0, i32 0, i32 9
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  store i8 0, i8* %trig, align 1
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar, 0
  br i1 %2, label %condition_body, label %branch

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  %load_cnt = load i16, i16* %cnt, align 2
  %3 = sext i16 %load_cnt to i32
  %tmpVar8 = mul i32 1, %3
  %tmpVar9 = add i32 %tmpVar8, 0
  %tmpVar10 = getelementptr inbounds [64 x float], [64 x float]* %X, i32 0, i32 %tmpVar9
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %tmpVar10, align 4
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  br label %continue7

branch:                                           ; preds = %continue
  %load_tx12 = load i64, i64* %tx, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar13 = sub i64 %load_tx12, %load_last
  %load_T = load i64, i64* %T, align 4
  %load_length = load i16, i16* %length, align 2
  %4 = sext i16 %load_length to i64
  %tmpVar14 = sdiv i64 %load_T, %4
  %tmpVar15 = icmp sge i64 %tmpVar13, %tmpVar14
  br i1 %tmpVar15, label %condition_body11, label %continue7

condition_body11:                                 ; preds = %branch
  %load_cnt18 = load i16, i16* %cnt, align 2
  %5 = sext i16 %load_cnt18 to i32
  %load_length19 = load i16, i16* %length, align 2
  %6 = sext i16 %load_length19 to i32
  %tmpVar20 = sub i32 %6, 1
  %tmpVar21 = icmp eq i32 %5, %tmpVar20
  br i1 %tmpVar21, label %condition_body17, label %else

continue7:                                        ; preds = %continue16, %branch, %condition_body
  ret void

condition_body17:                                 ; preds = %condition_body11
  store i16 0, i16* %cnt, align 2
  br label %continue16

else:                                             ; preds = %condition_body11
  %load_cnt22 = load i16, i16* %cnt, align 2
  %7 = sext i16 %load_cnt22 to i32
  %tmpVar23 = add i32 %7, 1
  %8 = trunc i32 %tmpVar23 to i16
  store i16 %8, i16* %cnt, align 2
  br label %continue16

continue16:                                       ; preds = %else, %condition_body17
  %load_cnt24 = load i16, i16* %cnt, align 2
  %9 = sext i16 %load_cnt24 to i32
  %tmpVar25 = mul i32 1, %9
  %tmpVar26 = add i32 %tmpVar25, 0
  %tmpVar27 = getelementptr inbounds [64 x float], [64 x float]* %X, i32 0, i32 %tmpVar26
  %load_tmpVar = load float, float* %tmpVar27, align 4
  store float %load_tmpVar, float* %out, align 4
  %load_cnt28 = load i16, i16* %cnt, align 2
  %10 = sext i16 %load_cnt28 to i32
  %tmpVar29 = mul i32 1, %10
  %tmpVar30 = add i32 %tmpVar29, 0
  %tmpVar31 = getelementptr inbounds [64 x float], [64 x float]* %X, i32 0, i32 %tmpVar30
  %load_in32 = load float, float* %in, align 4
  store float %load_in32, float* %tmpVar31, align 4
  %load_tx33 = load i64, i64* %tx, align 4
  store i64 %load_tx33, i64* %last, align 4
  store i8 1, i8* %trig, align 1
  br label %continue7
}

define void @FT_TN8(%FT_TN8_interface* %0) {
entry:
  %in = getelementptr inbounds %FT_TN8_interface, %FT_TN8_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %FT_TN8_interface, %FT_TN8_interface* %0, i32 0, i32 1
  %out = getelementptr inbounds %FT_TN8_interface, %FT_TN8_interface* %0, i32 0, i32 2
  %trig = getelementptr inbounds %FT_TN8_interface, %FT_TN8_interface* %0, i32 0, i32 3
  %length = getelementptr inbounds %FT_TN8_interface, %FT_TN8_interface* %0, i32 0, i32 4
  %X = getelementptr inbounds %FT_TN8_interface, %FT_TN8_interface* %0, i32 0, i32 5
  %cnt = getelementptr inbounds %FT_TN8_interface, %FT_TN8_interface* %0, i32 0, i32 6
  %last = getelementptr inbounds %FT_TN8_interface, %FT_TN8_interface* %0, i32 0, i32 7
  %tx = getelementptr inbounds %FT_TN8_interface, %FT_TN8_interface* %0, i32 0, i32 8
  %init = getelementptr inbounds %FT_TN8_interface, %FT_TN8_interface* %0, i32 0, i32 9
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  store i8 0, i8* %trig, align 1
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar, 0
  br i1 %2, label %condition_body, label %branch

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  %load_cnt = load i16, i16* %cnt, align 2
  %3 = sext i16 %load_cnt to i32
  %tmpVar8 = mul i32 1, %3
  %tmpVar9 = add i32 %tmpVar8, 0
  %tmpVar10 = getelementptr inbounds [8 x float], [8 x float]* %X, i32 0, i32 %tmpVar9
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %tmpVar10, align 4
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  br label %continue7

branch:                                           ; preds = %continue
  %load_tx12 = load i64, i64* %tx, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar13 = sub i64 %load_tx12, %load_last
  %load_T = load i64, i64* %T, align 4
  %load_length = load i16, i16* %length, align 2
  %4 = sext i16 %load_length to i64
  %tmpVar14 = sdiv i64 %load_T, %4
  %tmpVar15 = icmp sge i64 %tmpVar13, %tmpVar14
  br i1 %tmpVar15, label %condition_body11, label %continue7

condition_body11:                                 ; preds = %branch
  %load_cnt18 = load i16, i16* %cnt, align 2
  %5 = sext i16 %load_cnt18 to i32
  %load_length19 = load i16, i16* %length, align 2
  %6 = sext i16 %load_length19 to i32
  %tmpVar20 = sub i32 %6, 1
  %tmpVar21 = icmp eq i32 %5, %tmpVar20
  br i1 %tmpVar21, label %condition_body17, label %else

continue7:                                        ; preds = %continue16, %branch, %condition_body
  ret void

condition_body17:                                 ; preds = %condition_body11
  store i16 0, i16* %cnt, align 2
  br label %continue16

else:                                             ; preds = %condition_body11
  %load_cnt22 = load i16, i16* %cnt, align 2
  %7 = sext i16 %load_cnt22 to i32
  %tmpVar23 = add i32 %7, 1
  %8 = trunc i32 %tmpVar23 to i16
  store i16 %8, i16* %cnt, align 2
  br label %continue16

continue16:                                       ; preds = %else, %condition_body17
  %load_cnt24 = load i16, i16* %cnt, align 2
  %9 = sext i16 %load_cnt24 to i32
  %tmpVar25 = mul i32 1, %9
  %tmpVar26 = add i32 %tmpVar25, 0
  %tmpVar27 = getelementptr inbounds [8 x float], [8 x float]* %X, i32 0, i32 %tmpVar26
  %load_tmpVar = load float, float* %tmpVar27, align 4
  store float %load_tmpVar, float* %out, align 4
  %load_cnt28 = load i16, i16* %cnt, align 2
  %10 = sext i16 %load_cnt28 to i32
  %tmpVar29 = mul i32 1, %10
  %tmpVar30 = add i32 %tmpVar29, 0
  %tmpVar31 = getelementptr inbounds [8 x float], [8 x float]* %X, i32 0, i32 %tmpVar30
  %load_in32 = load float, float* %in, align 4
  store float %load_in32, float* %tmpVar31, align 4
  %load_tx33 = load i64, i64* %tx, align 4
  store i64 %load_tx33, i64* %last, align 4
  store i8 1, i8* %trig, align 1
  br label %continue7
}

define void @HYST(%HYST_interface* %0) {
entry:
  %In = getelementptr inbounds %HYST_interface, %HYST_interface* %0, i32 0, i32 0
  %ON = getelementptr inbounds %HYST_interface, %HYST_interface* %0, i32 0, i32 1
  %OFF = getelementptr inbounds %HYST_interface, %HYST_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %HYST_interface, %HYST_interface* %0, i32 0, i32 3
  %win = getelementptr inbounds %HYST_interface, %HYST_interface* %0, i32 0, i32 4
  %load_ON = load float, float* %ON, align 4
  %load_OFF = load float, float* %OFF, align 4
  %tmpVar = fcmp oge float %load_ON, %load_OFF
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_IN = load float, float* %In, align 4
  %load_OFF4 = load float, float* %OFF, align 4
  %tmpVar5 = fcmp olt float %load_IN, %load_OFF4
  br i1 %tmpVar5, label %condition_body3, label %branch

else:                                             ; preds = %entry
  %load_IN14 = load float, float* %In, align 4
  %load_OFF15 = load float, float* %OFF, align 4
  %tmpVar16 = fcmp ogt float %load_IN14, %load_OFF15
  br i1 %tmpVar16, label %condition_body13, label %branch10

continue:                                         ; preds = %continue12, %continue2
  ret void

condition_body3:                                  ; preds = %condition_body
  store i8 0, i8* %Q, align 1
  store i8 0, i8* %win, align 1
  br label %continue2

branch:                                           ; preds = %condition_body
  %load_IN7 = load float, float* %In, align 4
  %load_ON8 = load float, float* %ON, align 4
  %tmpVar9 = fcmp ogt float %load_IN7, %load_ON8
  br i1 %tmpVar9, label %condition_body6, label %else1

condition_body6:                                  ; preds = %branch
  store i8 1, i8* %Q, align 1
  store i8 0, i8* %win, align 1
  br label %continue2

else1:                                            ; preds = %branch
  store i8 1, i8* %win, align 1
  br label %continue2

continue2:                                        ; preds = %else1, %condition_body6, %condition_body3
  br label %continue

condition_body13:                                 ; preds = %else
  store i8 0, i8* %Q, align 1
  store i8 0, i8* %win, align 1
  br label %continue12

branch10:                                         ; preds = %else
  %load_IN18 = load float, float* %In, align 4
  %load_ON19 = load float, float* %ON, align 4
  %tmpVar20 = fcmp olt float %load_IN18, %load_ON19
  br i1 %tmpVar20, label %condition_body17, label %else11

condition_body17:                                 ; preds = %branch10
  store i8 1, i8* %Q, align 1
  store i8 0, i8* %win, align 1
  br label %continue12

else11:                                           ; preds = %branch10
  store i8 1, i8* %win, align 1
  br label %continue12

continue12:                                       ; preds = %else11, %condition_body17, %condition_body13
  br label %continue
}

define void @HYST_1(%HYST_1_interface* %0) {
entry:
  %In = getelementptr inbounds %HYST_1_interface, %HYST_1_interface* %0, i32 0, i32 0
  %high = getelementptr inbounds %HYST_1_interface, %HYST_1_interface* %0, i32 0, i32 1
  %low = getelementptr inbounds %HYST_1_interface, %HYST_1_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %HYST_1_interface, %HYST_1_interface* %0, i32 0, i32 3
  %win = getelementptr inbounds %HYST_1_interface, %HYST_1_interface* %0, i32 0, i32 4
  %load_in = load float, float* %In, align 4
  %load_low = load float, float* %low, align 4
  %tmpVar = fcmp olt float %load_in, %load_low
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q, align 1
  store i8 0, i8* %win, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_in2 = load float, float* %In, align 4
  %load_high = load float, float* %high, align 4
  %tmpVar3 = fcmp ogt float %load_in2, %load_high
  br i1 %tmpVar3, label %condition_body1, label %else

condition_body1:                                  ; preds = %branch
  store i8 1, i8* %Q, align 1
  store i8 0, i8* %win, align 1
  br label %continue

else:                                             ; preds = %branch
  store i8 1, i8* %win, align 1
  br label %continue

continue:                                         ; preds = %else, %condition_body1, %condition_body
  ret void
}

define void @HYST_2(%HYST_2_interface* %0) {
entry:
  %IN = getelementptr inbounds %HYST_2_interface, %HYST_2_interface* %0, i32 0, i32 0
  %VAL = getelementptr inbounds %HYST_2_interface, %HYST_2_interface* %0, i32 0, i32 1
  %HYS = getelementptr inbounds %HYST_2_interface, %HYST_2_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %HYST_2_interface, %HYST_2_interface* %0, i32 0, i32 3
  %WIN = getelementptr inbounds %HYST_2_interface, %HYST_2_interface* %0, i32 0, i32 4
  %tmp = getelementptr inbounds %HYST_2_interface, %HYST_2_interface* %0, i32 0, i32 5
  %load_val = load float, float* %VAL, align 4
  %load_hys = load float, float* %HYS, align 4
  %tmpVar = fmul float %load_hys, 5.000000e-01
  %tmpVar1 = fsub float %load_val, %tmpVar
  store float %tmpVar1, float* %tmp, align 4
  %load_in = load float, float* %IN, align 4
  %load_tmp = load float, float* %tmp, align 4
  %tmpVar2 = fcmp olt float %load_in, %load_tmp
  br i1 %tmpVar2, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q, align 1
  store i8 0, i8* %WIN, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_in4 = load float, float* %IN, align 4
  %load_tmp5 = load float, float* %tmp, align 4
  %load_hys6 = load float, float* %HYS, align 4
  %tmpVar7 = fadd float %load_tmp5, %load_hys6
  %tmpVar8 = fcmp ogt float %load_in4, %tmpVar7
  br i1 %tmpVar8, label %condition_body3, label %else

condition_body3:                                  ; preds = %branch
  store i8 1, i8* %Q, align 1
  store i8 0, i8* %WIN, align 1
  br label %continue

else:                                             ; preds = %branch
  store i8 1, i8* %WIN, align 1
  br label %continue

continue:                                         ; preds = %else, %condition_body3, %condition_body
  ret void
}

define void @HYST_3(%HYST_3_interface* %0) {
entry:
  %in = getelementptr inbounds %HYST_3_interface, %HYST_3_interface* %0, i32 0, i32 0
  %hyst = getelementptr inbounds %HYST_3_interface, %HYST_3_interface* %0, i32 0, i32 1
  %val1 = getelementptr inbounds %HYST_3_interface, %HYST_3_interface* %0, i32 0, i32 2
  %val2 = getelementptr inbounds %HYST_3_interface, %HYST_3_interface* %0, i32 0, i32 3
  %Q1 = getelementptr inbounds %HYST_3_interface, %HYST_3_interface* %0, i32 0, i32 4
  %Q2 = getelementptr inbounds %HYST_3_interface, %HYST_3_interface* %0, i32 0, i32 5
  %X = getelementptr inbounds %HYST_3_interface, %HYST_3_interface* %0, i32 0, i32 6
  %load_hyst = load float, float* %hyst, align 4
  %tmpVar = fmul float %load_hyst, 5.000000e-01
  store float %tmpVar, float* %X, align 4
  %load_in = load float, float* %in, align 4
  %load_val1 = load float, float* %val1, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar1 = fsub float %load_val1, %load_X
  %tmpVar2 = fcmp olt float %load_in, %tmpVar1
  br i1 %tmpVar2, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 1, i8* %Q1, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_in4 = load float, float* %in, align 4
  %load_val15 = load float, float* %val1, align 4
  %load_X6 = load float, float* %X, align 4
  %tmpVar7 = fadd float %load_val15, %load_X6
  %tmpVar8 = fcmp ogt float %load_in4, %tmpVar7
  br i1 %tmpVar8, label %condition_body3, label %continue

condition_body3:                                  ; preds = %branch
  store i8 0, i8* %Q1, align 1
  br label %continue

continue:                                         ; preds = %condition_body3, %branch, %condition_body
  %load_in12 = load float, float* %in, align 4
  %load_val2 = load float, float* %val2, align 4
  %load_X13 = load float, float* %X, align 4
  %tmpVar14 = fsub float %load_val2, %load_X13
  %tmpVar15 = fcmp olt float %load_in12, %tmpVar14
  br i1 %tmpVar15, label %condition_body11, label %branch9

condition_body11:                                 ; preds = %continue
  store i8 0, i8* %Q2, align 1
  br label %continue10

branch9:                                          ; preds = %continue
  %load_in17 = load float, float* %in, align 4
  %load_val218 = load float, float* %val2, align 4
  %load_X19 = load float, float* %X, align 4
  %tmpVar20 = fadd float %load_val218, %load_X19
  %tmpVar21 = fcmp ogt float %load_in17, %tmpVar20
  br i1 %tmpVar21, label %condition_body16, label %continue10

condition_body16:                                 ; preds = %branch9
  store i8 1, i8* %Q2, align 1
  br label %continue10

continue10:                                       ; preds = %condition_body16, %branch9, %condition_body11
  ret void
}

define void @INTEGRATE(%INTEGRATE_interface* %0) {
entry:
  %E = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %0, i32 0, i32 0
  %X = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %0, i32 0, i32 1
  %K = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %0, i32 0, i32 2
  %Y = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %0, i32 0, i32 3
  %X_last = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %0, i32 0, i32 4
  %init = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %0, i32 0, i32 5
  %last = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %0, i32 0, i32 6
  %tx = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %0, i32 0, i32 7
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %X_last, align 4
  br label %continue2

branch:                                           ; preds = %continue
  %load_E = load i8, i8* %E, align 1
  %2 = icmp ne i8 %load_E, 0
  br i1 %2, label %condition_body3, label %continue2

condition_body3:                                  ; preds = %branch
  %deref = load float*, float** %Y, align 8
  %load_X4 = load float, float* %X, align 4
  %load_X_LAST = load float, float* %X_last, align 4
  %tmpVar5 = fadd float %load_X4, %load_X_LAST
  %tmpVar6 = fmul float %tmpVar5, 0x3F40624DE0000000
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input7

continue2:                                        ; preds = %continue10, %branch, %condition_body
  %load_tx18 = load i32, i32* %tx, align 4
  store i32 %load_tx18, i32* %last, align 4
  ret void

input7:                                           ; preds = %condition_body3
  %3 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_tx = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar11 = sub i32 %load_tx, %load_last
  store i32 %tmpVar11, i32* %3, align 4
  br label %call8

call8:                                            ; preds = %input7
  %call12 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %tmpVar13 = fmul float %tmpVar6, %call12
  %load_K = load float, float* %K, align 4
  %tmpVar14 = fmul float %tmpVar13, %load_K
  %deref15 = load float*, float** %Y, align 8
  %load_Y = load float, float* %deref15, align 4
  %tmpVar16 = fadd float %tmpVar14, %load_Y
  store float %tmpVar16, float* %deref, align 4
  %load_X17 = load float, float* %X, align 4
  store float %load_X17, float* %X_last, align 4
  br label %continue2
}

define void @ASTRO(%ASTRO_interface* %0) {
entry:
  %m = getelementptr inbounds %ASTRO_interface, %ASTRO_interface* %0, i32 0, i32 0
  %AE = getelementptr inbounds %ASTRO_interface, %ASTRO_interface* %0, i32 0, i32 1
  %PC = getelementptr inbounds %ASTRO_interface, %ASTRO_interface* %0, i32 0, i32 2
  %LJ = getelementptr inbounds %ASTRO_interface, %ASTRO_interface* %0, i32 0, i32 3
  %Ym = getelementptr inbounds %ASTRO_interface, %ASTRO_interface* %0, i32 0, i32 4
  %YAE = getelementptr inbounds %ASTRO_interface, %ASTRO_interface* %0, i32 0, i32 5
  %YPC = getelementptr inbounds %ASTRO_interface, %ASTRO_interface* %0, i32 0, i32 6
  %YLJ = getelementptr inbounds %ASTRO_interface, %ASTRO_interface* %0, i32 0, i32 7
  %load_AE = load float, float* %AE, align 4
  %load_m = load float, float* %m, align 4
  %tmpVar = fmul float %load_m, 0x3D9D662D20000000
  %tmpVar1 = fadd float %load_AE, %tmpVar
  %load_PC = load float, float* %PC, align 4
  %tmpVar2 = fmul float %load_PC, 2.062650e+05
  %tmpVar3 = fadd float %tmpVar1, %tmpVar2
  %load_LJ = load float, float* %LJ, align 4
  %tmpVar4 = fmul float %load_LJ, 6.324000e+04
  %tmpVar5 = fadd float %tmpVar3, %tmpVar4
  store float %tmpVar5, float* %YAE, align 4
  %load_YAE = load float, float* %YAE, align 4
  %tmpVar6 = fmul float %load_YAE, 0x42416A5D20000000
  store float %tmpVar6, float* %Ym, align 4
  %load_YAE7 = load float, float* %YAE, align 4
  %tmpVar8 = fmul float %load_YAE7, 0x3ED455A480000000
  store float %tmpVar8, float* %YPC, align 4
  %load_YAE9 = load float, float* %YAE, align 4
  %tmpVar10 = fmul float %load_YAE9, 0x3EF094B5C0000000
  store float %tmpVar10, float* %YLJ, align 4
  ret void
}

define float @BFT_TO_MS(%BFT_TO_MS_interface* %0) {
entry:
  %BFT = getelementptr inbounds %BFT_TO_MS_interface, %BFT_TO_MS_interface* %0, i32 0, i32 0
  %BFT_TO_MS = alloca float, align 4
  store float 0.000000e+00, float* %BFT_TO_MS, align 4
  %EXPT_instance = alloca %EXPT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %EXPT_interface, %EXPT_interface* %EXPT_instance, i32 0, i32 0
  %load_BFT = load i16, i16* %BFT, align 2
  %2 = sext i16 %load_BFT to i32
  store i32 %2, i32* %1, align 4
  %3 = getelementptr inbounds %EXPT_interface, %EXPT_interface* %EXPT_instance, i32 0, i32 1
  store i32 1, i32* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call double @EXPT(%EXPT_interface* %EXPT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = fmul double %call1, 8.360000e-01
  %4 = fptrunc double %tmpVar to float
  store float %4, float* %BFT_TO_MS, align 4
  %BFT_TO_MS_ret = load float, float* %BFT_TO_MS, align 4
  ret float %BFT_TO_MS_ret
}

define float @C_TO_F(%C_TO_F_interface* %0) {
entry:
  %celsius = getelementptr inbounds %C_TO_F_interface, %C_TO_F_interface* %0, i32 0, i32 0
  %C_TO_F = alloca float, align 4
  store float 0.000000e+00, float* %C_TO_F, align 4
  %load_celsius = load float, float* %celsius, align 4
  %tmpVar = fmul float %load_celsius, 0x3FFCCCCCC0000000
  %tmpVar1 = fadd float %tmpVar, 3.200000e+01
  store float %tmpVar1, float* %C_TO_F, align 4
  %C_TO_F_ret = load float, float* %C_TO_F, align 4
  ret float %C_TO_F_ret
}

define float @C_TO_K(%C_TO_K_interface* %0) {
entry:
  %Celsius = getelementptr inbounds %C_TO_K_interface, %C_TO_K_interface* %0, i32 0, i32 0
  %C_TO_K = alloca float, align 4
  store float 0.000000e+00, float* %C_TO_K, align 4
  %load_Celsius = load float, float* %Celsius, align 4
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_PHYS, %CONSTANTS_PHYS* @PHYS, i32 0, i32 3), align 4
  %tmpVar = fsub float %load_Celsius, %load_
  store float %tmpVar, float* %C_TO_K, align 4
  %C_TO_K_ret = load float, float* %C_TO_K, align 4
  ret float %C_TO_K_ret
}

define [4 x i8] @DEG_TO_DIR(%DEG_TO_DIR_interface* %0) {
entry:
  %DEG = getelementptr inbounds %DEG_TO_DIR_interface, %DEG_TO_DIR_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %DEG_TO_DIR_interface, %DEG_TO_DIR_interface* %0, i32 0, i32 1
  %L = getelementptr inbounds %DEG_TO_DIR_interface, %DEG_TO_DIR_interface* %0, i32 0, i32 2
  %ly = getelementptr inbounds %DEG_TO_DIR_interface, %DEG_TO_DIR_interface* %0, i32 0, i32 3
  %DEG_TO_DIR = alloca [4 x i8], align 1
  store i16 0, i16* %ly, align 2
  %1 = bitcast [4 x i8]* %DEG_TO_DIR to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 4), i1 false)
  %load_L = load i16, i16* %L, align 2
  %2 = sext i16 %load_L to i32
  %tmpVar = icmp eq i32 %2, 0
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_ = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 0), align 2
  store i16 %load_, i16* %ly, align 2
  br label %continue

else:                                             ; preds = %entry
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %condition_body
  %load_ly = load i16, i16* %ly, align 2
  %3 = sub i16 %load_ly, 1
  %4 = sext i16 %3 to i32
  %tmpVar5 = mul i32 16, %4
  %tmpVar6 = add i32 %tmpVar5, 0
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input7

input:                                            ; preds = %else
  %5 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_L2 = load i16, i16* %L, align 2
  %6 = sext i16 %load_L2 to i64
  store i64 %6, i64* %5, align 4
  %7 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_3 = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 1), align 2
  %8 = sext i16 %load_3 to i64
  store i64 %8, i64* %7, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %9 = trunc i64 %call4 to i16
  store i16 %9, i16* %ly, align 2
  br label %continue

input7:                                           ; preds = %continue
  %10 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_DEG = load i16, i16* %DEG, align 2
  %11 = sext i16 %load_DEG to i64
  store i64 %11, i64* %10, align 4
  %12 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %13 = sext i16 %load_N to i32
  %tmpVar11 = sub i32 %13, 1
  %14 = trunc i32 %tmpVar11 to i16
  store i16 %14, i16* %12, align 2
  br label %call8

call8:                                            ; preds = %input7
  %call12 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %tmpVar13 = add i64 %call12, 45
  %tmpVar14 = sdiv i64 %tmpVar13, 90
  %SHL_instance15 = alloca %SHL_interface, align 8
  br label %input16

input16:                                          ; preds = %continue10
  %15 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance15, i32 0, i32 0
  store i64 2, i64* %15, align 4
  %16 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance15, i32 0, i32 1
  %load_N20 = load i16, i16* %N, align 2
  store i16 %load_N20, i16* %16, align 2
  br label %call17

call17:                                           ; preds = %input16
  %call21 = call i64 @SHL(%SHL_interface* %SHL_instance15)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %tmpVar22 = srem i64 %tmpVar14, %call21
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input23

input23:                                          ; preds = %continue19
  %17 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  store i64 8, i64* %17, align 4
  %18 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %load_N27 = load i16, i16* %N, align 2
  store i16 %load_N27, i16* %18, align 2
  br label %call24

call24:                                           ; preds = %input23
  %call28 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %tmpVar29 = mul i64 %tmpVar22, %call28
  %19 = trunc i64 %tmpVar29 to i32
  %tmpVar30 = mul i32 1, %19
  %tmpVar31 = add i32 %tmpVar30, %tmpVar6
  %tmpVar32 = getelementptr inbounds [48 x [4 x i8]], [48 x [4 x i8]]* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 6), i32 0, i32 %tmpVar31
  %20 = bitcast [4 x i8]* %DEG_TO_DIR to i8*
  %21 = bitcast [4 x i8]* %tmpVar32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 3, i1 false)
  %DEG_TO_DIR_ret = load [4 x i8], [4 x i8]* %DEG_TO_DIR, align 1
  ret [4 x i8] %DEG_TO_DIR_ret
}

declare i16 @DIR_TO_DEG(%DIR_TO_DEG_interface*)

define void @ENERGY(%ENERGY_interface* %0) {
entry:
  %J = getelementptr inbounds %ENERGY_interface, %ENERGY_interface* %0, i32 0, i32 0
  %C = getelementptr inbounds %ENERGY_interface, %ENERGY_interface* %0, i32 0, i32 1
  %Wh = getelementptr inbounds %ENERGY_interface, %ENERGY_interface* %0, i32 0, i32 2
  %YJ = getelementptr inbounds %ENERGY_interface, %ENERGY_interface* %0, i32 0, i32 3
  %YC = getelementptr inbounds %ENERGY_interface, %ENERGY_interface* %0, i32 0, i32 4
  %YWh = getelementptr inbounds %ENERGY_interface, %ENERGY_interface* %0, i32 0, i32 5
  %load_J = load float, float* %J, align 4
  %load_Wh = load float, float* %Wh, align 4
  %tmpVar = fmul float %load_Wh, 3.600000e+03
  %tmpVar1 = fadd float %load_J, %tmpVar
  %load_C = load float, float* %C, align 4
  %tmpVar2 = fmul float %load_C, 0x4010BF4880000000
  %tmpVar3 = fadd float %tmpVar1, %tmpVar2
  store float %tmpVar3, float* %YJ, align 4
  %load_YJ = load float, float* %YJ, align 4
  %tmpVar4 = fmul float %load_YJ, 0x3FCE9280A0000000
  store float %tmpVar4, float* %YC, align 4
  %load_YJ5 = load float, float* %YJ, align 4
  %tmpVar6 = fmul float %load_YJ5, 0x3F32345680000000
  store float %tmpVar6, float* %YWh, align 4
  ret void
}

define float @F_TO_C(%F_TO_C_interface* %0) {
entry:
  %fahrenheit = getelementptr inbounds %F_TO_C_interface, %F_TO_C_interface* %0, i32 0, i32 0
  %F_TO_C = alloca float, align 4
  store float 0.000000e+00, float* %F_TO_C, align 4
  %load_fahrenheit = load float, float* %fahrenheit, align 4
  %tmpVar = fsub float %load_fahrenheit, 3.200000e+01
  %tmpVar1 = fmul float %tmpVar, 0x3FE1C71C80000000
  store float %tmpVar1, float* %F_TO_C, align 4
  %F_TO_C_ret = load float, float* %F_TO_C, align 4
  ret float %F_TO_C_ret
}

define float @F_TO_OM(%F_TO_OM_interface* %0) {
entry:
  %F = getelementptr inbounds %F_TO_OM_interface, %F_TO_OM_interface* %0, i32 0, i32 0
  %F_TO_OM = alloca float, align 4
  store float 0.000000e+00, float* %F_TO_OM, align 4
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 1), align 4
  %load_F = load float, float* %F, align 4
  %tmpVar = fmul float %load_, %load_F
  store float %tmpVar, float* %F_TO_OM, align 4
  %F_TO_OM_ret = load float, float* %F_TO_OM, align 4
  ret float %F_TO_OM_ret
}

define i64 @F_TO_PT(%F_TO_PT_interface* %0) {
entry:
  %F = getelementptr inbounds %F_TO_PT_interface, %F_TO_PT_interface* %0, i32 0, i32 0
  %F_TO_PT = alloca i64, align 8
  store i64 0, i64* %F_TO_PT, align 4
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call7 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call7, i64* %F_TO_PT, align 4
  %F_TO_PT_ret = load i64, i64* %F_TO_PT, align 4
  ret i64 %F_TO_PT_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %load_F = load float, float* %F, align 4
  %tmpVar = fdiv float 1.000000e+00, %load_F
  %tmpVar5 = fmul float %tmpVar, 1.000000e+03
  store float %tmpVar5, float* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call6 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call6, i32* %1, align 4
  br label %call
}

define float @GEO_TO_DEG(%GEO_TO_DEG_interface* %0) {
entry:
  %D = getelementptr inbounds %GEO_TO_DEG_interface, %GEO_TO_DEG_interface* %0, i32 0, i32 0
  %M = getelementptr inbounds %GEO_TO_DEG_interface, %GEO_TO_DEG_interface* %0, i32 0, i32 1
  %SEC = getelementptr inbounds %GEO_TO_DEG_interface, %GEO_TO_DEG_interface* %0, i32 0, i32 2
  %GEO_TO_DEG = alloca float, align 4
  store float 0.000000e+00, float* %GEO_TO_DEG, align 4
  %INT_TO_REAL_instance = alloca %INT_TO_REAL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %INT_TO_REAL_interface, %INT_TO_REAL_interface* %INT_TO_REAL_instance, i32 0, i32 0
  %load_D = load i16, i16* %D, align 2
  store i16 %load_D, i16* %1, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call float @INT_TO_REAL(%INT_TO_REAL_interface* %INT_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %INT_TO_REAL_instance2 = alloca %INT_TO_REAL_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %2 = getelementptr inbounds %INT_TO_REAL_interface, %INT_TO_REAL_interface* %INT_TO_REAL_instance2, i32 0, i32 0
  %load_M = load i16, i16* %M, align 2
  store i16 %load_M, i16* %2, align 2
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call float @INT_TO_REAL(%INT_TO_REAL_interface* %INT_TO_REAL_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %tmpVar = fmul float %call7, 0x3F91111120000000
  %tmpVar8 = fadd float %call1, %tmpVar
  %load_sec = load float, float* %SEC, align 4
  %tmpVar9 = fmul float %load_sec, 0x3F32345680000000
  %tmpVar10 = fadd float %tmpVar8, %tmpVar9
  store float %tmpVar10, float* %GEO_TO_DEG, align 4
  %GEO_TO_DEG_ret = load float, float* %GEO_TO_DEG, align 4
  ret float %GEO_TO_DEG_ret
}

define float @K_TO_C(%K_TO_C_interface* %0) {
entry:
  %Kelvin = getelementptr inbounds %K_TO_C_interface, %K_TO_C_interface* %0, i32 0, i32 0
  %K_TO_C = alloca float, align 4
  store float 0.000000e+00, float* %K_TO_C, align 4
  %load_Kelvin = load float, float* %Kelvin, align 4
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_PHYS, %CONSTANTS_PHYS* @PHYS, i32 0, i32 3), align 4
  %tmpVar = fadd float %load_Kelvin, %load_
  store float %tmpVar, float* %K_TO_C, align 4
  %K_TO_C_ret = load float, float* %K_TO_C, align 4
  ret float %K_TO_C_ret
}

define float @KMH_TO_MS(%KMH_TO_MS_interface* %0) {
entry:
  %kmh = getelementptr inbounds %KMH_TO_MS_interface, %KMH_TO_MS_interface* %0, i32 0, i32 0
  %KMH_TO_MS = alloca float, align 4
  store float 0.000000e+00, float* %KMH_TO_MS, align 4
  %load_kmh = load float, float* %kmh, align 4
  %tmpVar = fmul float %load_kmh, 0x3FD1C71C80000000
  store float %tmpVar, float* %KMH_TO_MS, align 4
  %KMH_TO_MS_ret = load float, float* %KMH_TO_MS, align 4
  ret float %KMH_TO_MS_ret
}

define void @LENGTH(%LENGTH_interface* %0) {
entry:
  %m = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 0
  %p = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 1
  %in = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 2
  %ft = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 3
  %yd = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 4
  %mile = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 5
  %sm = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 6
  %fm = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 7
  %Ym = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 8
  %Yp = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 9
  %Yin = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 10
  %Yft = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 11
  %Yyd = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 12
  %Ymile = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 13
  %Ysm = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 14
  %Yfm = getelementptr inbounds %LENGTH_interface, %LENGTH_interface* %0, i32 0, i32 15
  %load_m = load float, float* %m, align 4
  %load_p = load float, float* %p, align 4
  %tmpVar = fmul float %load_p, 0x3F38A552E0000000
  %tmpVar1 = fadd float %load_m, %tmpVar
  %load_in = load float, float* %in, align 4
  %tmpVar2 = fmul float %load_in, 0x3F9A027520000000
  %tmpVar3 = fadd float %tmpVar1, %tmpVar2
  %load_ft = load float, float* %ft, align 4
  %tmpVar4 = fmul float %load_ft, 0x3FD381D7E0000000
  %tmpVar5 = fadd float %tmpVar3, %tmpVar4
  %load_yd = load float, float* %yd, align 4
  %tmpVar6 = fmul float %load_yd, 0x3FED42C3C0000000
  %tmpVar7 = fadd float %tmpVar5, %tmpVar6
  %load_mile = load float, float* %mile, align 4
  %tmpVar8 = fmul float %load_mile, 0x4099256040000000
  %tmpVar9 = fadd float %tmpVar7, %tmpVar8
  %load_sm = load float, float* %sm, align 4
  %tmpVar10 = fmul float %load_sm, 1.852000e+03
  %tmpVar11 = fadd float %tmpVar9, %tmpVar10
  %load_fm = load float, float* %fm, align 4
  %tmpVar12 = fmul float %load_fm, 0x3FFD439580000000
  %tmpVar13 = fadd float %tmpVar11, %tmpVar12
  store float %tmpVar13, float* %Ym, align 4
  %load_Ym = load float, float* %Ym, align 4
  %tmpVar14 = fmul float %load_Ym, 0x40A4C63AC0000000
  store float %tmpVar14, float* %Yp, align 4
  %load_Ym15 = load float, float* %Ym, align 4
  %tmpVar16 = fmul float %load_Ym15, 0x4043AF5EC0000000
  store float %tmpVar16, float* %Yin, align 4
  %load_Ym17 = load float, float* %Ym, align 4
  %tmpVar18 = fmul float %load_Ym17, 0x400A3F2900000000
  store float %tmpVar18, float* %Yft, align 4
  %load_Ym19 = load float, float* %Ym, align 4
  %tmpVar20 = fmul float %load_Ym19, 0x3FF17F70A0000000
  store float %tmpVar20, float* %Yyd, align 4
  %load_Ym21 = load float, float* %Ym, align 4
  %tmpVar22 = fmul float %load_Ym21, 0x3F445C7080000000
  store float %tmpVar22, float* %Ymile, align 4
  %load_Ym23 = load float, float* %Ym, align 4
  %tmpVar24 = fmul float %load_Ym23, 0x3F41B17C60000000
  store float %tmpVar24, float* %Ysm, align 4
  %load_Ym25 = load float, float* %Ym, align 4
  %tmpVar26 = fmul float %load_Ym25, 0x3FE17EF340000000
  store float %tmpVar26, float* %Yfm, align 4
  ret void
}

define i16 @MS_TO_BFT(%MS_TO_BFT_interface* %0) {
entry:
  %MS = getelementptr inbounds %MS_TO_BFT_interface, %MS_TO_BFT_interface* %0, i32 0, i32 0
  %MS_TO_BFT = alloca i16, align 2
  store i16 0, i16* %MS_TO_BFT, align 2
  %REAL_TO_INT_instance = alloca %REAL_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %REAL_TO_INT_interface, %REAL_TO_INT_interface* %REAL_TO_INT_instance, i32 0, i32 0
  %EXPT_instance = alloca %EXPT_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i16 @REAL_TO_INT(%REAL_TO_INT_interface* %REAL_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call6, i16* %MS_TO_BFT, align 2
  %MS_TO_BFT_ret = load i16, i16* %MS_TO_BFT, align 2
  ret i16 %MS_TO_BFT_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %EXPT_interface, %EXPT_interface* %EXPT_instance, i32 0, i32 0
  %load_MS = load float, float* %MS, align 4
  %tmpVar = fmul float %load_MS, 0x3FF3238540000000
  %3 = fptosi float %tmpVar to i32
  store i32 %3, i32* %2, align 4
  %4 = getelementptr inbounds %EXPT_interface, %EXPT_interface* %EXPT_instance, i32 0, i32 1
  store i32 0, i32* %4, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call double @EXPT(%EXPT_interface* %EXPT_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %5 = fptrunc double %call5 to float
  store float %5, float* %1, align 4
  br label %call
}

define float @MS_TO_KMH(%MS_TO_KMH_interface* %0) {
entry:
  %ms = getelementptr inbounds %MS_TO_KMH_interface, %MS_TO_KMH_interface* %0, i32 0, i32 0
  %MS_TO_KMH = alloca float, align 4
  store float 0.000000e+00, float* %MS_TO_KMH, align 4
  %load_ms = load float, float* %ms, align 4
  %tmpVar = fmul float %load_ms, 0x400CCCCCC0000000
  store float %tmpVar, float* %MS_TO_KMH, align 4
  %MS_TO_KMH_ret = load float, float* %MS_TO_KMH, align 4
  ret float %MS_TO_KMH_ret
}

define float @OM_TO_F(%OM_TO_F_interface* %0) {
entry:
  %OM = getelementptr inbounds %OM_TO_F_interface, %OM_TO_F_interface* %0, i32 0, i32 0
  %OM_TO_F = alloca float, align 4
  store float 0.000000e+00, float* %OM_TO_F, align 4
  %load_OM = load float, float* %OM, align 4
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 1), align 4
  %tmpVar = fdiv float %load_OM, %load_
  store float %tmpVar, float* %OM_TO_F, align 4
  %OM_TO_F_ret = load float, float* %OM_TO_F, align 4
  ret float %OM_TO_F_ret
}

define void @PRESSURE(%PRESSURE_interface* %0) {
entry:
  %mws = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 0
  %torr = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 1
  %att = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 2
  %atm = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 3
  %pa = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 4
  %bar = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 5
  %Ymws = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 6
  %Ytorr = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 7
  %Yatt = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 8
  %Yatm = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 9
  %Ypa = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 10
  %Ybar = getelementptr inbounds %PRESSURE_interface, %PRESSURE_interface* %0, i32 0, i32 11
  %load_bar = load float, float* %bar, align 4
  %load_pa = load float, float* %pa, align 4
  %tmpVar = fmul float %load_pa, 0x3EE4F8B580000000
  %tmpVar1 = fadd float %load_bar, %tmpVar
  %load_att = load float, float* %att, align 4
  %tmpVar2 = fmul float 0x3FEF619BA0000000, %load_att
  %tmpVar3 = fadd float %tmpVar1, %tmpVar2
  %load_atm = load float, float* %atm, align 4
  %tmpVar4 = fmul float 0x3FF03645A0000000, %load_atm
  %tmpVar5 = fadd float %tmpVar3, %tmpVar4
  %load_torr = load float, float* %torr, align 4
  %tmpVar6 = fmul float 0x3F55D7F260000000, %load_torr
  %tmpVar7 = fadd float %tmpVar5, %tmpVar6
  %load_mws = load float, float* %mws, align 4
  %tmpVar8 = fmul float 0x3FB91AE2E0000000, %load_mws
  %tmpVar9 = fadd float %tmpVar7, %tmpVar8
  store float %tmpVar9, float* %Ybar, align 4
  %load_ybar = load float, float* %Ybar, align 4
  %tmpVar10 = fmul float %load_ybar, 0x402464F260000000
  store float %tmpVar10, float* %Ymws, align 4
  %load_ybar11 = load float, float* %Ybar, align 4
  %tmpVar12 = fmul float %load_ybar11, 0x4087707E00000000
  store float %tmpVar12, float* %Ytorr, align 4
  %load_ybar13 = load float, float* %Ybar, align 4
  %tmpVar14 = fmul float %load_ybar13, 0x3FF050C200000000
  store float %tmpVar14, float* %Yatt, align 4
  %load_ybar15 = load float, float* %Ybar, align 4
  %tmpVar16 = fmul float %load_ybar15, 0x3FEF94E020000000
  store float %tmpVar16, float* %Yatm, align 4
  %load_ybar17 = load float, float* %Ybar, align 4
  %tmpVar18 = fmul float %load_ybar17, 1.000000e+05
  store float %tmpVar18, float* %Ypa, align 4
  ret void
}

define float @PT_TO_F(%PT_TO_F_interface* %0) {
entry:
  %PT = getelementptr inbounds %PT_TO_F_interface, %PT_TO_F_interface* %0, i32 0, i32 0
  %PT_TO_F = alloca float, align 4
  store float 0.000000e+00, float* %PT_TO_F, align 4
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = fdiv float 1.000000e+03, %call6
  store float %tmpVar, float* %PT_TO_F, align 4
  %PT_TO_F_ret = load float, float* %PT_TO_F, align 4
  ret float %PT_TO_F_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_PT = load i64, i64* %PT, align 4
  store i64 %load_PT, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call
}

define void @SPEED(%SPEED_interface* %0) {
entry:
  %ms = getelementptr inbounds %SPEED_interface, %SPEED_interface* %0, i32 0, i32 0
  %kmh = getelementptr inbounds %SPEED_interface, %SPEED_interface* %0, i32 0, i32 1
  %kn = getelementptr inbounds %SPEED_interface, %SPEED_interface* %0, i32 0, i32 2
  %mh = getelementptr inbounds %SPEED_interface, %SPEED_interface* %0, i32 0, i32 3
  %Yms = getelementptr inbounds %SPEED_interface, %SPEED_interface* %0, i32 0, i32 4
  %Ykmh = getelementptr inbounds %SPEED_interface, %SPEED_interface* %0, i32 0, i32 5
  %Ykn = getelementptr inbounds %SPEED_interface, %SPEED_interface* %0, i32 0, i32 6
  %Ymh = getelementptr inbounds %SPEED_interface, %SPEED_interface* %0, i32 0, i32 7
  %load_ms = load float, float* %ms, align 4
  %load_kmh = load float, float* %kmh, align 4
  %tmpVar = fmul float %load_kmh, 0x3FD1C71C80000000
  %tmpVar1 = fadd float %load_ms, %tmpVar
  %load_kn = load float, float* %kn, align 4
  %tmpVar2 = fmul float %load_kn, 0x3FE0765420000000
  %tmpVar3 = fadd float %tmpVar1, %tmpVar2
  %load_mh = load float, float* %mh, align 4
  %tmpVar4 = fmul float %load_mh, 0x3FDC9C4DA0000000
  %tmpVar5 = fadd float %tmpVar3, %tmpVar4
  store float %tmpVar5, float* %Yms, align 4
  %load_Yms = load float, float* %Yms, align 4
  %tmpVar6 = fmul float %load_Yms, 0x400CCCCCC0000000
  store float %tmpVar6, float* %Ykmh, align 4
  %load_Yms7 = load float, float* %Yms, align 4
  %tmpVar8 = fmul float %load_Yms7, 0x3FFF19FCE0000000
  store float %tmpVar8, float* %Ykn, align 4
  %load_Yms9 = load float, float* %Yms, align 4
  %tmpVar10 = fmul float %load_Yms9, 0x4001E53EE0000000
  store float %tmpVar10, float* %Ymh, align 4
  ret void
}

define void @TEMPERATURE(%TEMPERATURE_interface* %0) {
entry:
  %K = getelementptr inbounds %TEMPERATURE_interface, %TEMPERATURE_interface* %0, i32 0, i32 0
  %C = getelementptr inbounds %TEMPERATURE_interface, %TEMPERATURE_interface* %0, i32 0, i32 1
  %F = getelementptr inbounds %TEMPERATURE_interface, %TEMPERATURE_interface* %0, i32 0, i32 2
  %Re = getelementptr inbounds %TEMPERATURE_interface, %TEMPERATURE_interface* %0, i32 0, i32 3
  %Ra = getelementptr inbounds %TEMPERATURE_interface, %TEMPERATURE_interface* %0, i32 0, i32 4
  %YK = getelementptr inbounds %TEMPERATURE_interface, %TEMPERATURE_interface* %0, i32 0, i32 5
  %YC = getelementptr inbounds %TEMPERATURE_interface, %TEMPERATURE_interface* %0, i32 0, i32 6
  %YF = getelementptr inbounds %TEMPERATURE_interface, %TEMPERATURE_interface* %0, i32 0, i32 7
  %YRe = getelementptr inbounds %TEMPERATURE_interface, %TEMPERATURE_interface* %0, i32 0, i32 8
  %YRa = getelementptr inbounds %TEMPERATURE_interface, %TEMPERATURE_interface* %0, i32 0, i32 9
  %load_K = load float, float* %K, align 4
  %load_C = load float, float* %C, align 4
  %tmpVar = fadd float %load_C, 0x4071126660000000
  %tmpVar1 = fadd float %load_K, %tmpVar
  %load_F = load float, float* %F, align 4
  %tmpVar2 = fadd float %load_F, 0x407CBAB860000000
  %tmpVar3 = fmul float %tmpVar2, 0x3FE1C71C80000000
  %tmpVar4 = fadd float %tmpVar1, %tmpVar3
  %load_Re = load float, float* %Re, align 4
  %tmpVar5 = fmul float %load_Re, 1.250000e+00
  %tmpVar6 = fadd float %tmpVar5, 0x4071126660000000
  %tmpVar7 = fadd float %tmpVar4, %tmpVar6
  %load_Ra = load float, float* %Ra, align 4
  %tmpVar8 = fmul float %load_Ra, 0x3FE1C71C80000000
  %tmpVar9 = fadd float %tmpVar7, %tmpVar8
  store float %tmpVar9, float* %YK, align 4
  %load_YK = load float, float* %YK, align 4
  %tmpVar10 = fsub float %load_YK, 0x4071126660000000
  store float %tmpVar10, float* %YC, align 4
  %load_YK11 = load float, float* %YK, align 4
  %tmpVar12 = fmul float %load_YK11, 0x3FFCCCCCC0000000
  %tmpVar13 = fsub float %tmpVar12, 0x407CBAB860000000
  store float %tmpVar13, float* %YF, align 4
  %load_YK14 = load float, float* %YK, align 4
  %tmpVar15 = fsub float %load_YK14, 0x4071126660000000
  %tmpVar16 = fmul float %tmpVar15, 0x3FE99999A0000000
  store float %tmpVar16, float* %YRe, align 4
  %load_YK17 = load float, float* %YK, align 4
  %tmpVar18 = fmul float %load_YK17, 0x3FFCCCCCC0000000
  store float %tmpVar18, float* %YRa, align 4
  ret void
}

define void @ALARM_2(%ALARM_2_interface* %0) {
entry:
  %X = getelementptr inbounds %ALARM_2_interface, %ALARM_2_interface* %0, i32 0, i32 0
  %LO_1 = getelementptr inbounds %ALARM_2_interface, %ALARM_2_interface* %0, i32 0, i32 1
  %HI_1 = getelementptr inbounds %ALARM_2_interface, %ALARM_2_interface* %0, i32 0, i32 2
  %LO_2 = getelementptr inbounds %ALARM_2_interface, %ALARM_2_interface* %0, i32 0, i32 3
  %HI_2 = getelementptr inbounds %ALARM_2_interface, %ALARM_2_interface* %0, i32 0, i32 4
  %HYS = getelementptr inbounds %ALARM_2_interface, %ALARM_2_interface* %0, i32 0, i32 5
  %Q1_LO = getelementptr inbounds %ALARM_2_interface, %ALARM_2_interface* %0, i32 0, i32 6
  %Q1_HI = getelementptr inbounds %ALARM_2_interface, %ALARM_2_interface* %0, i32 0, i32 7
  %Q2_LO = getelementptr inbounds %ALARM_2_interface, %ALARM_2_interface* %0, i32 0, i32 8
  %Q2_HI = getelementptr inbounds %ALARM_2_interface, %ALARM_2_interface* %0, i32 0, i32 9
  %tmp = getelementptr inbounds %ALARM_2_interface, %ALARM_2_interface* %0, i32 0, i32 10
  %load_X = load float, float* %X, align 4
  %load_Hys = load float, float* %HYS, align 4
  %tmpVar = fmul float %load_Hys, 5.000000e-01
  %tmpVar1 = fsub float %load_X, %tmpVar
  store float %tmpVar1, float* %tmp, align 4
  %load_tmp = load float, float* %tmp, align 4
  %load_LO_1 = load float, float* %LO_1, align 4
  %tmpVar2 = fcmp ogt float %load_tmp, %load_LO_1
  br i1 %tmpVar2, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q1_LO, align 1
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  %load_tmp5 = load float, float* %tmp, align 4
  %load_LO_2 = load float, float* %LO_2, align 4
  %tmpVar6 = fcmp ogt float %load_tmp5, %load_LO_2
  br i1 %tmpVar6, label %condition_body4, label %continue3

condition_body4:                                  ; preds = %continue
  store i8 0, i8* %Q2_LO, align 1
  br label %continue3

continue3:                                        ; preds = %condition_body4, %continue
  %load_tmp9 = load float, float* %tmp, align 4
  %load_HI_1 = load float, float* %HI_1, align 4
  %tmpVar10 = fcmp ogt float %load_tmp9, %load_HI_1
  br i1 %tmpVar10, label %condition_body8, label %continue7

condition_body8:                                  ; preds = %continue3
  store i8 1, i8* %Q1_HI, align 1
  br label %continue7

continue7:                                        ; preds = %condition_body8, %continue3
  %load_tmp13 = load float, float* %tmp, align 4
  %load_HI_2 = load float, float* %HI_2, align 4
  %tmpVar14 = fcmp ogt float %load_tmp13, %load_HI_2
  br i1 %tmpVar14, label %condition_body12, label %continue11

condition_body12:                                 ; preds = %continue7
  store i8 1, i8* %Q2_HI, align 1
  br label %continue11

continue11:                                       ; preds = %condition_body12, %continue7
  %load_tmp15 = load float, float* %tmp, align 4
  %load_hys = load float, float* %HYS, align 4
  %tmpVar16 = fadd float %load_tmp15, %load_hys
  store float %tmpVar16, float* %tmp, align 4
  %load_tmp19 = load float, float* %tmp, align 4
  %load_LO_120 = load float, float* %LO_1, align 4
  %tmpVar21 = fcmp olt float %load_tmp19, %load_LO_120
  br i1 %tmpVar21, label %condition_body18, label %continue17

condition_body18:                                 ; preds = %continue11
  store i8 1, i8* %Q1_LO, align 1
  br label %continue17

continue17:                                       ; preds = %condition_body18, %continue11
  %load_tmp24 = load float, float* %tmp, align 4
  %load_LO_225 = load float, float* %LO_2, align 4
  %tmpVar26 = fcmp olt float %load_tmp24, %load_LO_225
  br i1 %tmpVar26, label %condition_body23, label %continue22

condition_body23:                                 ; preds = %continue17
  store i8 1, i8* %Q2_LO, align 1
  br label %continue22

continue22:                                       ; preds = %condition_body23, %continue17
  %load_tmp29 = load float, float* %tmp, align 4
  %load_HI_130 = load float, float* %HI_1, align 4
  %tmpVar31 = fcmp olt float %load_tmp29, %load_HI_130
  br i1 %tmpVar31, label %condition_body28, label %continue27

condition_body28:                                 ; preds = %continue22
  store i8 0, i8* %Q1_HI, align 1
  br label %continue27

continue27:                                       ; preds = %condition_body28, %continue22
  %load_tmp34 = load float, float* %tmp, align 4
  %load_HI_235 = load float, float* %HI_2, align 4
  %tmpVar36 = fcmp olt float %load_tmp34, %load_HI_235
  br i1 %tmpVar36, label %condition_body33, label %continue32

condition_body33:                                 ; preds = %continue27
  store i8 0, i8* %Q2_HI, align 1
  br label %continue32

continue32:                                       ; preds = %condition_body33, %continue27
  ret void
}

define void @BAR_GRAPH(%BAR_GRAPH_interface* %0) {
entry:
  %X = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 0
  %rst = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 1
  %trigger_Low = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 2
  %trigger_High = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 3
  %Alarm_low = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 4
  %Alarm_high = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 5
  %log_scale = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 6
  %LOW = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 7
  %Q1 = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 8
  %Q2 = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 9
  %Q3 = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 10
  %Q4 = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 11
  %Q5 = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 12
  %Q6 = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 13
  %HIGH = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 14
  %Alarm = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 15
  %Status = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 16
  %init = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 17
  %T1 = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 18
  %T2 = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 19
  %T3 = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 20
  %T4 = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 21
  %T5 = getelementptr inbounds %BAR_GRAPH_interface, %BAR_GRAPH_interface* %0, i32 0, i32 22
  %temp = alloca float, align 4
  store float 0.000000e+00, float* %temp, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  store i8 1, i8* %init, align 1
  %load_log_scale = load i8, i8* %log_scale, align 1
  %2 = icmp ne i8 %load_log_scale, 0
  br i1 %2, label %condition_body2, label %else

continue:                                         ; preds = %continue1, %entry
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i8 0, i8* %Q4, align 1
  store i8 0, i8* %Q5, align 1
  store i8 0, i8* %Q6, align 1
  store i8 110, i8* %Status, align 1
  %load_alarm_low = load i8, i8* %Alarm_low, align 1
  %tmpVar41 = xor i8 %load_alarm_low, -1
  %3 = icmp ne i8 %tmpVar41, 0
  br i1 %3, label %condition_body40, label %continue39

condition_body2:                                  ; preds = %condition_body
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input

else:                                             ; preds = %condition_body
  %load_trigger_high = load float, float* %trigger_High, align 4
  %load_trigger_low21 = load float, float* %trigger_Low, align 4
  %tmpVar22 = fsub float %load_trigger_high, %load_trigger_low21
  %tmpVar23 = fmul float %tmpVar22, 0x3FC24924A0000000
  store float %tmpVar23, float* %temp, align 4
  %load_trigger_low24 = load float, float* %trigger_Low, align 4
  %load_temp25 = load float, float* %temp, align 4
  %tmpVar26 = fadd float %load_trigger_low24, %load_temp25
  store float %tmpVar26, float* %T1, align 4
  %load_T127 = load float, float* %T1, align 4
  %load_temp28 = load float, float* %temp, align 4
  %tmpVar29 = fadd float %load_T127, %load_temp28
  store float %tmpVar29, float* %T2, align 4
  %load_T230 = load float, float* %T2, align 4
  %load_temp31 = load float, float* %temp, align 4
  %tmpVar32 = fadd float %load_T230, %load_temp31
  store float %tmpVar32, float* %T3, align 4
  %load_T333 = load float, float* %T3, align 4
  %load_temp34 = load float, float* %temp, align 4
  %tmpVar35 = fadd float %load_T333, %load_temp34
  store float %tmpVar35, float* %T4, align 4
  %load_T436 = load float, float* %T4, align 4
  %load_temp37 = load float, float* %temp, align 4
  %tmpVar38 = fadd float %load_T436, %load_temp37
  store float %tmpVar38, float* %T5, align 4
  br label %continue1

continue1:                                        ; preds = %else, %continue3
  br label %continue

input:                                            ; preds = %condition_body2
  %4 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %LN_instance = alloca %LN_interface, align 8
  br label %input4

call:                                             ; preds = %continue7
  %call11 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  %5 = fptrunc double %call11 to float
  store float %5, float* %temp, align 4
  %load_trigger_low = load float, float* %trigger_Low, align 4
  %load_temp = load float, float* %temp, align 4
  %tmpVar12 = fmul float %load_trigger_low, %load_temp
  store float %tmpVar12, float* %T1, align 4
  %load_T1 = load float, float* %T1, align 4
  %load_temp13 = load float, float* %temp, align 4
  %tmpVar14 = fmul float %load_T1, %load_temp13
  store float %tmpVar14, float* %T2, align 4
  %load_T2 = load float, float* %T2, align 4
  %load_temp15 = load float, float* %temp, align 4
  %tmpVar16 = fmul float %load_T2, %load_temp15
  store float %tmpVar16, float* %T3, align 4
  %load_T3 = load float, float* %T3, align 4
  %load_temp17 = load float, float* %temp, align 4
  %tmpVar18 = fmul float %load_T3, %load_temp17
  store float %tmpVar18, float* %T4, align 4
  %load_T4 = load float, float* %T4, align 4
  %load_temp19 = load float, float* %temp, align 4
  %tmpVar20 = fmul float %load_T4, %load_temp19
  store float %tmpVar20, float* %T5, align 4
  br label %continue1

input4:                                           ; preds = %input
  %6 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %load_Trigger_high = load float, float* %trigger_High, align 4
  %load_Trigger_low = load float, float* %trigger_Low, align 4
  %tmpVar8 = fdiv float %load_Trigger_high, %load_Trigger_low
  %7 = fptosi float %tmpVar8 to i32
  store i32 %7, i32* %6, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call9 = call double @LN(%LN_interface* %LN_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %tmpVar10 = fmul double %call9, 0x3FC5555555555555
  %8 = fptosi double %tmpVar10 to i32
  store i32 %8, i32* %4, align 4
  br label %call

condition_body40:                                 ; preds = %continue
  store i8 0, i8* %LOW, align 1
  br label %continue39

continue39:                                       ; preds = %condition_body40, %continue
  %load_alarm_high = load i8, i8* %Alarm_high, align 1
  %tmpVar44 = xor i8 %load_alarm_high, -1
  %9 = icmp ne i8 %tmpVar44, 0
  br i1 %9, label %condition_body43, label %continue42

condition_body43:                                 ; preds = %continue39
  store i8 0, i8* %HIGH, align 1
  br label %continue42

continue42:                                       ; preds = %condition_body43, %continue39
  %load_rst = load i8, i8* %rst, align 1
  %10 = icmp ne i8 %load_rst, 0
  br i1 %10, label %condition_body46, label %continue45

condition_body46:                                 ; preds = %continue42
  store i8 0, i8* %Alarm, align 1
  store i8 0, i8* %LOW, align 1
  store i8 0, i8* %HIGH, align 1
  br label %continue45

continue45:                                       ; preds = %condition_body46, %continue42
  %load_X = load float, float* %X, align 4
  %load_trigger_low55 = load float, float* %trigger_Low, align 4
  %tmpVar56 = fcmp olt float %load_X, %load_trigger_low55
  br i1 %tmpVar56, label %condition_body54, label %branch

condition_body54:                                 ; preds = %continue45
  store i8 1, i8* %LOW, align 1
  store i8 111, i8* %Status, align 1
  %load_alarm_low59 = load i8, i8* %Alarm_low, align 1
  %11 = icmp ne i8 %load_alarm_low59, 0
  br i1 %11, label %condition_body58, label %continue57

branch:                                           ; preds = %continue45
  %load_X61 = load float, float* %X, align 4
  %load_T162 = load float, float* %T1, align 4
  %tmpVar63 = fcmp olt float %load_X61, %load_T162
  br i1 %tmpVar63, label %condition_body60, label %branch47

condition_body60:                                 ; preds = %branch
  store i8 1, i8* %Q1, align 1
  br label %continue53

branch47:                                         ; preds = %branch
  %load_x = load float, float* %X, align 4
  %load_t2 = load float, float* %T2, align 4
  %tmpVar65 = fcmp olt float %load_x, %load_t2
  br i1 %tmpVar65, label %condition_body64, label %branch48

condition_body64:                                 ; preds = %branch47
  store i8 1, i8* %Q2, align 1
  br label %continue53

branch48:                                         ; preds = %branch47
  %load_x67 = load float, float* %X, align 4
  %load_t3 = load float, float* %T3, align 4
  %tmpVar68 = fcmp olt float %load_x67, %load_t3
  br i1 %tmpVar68, label %condition_body66, label %branch49

condition_body66:                                 ; preds = %branch48
  store i8 1, i8* %Q3, align 1
  br label %continue53

branch49:                                         ; preds = %branch48
  %load_x70 = load float, float* %X, align 4
  %load_T471 = load float, float* %T4, align 4
  %tmpVar72 = fcmp olt float %load_x70, %load_T471
  br i1 %tmpVar72, label %condition_body69, label %branch50

condition_body69:                                 ; preds = %branch49
  store i8 1, i8* %Q4, align 1
  br label %continue53

branch50:                                         ; preds = %branch49
  %load_x74 = load float, float* %X, align 4
  %load_T5 = load float, float* %T5, align 4
  %tmpVar75 = fcmp olt float %load_x74, %load_T5
  br i1 %tmpVar75, label %condition_body73, label %branch51

condition_body73:                                 ; preds = %branch50
  store i8 1, i8* %Q5, align 1
  br label %continue53

branch51:                                         ; preds = %branch50
  %load_x77 = load float, float* %X, align 4
  %load_trigger_high78 = load float, float* %trigger_High, align 4
  %tmpVar79 = fcmp olt float %load_x77, %load_trigger_high78
  br i1 %tmpVar79, label %condition_body76, label %else52

condition_body76:                                 ; preds = %branch51
  store i8 1, i8* %Q6, align 1
  br label %continue53

else52:                                           ; preds = %branch51
  store i8 1, i8* %HIGH, align 1
  store i8 112, i8* %Status, align 1
  %load_alarm_high82 = load i8, i8* %Alarm_high, align 1
  %12 = icmp ne i8 %load_alarm_high82, 0
  br i1 %12, label %condition_body81, label %continue80

continue53:                                       ; preds = %continue80, %condition_body76, %condition_body73, %condition_body69, %condition_body66, %condition_body64, %condition_body60, %continue57
  ret void

condition_body58:                                 ; preds = %condition_body54
  store i8 1, i8* %Alarm, align 1
  store i8 1, i8* %Status, align 1
  br label %continue57

continue57:                                       ; preds = %condition_body58, %condition_body54
  br label %continue53

condition_body81:                                 ; preds = %else52
  store i8 1, i8* %Alarm, align 1
  store i8 2, i8* %Status, align 1
  br label %continue80

continue80:                                       ; preds = %condition_body81, %else52
  br label %continue53
}

define void @CALIBRATE(%CALIBRATE_interface* %0) {
entry:
  %X = getelementptr inbounds %CALIBRATE_interface, %CALIBRATE_interface* %0, i32 0, i32 0
  %CO = getelementptr inbounds %CALIBRATE_interface, %CALIBRATE_interface* %0, i32 0, i32 1
  %CS = getelementptr inbounds %CALIBRATE_interface, %CALIBRATE_interface* %0, i32 0, i32 2
  %Y_Offset = getelementptr inbounds %CALIBRATE_interface, %CALIBRATE_interface* %0, i32 0, i32 3
  %Y_Scale = getelementptr inbounds %CALIBRATE_interface, %CALIBRATE_interface* %0, i32 0, i32 4
  %Y = getelementptr inbounds %CALIBRATE_interface, %CALIBRATE_interface* %0, i32 0, i32 5
  %offset = getelementptr inbounds %CALIBRATE_interface, %CALIBRATE_interface* %0, i32 0, i32 6
  %Scale = getelementptr inbounds %CALIBRATE_interface, %CALIBRATE_interface* %0, i32 0, i32 7
  %load_CO = load i8, i8* %CO, align 1
  %1 = icmp ne i8 %load_CO, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  %load_Y_Offset = load float, float* %Y_Offset, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fsub float %load_Y_Offset, %load_X
  store float %tmpVar, float* %offset, align 4
  br label %continue

branch:                                           ; preds = %entry
  %load_CS = load i8, i8* %CS, align 1
  %2 = icmp ne i8 %load_CS, 0
  br i1 %2, label %condition_body1, label %continue

condition_body1:                                  ; preds = %branch
  %load_Y_scale = load float, float* %Y_Scale, align 4
  %load_X2 = load float, float* %X, align 4
  %load_OFFSET = load float, float* %offset, align 4
  %tmpVar3 = fadd float %load_X2, %load_OFFSET
  %tmpVar4 = fdiv float %load_Y_scale, %tmpVar3
  store float %tmpVar4, float* %Scale, align 4
  br label %continue

continue:                                         ; preds = %condition_body1, %branch, %condition_body
  %load_X5 = load float, float* %X, align 4
  %load_OFFSET6 = load float, float* %offset, align 4
  %tmpVar7 = fadd float %load_X5, %load_OFFSET6
  %load_SCALE = load float, float* %Scale, align 4
  %tmpVar8 = fmul float %tmpVar7, %load_SCALE
  store float %tmpVar8, float* %Y, align 4
  ret void
}

define void @CYCLE_TIME(%CYCLE_TIME_interface* %0) {
entry:
  %RST = getelementptr inbounds %CYCLE_TIME_interface, %CYCLE_TIME_interface* %0, i32 0, i32 0
  %ct_min = getelementptr inbounds %CYCLE_TIME_interface, %CYCLE_TIME_interface* %0, i32 0, i32 1
  %ct_max = getelementptr inbounds %CYCLE_TIME_interface, %CYCLE_TIME_interface* %0, i32 0, i32 2
  %ct_last = getelementptr inbounds %CYCLE_TIME_interface, %CYCLE_TIME_interface* %0, i32 0, i32 3
  %systime = getelementptr inbounds %CYCLE_TIME_interface, %CYCLE_TIME_interface* %0, i32 0, i32 4
  %sysdays = getelementptr inbounds %CYCLE_TIME_interface, %CYCLE_TIME_interface* %0, i32 0, i32 5
  %cycles = getelementptr inbounds %CYCLE_TIME_interface, %CYCLE_TIME_interface* %0, i32 0, i32 6
  %last_cycle = getelementptr inbounds %CYCLE_TIME_interface, %CYCLE_TIME_interface* %0, i32 0, i32 7
  %tx = getelementptr inbounds %CYCLE_TIME_interface, %CYCLE_TIME_interface* %0, i32 0, i32 8
  %init = getelementptr inbounds %CYCLE_TIME_interface, %CYCLE_TIME_interface* %0, i32 0, i32 9
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_last_cycle = load i64, i64* %last_cycle, align 4
  %tmpVar = sub i64 %call6, %load_last_cycle
  store i64 %tmpVar, i64* %tx, align 4
  %load_rst = load i8, i8* %RST, align 1
  %2 = icmp ne i8 %load_rst, 0
  br i1 %2, label %condition_body, label %branch

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  store i64 36000000000000, i64* %ct_min, align 4
  store i64 0, i64* %ct_max, align 4
  store i32 0, i32* %cycles, align 4
  br label %continue8

branch:                                           ; preds = %continue
  %load_last_cycle10 = load i64, i64* %last_cycle, align 4
  %tmpVar11 = icmp sgt i64 %load_last_cycle10, 0
  br i1 %tmpVar11, label %condition_body9, label %branch7

condition_body9:                                  ; preds = %branch
  %load_tx = load i64, i64* %tx, align 4
  %load_ct_min = load i64, i64* %ct_min, align 4
  %tmpVar15 = icmp slt i64 %load_tx, %load_ct_min
  br i1 %tmpVar15, label %condition_body14, label %branch12

branch7:                                          ; preds = %branch
  %load_ct_min23 = load i64, i64* %ct_min, align 4
  %tmpVar24 = icmp eq i64 %load_ct_min23, 0
  br i1 %tmpVar24, label %condition_body22, label %continue8

condition_body22:                                 ; preds = %branch7
  store i64 -1000000, i64* %ct_min, align 4
  br label %continue8

continue8:                                        ; preds = %condition_body22, %branch7, %continue13, %condition_body
  %load_init = load i8, i8* %init, align 1
  %3 = icmp ne i8 %load_init, 0
  br i1 %3, label %condition_body26, label %continue25

condition_body14:                                 ; preds = %condition_body9
  %load_tx16 = load i64, i64* %tx, align 4
  store i64 %load_tx16, i64* %ct_min, align 4
  br label %continue13

branch12:                                         ; preds = %condition_body9
  %load_tx18 = load i64, i64* %tx, align 4
  %load_ct_max = load i64, i64* %ct_max, align 4
  %tmpVar19 = icmp sgt i64 %load_tx18, %load_ct_max
  br i1 %tmpVar19, label %condition_body17, label %continue13

condition_body17:                                 ; preds = %branch12
  %load_tx20 = load i64, i64* %tx, align 4
  store i64 %load_tx20, i64* %ct_max, align 4
  br label %continue13

continue13:                                       ; preds = %condition_body17, %branch12, %condition_body14
  %load_tx21 = load i64, i64* %tx, align 4
  store i64 %load_tx21, i64* %ct_last, align 4
  br label %continue8

condition_body26:                                 ; preds = %continue8
  %load_systime = load i64, i64* %systime, align 4
  %load_tx27 = load i64, i64* %tx, align 4
  %tmpVar28 = add i64 %load_systime, %load_tx27
  store i64 %tmpVar28, i64* %systime, align 4
  %load_systime31 = load i64, i64* %systime, align 4
  %tmpVar32 = icmp sge i64 %load_systime31, 86400000000000
  br i1 %tmpVar32, label %condition_body30, label %continue29

continue25:                                       ; preds = %continue29, %continue8
  store i8 1, i8* %init, align 1
  %load_last_cycle36 = load i64, i64* %last_cycle, align 4
  %load_tx37 = load i64, i64* %tx, align 4
  %tmpVar38 = add i64 %load_last_cycle36, %load_tx37
  store i64 %tmpVar38, i64* %last_cycle, align 4
  %load_cycles = load i32, i32* %cycles, align 4
  %tmpVar39 = add i32 %load_cycles, 1
  store i32 %tmpVar39, i32* %cycles, align 4
  ret void

condition_body30:                                 ; preds = %condition_body26
  %load_systime33 = load i64, i64* %systime, align 4
  %tmpVar34 = sub i64 %load_systime33, 86400000000000
  store i64 %tmpVar34, i64* %systime, align 4
  %load_sysdays = load i16, i16* %sysdays, align 2
  %4 = sext i16 %load_sysdays to i32
  %tmpVar35 = add i32 %4, 1
  %5 = trunc i32 %tmpVar35 to i16
  store i16 %5, i16* %sysdays, align 2
  br label %continue29

continue29:                                       ; preds = %condition_body30, %condition_body26
  br label %continue25
}

define void @DT_SIMU(%DT_SIMU_interface* %0) {
entry:
  %START = getelementptr inbounds %DT_SIMU_interface, %DT_SIMU_interface* %0, i32 0, i32 0
  %SPEED = getelementptr inbounds %DT_SIMU_interface, %DT_SIMU_interface* %0, i32 0, i32 1
  %DTS = getelementptr inbounds %DT_SIMU_interface, %DT_SIMU_interface* %0, i32 0, i32 2
  %tc = getelementptr inbounds %DT_SIMU_interface, %DT_SIMU_interface* %0, i32 0, i32 3
  %init = getelementptr inbounds %DT_SIMU_interface, %DT_SIMU_interface* %0, i32 0, i32 4
  %last = getelementptr inbounds %DT_SIMU_interface, %DT_SIMU_interface* %0, i32 0, i32 5
  %tx = getelementptr inbounds %DT_SIMU_interface, %DT_SIMU_interface* %0, i32 0, i32 6
  %td = getelementptr inbounds %DT_SIMU_interface, %DT_SIMU_interface* %0, i32 0, i32 7
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %1 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input6

call3:                                            ; preds = %continue9
  %call12 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i32 %call12, i32* %tc, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar15 = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar15, 0
  br i1 %2, label %condition_body, label %branch

input6:                                           ; preds = %input2
  %3 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_tx = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar = sub i32 %load_tx, %load_last
  store i32 %tmpVar, i32* %3, align 4
  br label %call7

call7:                                            ; preds = %input6
  %call10 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %load_speed = load float, float* %SPEED, align 4
  %tmpVar11 = fmul float %call10, %load_speed
  store float %tmpVar11, float* %1, align 4
  br label %call3

condition_body:                                   ; preds = %continue5
  store i8 1, i8* %init, align 1
  %load_Start = load i64, i64* %START, align 4
  store i64 %load_Start, i64* %DTS, align 4
  store i32 0, i32* %tc, align 4
  %load_tx16 = load i32, i32* %tx, align 4
  store i32 %load_tx16, i32* %last, align 4
  br label %continue14

branch:                                           ; preds = %continue5
  %load_SPEED = load float, float* %SPEED, align 4
  %tmpVar18 = fcmp oeq float %load_SPEED, 0.000000e+00
  br i1 %tmpVar18, label %condition_body17, label %branch13

condition_body17:                                 ; preds = %branch
  %DWORD_TO_DT_instance = alloca %DWORD_TO_DT_interface, align 8
  br label %input19

branch13:                                         ; preds = %branch
  %load_tc = load i32, i32* %tc, align 4
  %tmpVar31 = icmp sge i32 %load_tc, 1000
  br i1 %tmpVar31, label %condition_body30, label %continue14

condition_body30:                                 ; preds = %branch13
  %load_tc32 = load i32, i32* %tc, align 4
  %tmpVar33 = sdiv i32 %load_tc32, 1000
  %tmpVar34 = mul i32 %tmpVar33, 1000
  store i32 %tmpVar34, i32* %td, align 4
  %load_DTS35 = load i64, i64* %DTS, align 4
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input36

continue14:                                       ; preds = %continue47, %branch13, %continue22, %condition_body
  ret void

input19:                                          ; preds = %condition_body17
  %4 = getelementptr inbounds %DWORD_TO_DT_interface, %DWORD_TO_DT_interface* %DWORD_TO_DT_instance, i32 0, i32 0
  %DT_TO_DWORD_instance = alloca %DT_TO_DWORD_interface, align 8
  br label %input23

call20:                                           ; preds = %continue26
  %call29 = call i64 @DWORD_TO_DT(%DWORD_TO_DT_interface* %DWORD_TO_DT_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  store i64 %call29, i64* %DTS, align 4
  br label %continue14

input23:                                          ; preds = %input19
  %5 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance, i32 0, i32 0
  %load_DTS = load i64, i64* %DTS, align 4
  store i64 %load_DTS, i64* %5, align 4
  br label %call24

call24:                                           ; preds = %input23
  %call27 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %tmpVar28 = add i32 %call27, 1
  store i32 %tmpVar28, i32* %4, align 4
  br label %call20

input36:                                          ; preds = %condition_body30
  %6 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %load_td = load i32, i32* %td, align 4
  store i32 %load_td, i32* %6, align 4
  br label %call37

call37:                                           ; preds = %input36
  %call40 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output38

output38:                                         ; preds = %call37
  br label %continue39

continue39:                                       ; preds = %output38
  %tmpVar41 = add i64 %load_DTS35, %call40
  store i64 %tmpVar41, i64* %DTS, align 4
  %load_last42 = load i32, i32* %last, align 4
  %REAL_TO_DWORD_instance43 = alloca %REAL_TO_DWORD_interface, align 8
  br label %input44

input44:                                          ; preds = %continue39
  %7 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance43, i32 0, i32 0
  %DWORD_TO_REAL_instance48 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input49

call45:                                           ; preds = %continue52
  %call57 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance43)
  br label %output46

output46:                                         ; preds = %call45
  br label %continue47

continue47:                                       ; preds = %output46
  %tmpVar58 = add i32 %load_last42, %call57
  store i32 %tmpVar58, i32* %last, align 4
  br label %continue14

input49:                                          ; preds = %input44
  %8 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance48, i32 0, i32 0
  %load_td53 = load i32, i32* %td, align 4
  store i32 %load_td53, i32* %8, align 4
  br label %call50

call50:                                           ; preds = %input49
  %call54 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance48)
  br label %output51

output51:                                         ; preds = %call50
  br label %continue52

continue52:                                       ; preds = %output51
  %load_speed55 = load float, float* %SPEED, align 4
  %tmpVar56 = fdiv float %call54, %load_speed55
  store float %tmpVar56, float* %7, align 4
  br label %call45
}

define void @FLOW_METER(%FLOW_METER_interface* %0) {
entry:
  %VX = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 0
  %E = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 2
  %PULSE_MODE = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 3
  %UPDATE_TIME = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 4
  %F = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 5
  %X = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 6
  %Y = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 7
  %tx = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 8
  %tl = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 9
  %int1 = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 10
  %init = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 11
  %e_last = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 12
  %tmp = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 13
  %x_last = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 14
  %y_last = getelementptr inbounds %FLOW_METER_interface, %FLOW_METER_interface* %0, i32 0, i32 15
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %tl, align 4
  %deref = load float*, float** %X, align 8
  %load_X = load float, float* %deref, align 4
  store float %load_X, float* %x_last, align 4
  %deref1 = load i32*, i32** %Y, align 8
  %load_Y = load i32, i32* %deref1, align 4
  store i32 %load_Y, i32* %y_last, align 4
  %K = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %int1, i32 0, i32 2
  store float 0x3F32345680000000, float* %K, align 4
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  br label %input

input:                                            ; preds = %continue
  %2 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %int1, i32 0, i32 0
  %load_RST = load i8, i8* %RST, align 1
  %3 = zext i8 %load_RST to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %14, label %12
  %5 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %int1, i32 0, i32 1
  %load_VX = load float, float* %VX, align 4
  store float %load_VX, float* %5, align 4
  %6 = getelementptr inbounds %INTEGRATE_interface, %INTEGRATE_interface* %int1, i32 0, i32 3
  %deref4 = load float*, float** %X, align 8
  %load_X5 = load float, float* %deref4, align 4
  store float %load_X5, float** %6, align 4
  br label %call

call:                                             ; preds = %input
  call void @INTEGRATE(%INTEGRATE_interface* %int1)
  br label %output

output:                                           ; preds = %call
  br label %continue2

continue2:                                        ; preds = %output
  %load_RST8 = load i8, i8* %RST, align 1
  %7 = icmp ne i8 %load_RST8, 0
  br i1 %7, label %condition_body7, label %branch

8:                                                ; preds = %14
  %load_E = load i8, i8* %E, align 1
  %9 = zext i8 %load_E to i32
  br label %10

10:                                               ; preds = %8, %14
  %11 = phi i32 [ %tmpVar3, %14 ], [ %9, %8 ]
  store i32 %11, i8* %2, align 4

12:                                               ; preds = %input
  %load_PULSE_MODE = load i8, i8* %PULSE_MODE, align 1
  %13 = zext i8 %load_PULSE_MODE to i32
  br label %14

14:                                               ; preds = %12, %input
  %15 = phi i32 [ %3, %input ], [ %13, %12 ]
  %tmpVar3 = xor i32 %15, -1
  %16 = icmp ne i32 %tmpVar3, 0
  br i1 %16, label %8, label %10

condition_body7:                                  ; preds = %continue2
  %deref9 = load float*, float** %X, align 8
  store float 0.000000e+00, float* %deref9, align 4
  %deref10 = load i32*, i32** %Y, align 8
  store i32 0, i32* %deref10, align 4
  %load_tx11 = load i64, i64* %tx, align 4
  store i64 %load_tx11, i64* %tl, align 4
  store float 0.000000e+00, float* %x_last, align 4
  store i32 0, i32* %y_last, align 4
  br label %continue6

branch:                                           ; preds = %continue2
  %load_E13 = load i8, i8* %E, align 1
  %17 = zext i8 %load_E13 to i32
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %20, label %22

condition_body12:                                 ; preds = %22
  %load_e_last = load i8, i8* %e_last, align 1
  %tmpVar17 = xor i8 %load_e_last, -1
  %19 = icmp ne i8 %tmpVar17, 0
  br i1 %19, label %condition_body16, label %continue15

continue6:                                        ; preds = %continue15, %22, %condition_body7
  %load_E23 = load i8, i8* %E, align 1
  store i8 %load_E23, i8* %e_last, align 1
  %deref26 = load float*, float** %X, align 8
  %load_X27 = load float, float* %deref26, align 4
  %tmpVar28 = fcmp ogt float %load_X27, 1.000000e+00
  br i1 %tmpVar28, label %condition_body25, label %continue24

20:                                               ; preds = %branch
  %load_PULSE_MODE14 = load i8, i8* %PULSE_MODE, align 1
  %21 = zext i8 %load_PULSE_MODE14 to i32
  br label %22

22:                                               ; preds = %20, %branch
  %23 = phi i32 [ %17, %branch ], [ %21, %20 ]
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %condition_body12, label %continue6

condition_body16:                                 ; preds = %condition_body12
  %deref18 = load float*, float** %X, align 8
  %deref19 = load float*, float** %X, align 8
  %load_X20 = load float, float* %deref19, align 4
  %load_VX21 = load float, float* %VX, align 4
  %tmpVar22 = fadd float %load_X20, %load_VX21
  store float %tmpVar22, float* %deref18, align 4
  br label %continue15

continue15:                                       ; preds = %condition_body16, %condition_body12
  br label %continue6

condition_body25:                                 ; preds = %continue6
  %FLOOR_instance = alloca %FLOOR_interface, align 8
  br label %input29

continue24:                                       ; preds = %continue51, %continue6
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input55

input29:                                          ; preds = %condition_body25
  %25 = getelementptr inbounds %FLOOR_interface, %FLOOR_interface* %FLOOR_instance, i32 0, i32 0
  %deref33 = load float*, float** %X, align 8
  %load_X34 = load float, float* %deref33, align 4
  store float %load_X34, float* %25, align 4
  br label %call30

call30:                                           ; preds = %input29
  %call35 = call i16 @FLOOR(%FLOOR_interface* %FLOOR_instance)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  store i16 %call35, i16* %tmp, align 2
  %deref36 = load i32*, i32** %Y, align 8
  %deref37 = load i32*, i32** %Y, align 8
  %load_Y38 = load i32, i32* %deref37, align 4
  %INT_TO_UDINT_instance = alloca %INT_TO_UDINT_interface, align 8
  br label %input39

input39:                                          ; preds = %continue32
  %26 = getelementptr inbounds %INT_TO_UDINT_interface, %INT_TO_UDINT_interface* %INT_TO_UDINT_instance, i32 0, i32 0
  %load_tmp = load i16, i16* %tmp, align 2
  store i16 %load_tmp, i16* %26, align 2
  br label %call40

call40:                                           ; preds = %input39
  %call43 = call i32 @INT_TO_UDINT(%INT_TO_UDINT_interface* %INT_TO_UDINT_instance)
  br label %output41

output41:                                         ; preds = %call40
  br label %continue42

continue42:                                       ; preds = %output41
  %tmpVar44 = add i32 %load_Y38, %call43
  store i32 %tmpVar44, i32* %deref36, align 4
  %deref45 = load float*, float** %X, align 8
  %deref46 = load float*, float** %X, align 8
  %load_X47 = load float, float* %deref46, align 4
  %INT_TO_REAL_instance = alloca %INT_TO_REAL_interface, align 8
  br label %input48

input48:                                          ; preds = %continue42
  %27 = getelementptr inbounds %INT_TO_REAL_interface, %INT_TO_REAL_interface* %INT_TO_REAL_instance, i32 0, i32 0
  %load_tmp52 = load i16, i16* %tmp, align 2
  store i16 %load_tmp52, i16* %27, align 2
  br label %call49

call49:                                           ; preds = %input48
  %call53 = call float @INT_TO_REAL(%INT_TO_REAL_interface* %INT_TO_REAL_instance)
  br label %output50

output50:                                         ; preds = %call49
  br label %continue51

continue51:                                       ; preds = %output50
  %tmpVar54 = fsub float %load_X47, %call53
  store float %tmpVar54, float* %deref45, align 4
  br label %continue24

input55:                                          ; preds = %continue24
  %28 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input59

call56:                                           ; preds = %continue62
  %call64 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output57

output57:                                         ; preds = %call56
  br label %continue58

continue58:                                       ; preds = %output57
  store i64 %call64, i64* %tx, align 4
  %load_tx67 = load i64, i64* %tx, align 4
  %load_tl = load i64, i64* %tl, align 4
  %tmpVar68 = sub i64 %load_tx67, %load_tl
  %load_UPDATE_TIME = load i64, i64* %UPDATE_TIME, align 4
  %tmpVar69 = icmp sge i64 %tmpVar68, %load_UPDATE_TIME
  %29 = zext i1 %tmpVar69 to i32
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %31, label %33

input59:                                          ; preds = %input55
  br label %call60

call60:                                           ; preds = %input59
  %call63 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output61

output61:                                         ; preds = %call60
  br label %continue62

continue62:                                       ; preds = %output61
  store i32 %call63, i32* %28, align 4
  br label %call56

condition_body66:                                 ; preds = %33
  %UDINT_TO_REAL_instance = alloca %UDINT_TO_REAL_interface, align 8
  br label %input72

continue65:                                       ; preds = %continue87, %33
  ret void

31:                                               ; preds = %continue58
  %load_UPDATE_TIME70 = load i64, i64* %UPDATE_TIME, align 4
  %tmpVar71 = icmp sgt i64 %load_UPDATE_TIME70, 0
  %32 = zext i1 %tmpVar71 to i32
  br label %33

33:                                               ; preds = %31, %continue58
  %34 = phi i32 [ %29, %continue58 ], [ %32, %31 ]
  %35 = icmp ne i32 %34, 0
  br i1 %35, label %condition_body66, label %continue65

input72:                                          ; preds = %condition_body66
  %36 = getelementptr inbounds %UDINT_TO_REAL_interface, %UDINT_TO_REAL_interface* %UDINT_TO_REAL_instance, i32 0, i32 0
  %deref76 = load i32*, i32** %Y, align 8
  %load_Y77 = load i32, i32* %deref76, align 4
  %load_y_last = load i32, i32* %y_last, align 4
  %tmpVar78 = sub i32 %load_Y77, %load_y_last
  store i32 %tmpVar78, i32* %36, align 4
  br label %call73

call73:                                           ; preds = %input72
  %call79 = call float @UDINT_TO_REAL(%UDINT_TO_REAL_interface* %UDINT_TO_REAL_instance)
  br label %output74

output74:                                         ; preds = %call73
  br label %continue75

continue75:                                       ; preds = %output74
  %deref80 = load float*, float** %X, align 8
  %load_X81 = load float, float* %deref80, align 4
  %tmpVar82 = fadd float %call79, %load_X81
  %load_x_last = load float, float* %x_last, align 4
  %tmpVar83 = fsub float %tmpVar82, %load_x_last
  %TIME_TO_REAL_instance = alloca %TIME_TO_REAL_interface, align 8
  br label %input84

input84:                                          ; preds = %continue75
  %37 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance, i32 0, i32 0
  %load_tx88 = load i64, i64* %tx, align 4
  %load_tl89 = load i64, i64* %tl, align 4
  %tmpVar90 = sub i64 %load_tx88, %load_tl89
  store i64 %tmpVar90, i64* %37, align 4
  br label %call85

call85:                                           ; preds = %input84
  %call91 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance)
  br label %output86

output86:                                         ; preds = %call85
  br label %continue87

continue87:                                       ; preds = %output86
  %tmpVar92 = fdiv float %tmpVar83, %call91
  %tmpVar93 = fmul float %tmpVar92, 3.600000e+06
  store float %tmpVar93, float* %F, align 4
  %deref94 = load i32*, i32** %Y, align 8
  %load_Y95 = load i32, i32* %deref94, align 4
  store i32 %load_Y95, i32* %y_last, align 4
  %deref96 = load float*, float** %X, align 8
  %load_X97 = load float, float* %deref96, align 4
  store float %load_X97, float* %x_last, align 4
  %load_tx98 = load i64, i64* %tx, align 4
  store i64 %load_tx98, i64* %tl, align 4
  br label %continue65
}

define void @M_D(%M_D_interface* %0) {
entry:
  %start = getelementptr inbounds %M_D_interface, %M_D_interface* %0, i32 0, i32 0
  %stop = getelementptr inbounds %M_D_interface, %M_D_interface* %0, i32 0, i32 1
  %tmax = getelementptr inbounds %M_D_interface, %M_D_interface* %0, i32 0, i32 2
  %rst = getelementptr inbounds %M_D_interface, %M_D_interface* %0, i32 0, i32 3
  %PT = getelementptr inbounds %M_D_interface, %M_D_interface* %0, i32 0, i32 4
  %ET = getelementptr inbounds %M_D_interface, %M_D_interface* %0, i32 0, i32 5
  %run = getelementptr inbounds %M_D_interface, %M_D_interface* %0, i32 0, i32 6
  %edge = getelementptr inbounds %M_D_interface, %M_D_interface* %0, i32 0, i32 7
  %T0 = getelementptr inbounds %M_D_interface, %M_D_interface* %0, i32 0, i32 8
  %tx = getelementptr inbounds %M_D_interface, %M_D_interface* %0, i32 0, i32 9
  %startup = getelementptr inbounds %M_D_interface, %M_D_interface* %0, i32 0, i32 10
  %load_rst = load i8, i8* %rst, align 1
  %1 = zext i8 %load_rst to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %6, label %4

condition_body:                                   ; preds = %6
  store i64 0, i64* %PT, align 4
  store i64 0, i64* %ET, align 4
  store i8 0, i8* %startup, align 1
  store i8 0, i8* %run, align 1
  br label %continue

continue:                                         ; preds = %condition_body, %6
  %load_startup = load i8, i8* %startup, align 1
  %tmpVar3 = xor i8 %load_startup, -1
  %3 = icmp ne i8 %tmpVar3, 0
  br i1 %3, label %condition_body2, label %continue1

4:                                                ; preds = %entry
  %load_et = load i64, i64* %ET, align 4
  %load_tmax = load i64, i64* %tmax, align 4
  %tmpVar = icmp sge i64 %load_et, %load_tmax
  %5 = zext i1 %tmpVar to i32
  br label %6

6:                                                ; preds = %4, %entry
  %7 = phi i32 [ %1, %entry ], [ %5, %4 ]
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %condition_body, label %continue

condition_body2:                                  ; preds = %continue
  %load_start = load i8, i8* %start, align 1
  store i8 %load_start, i8* %edge, align 1
  store i8 1, i8* %startup, align 1
  br label %continue1

continue1:                                        ; preds = %condition_body2, %continue
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %continue1
  %9 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input5

call:                                             ; preds = %continue8
  %call10 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue4

continue4:                                        ; preds = %output
  store i64 %call10, i64* %tx, align 4
  %load_start13 = load i8, i8* %start, align 1
  %10 = zext i8 %load_start13 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %20, label %22

input5:                                           ; preds = %input
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  store i32 %call9, i32* %9, align 4
  br label %call

condition_body12:                                 ; preds = %17
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %T0, align 4
  store i8 1, i8* %run, align 1
  store i64 0, i64* %PT, align 4
  br label %continue11

branch:                                           ; preds = %17
  %load_stop17 = load i8, i8* %stop, align 1
  %12 = zext i8 %load_stop17 to i32
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %25, label %27

condition_body16:                                 ; preds = %27
  %load_et18 = load i64, i64* %ET, align 4
  store i64 %load_et18, i64* %PT, align 4
  store i8 0, i8* %run, align 1
  br label %continue11

continue11:                                       ; preds = %condition_body16, %27, %condition_body12
  %load_start19 = load i8, i8* %start, align 1
  store i8 %load_start19, i8* %edge, align 1
  %load_run22 = load i8, i8* %run, align 1
  %14 = icmp ne i8 %load_run22, 0
  br i1 %14, label %condition_body21, label %continue20

15:                                               ; preds = %22
  %load_stop = load i8, i8* %stop, align 1
  %tmpVar15 = xor i8 %load_stop, -1
  %16 = zext i8 %tmpVar15 to i32
  br label %17

17:                                               ; preds = %15, %22
  %18 = phi i32 [ %23, %22 ], [ %16, %15 ]
  %19 = icmp ne i32 %18, 0
  br i1 %19, label %condition_body12, label %branch

20:                                               ; preds = %continue4
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar14 = xor i8 %load_edge, -1
  %21 = zext i8 %tmpVar14 to i32
  br label %22

22:                                               ; preds = %20, %continue4
  %23 = phi i32 [ %10, %continue4 ], [ %21, %20 ]
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %15, label %17

25:                                               ; preds = %branch
  %load_run = load i8, i8* %run, align 1
  %26 = zext i8 %load_run to i32
  br label %27

27:                                               ; preds = %25, %branch
  %28 = phi i32 [ %12, %branch ], [ %26, %25 ]
  %29 = icmp ne i32 %28, 0
  br i1 %29, label %condition_body16, label %continue11

condition_body21:                                 ; preds = %continue11
  %load_tx23 = load i64, i64* %tx, align 4
  %load_t0 = load i64, i64* %T0, align 4
  %tmpVar24 = sub i64 %load_tx23, %load_t0
  store i64 %tmpVar24, i64* %ET, align 4
  br label %continue20

continue20:                                       ; preds = %condition_body21, %continue11
  ret void
}

define void @M_T(%M_T_interface* %0) {
entry:
  %IN = getelementptr inbounds %M_T_interface, %M_T_interface* %0, i32 0, i32 0
  %TMAX = getelementptr inbounds %M_T_interface, %M_T_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %M_T_interface, %M_T_interface* %0, i32 0, i32 2
  %PT = getelementptr inbounds %M_T_interface, %M_T_interface* %0, i32 0, i32 3
  %ET = getelementptr inbounds %M_T_interface, %M_T_interface* %0, i32 0, i32 4
  %edge = getelementptr inbounds %M_T_interface, %M_T_interface* %0, i32 0, i32 5
  %start = getelementptr inbounds %M_T_interface, %M_T_interface* %0, i32 0, i32 6
  %tx = getelementptr inbounds %M_T_interface, %M_T_interface* %0, i32 0, i32 7
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_RST = load i8, i8* %RST, align 1
  %2 = zext i8 %load_RST to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %8, label %6

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %8
  store i64 0, i64* %PT, align 4
  store i64 0, i64* %ET, align 4
  br label %continue7

branch:                                           ; preds = %8
  %load_IN = load i8, i8* %IN, align 1
  %4 = icmp ne i8 %load_IN, 0
  br i1 %4, label %condition_body8, label %else

condition_body8:                                  ; preds = %branch
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar11 = xor i8 %load_edge, -1
  %5 = icmp ne i8 %tmpVar11, 0
  br i1 %5, label %condition_body10, label %continue9

else:                                             ; preds = %branch
  %load_ET14 = load i64, i64* %ET, align 4
  store i64 %load_ET14, i64* %PT, align 4
  br label %continue7

continue7:                                        ; preds = %else, %continue9, %condition_body
  %load_IN15 = load i8, i8* %IN, align 1
  store i8 %load_IN15, i8* %edge, align 1
  ret void

6:                                                ; preds = %continue
  %load_ET = load i64, i64* %ET, align 4
  %load_TMAX = load i64, i64* %TMAX, align 4
  %tmpVar = icmp sge i64 %load_ET, %load_TMAX
  %7 = zext i1 %tmpVar to i32
  br label %8

8:                                                ; preds = %6, %continue
  %9 = phi i32 [ %2, %continue ], [ %7, %6 ]
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %condition_body, label %branch

condition_body10:                                 ; preds = %condition_body8
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %start, align 4
  br label %continue9

continue9:                                        ; preds = %condition_body10, %condition_body8
  %load_tx12 = load i64, i64* %tx, align 4
  %load_start = load i64, i64* %start, align 4
  %tmpVar13 = sub i64 %load_tx12, %load_start
  store i64 %tmpVar13, i64* %ET, align 4
  br label %continue7
}

define void @M_TX(%M_TX_interface* %0) {
entry:
  %in = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 0
  %tmax = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 1
  %rst = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 2
  %TH = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 3
  %TL = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 4
  %DC = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 5
  %F = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 6
  %ET = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 7
  %edge = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 8
  %start = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 9
  %stop = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 10
  %tx = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 11
  %rise = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 12
  %fall = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 13
  %startup = getelementptr inbounds %M_TX_interface, %M_TX_interface* %0, i32 0, i32 14
  %load_rst = load i8, i8* %rst, align 1
  %1 = zext i8 %load_rst to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %6, label %4

condition_body:                                   ; preds = %6
  store i8 0, i8* %rise, align 1
  store i8 0, i8* %fall, align 1
  store i8 0, i8* %startup, align 1
  store i64 0, i64* %TH, align 4
  store i64 0, i64* %TL, align 4
  store float 0.000000e+00, float* %DC, align 4
  store float 0.000000e+00, float* %F, align 4
  store i64 0, i64* %ET, align 4
  br label %continue

continue:                                         ; preds = %condition_body, %6
  %load_startup = load i8, i8* %startup, align 1
  %tmpVar3 = xor i8 %load_startup, -1
  %3 = icmp ne i8 %tmpVar3, 0
  br i1 %3, label %condition_body2, label %continue1

4:                                                ; preds = %entry
  %load_et = load i64, i64* %ET, align 4
  %load_tmax = load i64, i64* %tmax, align 4
  %tmpVar = icmp sge i64 %load_et, %load_tmax
  %5 = zext i1 %tmpVar to i32
  br label %6

6:                                                ; preds = %4, %entry
  %7 = phi i32 [ %1, %entry ], [ %5, %4 ]
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %condition_body, label %continue

condition_body2:                                  ; preds = %continue
  %load_in = load i8, i8* %in, align 1
  store i8 %load_in, i8* %edge, align 1
  store i8 1, i8* %startup, align 1
  br label %continue1

continue1:                                        ; preds = %condition_body2, %continue
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %continue1
  %9 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input5

call:                                             ; preds = %continue8
  %call10 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue4

continue4:                                        ; preds = %output
  store i64 %call10, i64* %tx, align 4
  %load_in13 = load i8, i8* %in, align 1
  %10 = zext i8 %load_in13 to i32
  %load_edge = load i8, i8* %edge, align 1
  %11 = zext i8 %load_edge to i32
  %tmpVar14 = xor i32 %10, %11
  %12 = icmp ne i32 %tmpVar14, 0
  br i1 %12, label %condition_body12, label %continue11

input5:                                           ; preds = %input
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  store i32 %call9, i32* %9, align 4
  br label %call

condition_body12:                                 ; preds = %continue4
  %load_in15 = load i8, i8* %in, align 1
  store i8 %load_in15, i8* %edge, align 1
  %load_in18 = load i8, i8* %in, align 1
  %13 = icmp ne i8 %load_in18, 0
  br i1 %13, label %condition_body17, label %else

continue11:                                       ; preds = %continue16, %continue4
  %load_rise93 = load i8, i8* %rise, align 1
  %14 = icmp ne i8 %load_rise93, 0
  br i1 %14, label %condition_body92, label %continue91

condition_body17:                                 ; preds = %condition_body12
  %load_Tx = load i64, i64* %tx, align 4
  store i64 %load_Tx, i64* %start, align 4
  store i8 1, i8* %rise, align 1
  %load_fall = load i8, i8* %fall, align 1
  %15 = icmp ne i8 %load_fall, 0
  br i1 %15, label %condition_body20, label %continue19

else:                                             ; preds = %condition_body12
  %load_Tx52 = load i64, i64* %tx, align 4
  store i64 %load_Tx52, i64* %stop, align 4
  store i8 1, i8* %fall, align 1
  %load_rise = load i8, i8* %rise, align 1
  %16 = icmp ne i8 %load_rise, 0
  br i1 %16, label %condition_body54, label %continue53

continue16:                                       ; preds = %continue58, %continue22
  br label %continue11

condition_body20:                                 ; preds = %condition_body17
  %load_start = load i64, i64* %start, align 4
  %load_stop = load i64, i64* %stop, align 4
  %tmpVar21 = sub i64 %load_start, %load_stop
  store i64 %tmpVar21, i64* %TL, align 4
  br label %continue19

continue19:                                       ; preds = %condition_body20, %condition_body17
  %load_th = load i64, i64* %TH, align 4
  %tmpVar24 = icmp sgt i64 %load_th, 0
  %17 = zext i1 %tmpVar24 to i32
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %19, label %21

condition_body23:                                 ; preds = %21
  %TIME_TO_REAL_instance = alloca %TIME_TO_REAL_interface, align 8
  br label %input26

continue22:                                       ; preds = %continue46, %21
  br label %continue16

19:                                               ; preds = %continue19
  %load_tl = load i64, i64* %TL, align 4
  %tmpVar25 = icmp sgt i64 %load_tl, 0
  %20 = zext i1 %tmpVar25 to i32
  br label %21

21:                                               ; preds = %19, %continue19
  %22 = phi i32 [ %17, %continue19 ], [ %20, %19 ]
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %condition_body23, label %continue22

input26:                                          ; preds = %condition_body23
  %24 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance, i32 0, i32 0
  %load_th30 = load i64, i64* %TH, align 4
  store i64 %load_th30, i64* %24, align 4
  br label %call27

call27:                                           ; preds = %input26
  %call31 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  %TIME_TO_REAL_instance32 = alloca %TIME_TO_REAL_interface, align 8
  br label %input33

input33:                                          ; preds = %continue29
  %25 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance32, i32 0, i32 0
  %load_th37 = load i64, i64* %TH, align 4
  %load_tl38 = load i64, i64* %TL, align 4
  %tmpVar39 = add i64 %load_th37, %load_tl38
  store i64 %tmpVar39, i64* %25, align 4
  br label %call34

call34:                                           ; preds = %input33
  %call40 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance32)
  br label %output35

output35:                                         ; preds = %call34
  br label %continue36

continue36:                                       ; preds = %output35
  %tmpVar41 = fdiv float %call31, %call40
  store float %tmpVar41, float* %DC, align 4
  %TIME_TO_REAL_instance42 = alloca %TIME_TO_REAL_interface, align 8
  br label %input43

input43:                                          ; preds = %continue36
  %26 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance42, i32 0, i32 0
  %load_th47 = load i64, i64* %TH, align 4
  %load_tl48 = load i64, i64* %TL, align 4
  %tmpVar49 = add i64 %load_th47, %load_tl48
  store i64 %tmpVar49, i64* %26, align 4
  br label %call44

call44:                                           ; preds = %input43
  %call50 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance42)
  br label %output45

output45:                                         ; preds = %call44
  br label %continue46

continue46:                                       ; preds = %output45
  %tmpVar51 = fdiv float 1.000000e+03, %call50
  store float %tmpVar51, float* %F, align 4
  br label %continue22

condition_body54:                                 ; preds = %else
  %load_stop55 = load i64, i64* %stop, align 4
  %load_start56 = load i64, i64* %start, align 4
  %tmpVar57 = sub i64 %load_stop55, %load_start56
  store i64 %tmpVar57, i64* %TH, align 4
  br label %continue53

continue53:                                       ; preds = %condition_body54, %else
  %load_th60 = load i64, i64* %TH, align 4
  %tmpVar61 = icmp sgt i64 %load_th60, 0
  %27 = zext i1 %tmpVar61 to i32
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %29, label %31

condition_body59:                                 ; preds = %31
  %TIME_TO_REAL_instance64 = alloca %TIME_TO_REAL_interface, align 8
  br label %input65

continue58:                                       ; preds = %continue85, %31
  br label %continue16

29:                                               ; preds = %continue53
  %load_tl62 = load i64, i64* %TL, align 4
  %tmpVar63 = icmp sgt i64 %load_tl62, 0
  %30 = zext i1 %tmpVar63 to i32
  br label %31

31:                                               ; preds = %29, %continue53
  %32 = phi i32 [ %27, %continue53 ], [ %30, %29 ]
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %condition_body59, label %continue58

input65:                                          ; preds = %condition_body59
  %34 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance64, i32 0, i32 0
  %load_th69 = load i64, i64* %TH, align 4
  store i64 %load_th69, i64* %34, align 4
  br label %call66

call66:                                           ; preds = %input65
  %call70 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance64)
  br label %output67

output67:                                         ; preds = %call66
  br label %continue68

continue68:                                       ; preds = %output67
  %TIME_TO_REAL_instance71 = alloca %TIME_TO_REAL_interface, align 8
  br label %input72

input72:                                          ; preds = %continue68
  %35 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance71, i32 0, i32 0
  %load_th76 = load i64, i64* %TH, align 4
  %load_tl77 = load i64, i64* %TL, align 4
  %tmpVar78 = add i64 %load_th76, %load_tl77
  store i64 %tmpVar78, i64* %35, align 4
  br label %call73

call73:                                           ; preds = %input72
  %call79 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance71)
  br label %output74

output74:                                         ; preds = %call73
  br label %continue75

continue75:                                       ; preds = %output74
  %tmpVar80 = fdiv float %call70, %call79
  store float %tmpVar80, float* %DC, align 4
  %TIME_TO_REAL_instance81 = alloca %TIME_TO_REAL_interface, align 8
  br label %input82

input82:                                          ; preds = %continue75
  %36 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance81, i32 0, i32 0
  %load_th86 = load i64, i64* %TH, align 4
  %load_tl87 = load i64, i64* %TL, align 4
  %tmpVar88 = add i64 %load_th86, %load_tl87
  store i64 %tmpVar88, i64* %36, align 4
  br label %call83

call83:                                           ; preds = %input82
  %call89 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance81)
  br label %output84

output84:                                         ; preds = %call83
  br label %continue85

continue85:                                       ; preds = %output84
  %tmpVar90 = fdiv float 1.000000e+03, %call89
  store float %tmpVar90, float* %F, align 4
  br label %continue58

condition_body92:                                 ; preds = %continue11
  %load_tx = load i64, i64* %tx, align 4
  %load_start94 = load i64, i64* %start, align 4
  %tmpVar95 = sub i64 %load_tx, %load_start94
  store i64 %tmpVar95, i64* %ET, align 4
  br label %continue91

continue91:                                       ; preds = %condition_body92, %continue11
  ret void
}

define void @METER(%METER_interface* %0) {
entry:
  %M1 = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 0
  %M2 = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 1
  %I1 = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 2
  %I2 = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 3
  %D = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 4
  %RST = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 5
  %MX = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 6
  %MR = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 7
  %MX1 = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 8
  %MX2 = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 9
  %tx = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 10
  %last = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 11
  %tc = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 12
  %init = getelementptr inbounds %METER_interface, %METER_interface* %0, i32 0, i32 13
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  %load_tx = load i32, i32* %tx, align 4
  store i32 %load_tx, i32* %last, align 4
  %RX = getelementptr inbounds %REAL2, %REAL2* %MR, i32 0, i32 1
  %deref = load float*, float** %MX, align 8
  %load_mx = load float, float* %deref, align 4
  store float %load_mx, float* %RX, align 4
  %R1 = getelementptr inbounds %REAL2, %REAL2* %MR, i32 0, i32 0
  store float 0.000000e+00, float* %R1, align 4
  br label %continue2

branch:                                           ; preds = %continue
  %load_tx4 = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar5 = icmp eq i32 %load_tx4, %load_last
  br i1 %tmpVar5, label %condition_body3, label %else

condition_body3:                                  ; preds = %branch
  ret void

buffer_block:                                     ; No predecessors!
  br label %continue2

else:                                             ; preds = %branch
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input6

continue2:                                        ; preds = %continue9, %buffer_block, %condition_body
  %load_tx15 = load i32, i32* %tx, align 4
  store i32 %load_tx15, i32* %last, align 4
  %load_rst = load i8, i8* %RST, align 1
  %2 = icmp ne i8 %load_rst, 0
  br i1 %2, label %condition_body18, label %else16

input6:                                           ; preds = %else
  %3 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_tx10 = load i32, i32* %tx, align 4
  %load_last11 = load i32, i32* %last, align 4
  %tmpVar12 = sub i32 %load_tx10, %load_last11
  store i32 %tmpVar12, i32* %3, align 4
  br label %call7

call7:                                            ; preds = %input6
  %call13 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %tmpVar14 = fmul float %call13, 0x3F50624DE0000000
  store float %tmpVar14, float* %tc, align 4
  br label %continue2

condition_body18:                                 ; preds = %continue2
  %R119 = getelementptr inbounds %REAL2, %REAL2* %MR, i32 0, i32 0
  store float 0.000000e+00, float* %R119, align 4
  %RX20 = getelementptr inbounds %REAL2, %REAL2* %MR, i32 0, i32 1
  store float 0.000000e+00, float* %RX20, align 4
  br label %continue17

else16:                                           ; preds = %continue2
  %load_I1 = load i8, i8* %I1, align 1
  %4 = icmp ne i8 %load_I1, 0
  br i1 %4, label %condition_body23, label %else21

continue17:                                       ; preds = %continue30, %condition_body18
  ret void

condition_body23:                                 ; preds = %else16
  %load_M1 = load float, float* %M1, align 4
  store float %load_M1, float* %MX1, align 4
  br label %continue22

else21:                                           ; preds = %else16
  store float 0.000000e+00, float* %MX1, align 4
  br label %continue22

continue22:                                       ; preds = %else21, %condition_body23
  %load_I2 = load i8, i8* %I2, align 1
  %5 = icmp ne i8 %load_I2, 0
  br i1 %5, label %condition_body26, label %else24

condition_body26:                                 ; preds = %continue22
  %load_M2 = load float, float* %M2, align 4
  store float %load_M2, float* %MX2, align 4
  br label %continue25

else24:                                           ; preds = %continue22
  store float 0.000000e+00, float* %MX2, align 4
  br label %continue25

continue25:                                       ; preds = %else24, %condition_body26
  %R2_ADD_instance = alloca %R2_ADD_interface, align 8
  br label %input27

input27:                                          ; preds = %continue25
  %6 = getelementptr inbounds %R2_ADD_interface, %R2_ADD_interface* %R2_ADD_instance, i32 0, i32 0
  %load_MR = load %REAL2, %REAL2* %MR, align 4
  store %REAL2 %load_MR, %REAL2* %6, align 4
  %7 = getelementptr inbounds %R2_ADD_interface, %R2_ADD_interface* %R2_ADD_instance, i32 0, i32 1
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input31

call28:                                           ; preds = %continue41
  %call47 = call %REAL2 @R2_ADD(%R2_ADD_interface* %R2_ADD_instance)
  br label %output29

output29:                                         ; preds = %call28
  br label %continue30

continue30:                                       ; preds = %output29
  store %REAL2 %call47, %REAL2* %MR, align 4
  %deref48 = load float*, float** %MX, align 8
  %RX49 = getelementptr inbounds %REAL2, %REAL2* %MR, i32 0, i32 1
  %load_ = load float, float* %RX49, align 4
  store float %load_, float* %deref48, align 4
  br label %continue17

input31:                                          ; preds = %input27
  %8 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_I135 = load i8, i8* %I1, align 1
  store i8 %load_I135, i8* %8, align 1
  %9 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  store i64 0, i64* %9, align 4
  %10 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_mx1 = load float, float* %MX1, align 4
  %11 = fptoui float %load_mx1 to i64
  store i64 %11, i64* %10, align 4
  br label %call32

call32:                                           ; preds = %input31
  %call36 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  %SEL_instance37 = alloca %SEL_interface, align 8
  br label %input38

input38:                                          ; preds = %continue34
  %12 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance37, i32 0, i32 0
  %load_I242 = load i8, i8* %I2, align 1
  store i8 %load_I242, i8* %12, align 1
  %13 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance37, i32 0, i32 1
  store i64 0, i64* %13, align 4
  %14 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance37, i32 0, i32 2
  %load_mx2 = load float, float* %MX2, align 4
  %15 = fptoui float %load_mx2 to i64
  store i64 %15, i64* %14, align 4
  br label %call39

call39:                                           ; preds = %input38
  %call43 = call i64 @SEL(%SEL_interface* %SEL_instance37)
  br label %output40

output40:                                         ; preds = %call39
  br label %continue41

continue41:                                       ; preds = %output40
  %tmpVar44 = add i64 %call36, %call43
  %16 = uitofp i64 %tmpVar44 to double
  %load_D = load float, float* %D, align 4
  %17 = fpext float %load_D to double
  %tmpVar45 = fdiv double %16, %17
  %load_TC = load float, float* %tc, align 4
  %18 = fpext float %load_TC to double
  %tmpVar46 = fmul double %tmpVar45, %18
  %19 = fptrunc double %tmpVar46 to float
  store float %19, float* %7, align 4
  br label %call28
}

define void @METER_STAT(%METER_STAT_interface* %0) {
entry:
  %IN = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 0
  %DI = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 2
  %Last_Day = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 3
  %Current_Day = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 4
  %Last_Week = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 5
  %Current_Week = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 6
  %Last_Month = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 7
  %Current_Month = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 8
  %Last_Year = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 9
  %Current_Year = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 10
  %Year_Start = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 11
  %Month_Start = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 12
  %Week_Start = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 13
  %Day_Start = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 14
  %last_run = getelementptr inbounds %METER_STAT_interface, %METER_STAT_interface* %0, i32 0, i32 15
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %deref = load float*, float** %Last_Day, align 8
  store float 0.000000e+00, float* %deref, align 4
  %deref1 = load float*, float** %Current_Day, align 8
  store float 0.000000e+00, float* %deref1, align 4
  %load_IN = load float, float* %IN, align 4
  store float %load_IN, float* %Day_Start, align 4
  %deref2 = load float*, float** %Last_Week, align 8
  store float 0.000000e+00, float* %deref2, align 4
  %deref3 = load float*, float** %Current_Week, align 8
  store float 0.000000e+00, float* %deref3, align 4
  %load_in = load float, float* %IN, align 4
  store float %load_in, float* %Week_Start, align 4
  %deref4 = load float*, float** %Last_Month, align 8
  store float 0.000000e+00, float* %deref4, align 4
  %deref5 = load float*, float** %Current_Month, align 8
  store float 0.000000e+00, float* %deref5, align 4
  %load_in6 = load float, float* %IN, align 4
  store float %load_in6, float* %Month_Start, align 4
  %deref7 = load float*, float** %Last_Year, align 8
  store float 0.000000e+00, float* %deref7, align 4
  %deref8 = load float*, float** %Current_Year, align 8
  store float 0.000000e+00, float* %deref8, align 4
  %load_in9 = load float, float* %IN, align 4
  store float %load_in9, float* %Year_Start, align 4
  br label %continue

else:                                             ; preds = %entry
  %deref10 = load float*, float** %Current_Day, align 8
  %load_IN11 = load float, float* %IN, align 4
  %load_Day_Start = load float, float* %Day_Start, align 4
  %tmpVar = fsub float %load_IN11, %load_Day_Start
  store float %tmpVar, float* %deref10, align 4
  %deref12 = load float*, float** %Current_Week, align 8
  %load_In = load float, float* %IN, align 4
  %load_Week_Start = load float, float* %Week_Start, align 4
  %tmpVar13 = fsub float %load_In, %load_Week_Start
  store float %tmpVar13, float* %deref12, align 4
  %deref14 = load float*, float** %Current_Month, align 8
  %load_IN15 = load float, float* %IN, align 4
  %load_Month_Start = load float, float* %Month_Start, align 4
  %tmpVar16 = fsub float %load_IN15, %load_Month_Start
  store float %tmpVar16, float* %deref14, align 4
  %deref17 = load float*, float** %Current_Year, align 8
  %load_IN18 = load float, float* %IN, align 4
  %load_Year_Start = load float, float* %Year_Start, align 4
  %tmpVar19 = fsub float %load_IN18, %load_Year_Start
  store float %tmpVar19, float* %deref17, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body
  %YEAR_OF_DATE_instance = alloca %YEAR_OF_DATE_interface, align 8
  br label %input

condition_body22:                                 ; preds = %continue29
  %deref32 = load float*, float** %Last_Year, align 8
  %deref33 = load float*, float** %Current_Year, align 8
  %load_current_year = load float, float* %deref33, align 4
  store float %load_current_year, float* %deref32, align 4
  %deref34 = load float*, float** %Current_Year, align 8
  store float 0.000000e+00, float* %deref34, align 4
  %load_in35 = load float, float* %IN, align 4
  store float %load_in35, float* %Year_Start, align 4
  %deref36 = load float*, float** %Last_Month, align 8
  %deref37 = load float*, float** %Current_Month, align 8
  %load_current_month = load float, float* %deref37, align 4
  store float %load_current_month, float* %deref36, align 4
  %deref38 = load float*, float** %Current_Month, align 8
  store float 0.000000e+00, float* %deref38, align 4
  %load_in39 = load float, float* %IN, align 4
  store float %load_in39, float* %Month_Start, align 4
  %deref40 = load float*, float** %Last_Day, align 8
  %deref41 = load float*, float** %Current_Day, align 8
  %load_current_day = load float, float* %deref41, align 4
  store float %load_current_day, float* %deref40, align 4
  %deref42 = load float*, float** %Current_Day, align 8
  store float 0.000000e+00, float* %deref42, align 4
  %load_in43 = load float, float* %IN, align 4
  store float %load_in43, float* %Day_Start, align 4
  br label %continue21

branch:                                           ; preds = %continue29
  %MONTH_OF_DATE_instance = alloca %MONTH_OF_DATE_interface, align 8
  br label %input45

condition_body44:                                 ; preds = %continue55
  %deref59 = load float*, float** %Last_Month, align 8
  %deref60 = load float*, float** %Current_Month, align 8
  %load_current_month61 = load float, float* %deref60, align 4
  store float %load_current_month61, float* %deref59, align 4
  %deref62 = load float*, float** %Current_Month, align 8
  store float 0.000000e+00, float* %deref62, align 4
  %load_in63 = load float, float* %IN, align 4
  store float %load_in63, float* %Month_Start, align 4
  %deref64 = load float*, float** %Last_Day, align 8
  %deref65 = load float*, float** %Current_Day, align 8
  %load_current_day66 = load float, float* %deref65, align 4
  store float %load_current_day66, float* %deref64, align 4
  %deref67 = load float*, float** %Current_Day, align 8
  store float 0.000000e+00, float* %deref67, align 4
  %load_in68 = load float, float* %IN, align 4
  store float %load_in68, float* %Day_Start, align 4
  br label %continue21

branch20:                                         ; preds = %continue55
  %DAY_OF_YEAR_instance = alloca %DAY_OF_YEAR_interface, align 8
  br label %input70

condition_body69:                                 ; preds = %continue79
  %deref83 = load float*, float** %Last_Day, align 8
  %deref84 = load float*, float** %Current_Day, align 8
  %load_current_day85 = load float, float* %deref84, align 4
  store float %load_current_day85, float* %deref83, align 4
  %deref86 = load float*, float** %Current_Day, align 8
  store float 0.000000e+00, float* %deref86, align 4
  %load_in87 = load float, float* %IN, align 4
  store float %load_in87, float* %Day_Start, align 4
  br label %continue21

continue21:                                       ; preds = %condition_body69, %continue79, %condition_body44, %condition_body22
  %DAY_OF_WEEK_instance = alloca %DAY_OF_WEEK_interface, align 8
  br label %input90

input:                                            ; preds = %continue
  %2 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance, i32 0, i32 0
  %load_DI = load i64, i64* %DI, align 4
  store i64 %load_DI, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call24 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue23

continue23:                                       ; preds = %output
  %3 = sext i16 %call24 to i32
  %YEAR_OF_DATE_instance25 = alloca %YEAR_OF_DATE_interface, align 8
  br label %input26

input26:                                          ; preds = %continue23
  %4 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance25, i32 0, i32 0
  %load_last_run = load i64, i64* %last_run, align 4
  store i64 %load_last_run, i64* %4, align 4
  br label %call27

call27:                                           ; preds = %input26
  %call30 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance25)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  %5 = sext i16 %call30 to i32
  %tmpVar31 = icmp sgt i32 %3, %5
  br i1 %tmpVar31, label %condition_body22, label %branch

input45:                                          ; preds = %branch
  %6 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance, i32 0, i32 0
  %load_DI49 = load i64, i64* %DI, align 4
  store i64 %load_DI49, i64* %6, align 4
  br label %call46

call46:                                           ; preds = %input45
  %call50 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance)
  br label %output47

output47:                                         ; preds = %call46
  br label %continue48

continue48:                                       ; preds = %output47
  %7 = sext i16 %call50 to i32
  %MONTH_OF_DATE_instance51 = alloca %MONTH_OF_DATE_interface, align 8
  br label %input52

input52:                                          ; preds = %continue48
  %8 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance51, i32 0, i32 0
  %load_last_run56 = load i64, i64* %last_run, align 4
  store i64 %load_last_run56, i64* %8, align 4
  br label %call53

call53:                                           ; preds = %input52
  %call57 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance51)
  br label %output54

output54:                                         ; preds = %call53
  br label %continue55

continue55:                                       ; preds = %output54
  %9 = sext i16 %call57 to i32
  %tmpVar58 = icmp sgt i32 %7, %9
  br i1 %tmpVar58, label %condition_body44, label %branch20

input70:                                          ; preds = %branch20
  %10 = getelementptr inbounds %DAY_OF_YEAR_interface, %DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance, i32 0, i32 0
  %load_di = load i64, i64* %DI, align 4
  store i64 %load_di, i64* %10, align 4
  br label %call71

call71:                                           ; preds = %input70
  %call74 = call i16 @DAY_OF_YEAR(%DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance)
  br label %output72

output72:                                         ; preds = %call71
  br label %continue73

continue73:                                       ; preds = %output72
  %11 = sext i16 %call74 to i32
  %DAY_OF_YEAR_instance75 = alloca %DAY_OF_YEAR_interface, align 8
  br label %input76

input76:                                          ; preds = %continue73
  %12 = getelementptr inbounds %DAY_OF_YEAR_interface, %DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance75, i32 0, i32 0
  %load_last_run80 = load i64, i64* %last_run, align 4
  store i64 %load_last_run80, i64* %12, align 4
  br label %call77

call77:                                           ; preds = %input76
  %call81 = call i16 @DAY_OF_YEAR(%DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance75)
  br label %output78

output78:                                         ; preds = %call77
  br label %continue79

continue79:                                       ; preds = %output78
  %13 = sext i16 %call81 to i32
  %tmpVar82 = icmp sgt i32 %11, %13
  br i1 %tmpVar82, label %condition_body69, label %continue21

condition_body89:                                 ; preds = %continue100
  %deref104 = load float*, float** %Last_Week, align 8
  %deref105 = load float*, float** %Current_Week, align 8
  %load_current_week = load float, float* %deref105, align 4
  store float %load_current_week, float* %deref104, align 4
  %deref106 = load float*, float** %Current_Week, align 8
  store float 0.000000e+00, float* %deref106, align 4
  %load_in107 = load float, float* %IN, align 4
  store float %load_in107, float* %Week_Start, align 4
  br label %continue88

continue88:                                       ; preds = %condition_body89, %continue100
  %load_di108 = load i64, i64* %DI, align 4
  store i64 %load_di108, i64* %last_run, align 4
  ret void

input90:                                          ; preds = %continue21
  %14 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance, i32 0, i32 0
  %load_DI94 = load i64, i64* %DI, align 4
  store i64 %load_DI94, i64* %14, align 4
  br label %call91

call91:                                           ; preds = %input90
  %call95 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance)
  br label %output92

output92:                                         ; preds = %call91
  br label %continue93

continue93:                                       ; preds = %output92
  %15 = sext i16 %call95 to i32
  %DAY_OF_WEEK_instance96 = alloca %DAY_OF_WEEK_interface, align 8
  br label %input97

input97:                                          ; preds = %continue93
  %16 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance96, i32 0, i32 0
  %load_last_run101 = load i64, i64* %last_run, align 4
  store i64 %load_last_run101, i64* %16, align 4
  br label %call98

call98:                                           ; preds = %input97
  %call102 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance96)
  br label %output99

output99:                                         ; preds = %call98
  br label %continue100

continue100:                                      ; preds = %output99
  %17 = sext i16 %call102 to i32
  %tmpVar103 = icmp slt i32 %15, %17
  br i1 %tmpVar103, label %condition_body89, label %continue88
}

define void @ONTIME(%ONTIME_interface* %0) {
entry:
  %IN = getelementptr inbounds %ONTIME_interface, %ONTIME_interface* %0, i32 0, i32 0
  %RST = getelementptr inbounds %ONTIME_interface, %ONTIME_interface* %0, i32 0, i32 1
  %SECONDS = getelementptr inbounds %ONTIME_interface, %ONTIME_interface* %0, i32 0, i32 2
  %CYCLES = getelementptr inbounds %ONTIME_interface, %ONTIME_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %ONTIME_interface, %ONTIME_interface* %0, i32 0, i32 4
  %last = getelementptr inbounds %ONTIME_interface, %ONTIME_interface* %0, i32 0, i32 5
  %edge = getelementptr inbounds %ONTIME_interface, %ONTIME_interface* %0, i32 0, i32 6
  %init = getelementptr inbounds %ONTIME_interface, %ONTIME_interface* %0, i32 0, i32 7
  %ms = getelementptr inbounds %ONTIME_interface, %ONTIME_interface* %0, i32 0, i32 8
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %continue2

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  %load_tx = load i32, i32* %tx, align 4
  store i32 %load_tx, i32* %last, align 4
  store i32 0, i32* %ms, align 4
  br label %continue2

continue2:                                        ; preds = %condition_body, %continue
  %load_RST = load i8, i8* %RST, align 1
  %2 = icmp ne i8 %load_RST, 0
  br i1 %2, label %condition_body4, label %branch

condition_body4:                                  ; preds = %continue2
  %deref = load i32*, i32** %SECONDS, align 8
  store i32 0, i32* %deref, align 4
  %deref5 = load i32*, i32** %CYCLES, align 8
  store i32 0, i32* %deref5, align 4
  %load_tx6 = load i32, i32* %tx, align 4
  store i32 %load_tx6, i32* %last, align 4
  store i32 0, i32* %ms, align 4
  br label %continue3

branch:                                           ; preds = %continue2
  %load_IN = load i8, i8* %IN, align 1
  %3 = icmp ne i8 %load_IN, 0
  br i1 %3, label %condition_body7, label %continue3

condition_body7:                                  ; preds = %branch
  %load_tx8 = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar9 = sub i32 %load_tx8, %load_last
  %load_ms = load i32, i32* %ms, align 4
  %tmpVar10 = add i32 %tmpVar9, %load_ms
  store i32 %tmpVar10, i32* %ms, align 4
  %load_ms13 = load i32, i32* %ms, align 4
  %tmpVar14 = icmp sge i32 %load_ms13, 1000
  br i1 %tmpVar14, label %condition_body12, label %continue11

continue3:                                        ; preds = %continue25, %branch, %condition_body4
  %load_tx29 = load i32, i32* %tx, align 4
  store i32 %load_tx29, i32* %last, align 4
  %load_in = load i8, i8* %IN, align 1
  store i8 %load_in, i8* %edge, align 1
  ret void

condition_body12:                                 ; preds = %condition_body7
  %deref15 = load i32*, i32** %SECONDS, align 8
  %deref16 = load i32*, i32** %SECONDS, align 8
  %load_seconds = load i32, i32* %deref16, align 4
  %tmpVar17 = add i32 %load_seconds, 1
  store i32 %tmpVar17, i32* %deref15, align 4
  %load_ms18 = load i32, i32* %ms, align 4
  %tmpVar19 = sub i32 %load_ms18, 1000
  store i32 %tmpVar19, i32* %ms, align 4
  br label %continue11

continue11:                                       ; preds = %condition_body12, %condition_body7
  %deref20 = load i32*, i32** %CYCLES, align 8
  %deref21 = load i32*, i32** %CYCLES, align 8
  %load_cycles = load i32, i32* %deref21, align 4
  %BOOL_TO_UINT_instance = alloca %BOOL_TO_UINT_interface, align 8
  br label %input22

input22:                                          ; preds = %continue11
  %4 = getelementptr inbounds %BOOL_TO_UINT_interface, %BOOL_TO_UINT_interface* %BOOL_TO_UINT_instance, i32 0, i32 0
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar26 = xor i8 %load_edge, -1
  store i8 %tmpVar26, i8* %4, align 1
  br label %call23

call23:                                           ; preds = %input22
  %call27 = call i16 @BOOL_TO_UINT(%BOOL_TO_UINT_interface* %BOOL_TO_UINT_instance)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %5 = zext i16 %call27 to i32
  %tmpVar28 = add i32 %load_cycles, %5
  store i32 %tmpVar28, i32* %deref20, align 4
  br label %continue3
}

define i32 @T_PLC_MS(%T_PLC_MS_interface* %0) {
entry:
  %debug = getelementptr inbounds %T_PLC_MS_interface, %T_PLC_MS_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %T_PLC_MS_interface, %T_PLC_MS_interface* %0, i32 0, i32 1
  %offset = getelementptr inbounds %T_PLC_MS_interface, %T_PLC_MS_interface* %0, i32 0, i32 2
  %tx = getelementptr inbounds %T_PLC_MS_interface, %T_PLC_MS_interface* %0, i32 0, i32 3
  %T_PLC_MS = alloca i32, align 4
  store i8 0, i8* %debug, align 1
  store i16 0, i16* %N, align 2
  store i32 0, i32* %offset, align 4
  store i64 0, i64* %tx, align 4
  store i32 0, i32* %T_PLC_MS, align 4
  %_TIME_instance = alloca %_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @_TIME(%_TIME_interface* %_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call1, i64* %tx, align 4
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %1 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_Tx = load i64, i64* %tx, align 4
  store i64 %load_Tx, i64* %1, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i32 %call6, i32* %T_PLC_MS, align 4
  %load_debug = load i8, i8* %debug, align 1
  %2 = icmp ne i8 %load_debug, 0
  br i1 %2, label %condition_body, label %continue7

condition_body:                                   ; preds = %continue5
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input8

continue7:                                        ; preds = %4, %continue5
  %T_PLC_MS_ret = load i32, i32* %T_PLC_MS, align 4
  ret i32 %T_PLC_MS_ret

3:                                                ; preds = %continue11
  %SHL_instance13 = alloca %SHL_interface, align 8
  br label %input14

4:                                                ; preds = %continue17, %continue11
  %5 = phi i64 [ %call12, %continue11 ], [ %tmpVar, %continue17 ]
  %load_OFFSET = load i32, i32* %offset, align 4
  %tmpVar20 = add i64 %5, i32 %load_OFFSET
  store i64 %tmpVar20, i32* %T_PLC_MS, align 4
  br label %continue7

input8:                                           ; preds = %condition_body
  %6 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_T_PLC_MS = load i32, i32* %T_PLC_MS, align 4
  %7 = zext i32 %load_T_PLC_MS to i64
  store i64 %7, i64* %6, align 4
  %8 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  store i16 %load_N, i16* %8, align 2
  br label %call9

call9:                                            ; preds = %input8
  %call12 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %9 = icmp ne i64 %call12, 0
  br i1 %9, label %4, label %3

input14:                                          ; preds = %3
  %10 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance13, i32 0, i32 0
  store i64 1, i64* %10, align 4
  %11 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance13, i32 0, i32 1
  %load_N18 = load i16, i16* %N, align 2
  store i16 %load_N18, i16* %11, align 2
  br label %call15

call15:                                           ; preds = %input14
  %call19 = call i64 @SHL(%SHL_interface* %SHL_instance13)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %tmpVar = sub i64 %call19, 1
  br label %4
}

define i32 @T_PLC_US(%T_PLC_US_interface* %0) {
entry:
  %debug = getelementptr inbounds %T_PLC_US_interface, %T_PLC_US_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %T_PLC_US_interface, %T_PLC_US_interface* %0, i32 0, i32 1
  %offset = getelementptr inbounds %T_PLC_US_interface, %T_PLC_US_interface* %0, i32 0, i32 2
  %tx = getelementptr inbounds %T_PLC_US_interface, %T_PLC_US_interface* %0, i32 0, i32 3
  %T_PLC_US = alloca i32, align 4
  store i8 0, i8* %debug, align 1
  store i16 0, i16* %N, align 2
  store i32 0, i32* %offset, align 4
  store i64 0, i64* %tx, align 4
  store i32 0, i32* %T_PLC_US, align 4
  %_TIME_instance = alloca %_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @_TIME(%_TIME_interface* %_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call1, i64* %tx, align 4
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %1 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_Tx = load i64, i64* %tx, align 4
  store i64 %load_Tx, i64* %1, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %tmpVar = mul i32 %call6, 1000
  store i32 %tmpVar, i32* %T_PLC_US, align 4
  %load_debug = load i8, i8* %debug, align 1
  %2 = icmp ne i8 %load_debug, 0
  br i1 %2, label %condition_body, label %continue7

condition_body:                                   ; preds = %continue5
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input8

continue7:                                        ; preds = %4, %continue5
  %T_PLC_US_ret = load i32, i32* %T_PLC_US, align 4
  ret i32 %T_PLC_US_ret

3:                                                ; preds = %continue11
  %SHL_instance13 = alloca %SHL_interface, align 8
  br label %input14

4:                                                ; preds = %continue17, %continue11
  %5 = phi i64 [ %call12, %continue11 ], [ %tmpVar20, %continue17 ]
  %load_OFFSET = load i32, i32* %offset, align 4
  %tmpVar21 = add i64 %5, i32 %load_OFFSET
  store i64 %tmpVar21, i32* %T_PLC_US, align 4
  br label %continue7

input8:                                           ; preds = %condition_body
  %6 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_T_PLC_US = load i32, i32* %T_PLC_US, align 4
  %7 = zext i32 %load_T_PLC_US to i64
  store i64 %7, i64* %6, align 4
  %8 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  store i16 %load_N, i16* %8, align 2
  br label %call9

call9:                                            ; preds = %input8
  %call12 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %9 = icmp ne i64 %call12, 0
  br i1 %9, label %4, label %3

input14:                                          ; preds = %3
  %10 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance13, i32 0, i32 0
  store i64 1, i64* %10, align 4
  %11 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance13, i32 0, i32 1
  %load_N18 = load i16, i16* %N, align 2
  store i16 %load_N18, i16* %11, align 2
  br label %call15

call15:                                           ; preds = %input14
  %call19 = call i64 @SHL(%SHL_interface* %SHL_instance13)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %tmpVar20 = sub i64 %call19, 1
  br label %4
}

define void @TC_MS(%TC_MS_interface* %0) {
entry:
  %TC = getelementptr inbounds %TC_MS_interface, %TC_MS_interface* %0, i32 0, i32 0
  %init = getelementptr inbounds %TC_MS_interface, %TC_MS_interface* %0, i32 0, i32 1
  %tx = getelementptr inbounds %TC_MS_interface, %TC_MS_interface* %0, i32 0, i32 2
  %last = getelementptr inbounds %TC_MS_interface, %TC_MS_interface* %0, i32 0, i32 3
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  store i32 0, i32* %TC, align 4
  br label %continue2

else:                                             ; preds = %continue
  %load_tx = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar3 = sub i32 %load_tx, %load_last
  store i32 %tmpVar3, i32* %TC, align 4
  br label %continue2

continue2:                                        ; preds = %else, %condition_body
  %load_tx4 = load i32, i32* %tx, align 4
  store i32 %load_tx4, i32* %last, align 4
  ret void
}

define void @TC_S(%TC_S_interface* %0) {
entry:
  %TC = getelementptr inbounds %TC_S_interface, %TC_S_interface* %0, i32 0, i32 0
  %init = getelementptr inbounds %TC_S_interface, %TC_S_interface* %0, i32 0, i32 1
  %tx = getelementptr inbounds %TC_S_interface, %TC_S_interface* %0, i32 0, i32 2
  %last = getelementptr inbounds %TC_S_interface, %TC_S_interface* %0, i32 0, i32 3
  %T_PLC_US_instance = alloca %T_PLC_US_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_US(%T_PLC_US_interface* %T_PLC_US_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  store float 0.000000e+00, float* %TC, align 4
  br label %continue2

else:                                             ; preds = %continue
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input3

continue2:                                        ; preds = %continue6, %condition_body
  %load_tx10 = load i32, i32* %tx, align 4
  store i32 %load_tx10, i32* %last, align 4
  ret void

input3:                                           ; preds = %else
  %2 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_tx = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar7 = sub i32 %load_tx, %load_last
  store i32 %tmpVar7, i32* %2, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %tmpVar9 = fmul float %call8, 0x3EB0C6F7A0000000
  store float %tmpVar9, float* %TC, align 4
  br label %continue2
}

define void @TC_US(%TC_US_interface* %0) {
entry:
  %TC = getelementptr inbounds %TC_US_interface, %TC_US_interface* %0, i32 0, i32 0
  %init = getelementptr inbounds %TC_US_interface, %TC_US_interface* %0, i32 0, i32 1
  %tx = getelementptr inbounds %TC_US_interface, %TC_US_interface* %0, i32 0, i32 2
  %last = getelementptr inbounds %TC_US_interface, %TC_US_interface* %0, i32 0, i32 3
  %T_PLC_US_instance = alloca %T_PLC_US_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_US(%T_PLC_US_interface* %T_PLC_US_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  store i32 0, i32* %TC, align 4
  br label %continue2

else:                                             ; preds = %continue
  %load_tx = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar3 = sub i32 %load_tx, %load_last
  store i32 %tmpVar3, i32* %TC, align 4
  br label %continue2

continue2:                                        ; preds = %else, %condition_body
  %load_tx4 = load i32, i32* %tx, align 4
  store i32 %load_tx4, i32* %last, align 4
  ret void
}

define float @MULTI_IN(%MULTI_IN_interface* %0) {
entry:
  %in_1 = getelementptr inbounds %MULTI_IN_interface, %MULTI_IN_interface* %0, i32 0, i32 0
  %in_2 = getelementptr inbounds %MULTI_IN_interface, %MULTI_IN_interface* %0, i32 0, i32 1
  %in_3 = getelementptr inbounds %MULTI_IN_interface, %MULTI_IN_interface* %0, i32 0, i32 2
  %default = getelementptr inbounds %MULTI_IN_interface, %MULTI_IN_interface* %0, i32 0, i32 3
  %in_min = getelementptr inbounds %MULTI_IN_interface, %MULTI_IN_interface* %0, i32 0, i32 4
  %in_max = getelementptr inbounds %MULTI_IN_interface, %MULTI_IN_interface* %0, i32 0, i32 5
  %mode = getelementptr inbounds %MULTI_IN_interface, %MULTI_IN_interface* %0, i32 0, i32 6
  %count = getelementptr inbounds %MULTI_IN_interface, %MULTI_IN_interface* %0, i32 0, i32 7
  %F1 = getelementptr inbounds %MULTI_IN_interface, %MULTI_IN_interface* %0, i32 0, i32 8
  %F2 = getelementptr inbounds %MULTI_IN_interface, %MULTI_IN_interface* %0, i32 0, i32 9
  %F3 = getelementptr inbounds %MULTI_IN_interface, %MULTI_IN_interface* %0, i32 0, i32 10
  %MULTI_IN = alloca float, align 4
  store i16 0, i16* %count, align 2
  store i8 0, i8* %F1, align 1
  store i8 0, i8* %F2, align 1
  store i8 0, i8* %F3, align 1
  store float 0.000000e+00, float* %MULTI_IN, align 4
  %load_in_1 = load float, float* %in_1, align 4
  %load_in_min = load float, float* %in_min, align 4
  %tmpVar = fcmp ogt float %load_in_1, %load_in_min
  %1 = zext i1 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %3, label %5

3:                                                ; preds = %entry
  %load_in_11 = load float, float* %in_1, align 4
  %load_in_max = load float, float* %in_max, align 4
  %tmpVar2 = fcmp olt float %load_in_11, %load_in_max
  %4 = zext i1 %tmpVar2 to i32
  br label %5

5:                                                ; preds = %3, %entry
  %6 = phi i32 [ %1, %entry ], [ %4, %3 ]
  store i32 %6, i8* %F1, align 4
  %load_in_2 = load float, float* %in_2, align 4
  %load_in_min3 = load float, float* %in_min, align 4
  %tmpVar4 = fcmp ogt float %load_in_2, %load_in_min3
  %7 = zext i1 %tmpVar4 to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %9, label %11

9:                                                ; preds = %5
  %load_in_25 = load float, float* %in_2, align 4
  %load_in_max6 = load float, float* %in_max, align 4
  %tmpVar7 = fcmp olt float %load_in_25, %load_in_max6
  %10 = zext i1 %tmpVar7 to i32
  br label %11

11:                                               ; preds = %9, %5
  %12 = phi i32 [ %7, %5 ], [ %10, %9 ]
  store i32 %12, i8* %F2, align 4
  %load_in_3 = load float, float* %in_3, align 4
  %load_in_min8 = load float, float* %in_min, align 4
  %tmpVar9 = fcmp ogt float %load_in_3, %load_in_min8
  %13 = zext i1 %tmpVar9 to i32
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %15, label %17

15:                                               ; preds = %11
  %load_in_310 = load float, float* %in_3, align 4
  %load_in_max11 = load float, float* %in_max, align 4
  %tmpVar12 = fcmp olt float %load_in_310, %load_in_max11
  %16 = zext i1 %tmpVar12 to i32
  br label %17

17:                                               ; preds = %15, %11
  %18 = phi i32 [ %13, %11 ], [ %16, %15 ]
  store i32 %18, i8* %F3, align 4
  %load_mode = load i8, i8* %mode, align 1
  switch i8 %load_mode, label %else [
    i8 0, label %case
    i8 1, label %case42
    i8 2, label %case51
    i8 3, label %case60
    i8 4, label %case69
    i8 5, label %case71
    i8 6, label %case101
    i8 7, label %case131
  ]

case:                                             ; preds = %17
  store i16 0, i16* %count, align 2
  %load_F1 = load i8, i8* %F1, align 1
  %19 = icmp ne i8 %load_F1, 0
  br i1 %19, label %condition_body, label %else13

case42:                                           ; preds = %17
  %SEL_instance43 = alloca %SEL_interface, align 8
  br label %input44

case51:                                           ; preds = %17
  %SEL_instance52 = alloca %SEL_interface, align 8
  br label %input53

case60:                                           ; preds = %17
  %SEL_instance61 = alloca %SEL_interface, align 8
  br label %input62

case69:                                           ; preds = %17
  %load_default70 = load float, float* %default, align 4
  store float %load_default70, float* %MULTI_IN, align 4
  br label %continue

case71:                                           ; preds = %17
  %SEL_instance72 = alloca %SEL_interface, align 8
  br label %input73

case101:                                          ; preds = %17
  %SEL_instance102 = alloca %SEL_interface, align 8
  br label %input103

case131:                                          ; preds = %17
  %load_F1140 = load i8, i8* %F1, align 1
  %20 = zext i8 %load_F1140 to i32
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %111, label %113

else:                                             ; preds = %17
  br label %continue

continue:                                         ; preds = %else, %continue138, %continue125, %continue95, %case69, %continue65, %continue56, %continue47, %continue30
  %MULTI_IN_ret = load float, float* %MULTI_IN, align 4
  ret float %MULTI_IN_ret

condition_body:                                   ; preds = %case
  %load_count = load i16, i16* %count, align 2
  %22 = sext i16 %load_count to i32
  %tmpVar15 = add i32 %22, 1
  %23 = trunc i32 %tmpVar15 to i16
  store i16 %23, i16* %count, align 2
  %load_in_116 = load float, float* %in_1, align 4
  store float %load_in_116, float* %MULTI_IN, align 4
  br label %continue14

else13:                                           ; preds = %case
  store float 0.000000e+00, float* %MULTI_IN, align 4
  br label %continue14

continue14:                                       ; preds = %else13, %condition_body
  %load_F2 = load i8, i8* %F2, align 1
  %24 = icmp ne i8 %load_F2, 0
  br i1 %24, label %condition_body18, label %continue17

condition_body18:                                 ; preds = %continue14
  %load_count19 = load i16, i16* %count, align 2
  %25 = sext i16 %load_count19 to i32
  %tmpVar20 = add i32 %25, 1
  %26 = trunc i32 %tmpVar20 to i16
  store i16 %26, i16* %count, align 2
  %load_MULTI_IN = load float, float* %MULTI_IN, align 4
  %load_in_221 = load float, float* %in_2, align 4
  %tmpVar22 = fadd float %load_MULTI_IN, %load_in_221
  store float %tmpVar22, float* %MULTI_IN, align 4
  br label %continue17

continue17:                                       ; preds = %condition_body18, %continue14
  %load_F3 = load i8, i8* %F3, align 1
  %27 = icmp ne i8 %load_F3, 0
  br i1 %27, label %condition_body24, label %continue23

condition_body24:                                 ; preds = %continue17
  %load_count25 = load i16, i16* %count, align 2
  %28 = sext i16 %load_count25 to i32
  %tmpVar26 = add i32 %28, 1
  %29 = trunc i32 %tmpVar26 to i16
  store i16 %29, i16* %count, align 2
  %load_MULTI_IN27 = load float, float* %MULTI_IN, align 4
  %load_in_328 = load float, float* %in_3, align 4
  %tmpVar29 = fadd float %load_MULTI_IN27, %load_in_328
  store float %tmpVar29, float* %MULTI_IN, align 4
  br label %continue23

continue23:                                       ; preds = %condition_body24, %continue17
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input

input:                                            ; preds = %continue23
  %30 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_count31 = load i16, i16* %count, align 2
  %31 = sext i16 %load_count31 to i32
  %tmpVar32 = icmp eq i32 %31, 0
  %32 = zext i1 %tmpVar32 to i8
  store i8 %32, i8* %30, align 1
  %33 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_MULTI_IN33 = load float, float* %MULTI_IN, align 4
  %INT_TO_REAL_instance = alloca %INT_TO_REAL_interface, align 8
  br label %input34

call:                                             ; preds = %continue37
  %call41 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue30

continue30:                                       ; preds = %output
  %34 = uitofp i64 %call41 to float
  store float %34, float* %MULTI_IN, align 4
  br label %continue

input34:                                          ; preds = %input
  %35 = getelementptr inbounds %INT_TO_REAL_interface, %INT_TO_REAL_interface* %INT_TO_REAL_instance, i32 0, i32 0
  %load_count38 = load i16, i16* %count, align 2
  store i16 %load_count38, i16* %35, align 2
  br label %call35

call35:                                           ; preds = %input34
  %call39 = call float @INT_TO_REAL(%INT_TO_REAL_interface* %INT_TO_REAL_instance)
  br label %output36

output36:                                         ; preds = %call35
  br label %continue37

continue37:                                       ; preds = %output36
  %tmpVar40 = fdiv float %load_MULTI_IN33, %call39
  %36 = fptoui float %tmpVar40 to i64
  store i64 %36, i64* %33, align 4
  %37 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_default = load float, float* %default, align 4
  %38 = fptoui float %load_default to i64
  store i64 %38, i64* %37, align 4
  br label %call

input44:                                          ; preds = %case42
  %39 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance43, i32 0, i32 0
  %load_F148 = load i8, i8* %F1, align 1
  store i8 %load_F148, i8* %39, align 1
  %40 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance43, i32 0, i32 1
  %load_default49 = load float, float* %default, align 4
  %41 = fptoui float %load_default49 to i64
  store i64 %41, i64* %40, align 4
  %42 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance43, i32 0, i32 2
  %load_IN_1 = load float, float* %in_1, align 4
  %43 = fptoui float %load_IN_1 to i64
  store i64 %43, i64* %42, align 4
  br label %call45

call45:                                           ; preds = %input44
  %call50 = call i64 @SEL(%SEL_interface* %SEL_instance43)
  br label %output46

output46:                                         ; preds = %call45
  br label %continue47

continue47:                                       ; preds = %output46
  %44 = uitofp i64 %call50 to float
  store float %44, float* %MULTI_IN, align 4
  br label %continue

input53:                                          ; preds = %case51
  %45 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance52, i32 0, i32 0
  %load_F257 = load i8, i8* %F2, align 1
  store i8 %load_F257, i8* %45, align 1
  %46 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance52, i32 0, i32 1
  %load_default58 = load float, float* %default, align 4
  %47 = fptoui float %load_default58 to i64
  store i64 %47, i64* %46, align 4
  %48 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance52, i32 0, i32 2
  %load_IN_2 = load float, float* %in_2, align 4
  %49 = fptoui float %load_IN_2 to i64
  store i64 %49, i64* %48, align 4
  br label %call54

call54:                                           ; preds = %input53
  %call59 = call i64 @SEL(%SEL_interface* %SEL_instance52)
  br label %output55

output55:                                         ; preds = %call54
  br label %continue56

continue56:                                       ; preds = %output55
  %50 = uitofp i64 %call59 to float
  store float %50, float* %MULTI_IN, align 4
  br label %continue

input62:                                          ; preds = %case60
  %51 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance61, i32 0, i32 0
  %load_F366 = load i8, i8* %F3, align 1
  store i8 %load_F366, i8* %51, align 1
  %52 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance61, i32 0, i32 1
  %load_default67 = load float, float* %default, align 4
  %53 = fptoui float %load_default67 to i64
  store i64 %53, i64* %52, align 4
  %54 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance61, i32 0, i32 2
  %load_IN_3 = load float, float* %in_3, align 4
  %55 = fptoui float %load_IN_3 to i64
  store i64 %55, i64* %54, align 4
  br label %call63

call63:                                           ; preds = %input62
  %call68 = call i64 @SEL(%SEL_interface* %SEL_instance61)
  br label %output64

output64:                                         ; preds = %call63
  br label %continue65

continue65:                                       ; preds = %output64
  %56 = uitofp i64 %call68 to float
  store float %56, float* %MULTI_IN, align 4
  br label %continue

input73:                                          ; preds = %case71
  %57 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance72, i32 0, i32 0
  %load_F177 = load i8, i8* %F1, align 1
  store i8 %load_F177, i8* %57, align 1
  %58 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance72, i32 0, i32 1
  %load_in_max78 = load float, float* %in_max, align 4
  %59 = fptoui float %load_in_max78 to i64
  store i64 %59, i64* %58, align 4
  %60 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance72, i32 0, i32 2
  %load_IN_179 = load float, float* %in_1, align 4
  %61 = fptoui float %load_IN_179 to i64
  store i64 %61, i64* %60, align 4
  br label %call74

call74:                                           ; preds = %input73
  %call80 = call i64 @SEL(%SEL_interface* %SEL_instance72)
  br label %output75

output75:                                         ; preds = %call74
  br label %continue76

continue76:                                       ; preds = %output75
  %62 = uitofp i64 %call80 to float
  store float %62, float* %MULTI_IN, align 4
  %load_F283 = load i8, i8* %F2, align 1
  %63 = zext i8 %load_F283 to i32
  %64 = icmp ne i32 %63, 0
  br i1 %64, label %67, label %69

condition_body82:                                 ; preds = %69
  %load_in_287 = load float, float* %in_2, align 4
  store float %load_in_287, float* %MULTI_IN, align 4
  br label %continue81

continue81:                                       ; preds = %condition_body82, %69
  %load_F390 = load i8, i8* %F3, align 1
  %65 = zext i8 %load_F390 to i32
  %66 = icmp ne i32 %65, 0
  br i1 %66, label %72, label %74

67:                                               ; preds = %continue76
  %load_in_284 = load float, float* %in_2, align 4
  %load_MULTI_IN85 = load float, float* %MULTI_IN, align 4
  %tmpVar86 = fcmp olt float %load_in_284, %load_MULTI_IN85
  %68 = zext i1 %tmpVar86 to i32
  br label %69

69:                                               ; preds = %67, %continue76
  %70 = phi i32 [ %63, %continue76 ], [ %68, %67 ]
  %71 = icmp ne i32 %70, 0
  br i1 %71, label %condition_body82, label %continue81

condition_body89:                                 ; preds = %74
  %load_in_394 = load float, float* %in_3, align 4
  store float %load_in_394, float* %MULTI_IN, align 4
  br label %continue88

continue88:                                       ; preds = %condition_body89, %74
  %load_MULTI_IN97 = load float, float* %MULTI_IN, align 4
  %load_in_max98 = load float, float* %in_max, align 4
  %tmpVar99 = fcmp oeq float %load_MULTI_IN97, %load_in_max98
  br i1 %tmpVar99, label %condition_body96, label %continue95

72:                                               ; preds = %continue81
  %load_in_391 = load float, float* %in_3, align 4
  %load_MULTI_IN92 = load float, float* %MULTI_IN, align 4
  %tmpVar93 = fcmp olt float %load_in_391, %load_MULTI_IN92
  %73 = zext i1 %tmpVar93 to i32
  br label %74

74:                                               ; preds = %72, %continue81
  %75 = phi i32 [ %65, %continue81 ], [ %73, %72 ]
  %76 = icmp ne i32 %75, 0
  br i1 %76, label %condition_body89, label %continue88

condition_body96:                                 ; preds = %continue88
  %load_default100 = load float, float* %default, align 4
  store float %load_default100, float* %MULTI_IN, align 4
  br label %continue95

continue95:                                       ; preds = %condition_body96, %continue88
  br label %continue

input103:                                         ; preds = %case101
  %77 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance102, i32 0, i32 0
  %load_F1107 = load i8, i8* %F1, align 1
  store i8 %load_F1107, i8* %77, align 1
  %78 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance102, i32 0, i32 1
  %load_in_min108 = load float, float* %in_min, align 4
  %79 = fptoui float %load_in_min108 to i64
  store i64 %79, i64* %78, align 4
  %80 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance102, i32 0, i32 2
  %load_IN_1109 = load float, float* %in_1, align 4
  %81 = fptoui float %load_IN_1109 to i64
  store i64 %81, i64* %80, align 4
  br label %call104

call104:                                          ; preds = %input103
  %call110 = call i64 @SEL(%SEL_interface* %SEL_instance102)
  br label %output105

output105:                                        ; preds = %call104
  br label %continue106

continue106:                                      ; preds = %output105
  %82 = uitofp i64 %call110 to float
  store float %82, float* %MULTI_IN, align 4
  %load_F2113 = load i8, i8* %F2, align 1
  %83 = zext i8 %load_F2113 to i32
  %84 = icmp ne i32 %83, 0
  br i1 %84, label %87, label %89

condition_body112:                                ; preds = %89
  %load_in_2117 = load float, float* %in_2, align 4
  store float %load_in_2117, float* %MULTI_IN, align 4
  br label %continue111

continue111:                                      ; preds = %condition_body112, %89
  %load_F3120 = load i8, i8* %F3, align 1
  %85 = zext i8 %load_F3120 to i32
  %86 = icmp ne i32 %85, 0
  br i1 %86, label %92, label %94

87:                                               ; preds = %continue106
  %load_in_2114 = load float, float* %in_2, align 4
  %load_MULTI_IN115 = load float, float* %MULTI_IN, align 4
  %tmpVar116 = fcmp ogt float %load_in_2114, %load_MULTI_IN115
  %88 = zext i1 %tmpVar116 to i32
  br label %89

89:                                               ; preds = %87, %continue106
  %90 = phi i32 [ %83, %continue106 ], [ %88, %87 ]
  %91 = icmp ne i32 %90, 0
  br i1 %91, label %condition_body112, label %continue111

condition_body119:                                ; preds = %94
  %load_in_3124 = load float, float* %in_3, align 4
  store float %load_in_3124, float* %MULTI_IN, align 4
  br label %continue118

continue118:                                      ; preds = %condition_body119, %94
  %load_MULTI_IN127 = load float, float* %MULTI_IN, align 4
  %load_in_min128 = load float, float* %in_min, align 4
  %tmpVar129 = fcmp oeq float %load_MULTI_IN127, %load_in_min128
  br i1 %tmpVar129, label %condition_body126, label %continue125

92:                                               ; preds = %continue111
  %load_in_3121 = load float, float* %in_3, align 4
  %load_MULTI_IN122 = load float, float* %MULTI_IN, align 4
  %tmpVar123 = fcmp ogt float %load_in_3121, %load_MULTI_IN122
  %93 = zext i1 %tmpVar123 to i32
  br label %94

94:                                               ; preds = %92, %continue111
  %95 = phi i32 [ %85, %continue111 ], [ %93, %92 ]
  %96 = icmp ne i32 %95, 0
  br i1 %96, label %condition_body119, label %continue118

condition_body126:                                ; preds = %continue118
  %load_default130 = load float, float* %default, align 4
  store float %load_default130, float* %MULTI_IN, align 4
  br label %continue125

continue125:                                      ; preds = %condition_body126, %continue118
  br label %continue

condition_body139:                                ; preds = %108
  %MID3_instance = alloca %MID3_interface, align 8
  br label %input143

branch:                                           ; preds = %108
  %load_F1152 = load i8, i8* %F1, align 1
  %97 = zext i8 %load_F1152 to i32
  %98 = icmp ne i32 %97, 0
  br i1 %98, label %119, label %121

condition_body151:                                ; preds = %121
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input154

branch132:                                        ; preds = %121
  %load_F1162 = load i8, i8* %F1, align 1
  %99 = zext i8 %load_F1162 to i32
  %100 = icmp ne i32 %99, 0
  br i1 %100, label %129, label %131

condition_body161:                                ; preds = %131
  %MIN_instance164 = alloca %MIN_interface, align 8
  br label %input165

branch133:                                        ; preds = %131
  %load_F2173 = load i8, i8* %F2, align 1
  %101 = zext i8 %load_F2173 to i32
  %102 = icmp ne i32 %101, 0
  br i1 %102, label %139, label %141

condition_body172:                                ; preds = %141
  %MIN_instance175 = alloca %MIN_interface, align 8
  br label %input176

branch134:                                        ; preds = %141
  %load_F1184 = load i8, i8* %F1, align 1
  %103 = icmp ne i8 %load_F1184, 0
  br i1 %103, label %condition_body183, label %branch135

condition_body183:                                ; preds = %branch134
  %load_in_1185 = load float, float* %in_1, align 4
  store float %load_in_1185, float* %MULTI_IN, align 4
  br label %continue138

branch135:                                        ; preds = %branch134
  %load_F2187 = load i8, i8* %F2, align 1
  %104 = icmp ne i8 %load_F2187, 0
  br i1 %104, label %condition_body186, label %branch136

condition_body186:                                ; preds = %branch135
  %load_in_2188 = load float, float* %in_2, align 4
  store float %load_in_2188, float* %MULTI_IN, align 4
  br label %continue138

branch136:                                        ; preds = %branch135
  %load_F3190 = load i8, i8* %F3, align 1
  %105 = icmp ne i8 %load_F3190, 0
  br i1 %105, label %condition_body189, label %else137

condition_body189:                                ; preds = %branch136
  %load_in_3191 = load float, float* %in_3, align 4
  store float %load_in_3191, float* %MULTI_IN, align 4
  br label %continue138

else137:                                          ; preds = %branch136
  %load_default192 = load float, float* %default, align 4
  store float %load_default192, float* %MULTI_IN, align 4
  br label %continue138

continue138:                                      ; preds = %else137, %condition_body189, %condition_body186, %condition_body183, %continue179, %continue168, %continue157, %continue146
  br label %continue

106:                                              ; preds = %113
  %load_F3142 = load i8, i8* %F3, align 1
  %107 = zext i8 %load_F3142 to i32
  br label %108

108:                                              ; preds = %106, %113
  %109 = phi i32 [ %114, %113 ], [ %107, %106 ]
  %110 = icmp ne i32 %109, 0
  br i1 %110, label %condition_body139, label %branch

111:                                              ; preds = %case131
  %load_F2141 = load i8, i8* %F2, align 1
  %112 = zext i8 %load_F2141 to i32
  br label %113

113:                                              ; preds = %111, %case131
  %114 = phi i32 [ %20, %case131 ], [ %112, %111 ]
  %115 = icmp ne i32 %114, 0
  br i1 %115, label %106, label %108

input143:                                         ; preds = %condition_body139
  %116 = getelementptr inbounds %MID3_interface, %MID3_interface* %MID3_instance, i32 0, i32 0
  %load_in_1147 = load float, float* %in_1, align 4
  store float %load_in_1147, float* %116, align 4
  %117 = getelementptr inbounds %MID3_interface, %MID3_interface* %MID3_instance, i32 0, i32 1
  %load_in_2148 = load float, float* %in_2, align 4
  store float %load_in_2148, float* %117, align 4
  %118 = getelementptr inbounds %MID3_interface, %MID3_interface* %MID3_instance, i32 0, i32 2
  %load_in_3149 = load float, float* %in_3, align 4
  store float %load_in_3149, float* %118, align 4
  br label %call144

call144:                                          ; preds = %input143
  %call150 = call float @MID3(%MID3_interface* %MID3_instance)
  br label %output145

output145:                                        ; preds = %call144
  br label %continue146

continue146:                                      ; preds = %output145
  store float %call150, float* %MULTI_IN, align 4
  br label %continue138

119:                                              ; preds = %branch
  %load_F2153 = load i8, i8* %F2, align 1
  %120 = zext i8 %load_F2153 to i32
  br label %121

121:                                              ; preds = %119, %branch
  %122 = phi i32 [ %97, %branch ], [ %120, %119 ]
  %123 = icmp ne i32 %122, 0
  br i1 %123, label %condition_body151, label %branch132

input154:                                         ; preds = %condition_body151
  %124 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_in_1158 = load float, float* %in_1, align 4
  %125 = fptoui float %load_in_1158 to i64
  store i64 %125, i64* %124, align 4
  %126 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_in_2159 = load float, float* %in_2, align 4
  %127 = fptoui float %load_in_2159 to i64
  store i64 %127, i64* %126, align 4
  br label %call155

call155:                                          ; preds = %input154
  %call160 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output156

output156:                                        ; preds = %call155
  br label %continue157

continue157:                                      ; preds = %output156
  %128 = uitofp i64 %call160 to float
  store float %128, float* %MULTI_IN, align 4
  br label %continue138

129:                                              ; preds = %branch132
  %load_F3163 = load i8, i8* %F3, align 1
  %130 = zext i8 %load_F3163 to i32
  br label %131

131:                                              ; preds = %129, %branch132
  %132 = phi i32 [ %99, %branch132 ], [ %130, %129 ]
  %133 = icmp ne i32 %132, 0
  br i1 %133, label %condition_body161, label %branch133

input165:                                         ; preds = %condition_body161
  %134 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance164, i32 0, i32 0
  %load_in_1169 = load float, float* %in_1, align 4
  %135 = fptoui float %load_in_1169 to i64
  store i64 %135, i64* %134, align 4
  %136 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance164, i32 0, i32 1
  %load_in_3170 = load float, float* %in_3, align 4
  %137 = fptoui float %load_in_3170 to i64
  store i64 %137, i64* %136, align 4
  br label %call166

call166:                                          ; preds = %input165
  %call171 = call i64 @MIN(%MIN_interface* %MIN_instance164)
  br label %output167

output167:                                        ; preds = %call166
  br label %continue168

continue168:                                      ; preds = %output167
  %138 = uitofp i64 %call171 to float
  store float %138, float* %MULTI_IN, align 4
  br label %continue138

139:                                              ; preds = %branch133
  %load_F3174 = load i8, i8* %F3, align 1
  %140 = zext i8 %load_F3174 to i32
  br label %141

141:                                              ; preds = %139, %branch133
  %142 = phi i32 [ %101, %branch133 ], [ %140, %139 ]
  %143 = icmp ne i32 %142, 0
  br i1 %143, label %condition_body172, label %branch134

input176:                                         ; preds = %condition_body172
  %144 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance175, i32 0, i32 0
  %load_in_2180 = load float, float* %in_2, align 4
  %145 = fptoui float %load_in_2180 to i64
  store i64 %145, i64* %144, align 4
  %146 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance175, i32 0, i32 1
  %load_in_3181 = load float, float* %in_3, align 4
  %147 = fptoui float %load_in_3181 to i64
  store i64 %147, i64* %146, align 4
  br label %call177

call177:                                          ; preds = %input176
  %call182 = call i64 @MIN(%MIN_interface* %MIN_instance175)
  br label %output178

output178:                                        ; preds = %call177
  br label %continue179

continue179:                                      ; preds = %output178
  %148 = uitofp i64 %call182 to float
  store float %148, float* %MULTI_IN, align 4
  br label %continue138
}

define float @RES_NI(%RES_NI_interface* %0) {
entry:
  %T = getelementptr inbounds %RES_NI_interface, %RES_NI_interface* %0, i32 0, i32 0
  %R0 = getelementptr inbounds %RES_NI_interface, %RES_NI_interface* %0, i32 0, i32 1
  %A = getelementptr inbounds %RES_NI_interface, %RES_NI_interface* %0, i32 0, i32 2
  %B = getelementptr inbounds %RES_NI_interface, %RES_NI_interface* %0, i32 0, i32 3
  %C = getelementptr inbounds %RES_NI_interface, %RES_NI_interface* %0, i32 0, i32 4
  %T2 = getelementptr inbounds %RES_NI_interface, %RES_NI_interface* %0, i32 0, i32 5
  %RES_NI = alloca float, align 4
  store float 0x3FE18D4FE0000000, float* %A, align 4
  store float 0x3F45CA6CA0000000, float* %B, align 4
  store float 0x3E281842A0000000, float* %C, align 4
  store float 0.000000e+00, float* %T2, align 4
  store float 0.000000e+00, float* %RES_NI, align 4
  %load_T = load float, float* %T, align 4
  %load_T1 = load float, float* %T, align 4
  %tmpVar = fmul float %load_T, %load_T1
  store float %tmpVar, float* %T2, align 4
  %load_R0 = load float, float* %R0, align 4
  %load_A = load float, float* %A, align 4
  %load_T2 = load float, float* %T, align 4
  %tmpVar3 = fmul float %load_A, %load_T2
  %tmpVar4 = fadd float %load_R0, %tmpVar3
  %load_B = load float, float* %B, align 4
  %load_T25 = load float, float* %T2, align 4
  %tmpVar6 = fmul float %load_B, %load_T25
  %tmpVar7 = fadd float %tmpVar4, %tmpVar6
  %load_C = load float, float* %C, align 4
  %load_T28 = load float, float* %T2, align 4
  %tmpVar9 = fmul float %load_C, %load_T28
  %load_T210 = load float, float* %T2, align 4
  %tmpVar11 = fmul float %tmpVar9, %load_T210
  %tmpVar12 = fadd float %tmpVar7, %tmpVar11
  store float %tmpVar12, float* %RES_NI, align 4
  %RES_NI_ret = load float, float* %RES_NI, align 4
  ret float %RES_NI_ret
}

define float @RES_NTC(%RES_NTC_interface* %0) {
entry:
  %T = getelementptr inbounds %RES_NTC_interface, %RES_NTC_interface* %0, i32 0, i32 0
  %RN = getelementptr inbounds %RES_NTC_interface, %RES_NTC_interface* %0, i32 0, i32 1
  %B = getelementptr inbounds %RES_NTC_interface, %RES_NTC_interface* %0, i32 0, i32 2
  %RES_NTC = alloca float, align 4
  store float 0.000000e+00, float* %RES_NTC, align 4
  %load_RN = load float, float* %RN, align 4
  %1 = fpext float %load_RN to double
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %load_B = load float, float* %B, align 4
  %load_T = load float, float* %T, align 4
  %tmpVar = fadd float %load_T, 0x4071126660000000
  %tmpVar1 = fdiv float 1.000000e+00, %tmpVar
  %tmpVar2 = fsub float %tmpVar1, 0x3F6B79E1E0000000
  %tmpVar3 = fmul float %load_B, %tmpVar2
  %3 = fptosi float %tmpVar3 to i32
  store i32 %3, i32* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar5 = fmul double %1, %call4
  %4 = fptrunc double %tmpVar5 to float
  store float %4, float* %RES_NTC, align 4
  %RES_NTC_ret = load float, float* %RES_NTC, align 4
  ret float %RES_NTC_ret
}

define float @RES_PT(%RES_PT_interface* %0) {
entry:
  %T = getelementptr inbounds %RES_PT_interface, %RES_PT_interface* %0, i32 0, i32 0
  %R0 = getelementptr inbounds %RES_PT_interface, %RES_PT_interface* %0, i32 0, i32 1
  %A = getelementptr inbounds %RES_PT_interface, %RES_PT_interface* %0, i32 0, i32 2
  %B = getelementptr inbounds %RES_PT_interface, %RES_PT_interface* %0, i32 0, i32 3
  %C = getelementptr inbounds %RES_PT_interface, %RES_PT_interface* %0, i32 0, i32 4
  %T2 = getelementptr inbounds %RES_PT_interface, %RES_PT_interface* %0, i32 0, i32 5
  %RES_PT = alloca float, align 4
  store float 0x3F7001DB20000000, float* %A, align 4
  store float 0xBEA377E140000000, float* %B, align 4
  store float 0xBD92CB8880000000, float* %C, align 4
  store float 0.000000e+00, float* %T2, align 4
  store float 0.000000e+00, float* %RES_PT, align 4
  %load_T = load float, float* %T, align 4
  %load_T1 = load float, float* %T, align 4
  %tmpVar = fmul float %load_T, %load_T1
  store float %tmpVar, float* %T2, align 4
  %load_T2 = load float, float* %T, align 4
  %tmpVar3 = fcmp oge float %load_T2, 0.000000e+00
  br i1 %tmpVar3, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_R0 = load float, float* %R0, align 4
  %load_A = load float, float* %A, align 4
  %load_T4 = load float, float* %T, align 4
  %tmpVar5 = fmul float %load_A, %load_T4
  %tmpVar6 = fadd float 1.000000e+00, %tmpVar5
  %load_B = load float, float* %B, align 4
  %load_T27 = load float, float* %T2, align 4
  %tmpVar8 = fmul float %load_B, %load_T27
  %tmpVar9 = fadd float %tmpVar6, %tmpVar8
  %tmpVar10 = fmul float %load_R0, %tmpVar9
  store float %tmpVar10, float* %RES_PT, align 4
  br label %continue

else:                                             ; preds = %entry
  %load_R011 = load float, float* %R0, align 4
  %load_A12 = load float, float* %A, align 4
  %load_T13 = load float, float* %T, align 4
  %tmpVar14 = fmul float %load_A12, %load_T13
  %tmpVar15 = fadd float 1.000000e+00, %tmpVar14
  %load_B16 = load float, float* %B, align 4
  %load_T217 = load float, float* %T2, align 4
  %tmpVar18 = fmul float %load_B16, %load_T217
  %tmpVar19 = fadd float %tmpVar15, %tmpVar18
  %load_C = load float, float* %C, align 4
  %load_T20 = load float, float* %T, align 4
  %tmpVar21 = fsub float %load_T20, 1.000000e+02
  %tmpVar22 = fmul float %load_C, %tmpVar21
  %load_T223 = load float, float* %T2, align 4
  %tmpVar24 = fmul float %tmpVar22, %load_T223
  %load_T25 = load float, float* %T, align 4
  %tmpVar26 = fmul float %tmpVar24, %load_T25
  %tmpVar27 = fadd float %tmpVar19, %tmpVar26
  %tmpVar28 = fmul float %load_R011, %tmpVar27
  store float %tmpVar28, float* %RES_PT, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body
  %RES_PT_ret = load float, float* %RES_PT, align 4
  ret float %RES_PT_ret
}

define float @RES_SI(%RES_SI_interface* %0) {
entry:
  %T = getelementptr inbounds %RES_SI_interface, %RES_SI_interface* %0, i32 0, i32 0
  %RS = getelementptr inbounds %RES_SI_interface, %RES_SI_interface* %0, i32 0, i32 1
  %TS = getelementptr inbounds %RES_SI_interface, %RES_SI_interface* %0, i32 0, i32 2
  %A = getelementptr inbounds %RES_SI_interface, %RES_SI_interface* %0, i32 0, i32 3
  %B = getelementptr inbounds %RES_SI_interface, %RES_SI_interface* %0, i32 0, i32 4
  %TX = getelementptr inbounds %RES_SI_interface, %RES_SI_interface* %0, i32 0, i32 5
  %RES_SI = alloca float, align 4
  store float 0x3F7F4B1EE0000000, float* %A, align 4
  store float 0x3EF1680760000000, float* %B, align 4
  store float 0.000000e+00, float* %TX, align 4
  store float 0.000000e+00, float* %RES_SI, align 4
  %load_T = load float, float* %T, align 4
  %load_TS = load float, float* %TS, align 4
  %tmpVar = fsub float %load_T, %load_TS
  store float %tmpVar, float* %TX, align 4
  %load_RS = load float, float* %RS, align 4
  %load_A = load float, float* %A, align 4
  %load_TX = load float, float* %TX, align 4
  %tmpVar1 = fmul float %load_A, %load_TX
  %tmpVar2 = fadd float 1.000000e+00, %tmpVar1
  %load_B = load float, float* %B, align 4
  %load_TX3 = load float, float* %TX, align 4
  %tmpVar4 = fmul float %load_B, %load_TX3
  %load_TX5 = load float, float* %TX, align 4
  %tmpVar6 = fmul float %tmpVar4, %load_TX5
  %tmpVar7 = fadd float %tmpVar2, %tmpVar6
  %tmpVar8 = fmul float %load_RS, %tmpVar7
  store float %tmpVar8, float* %RES_SI, align 4
  %RES_SI_ret = load float, float* %RES_SI, align 4
  ret float %RES_SI_ret
}

define float @SENSOR_INT(%SENSOR_INT_interface* %0) {
entry:
  %Voltage = getelementptr inbounds %SENSOR_INT_interface, %SENSOR_INT_interface* %0, i32 0, i32 0
  %Current = getelementptr inbounds %SENSOR_INT_interface, %SENSOR_INT_interface* %0, i32 0, i32 1
  %RP = getelementptr inbounds %SENSOR_INT_interface, %SENSOR_INT_interface* %0, i32 0, i32 2
  %RS = getelementptr inbounds %SENSOR_INT_interface, %SENSOR_INT_interface* %0, i32 0, i32 3
  %RG = getelementptr inbounds %SENSOR_INT_interface, %SENSOR_INT_interface* %0, i32 0, i32 4
  %SENSOR_INT = alloca float, align 4
  store float 0.000000e+00, float* %RG, align 4
  store float 0.000000e+00, float* %SENSOR_INT, align 4
  %load_current = load float, float* %Current, align 4
  %tmpVar = fcmp one float %load_current, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %load_voltage = load float, float* %Voltage, align 4
  %load_current1 = load float, float* %Current, align 4
  %tmpVar2 = fdiv float %load_voltage, %load_current1
  store float %tmpVar2, float* %RG, align 4
  %load_RP = load float, float* %RP, align 4
  %load_RG = load float, float* %RG, align 4
  %load_RS = load float, float* %RS, align 4
  %tmpVar3 = fsub float %load_RG, %load_RS
  %tmpVar4 = fmul float %load_RP, %tmpVar3
  %load_RP5 = load float, float* %RP, align 4
  %load_RS6 = load float, float* %RS, align 4
  %tmpVar7 = fadd float %load_RP5, %load_RS6
  %load_RG8 = load float, float* %RG, align 4
  %tmpVar9 = fsub float %tmpVar7, %load_RG8
  %tmpVar10 = fdiv float %tmpVar4, %tmpVar9
  store float %tmpVar10, float* %SENSOR_INT, align 4
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  %SENSOR_INT_ret = load float, float* %SENSOR_INT, align 4
  ret float %SENSOR_INT_ret
}

define float @TEMP_NI(%TEMP_NI_interface* %0) {
entry:
  %Res = getelementptr inbounds %TEMP_NI_interface, %TEMP_NI_interface* %0, i32 0, i32 0
  %R0 = getelementptr inbounds %TEMP_NI_interface, %TEMP_NI_interface* %0, i32 0, i32 1
  %TEMP_NI = alloca float, align 4
  store float 0.000000e+00, float* %TEMP_NI, align 4
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_R0 = load float, float* %R0, align 4
  %load_Res = load float, float* %Res, align 4
  %tmpVar = fsub float %load_R0, %load_Res
  %tmpVar1 = fmul float 0x3F65CA6CA0000000, %tmpVar
  %tmpVar2 = fsub float 0x3FD34129C0000000, %tmpVar1
  %2 = fptosi float %tmpVar2 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call3 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar4 = fsub double %call3, 5.485000e-01
  %tmpVar5 = fmul double %tmpVar4, 0x40877F099FBBF28A
  %3 = fptrunc double %tmpVar5 to float
  store float %3, float* %TEMP_NI, align 4
  %TEMP_NI_ret = load float, float* %TEMP_NI, align 4
  ret float %TEMP_NI_ret
}

define float @TEMP_NTC(%TEMP_NTC_interface* %0) {
entry:
  %RES = getelementptr inbounds %TEMP_NTC_interface, %TEMP_NTC_interface* %0, i32 0, i32 0
  %RN = getelementptr inbounds %TEMP_NTC_interface, %TEMP_NTC_interface* %0, i32 0, i32 1
  %B = getelementptr inbounds %TEMP_NTC_interface, %TEMP_NTC_interface* %0, i32 0, i32 2
  %TEMP_NTC = alloca float, align 4
  store float 0.000000e+00, float* %TEMP_NTC, align 4
  %load_res = load float, float* %RES, align 4
  %tmpVar = fcmp ogt float %load_res, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %load_B = load float, float* %B, align 4
  %tmpVar1 = fmul float %load_B, 0x4072A26660000000
  %1 = fpext float %tmpVar1 to double
  %load_B2 = load float, float* %B, align 4
  %2 = fpext float %load_B2 to double
  %LN_instance = alloca %LN_interface, align 8
  br label %input

continue:                                         ; preds = %continue3, %entry
  %TEMP_NTC_ret = load float, float* %TEMP_NTC, align 4
  ret float %TEMP_NTC_ret

input:                                            ; preds = %condition_body
  %3 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %load_RES = load float, float* %RES, align 4
  %load_RN = load float, float* %RN, align 4
  %tmpVar4 = fdiv float %load_RES, %load_RN
  %4 = fptosi float %tmpVar4 to i32
  store i32 %4, i32* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call5 = call double @LN(%LN_interface* %LN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  %tmpVar6 = fmul double %call5, 2.981500e+02
  %tmpVar7 = fadd double %2, %tmpVar6
  %tmpVar8 = fdiv double %1, %tmpVar7
  %tmpVar9 = fsub double %tmpVar8, 2.731500e+02
  %5 = fptrunc double %tmpVar9 to float
  store float %5, float* %TEMP_NTC, align 4
  br label %continue
}

define float @TEMP_PT(%TEMP_PT_interface* %0) {
entry:
  %Res = getelementptr inbounds %TEMP_PT_interface, %TEMP_PT_interface* %0, i32 0, i32 0
  %R0 = getelementptr inbounds %TEMP_PT_interface, %TEMP_PT_interface* %0, i32 0, i32 1
  %A = getelementptr inbounds %TEMP_PT_interface, %TEMP_PT_interface* %0, i32 0, i32 2
  %B = getelementptr inbounds %TEMP_PT_interface, %TEMP_PT_interface* %0, i32 0, i32 3
  %accuracy = getelementptr inbounds %TEMP_PT_interface, %TEMP_PT_interface* %0, i32 0, i32 4
  %step = getelementptr inbounds %TEMP_PT_interface, %TEMP_PT_interface* %0, i32 0, i32 5
  %X = getelementptr inbounds %TEMP_PT_interface, %TEMP_PT_interface* %0, i32 0, i32 6
  %Y = getelementptr inbounds %TEMP_PT_interface, %TEMP_PT_interface* %0, i32 0, i32 7
  %t1 = getelementptr inbounds %TEMP_PT_interface, %TEMP_PT_interface* %0, i32 0, i32 8
  %pt = getelementptr inbounds %TEMP_PT_interface, %TEMP_PT_interface* %0, i32 0, i32 9
  %TEMP_PT = alloca float, align 4
  store float 0x3F70022640000000, float* %A, align 4
  store float 0xBEA360AFE0000000, float* %B, align 4
  store float 0x3F847AE140000000, float* %accuracy, align 4
  store float 5.000000e+01, float* %step, align 4
  store float 0.000000e+00, float* %X, align 4
  store float 0.000000e+00, float* %Y, align 4
  store float 0.000000e+00, float* %t1, align 4
  store i32* null, i32** %pt, align 8
  store float 0.000000e+00, float* %TEMP_PT, align 4
  %load_A = load float, float* %A, align 4
  %load_R0 = load float, float* %R0, align 4
  %tmpVar = fmul float %load_A, %load_R0
  store float %tmpVar, float* %X, align 4
  %load_B = load float, float* %B, align 4
  %load_R01 = load float, float* %R0, align 4
  %tmpVar2 = fmul float %load_B, %load_R01
  store float %tmpVar2, float* %Y, align 4
  %load_Res = load float, float* %Res, align 4
  %load_R03 = load float, float* %R0, align 4
  %tmpVar4 = fcmp oge float %load_Res, %load_R03
  br i1 %tmpVar4, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_X = load float, float* %X, align 4
  %load_X5 = load float, float* %X, align 4
  %tmpVar6 = fmul float %load_X, %load_X5
  %load_Y = load float, float* %Y, align 4
  %tmpVar7 = fmul float 4.000000e+00, %load_Y
  %load_R08 = load float, float* %R0, align 4
  %load_Res9 = load float, float* %Res, align 4
  %tmpVar10 = fsub float %load_R08, %load_Res9
  %tmpVar11 = fmul float %tmpVar7, %tmpVar10
  %tmpVar12 = fsub float %tmpVar6, %tmpVar11
  store float %tmpVar12, float* %t1, align 4
  %load_t1 = load float, float* %t1, align 4
  %tmpVar16 = fcmp olt float %load_t1, 0.000000e+00
  br i1 %tmpVar16, label %condition_body15, label %else13

else:                                             ; preds = %entry
  store float* %step, i32** %pt, align 8
  store float -1.000000e+02, float* %TEMP_PT, align 4
  br label %condition_check

continue:                                         ; preds = %continue26, %continue14
  %TEMP_PT_ret = load float, float* %TEMP_PT, align 4
  ret float %TEMP_PT_ret

condition_body15:                                 ; preds = %condition_body
  store float 1.000000e+04, float* %TEMP_PT, align 4
  br label %continue14

else13:                                           ; preds = %condition_body
  %load_X17 = load float, float* %X, align 4
  %tmpVar18 = fneg float %load_X17
  %1 = fpext float %tmpVar18 to double
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input

continue14:                                       ; preds = %continue19, %condition_body15
  br label %continue

input:                                            ; preds = %else13
  %2 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_t120 = load float, float* %t1, align 4
  %3 = fptosi float %load_t120 to i32
  store i32 %3, i32* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call21 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue19

continue19:                                       ; preds = %output
  %tmpVar22 = fadd double %1, %call21
  %load_Y23 = load float, float* %Y, align 4
  %tmpVar24 = fmul float 2.000000e+00, %load_Y23
  %4 = fpext float %tmpVar24 to double
  %tmpVar25 = fdiv double %tmpVar22, %4
  %5 = fptrunc double %tmpVar25 to float
  store float %5, float* %TEMP_PT, align 4
  br label %continue14

condition_check:                                  ; preds = %else, %continue29
  %load_step = load float, float* %step, align 4
  %load_accuracy = load float, float* %accuracy, align 4
  %tmpVar27 = fcmp ogt float %load_step, %load_accuracy
  br i1 %tmpVar27, label %while_body, label %continue26

while_body:                                       ; preds = %condition_check
  %RES_PT_instance = alloca %RES_PT_interface, align 8
  br label %input31

continue26:                                       ; preds = %condition_check
  br label %continue

condition_body30:                                 ; preds = %continue34
  %load_TEMP_PT38 = load float, float* %TEMP_PT, align 4
  %load_step39 = load float, float* %step, align 4
  %tmpVar40 = fadd float %load_TEMP_PT38, %load_step39
  store float %tmpVar40, float* %TEMP_PT, align 4
  br label %continue29

else28:                                           ; preds = %continue34
  %load_TEMP_PT41 = load float, float* %TEMP_PT, align 4
  %load_step42 = load float, float* %step, align 4
  %tmpVar43 = fsub float %load_TEMP_PT41, %load_step42
  store float %tmpVar43, float* %TEMP_PT, align 4
  br label %continue29

continue29:                                       ; preds = %else28, %condition_body30
  %deref = load i32*, i32** %pt, align 8
  %deref44 = load i32*, i32** %pt, align 8
  %load_tmpVar = load i32, i32* %deref44, align 4
  %tmpVar45 = sub i32 %load_tmpVar, 8388608
  store i32 %tmpVar45, i32* %deref, align 4
  br label %condition_check

input31:                                          ; preds = %while_body
  %6 = getelementptr inbounds %RES_PT_interface, %RES_PT_interface* %RES_PT_instance, i32 0, i32 0
  %load_TEMP_PT = load float, float* %TEMP_PT, align 4
  store float %load_TEMP_PT, float* %6, align 4
  %7 = getelementptr inbounds %RES_PT_interface, %RES_PT_interface* %RES_PT_instance, i32 0, i32 1
  %load_R035 = load float, float* %R0, align 4
  store float %load_R035, float* %7, align 4
  br label %call32

call32:                                           ; preds = %input31
  %call36 = call float @RES_PT(%RES_PT_interface* %RES_PT_instance)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  %load_res = load float, float* %Res, align 4
  %tmpVar37 = fcmp olt float %call36, %load_res
  br i1 %tmpVar37, label %condition_body30, label %else28
}

define float @TEMP_SI(%TEMP_SI_interface* %0) {
entry:
  %Res = getelementptr inbounds %TEMP_SI_interface, %TEMP_SI_interface* %0, i32 0, i32 0
  %RS = getelementptr inbounds %TEMP_SI_interface, %TEMP_SI_interface* %0, i32 0, i32 1
  %TS = getelementptr inbounds %TEMP_SI_interface, %TEMP_SI_interface* %0, i32 0, i32 2
  %TEMP_SI = alloca float, align 4
  store float 0.000000e+00, float* %TEMP_SI, align 4
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_Res = load float, float* %Res, align 4
  %load_RS = load float, float* %RS, align 4
  %tmpVar = fdiv float %load_Res, %load_RS
  %tmpVar1 = fmul float %tmpVar, 0x3F11680760000000
  %tmpVar2 = fsub float %tmpVar1, 0x3EE0D712C0000000
  %2 = fptosi float %tmpVar2 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call3 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar4 = fadd double 0xBF7F4B1EE0000000, %call3
  %tmpVar5 = fmul double %tmpVar4, 0x40DD6A1ED7F0ED3E
  %load_TS = load float, float* %TS, align 4
  %3 = fpext float %load_TS to double
  %tmpVar6 = fadd double %tmpVar5, %3
  %4 = fptrunc double %tmpVar6 to float
  store float %4, float* %TEMP_SI, align 4
  %TEMP_SI_ret = load float, float* %TEMP_SI, align 4
  ret float %TEMP_SI_ret
}

define void @_RMP_B(%_RMP_B_interface* %0) {
entry:
  %DIR = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %0, i32 0, i32 0
  %E = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %0, i32 0, i32 1
  %TR = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %0, i32 0, i32 2
  %RMP = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %0, i32 0, i32 4
  %tl = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %0, i32 0, i32 5
  %tn = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %0, i32 0, i32 6
  %init = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %0, i32 0, i32 7
  %last_dir = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %0, i32 0, i32 8
  %start = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %0, i32 0, i32 9
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_E = load i8, i8* %E, align 1
  %2 = zext i8 %load_E to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %21, label %23

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %6
  %deref15 = load i8*, i8** %RMP, align 8
  %FRMP_B_instance = alloca %FRMP_B_interface, align 8
  br label %input16

else:                                             ; preds = %6
  store i8 1, i8* %init, align 1
  %load_tx24 = load i64, i64* %tx, align 4
  store i64 %load_tx24, i64* %tl, align 4
  %load_tr = load i64, i64* %TR, align 4
  store i64 %load_tr, i64* %tn, align 4
  %deref25 = load i8*, i8** %RMP, align 8
  %load_RMP26 = load i8, i8* %deref25, align 1
  store i8 %load_RMP26, i8* %start, align 1
  br label %continue7

continue7:                                        ; preds = %else, %continue19
  %load_dir27 = load i8, i8* %DIR, align 1
  store i8 %load_dir27, i8* %last_dir, align 1
  ret void

4:                                                ; preds = %11
  %load_TR = load i64, i64* %TR, align 4
  %load_tn = load i64, i64* %tn, align 4
  %tmpVar14 = icmp eq i64 %load_TR, %load_tn
  %5 = zext i1 %tmpVar14 to i32
  br label %6

6:                                                ; preds = %4, %11
  %7 = phi i32 [ %12, %11 ], [ %5, %4 ]
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %condition_body, label %else

9:                                                ; preds = %18
  %deref = load i8*, i8** %RMP, align 8
  %load_RMP = load i8, i8* %deref, align 1
  %10 = zext i8 %load_RMP to i64
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input8

11:                                               ; preds = %continue11, %18
  %12 = phi i32 [ %19, %18 ], [ %29, %continue11 ]
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %4, label %6

14:                                               ; preds = %23
  %load_dir = load i8, i8* %DIR, align 1
  %15 = zext i8 %load_dir to i32
  %load_last_dir = load i8, i8* %last_dir, align 1
  %16 = zext i8 %load_last_dir to i32
  %tmpVar = icmp eq i32 %15, %16
  %17 = zext i1 %tmpVar to i32
  br label %18

18:                                               ; preds = %14, %23
  %19 = phi i32 [ %24, %23 ], [ %17, %14 ]
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %9, label %11

21:                                               ; preds = %continue
  %load_init = load i8, i8* %init, align 1
  %22 = zext i8 %load_init to i32
  br label %23

23:                                               ; preds = %21, %continue
  %24 = phi i32 [ %2, %continue ], [ %22, %21 ]
  %25 = icmp ne i32 %24, 0
  br i1 %25, label %14, label %18

input8:                                           ; preds = %9
  %26 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_DIR = load i8, i8* %DIR, align 1
  store i8 %load_DIR, i8* %26, align 1
  %27 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  store i64 0, i64* %27, align 4
  %28 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  store i64 255, i64* %28, align 4
  br label %call9

call9:                                            ; preds = %input8
  %call12 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %tmpVar13 = icmp ne i64 %10, %call12
  %29 = zext i1 %tmpVar13 to i32
  br label %11

input16:                                          ; preds = %condition_body
  %30 = getelementptr inbounds %FRMP_B_interface, %FRMP_B_interface* %FRMP_B_instance, i32 0, i32 0
  %load_start = load i8, i8* %start, align 1
  store i8 %load_start, i8* %30, align 1
  %31 = getelementptr inbounds %FRMP_B_interface, %FRMP_B_interface* %FRMP_B_instance, i32 0, i32 1
  %load_DIR20 = load i8, i8* %DIR, align 1
  store i8 %load_DIR20, i8* %31, align 1
  %32 = getelementptr inbounds %FRMP_B_interface, %FRMP_B_interface* %FRMP_B_instance, i32 0, i32 2
  %load_tx = load i64, i64* %tx, align 4
  %load_tl = load i64, i64* %tl, align 4
  %tmpVar21 = sub i64 %load_tx, %load_tl
  store i64 %tmpVar21, i64* %32, align 4
  %33 = getelementptr inbounds %FRMP_B_interface, %FRMP_B_interface* %FRMP_B_instance, i32 0, i32 3
  %load_TR22 = load i64, i64* %TR, align 4
  store i64 %load_TR22, i64* %33, align 4
  br label %call17

call17:                                           ; preds = %input16
  %call23 = call i8 @FRMP_B(%FRMP_B_interface* %FRMP_B_instance)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  store i8 %call23, i8* %deref15, align 1
  br label %continue7
}

define void @_RMP_NEXT(%_RMP_NEXT_interface* %0) {
entry:
  %E = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 0
  %IN = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 1
  %TR = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 2
  %TF = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 3
  %TL = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 4
  %DIR = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 5
  %UP = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 6
  %DN = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 7
  %OUT = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 8
  %rmx = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 9
  %dirx = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 10
  %t_lock = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 11
  %xen = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 12
  %xdir = getelementptr inbounds %_RMP_NEXT_interface, %_RMP_NEXT_interface* %0, i32 0, i32 13
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %TREND_DW_interface, %TREND_DW_interface* %dirx, i32 0, i32 0
  %load_in = load i8, i8* %IN, align 1
  %2 = zext i8 %load_in to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  call void @TREND_DW(%TREND_DW_interface* %dirx)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  br label %input1

input1:                                           ; preds = %continue
  %3 = getelementptr inbounds %TP_interface, %TP_interface* %t_lock, i32 0, i32 0
  store i8 0, i8* %3, align 1
  %4 = getelementptr inbounds %TP_interface, %TP_interface* %t_lock, i32 0, i32 1
  %load_TL = load i64, i64* %TL, align 4
  store i64 %load_TL, i64* %4, align 4
  br label %call2

call2:                                            ; preds = %input1
  call void @TP(%TP_interface* %t_lock)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %TU = getelementptr inbounds %TREND_DW_interface, %TREND_DW_interface* %dirx, i32 0, i32 2
  %load_ = load i8, i8* %TU, align 1
  %5 = zext i8 %load_ to i32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %18, label %22

condition_body:                                   ; preds = %22
  %load_xdir = load i8, i8* %xdir, align 1
  %tmpVar9 = xor i8 %load_xdir, -1
  %7 = zext i8 %tmpVar9 to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %25, label %27

branch:                                           ; preds = %22
  %TD = getelementptr inbounds %TREND_DW_interface, %TREND_DW_interface* %dirx, i32 0, i32 3
  %load_15 = load i8, i8* %TD, align 1
  %9 = zext i8 %load_15 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %31, label %35

condition_body14:                                 ; preds = %35
  %load_xdir22 = load i8, i8* %xdir, align 1
  %11 = zext i8 %load_xdir22 to i32
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %38, label %40

branch5:                                          ; preds = %35
  %load_xen29 = load i8, i8* %xen, align 1
  %13 = icmp ne i8 %load_xen29, 0
  br i1 %13, label %condition_body28, label %continue6

condition_body28:                                 ; preds = %branch5
  %load_xdir32 = load i8, i8* %xdir, align 1
  %14 = zext i8 %load_xdir32 to i32
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %50, label %54

continue6:                                        ; preds = %continue30, %branch5, %continue20, %continue7
  %Q = getelementptr inbounds %TP_interface, %TP_interface* %t_lock, i32 0, i32 2
  %load_51 = load i8, i8* %Q, align 1
  %tmpVar52 = xor i8 %load_51, -1
  %16 = zext i8 %tmpVar52 to i32
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %64, label %66

18:                                               ; preds = %continue4
  %deref = load i8*, i8** %OUT, align 8
  %load_OUT = load i8, i8* %deref, align 1
  %19 = zext i8 %load_OUT to i32
  %load_IN = load i8, i8* %IN, align 1
  %20 = zext i8 %load_IN to i32
  %tmpVar = icmp slt i32 %19, %20
  %21 = zext i1 %tmpVar to i32
  br label %22

22:                                               ; preds = %18, %continue4
  %23 = phi i32 [ %5, %continue4 ], [ %21, %18 ]
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %condition_body, label %branch

condition_body8:                                  ; preds = %27
  br label %input10

continue7:                                        ; preds = %continue13, %27
  store i8 1, i8* %xen, align 1
  store i8 1, i8* %xdir, align 1
  br label %continue6

25:                                               ; preds = %condition_body
  %load_xen = load i8, i8* %xen, align 1
  %26 = zext i8 %load_xen to i32
  br label %27

27:                                               ; preds = %25, %condition_body
  %28 = phi i32 [ %7, %condition_body ], [ %26, %25 ]
  %29 = icmp ne i32 %28, 0
  br i1 %29, label %condition_body8, label %continue7

input10:                                          ; preds = %condition_body8
  %30 = getelementptr inbounds %TP_interface, %TP_interface* %t_lock, i32 0, i32 0
  store i8 1, i8* %30, align 1
  br label %call11

call11:                                           ; preds = %input10
  call void @TP(%TP_interface* %t_lock)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  br label %continue7

31:                                               ; preds = %branch
  %deref16 = load i8*, i8** %OUT, align 8
  %load_OUT17 = load i8, i8* %deref16, align 1
  %32 = zext i8 %load_OUT17 to i32
  %load_IN18 = load i8, i8* %IN, align 1
  %33 = zext i8 %load_IN18 to i32
  %tmpVar19 = icmp sgt i32 %32, %33
  %34 = zext i1 %tmpVar19 to i32
  br label %35

35:                                               ; preds = %31, %branch
  %36 = phi i32 [ %9, %branch ], [ %34, %31 ]
  %37 = icmp ne i32 %36, 0
  br i1 %37, label %condition_body14, label %branch5

condition_body21:                                 ; preds = %40
  br label %input24

continue20:                                       ; preds = %continue27, %40
  store i8 1, i8* %xen, align 1
  store i8 0, i8* %xdir, align 1
  br label %continue6

38:                                               ; preds = %condition_body14
  %load_xen23 = load i8, i8* %xen, align 1
  %39 = zext i8 %load_xen23 to i32
  br label %40

40:                                               ; preds = %38, %condition_body14
  %41 = phi i32 [ %11, %condition_body14 ], [ %39, %38 ]
  %42 = icmp ne i32 %41, 0
  br i1 %42, label %condition_body21, label %continue20

input24:                                          ; preds = %condition_body21
  %43 = getelementptr inbounds %TP_interface, %TP_interface* %t_lock, i32 0, i32 0
  store i8 1, i8* %43, align 1
  br label %call25

call25:                                           ; preds = %input24
  call void @TP(%TP_interface* %t_lock)
  br label %output26

output26:                                         ; preds = %call25
  br label %continue27

continue27:                                       ; preds = %output26
  br label %continue20

condition_body31:                                 ; preds = %47
  store i8 0, i8* %xen, align 1
  %load_tl = load i64, i64* %TL, align 4
  %tmpVar44 = icmp sgt i64 %load_tl, 0
  br i1 %tmpVar44, label %condition_body43, label %continue42

continue30:                                       ; preds = %continue42, %47
  br label %continue6

44:                                               ; preds = %54
  %load_xdir36 = load i8, i8* %xdir, align 1
  %tmpVar37 = xor i8 %load_xdir36, -1
  %45 = zext i8 %tmpVar37 to i32
  %46 = icmp ne i32 %45, 0
  br i1 %46, label %57, label %61

47:                                               ; preds = %61, %54
  %48 = phi i32 [ %55, %54 ], [ %62, %61 ]
  %49 = icmp ne i32 %48, 0
  br i1 %49, label %condition_body31, label %continue30

50:                                               ; preds = %condition_body28
  %deref33 = load i8*, i8** %OUT, align 8
  %load_out = load i8, i8* %deref33, align 1
  %51 = zext i8 %load_out to i32
  %load_in34 = load i8, i8* %IN, align 1
  %52 = zext i8 %load_in34 to i32
  %tmpVar35 = icmp sge i32 %51, %52
  %53 = zext i1 %tmpVar35 to i32
  br label %54

54:                                               ; preds = %50, %condition_body28
  %55 = phi i32 [ %14, %condition_body28 ], [ %53, %50 ]
  %56 = icmp ne i32 %55, 0
  br i1 %56, label %47, label %44

57:                                               ; preds = %44
  %deref38 = load i8*, i8** %OUT, align 8
  %load_out39 = load i8, i8* %deref38, align 1
  %58 = zext i8 %load_out39 to i32
  %load_in40 = load i8, i8* %IN, align 1
  %59 = zext i8 %load_in40 to i32
  %tmpVar41 = icmp sle i32 %58, %59
  %60 = zext i1 %tmpVar41 to i32
  br label %61

61:                                               ; preds = %57, %44
  %62 = phi i32 [ %45, %44 ], [ %60, %57 ]
  br label %47

condition_body43:                                 ; preds = %condition_body31
  br label %input45

continue42:                                       ; preds = %continue48, %condition_body31
  br label %continue30

input45:                                          ; preds = %condition_body43
  %63 = getelementptr inbounds %TP_interface, %TP_interface* %t_lock, i32 0, i32 0
  store i8 1, i8* %63, align 1
  br label %call46

call46:                                           ; preds = %input45
  call void @TP(%TP_interface* %t_lock)
  br label %output47

output47:                                         ; preds = %call46
  br label %continue48

continue48:                                       ; preds = %output47
  br label %continue42

condition_body50:                                 ; preds = %66
  %load_XDIR = load i8, i8* %xdir, align 1
  store i8 %load_XDIR, i8* %UP, align 1
  %load_XDIR54 = load i8, i8* %xdir, align 1
  store i8 %load_XDIR54, i8* %DIR, align 1
  %load_XDIR55 = load i8, i8* %xdir, align 1
  %tmpVar56 = xor i8 %load_XDIR55, -1
  store i8 %tmpVar56, i8* %DN, align 1
  br label %continue49

else:                                             ; preds = %66
  store i8 0, i8* %UP, align 1
  store i8 0, i8* %DN, align 1
  br label %continue49

continue49:                                       ; preds = %else, %condition_body50
  br label %input57

64:                                               ; preds = %continue6
  %load_xen53 = load i8, i8* %xen, align 1
  %65 = zext i8 %load_xen53 to i32
  br label %66

66:                                               ; preds = %64, %continue6
  %67 = phi i32 [ %16, %continue6 ], [ %65, %64 ]
  %68 = icmp ne i32 %67, 0
  br i1 %68, label %condition_body50, label %else

input57:                                          ; preds = %continue49
  %69 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmx, i32 0, i32 3
  %deref61 = load i8*, i8** %OUT, align 8
  store i8* %deref61, i8** %69, align 8
  %70 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmx, i32 0, i32 1
  %load_E = load i8, i8* %E, align 1
  %71 = zext i8 %load_E to i32
  %72 = icmp ne i32 %71, 0
  br i1 %72, label %75, label %78
  %73 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmx, i32 0, i32 0
  %load_DIR = load i8, i8* %DIR, align 1
  store i8 %load_DIR, i8* %73, align 1
  %74 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmx, i32 0, i32 2
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input62

call58:                                           ; preds = %continue65
  call void @_RMP_B(%_RMP_B_interface* %rmx)
  br label %output59

output59:                                         ; preds = %call58
  br label %continue60

continue60:                                       ; preds = %output59
  ret void

75:                                               ; preds = %input57
  %load_UP = load i8, i8* %UP, align 1
  %76 = zext i8 %load_UP to i32
  %77 = icmp ne i32 %76, 0
  br i1 %77, label %82, label %80

78:                                               ; preds = %82, %input57
  %79 = phi i32 [ %71, %input57 ], [ %83, %82 ]
  store i32 %79, i8* %70, align 4

80:                                               ; preds = %75
  %load_DN = load i8, i8* %DN, align 1
  %81 = zext i8 %load_DN to i32
  br label %82

82:                                               ; preds = %80, %75
  %83 = phi i32 [ %76, %75 ], [ %81, %80 ]
  br label %78

input62:                                          ; preds = %input57
  %84 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_dir = load i8, i8* %DIR, align 1
  store i8 %load_dir, i8* %84, align 1
  %85 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_TF = load i64, i64* %TF, align 4
  store i64 %load_TF, i64* %85, align 4
  %86 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_TR = load i64, i64* %TR, align 4
  store i64 %load_TR, i64* %86, align 4
  br label %call63

call63:                                           ; preds = %input62
  %call66 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output64

output64:                                         ; preds = %call63
  br label %continue65

continue65:                                       ; preds = %output64
  store i64 %call66, i64* %74, align 4
  br label %call58
}

define void @_RMP_W(%_RMP_W_interface* %0) {
entry:
  %DIR = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %0, i32 0, i32 0
  %E = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %0, i32 0, i32 1
  %TR = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %0, i32 0, i32 2
  %RMP = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %0, i32 0, i32 4
  %tl = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %0, i32 0, i32 5
  %step = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %0, i32 0, i32 6
  %init = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %0, i32 0, i32 7
  %last_dir = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %0, i32 0, i32 8
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_E = load i8, i8* %E, align 1
  %1 = zext i8 %load_E to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %6, label %8

condition_body:                                   ; preds = %8
  %load_dir = load i8, i8* %DIR, align 1
  %3 = zext i8 %load_dir to i32
  %load_last_dir = load i8, i8* %last_dir, align 1
  %4 = zext i8 %load_last_dir to i32
  %tmpVar = xor i32 %3, %4
  %5 = icmp ne i32 %tmpVar, 0
  br i1 %5, label %condition_body4, label %continue3

else:                                             ; preds = %8
  %load_tx56 = load i32, i32* %tx, align 4
  store i32 %load_tx56, i32* %tl, align 4
  store i8 1, i8* %init, align 1
  br label %continue2

continue2:                                        ; preds = %else, %continue28
  ret void

6:                                                ; preds = %continue
  %load_init = load i8, i8* %init, align 1
  %7 = zext i8 %load_init to i32
  br label %8

8:                                                ; preds = %6, %continue
  %9 = phi i32 [ %1, %continue ], [ %7, %6 ]
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %condition_body, label %else

condition_body4:                                  ; preds = %condition_body
  %load_tx = load i32, i32* %tx, align 4
  store i32 %load_tx, i32* %tl, align 4
  %load_dir5 = load i8, i8* %DIR, align 1
  store i8 %load_dir5, i8* %last_dir, align 1
  br label %continue3

continue3:                                        ; preds = %condition_body4, %condition_body
  %load_tr = load i64, i64* %TR, align 4
  %tmpVar9 = icmp sgt i64 %load_tr, 0
  br i1 %tmpVar9, label %condition_body8, label %else6

condition_body8:                                  ; preds = %continue3
  %DWORD_TO_DINT_instance = alloca %DWORD_TO_DINT_interface, align 8
  br label %input10

else6:                                            ; preds = %continue3
  store i32 65535, i32* %step, align 4
  br label %continue7

continue7:                                        ; preds = %else6, %continue13
  %load_step = load i32, i32* %step, align 4
  %tmpVar30 = icmp sgt i32 %load_step, 0
  br i1 %tmpVar30, label %condition_body29, label %continue28

input10:                                          ; preds = %condition_body8
  %11 = getelementptr inbounds %DWORD_TO_DINT_interface, %DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance, i32 0, i32 0
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input14

call11:                                           ; preds = %continue24
  %call27 = call i32 @DWORD_TO_DINT(%DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  store i32 %call27, i32* %step, align 4
  br label %continue7

input14:                                          ; preds = %input10
  %12 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_tx18 = load i32, i32* %tx, align 4
  %load_tl = load i32, i32* %tl, align 4
  %tmpVar19 = sub i32 %load_tx18, %load_tl
  %13 = sext i32 %tmpVar19 to i64
  store i64 %13, i64* %12, align 4
  %14 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 16, i16* %14, align 2
  br label %call15

call15:                                           ; preds = %input14
  %call20 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input21

input21:                                          ; preds = %continue17
  %15 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_TR = load i64, i64* %TR, align 4
  store i64 %load_TR, i64* %15, align 4
  br label %call22

call22:                                           ; preds = %input21
  %call25 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %16 = zext i32 %call25 to i64
  %tmpVar26 = sdiv i64 %call20, %16
  %17 = trunc i64 %tmpVar26 to i32
  store i32 %17, i32* %11, align 4
  br label %call11

condition_body29:                                 ; preds = %continue7
  %load_tx31 = load i32, i32* %tx, align 4
  store i32 %load_tx31, i32* %tl, align 4
  %load_dir34 = load i8, i8* %DIR, align 1
  %tmpVar35 = xor i8 %load_dir34, -1
  %18 = icmp ne i8 %tmpVar35, 0
  br i1 %18, label %condition_body33, label %continue32

continue28:                                       ; preds = %continue41, %continue7
  br label %continue2

condition_body33:                                 ; preds = %condition_body29
  %load_step36 = load i32, i32* %step, align 4
  %tmpVar37 = sub i32 0, %load_step36
  store i32 %tmpVar37, i32* %step, align 4
  br label %continue32

continue32:                                       ; preds = %condition_body33, %condition_body29
  %deref = load i16*, i16** %RMP, align 8
  %DINT_TO_WORD_instance = alloca %DINT_TO_WORD_interface, align 8
  br label %input38

input38:                                          ; preds = %continue32
  %19 = getelementptr inbounds %DINT_TO_WORD_interface, %DINT_TO_WORD_interface* %DINT_TO_WORD_instance, i32 0, i32 0
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input42

call39:                                           ; preds = %continue45
  %call55 = call i16 @DINT_TO_WORD(%DINT_TO_WORD_interface* %DINT_TO_WORD_instance)
  br label %output40

output40:                                         ; preds = %call39
  br label %continue41

continue41:                                       ; preds = %output40
  store i16 %call55, i16* %deref, align 2
  br label %continue28

input42:                                          ; preds = %input38
  %20 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %20, align 4
  %21 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %WORD_TO_DINT_instance = alloca %WORD_TO_DINT_interface, align 8
  br label %input46

call43:                                           ; preds = %continue49
  %call54 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output44

output44:                                         ; preds = %call43
  br label %continue45

continue45:                                       ; preds = %output44
  %22 = trunc i64 %call54 to i32
  store i32 %22, i32* %19, align 4
  br label %call39

input46:                                          ; preds = %input42
  %23 = getelementptr inbounds %WORD_TO_DINT_interface, %WORD_TO_DINT_interface* %WORD_TO_DINT_instance, i32 0, i32 0
  %deref50 = load i16*, i16** %RMP, align 8
  %load_rmp = load i16, i16* %deref50, align 2
  store i16 %load_rmp, i16* %23, align 2
  br label %call47

call47:                                           ; preds = %input46
  %call51 = call i32 @WORD_TO_DINT(%WORD_TO_DINT_interface* %WORD_TO_DINT_instance)
  br label %output48

output48:                                         ; preds = %call47
  br label %continue49

continue49:                                       ; preds = %output48
  %load_step52 = load i32, i32* %step, align 4
  %tmpVar53 = add i32 %call51, %load_step52
  %24 = sext i32 %tmpVar53 to i64
  store i64 %24, i64* %21, align 4
  %25 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 65535, i64* %25, align 4
  br label %call43
}

define void @GEN_PULSE(%GEN_PULSE_interface* %0) {
entry:
  %ENQ = getelementptr inbounds %GEN_PULSE_interface, %GEN_PULSE_interface* %0, i32 0, i32 0
  %PTH = getelementptr inbounds %GEN_PULSE_interface, %GEN_PULSE_interface* %0, i32 0, i32 1
  %PTL = getelementptr inbounds %GEN_PULSE_interface, %GEN_PULSE_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %GEN_PULSE_interface, %GEN_PULSE_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %GEN_PULSE_interface, %GEN_PULSE_interface* %0, i32 0, i32 4
  %tn = getelementptr inbounds %GEN_PULSE_interface, %GEN_PULSE_interface* %0, i32 0, i32 5
  %init = getelementptr inbounds %GEN_PULSE_interface, %GEN_PULSE_interface* %0, i32 0, i32 6
  %load_enq = load i8, i8* %ENQ, align 1
  %1 = icmp ne i8 %load_enq, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

else:                                             ; preds = %entry
  store i8 0, i8* %Q, align 1
  store i8 0, i8* %init, align 1
  br label %continue

continue:                                         ; preds = %else, %continue10
  ret void

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input2

call:                                             ; preds = %continue5
  %call7 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store i64 %call7, i64* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %3 = icmp ne i8 %tmpVar, 0
  br i1 %3, label %condition_body9, label %continue8

input2:                                           ; preds = %input
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i32 %call6, i32* %2, align 4
  br label %call

condition_body9:                                  ; preds = %continue1
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %tn, align 4
  br label %continue8

continue8:                                        ; preds = %condition_body9, %continue1
  %load_tx12 = load i64, i64* %tx, align 4
  %load_tn = load i64, i64* %tn, align 4
  %tmpVar13 = sub i64 %load_tx12, %load_tn
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input14

condition_body11:                                 ; preds = %continue17
  %load_tn20 = load i64, i64* %tn, align 4
  %SEL_instance21 = alloca %SEL_interface, align 8
  br label %input22

continue10:                                       ; preds = %continue25, %continue17
  br label %continue

input14:                                          ; preds = %continue8
  %4 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_Q = load i8, i8* %Q, align 1
  store i8 %load_Q, i8* %4, align 1
  %5 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_PTL = load i64, i64* %PTL, align 4
  store i64 %load_PTL, i64* %5, align 4
  %6 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_PTH = load i64, i64* %PTH, align 4
  store i64 %load_PTH, i64* %6, align 4
  br label %call15

call15:                                           ; preds = %input14
  %call18 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %tmpVar19 = icmp sge i64 %tmpVar13, %call18
  br i1 %tmpVar19, label %condition_body11, label %continue10

input22:                                          ; preds = %condition_body11
  %7 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance21, i32 0, i32 0
  %load_Q26 = load i8, i8* %Q, align 1
  store i8 %load_Q26, i8* %7, align 1
  %8 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance21, i32 0, i32 1
  %load_PTL27 = load i64, i64* %PTL, align 4
  store i64 %load_PTL27, i64* %8, align 4
  %9 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance21, i32 0, i32 2
  %load_PTH28 = load i64, i64* %PTH, align 4
  store i64 %load_PTH28, i64* %9, align 4
  br label %call23

call23:                                           ; preds = %input22
  %call29 = call i64 @SEL(%SEL_interface* %SEL_instance21)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %tmpVar30 = add i64 %load_tn20, %call29
  store i64 %tmpVar30, i64* %tn, align 4
  %load_Q31 = load i8, i8* %Q, align 1
  %tmpVar32 = xor i8 %load_Q31, -1
  store i8 %tmpVar32, i8* %Q, align 1
  br label %continue10
}

define void @GEN_PW2(%GEN_PW2_interface* %0) {
entry:
  %ENQ = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 0
  %TH1 = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 1
  %TL1 = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 2
  %TH2 = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 3
  %TL2 = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 4
  %TS = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 5
  %Q = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 6
  %TH = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 7
  %TL = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 8
  %t_high = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 9
  %t_low = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 10
  %tx = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 11
  %start = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 12
  %init = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 13
  %et = getelementptr inbounds %GEN_PW2_interface, %GEN_PW2_interface* %0, i32 0, i32 14
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar, 0
  br i1 %2, label %condition_body, label %continue7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %start, align 4
  store i8 1, i8* %init, align 1
  store i64 0, i64* %TH, align 4
  store i64 0, i64* %TL, align 4
  br label %continue7

continue7:                                        ; preds = %condition_body, %continue
  %load_TS = load i8, i8* %TS, align 1
  %3 = icmp ne i8 %load_TS, 0
  br i1 %3, label %condition_body9, label %else

condition_body9:                                  ; preds = %continue7
  %load_TH2 = load i64, i64* %TH2, align 4
  store i64 %load_TH2, i64* %t_high, align 4
  %load_TL2 = load i64, i64* %TL2, align 4
  store i64 %load_TL2, i64* %t_low, align 4
  br label %continue8

else:                                             ; preds = %continue7
  %load_TH1 = load i64, i64* %TH1, align 4
  store i64 %load_TH1, i64* %t_high, align 4
  %load_TL1 = load i64, i64* %TL1, align 4
  store i64 %load_TL1, i64* %t_low, align 4
  br label %continue8

continue8:                                        ; preds = %else, %condition_body9
  %load_ENQ = load i8, i8* %ENQ, align 1
  %4 = icmp ne i8 %load_ENQ, 0
  br i1 %4, label %condition_body12, label %else10

condition_body12:                                 ; preds = %continue8
  %load_tx13 = load i64, i64* %tx, align 4
  %load_start = load i64, i64* %start, align 4
  %tmpVar14 = sub i64 %load_tx13, %load_start
  store i64 %tmpVar14, i64* %et, align 4
  %load_Q = load i8, i8* %Q, align 1
  %tmpVar18 = xor i8 %load_Q, -1
  %5 = icmp ne i8 %tmpVar18, 0
  br i1 %5, label %condition_body17, label %else15

else10:                                           ; preds = %continue8
  store i8 0, i8* %Q, align 1
  store i64 0, i64* %TH, align 4
  store i64 0, i64* %TL, align 4
  %load_tx32 = load i64, i64* %tx, align 4
  store i64 %load_tx32, i64* %start, align 4
  br label %continue11

continue11:                                       ; preds = %else10, %continue16
  ret void

condition_body17:                                 ; preds = %condition_body12
  %load_et = load i64, i64* %et, align 4
  %load_t_low = load i64, i64* %t_low, align 4
  %tmpVar22 = icmp sge i64 %load_et, %load_t_low
  br i1 %tmpVar22, label %condition_body21, label %else19

else15:                                           ; preds = %condition_body12
  %load_et28 = load i64, i64* %et, align 4
  %load_t_high = load i64, i64* %t_high, align 4
  %tmpVar29 = icmp sge i64 %load_et28, %load_t_high
  br i1 %tmpVar29, label %condition_body27, label %else25

continue16:                                       ; preds = %continue26, %continue20
  br label %continue11

condition_body21:                                 ; preds = %condition_body17
  store i8 1, i8* %Q, align 1
  %load_tx23 = load i64, i64* %tx, align 4
  store i64 %load_tx23, i64* %start, align 4
  store i64 0, i64* %TL, align 4
  br label %continue20

else19:                                           ; preds = %condition_body17
  %load_et24 = load i64, i64* %et, align 4
  store i64 %load_et24, i64* %TL, align 4
  br label %continue20

continue20:                                       ; preds = %else19, %condition_body21
  br label %continue16

condition_body27:                                 ; preds = %else15
  store i8 0, i8* %Q, align 1
  %load_tx30 = load i64, i64* %tx, align 4
  store i64 %load_tx30, i64* %start, align 4
  store i64 0, i64* %TH, align 4
  br label %continue26

else25:                                           ; preds = %else15
  %load_et31 = load i64, i64* %et, align 4
  store i64 %load_et31, i64* %TH, align 4
  br label %continue26

continue26:                                       ; preds = %else25, %condition_body27
  br label %continue16
}

define void @GEN_RDM(%GEN_RDM_interface* %0) {
entry:
  %PT = getelementptr inbounds %GEN_RDM_interface, %GEN_RDM_interface* %0, i32 0, i32 0
  %AM = getelementptr inbounds %GEN_RDM_interface, %GEN_RDM_interface* %0, i32 0, i32 1
  %OS = getelementptr inbounds %GEN_RDM_interface, %GEN_RDM_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %GEN_RDM_interface, %GEN_RDM_interface* %0, i32 0, i32 3
  %Out = getelementptr inbounds %GEN_RDM_interface, %GEN_RDM_interface* %0, i32 0, i32 4
  %tx = getelementptr inbounds %GEN_RDM_interface, %GEN_RDM_interface* %0, i32 0, i32 5
  %last = getelementptr inbounds %GEN_RDM_interface, %GEN_RDM_interface* %0, i32 0, i32 6
  %init = getelementptr inbounds %GEN_RDM_interface, %GEN_RDM_interface* %0, i32 0, i32 7
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_last = load i64, i64* %last, align 4
  %tmpVar = sub i64 %call6, %load_last
  store i64 %tmpVar, i64* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar8 = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar8, 0
  br i1 %2, label %condition_body, label %continue7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  store i64 0, i64* %tx, align 4
  br label %continue7

continue7:                                        ; preds = %condition_body, %continue
  %load_tx11 = load i64, i64* %tx, align 4
  %load_pt = load i64, i64* %PT, align 4
  %tmpVar12 = icmp sge i64 %load_tx11, %load_pt
  br i1 %tmpVar12, label %condition_body10, label %else

condition_body10:                                 ; preds = %continue7
  %load_last13 = load i64, i64* %last, align 4
  %load_pt14 = load i64, i64* %PT, align 4
  %tmpVar15 = add i64 %load_last13, %load_pt14
  store i64 %tmpVar15, i64* %last, align 4
  %load_tx16 = load i64, i64* %tx, align 4
  %load_pt17 = load i64, i64* %PT, align 4
  %tmpVar18 = sub i64 %load_tx16, %load_pt17
  store i64 %tmpVar18, i64* %tx, align 4
  %load_am = load float, float* %AM, align 4
  %RDM_instance = alloca %RDM_interface, align 8
  br label %input19

else:                                             ; preds = %continue7
  store i8 0, i8* %Q, align 1
  br label %continue9

continue9:                                        ; preds = %else, %continue22
  ret void

input19:                                          ; preds = %condition_body10
  %3 = getelementptr inbounds %RDM_interface, %RDM_interface* %RDM_instance, i32 0, i32 0
  store float 0.000000e+00, float* %3, align 4
  br label %call20

call20:                                           ; preds = %input19
  %call23 = call float @RDM(%RDM_interface* %RDM_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  %tmpVar24 = fsub float %call23, 5.000000e-01
  %tmpVar25 = fmul float %load_am, %tmpVar24
  %load_os = load float, float* %OS, align 4
  %tmpVar26 = fadd float %tmpVar25, %load_os
  store float %tmpVar26, float* %Out, align 4
  store i8 1, i8* %Q, align 1
  br label %continue9
}

define void @GEN_RDT(%GEN_RDT_interface* %0) {
entry:
  %Enable = getelementptr inbounds %GEN_RDT_interface, %GEN_RDT_interface* %0, i32 0, i32 0
  %Min_Time_ms = getelementptr inbounds %GEN_RDT_interface, %GEN_RDT_interface* %0, i32 0, i32 1
  %Max_Time_ms = getelementptr inbounds %GEN_RDT_interface, %GEN_RDT_interface* %0, i32 0, i32 2
  %TP_Q = getelementptr inbounds %GEN_RDT_interface, %GEN_RDT_interface* %0, i32 0, i32 3
  %xQ = getelementptr inbounds %GEN_RDT_interface, %GEN_RDT_interface* %0, i32 0, i32 4
  %tonRDMTimer = getelementptr inbounds %GEN_RDT_interface, %GEN_RDT_interface* %0, i32 0, i32 5
  %tof_xQ = getelementptr inbounds %GEN_RDT_interface, %GEN_RDT_interface* %0, i32 0, i32 6
  %tRDMTime = getelementptr inbounds %GEN_RDT_interface, %GEN_RDT_interface* %0, i32 0, i32 7
  %rRDMTime = getelementptr inbounds %GEN_RDT_interface, %GEN_RDT_interface* %0, i32 0, i32 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %TON_interface, %TON_interface* %tonRDMTimer, i32 0, i32 0
  %load_Enable = load i8, i8* %Enable, align 1
  store i8 %load_Enable, i8* %1, align 1
  %2 = getelementptr inbounds %TON_interface, %TON_interface* %tonRDMTimer, i32 0, i32 1
  %load_tRDMTime = load i64, i64* %tRDMTime, align 4
  store i64 %load_tRDMTime, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  call void @TON(%TON_interface* %tonRDMTimer)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  br label %input1

input1:                                           ; preds = %continue
  %3 = getelementptr inbounds %TOF_interface, %TOF_interface* %tof_xQ, i32 0, i32 0
  %Q = getelementptr inbounds %TON_interface, %TON_interface* %tonRDMTimer, i32 0, i32 2
  %load_ = load i8, i8* %Q, align 1
  store i8 %load_, i8* %3, align 1
  %4 = getelementptr inbounds %TOF_interface, %TOF_interface* %tof_xQ, i32 0, i32 1
  %load_TP_Q = load i64, i64* %TP_Q, align 4
  store i64 %load_TP_Q, i64* %4, align 4
  br label %call2

call2:                                            ; preds = %input1
  call void @TOF(%TOF_interface* %tof_xQ)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %Q5 = getelementptr inbounds %TOF_interface, %TOF_interface* %tof_xQ, i32 0, i32 2
  %load_6 = load i8, i8* %Q5, align 1
  store i8 %load_6, i8* %xQ, align 1
  %Q8 = getelementptr inbounds %TON_interface, %TON_interface* %tonRDMTimer, i32 0, i32 2
  %load_9 = load i8, i8* %Q8, align 1
  %5 = icmp ne i8 %load_9, 0
  br i1 %5, label %condition_body, label %continue7

condition_body:                                   ; preds = %continue4
  store i8 1, i8* %xQ, align 1
  %RDM_instance = alloca %RDM_interface, align 8
  br label %input10

continue7:                                        ; preds = %continue43, %continue4
  ret void

input10:                                          ; preds = %condition_body
  %6 = getelementptr inbounds %RDM_interface, %RDM_interface* %RDM_instance, i32 0, i32 0
  %load_rRDMTime = load float, float* %rRDMTime, align 4
  store float %load_rRDMTime, float* %6, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call14 = call float @RDM(%RDM_interface* %RDM_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  store float %call14, float* %rRDMTime, align 4
  %REAL_TO_TIME_instance = alloca %REAL_TO_TIME_interface, align 8
  br label %input15

input15:                                          ; preds = %continue13
  %7 = getelementptr inbounds %REAL_TO_TIME_interface, %REAL_TO_TIME_interface* %REAL_TO_TIME_instance, i32 0, i32 0
  %load_rRDMTime19 = load float, float* %rRDMTime, align 4
  %DINT_TO_REAL_instance = alloca %DINT_TO_REAL_interface, align 8
  br label %input20

call16:                                           ; preds = %continue23
  %call39 = call i64 @REAL_TO_TIME(%REAL_TO_TIME_interface* %REAL_TO_TIME_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  store i64 %call39, i64* %tRDMTime, align 4
  br label %input40

input20:                                          ; preds = %input15
  %8 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance, i32 0, i32 0
  %TIME_TO_DINT_instance = alloca %TIME_TO_DINT_interface, align 8
  br label %input24

call21:                                           ; preds = %continue33
  %call37 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance)
  br label %output22

output22:                                         ; preds = %call21
  br label %continue23

continue23:                                       ; preds = %output22
  %tmpVar38 = fmul float %load_rRDMTime19, %call37
  store float %tmpVar38, float* %7, align 4
  br label %call16

input24:                                          ; preds = %input20
  %9 = getelementptr inbounds %TIME_TO_DINT_interface, %TIME_TO_DINT_interface* %TIME_TO_DINT_instance, i32 0, i32 0
  %load_Max_Time_ms = load i64, i64* %Max_Time_ms, align 4
  %load_Min_Time_ms = load i64, i64* %Min_Time_ms, align 4
  %tmpVar = sub i64 %load_Max_Time_ms, %load_Min_Time_ms
  store i64 %tmpVar, i64* %9, align 4
  br label %call25

call25:                                           ; preds = %input24
  %call28 = call i32 @TIME_TO_DINT(%TIME_TO_DINT_interface* %TIME_TO_DINT_instance)
  br label %output26

output26:                                         ; preds = %call25
  br label %continue27

continue27:                                       ; preds = %output26
  %TIME_TO_DINT_instance29 = alloca %TIME_TO_DINT_interface, align 8
  br label %input30

input30:                                          ; preds = %continue27
  %10 = getelementptr inbounds %TIME_TO_DINT_interface, %TIME_TO_DINT_interface* %TIME_TO_DINT_instance29, i32 0, i32 0
  %load_Min_Time_ms34 = load i64, i64* %Min_Time_ms, align 4
  store i64 %load_Min_Time_ms34, i64* %10, align 4
  br label %call31

call31:                                           ; preds = %input30
  %call35 = call i32 @TIME_TO_DINT(%TIME_TO_DINT_interface* %TIME_TO_DINT_instance29)
  br label %output32

output32:                                         ; preds = %call31
  br label %continue33

continue33:                                       ; preds = %output32
  %tmpVar36 = add i32 %call28, %call35
  store i32 %tmpVar36, i32* %8, align 4
  br label %call21

input40:                                          ; preds = %continue18
  %11 = getelementptr inbounds %TON_interface, %TON_interface* %tonRDMTimer, i32 0, i32 0
  store i8 0, i8* %11, align 1
  br label %call41

call41:                                           ; preds = %input40
  call void @TON(%TON_interface* %tonRDMTimer)
  br label %output42

output42:                                         ; preds = %call41
  br label %continue43

continue43:                                       ; preds = %output42
  br label %continue7
}

define void @GEN_RMP(%GEN_RMP_interface* %0) {
entry:
  %PT = getelementptr inbounds %GEN_RMP_interface, %GEN_RMP_interface* %0, i32 0, i32 0
  %AM = getelementptr inbounds %GEN_RMP_interface, %GEN_RMP_interface* %0, i32 0, i32 1
  %OS = getelementptr inbounds %GEN_RMP_interface, %GEN_RMP_interface* %0, i32 0, i32 2
  %DL = getelementptr inbounds %GEN_RMP_interface, %GEN_RMP_interface* %0, i32 0, i32 3
  %Q = getelementptr inbounds %GEN_RMP_interface, %GEN_RMP_interface* %0, i32 0, i32 4
  %OUT = getelementptr inbounds %GEN_RMP_interface, %GEN_RMP_interface* %0, i32 0, i32 5
  %tx = getelementptr inbounds %GEN_RMP_interface, %GEN_RMP_interface* %0, i32 0, i32 6
  %last = getelementptr inbounds %GEN_RMP_interface, %GEN_RMP_interface* %0, i32 0, i32 7
  %init = getelementptr inbounds %GEN_RMP_interface, %GEN_RMP_interface* %0, i32 0, i32 8
  %temp = getelementptr inbounds %GEN_RMP_interface, %GEN_RMP_interface* %0, i32 0, i32 9
  %ltemp = getelementptr inbounds %GEN_RMP_interface, %GEN_RMP_interface* %0, i32 0, i32 10
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_last = load i64, i64* %last, align 4
  %tmpVar = sub i64 %call6, %load_last
  store i64 %tmpVar, i64* %tx, align 4
  %MODR_instance = alloca %MODR_interface, align 8
  br label %input7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

input7:                                           ; preds = %continue
  %2 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 0
  %load_dl = load float, float* %DL, align 4
  store float %load_dl, float* %2, align 4
  %3 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 1
  store float 1.000000e+00, float* %3, align 4
  br label %call8

call8:                                            ; preds = %input7
  %call11 = call float @MODR(%MODR_interface* %MODR_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  store float %call11, float* %DL, align 4
  %load_dl13 = load float, float* %DL, align 4
  %tmpVar14 = fcmp olt float %load_dl13, 0.000000e+00
  br i1 %tmpVar14, label %condition_body, label %continue12

condition_body:                                   ; preds = %continue10
  %load_dl15 = load float, float* %DL, align 4
  %tmpVar16 = fsub float 1.000000e+00, %load_dl15
  store float %tmpVar16, float* %DL, align 4
  br label %continue12

continue12:                                       ; preds = %condition_body, %continue10
  %load_init = load i8, i8* %init, align 1
  %tmpVar19 = xor i8 %load_init, -1
  %4 = icmp ne i8 %tmpVar19, 0
  br i1 %4, label %condition_body18, label %continue17

condition_body18:                                 ; preds = %continue12
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  store i64 0, i64* %tx, align 4
  br label %continue17

continue17:                                       ; preds = %condition_body18, %continue12
  %load_tx22 = load i64, i64* %tx, align 4
  %load_pt = load i64, i64* %PT, align 4
  %tmpVar23 = icmp sge i64 %load_tx22, %load_pt
  br i1 %tmpVar23, label %condition_body21, label %continue20

condition_body21:                                 ; preds = %continue17
  %load_last24 = load i64, i64* %last, align 4
  %load_pt25 = load i64, i64* %PT, align 4
  %tmpVar26 = add i64 %load_last24, %load_pt25
  store i64 %tmpVar26, i64* %last, align 4
  %load_tx27 = load i64, i64* %tx, align 4
  %load_pt28 = load i64, i64* %PT, align 4
  %tmpVar29 = sub i64 %load_tx27, %load_pt28
  store i64 %tmpVar29, i64* %tx, align 4
  br label %continue20

continue20:                                       ; preds = %condition_body21, %continue17
  %load_temp = load float, float* %temp, align 4
  store float %load_temp, float* %ltemp, align 4
  %load_pt32 = load i64, i64* %PT, align 4
  %tmpVar33 = icmp sgt i64 %load_pt32, 0
  br i1 %tmpVar33, label %condition_body31, label %continue30

condition_body31:                                 ; preds = %continue20
  %FRACT_instance = alloca %FRACT_interface, align 8
  br label %input34

continue30:                                       ; preds = %continue37, %continue20
  %load_am = load float, float* %AM, align 4
  %load_temp61 = load float, float* %temp, align 4
  %tmpVar62 = fmul float %load_am, %load_temp61
  %load_os = load float, float* %OS, align 4
  %tmpVar63 = fadd float %tmpVar62, %load_os
  store float %tmpVar63, float* %OUT, align 4
  %load_temp64 = load float, float* %temp, align 4
  %load_ltemp = load float, float* %ltemp, align 4
  %tmpVar65 = fcmp olt float %load_temp64, %load_ltemp
  %5 = zext i1 %tmpVar65 to i8
  store i8 %5, i8* %Q, align 1
  ret void

input34:                                          ; preds = %condition_body31
  %6 = getelementptr inbounds %FRACT_interface, %FRACT_interface* %FRACT_instance, i32 0, i32 0
  %TIME_TO_REAL_instance = alloca %TIME_TO_REAL_interface, align 8
  br label %input38

call35:                                           ; preds = %continue56
  %call60 = call float @FRACT(%FRACT_interface* %FRACT_instance)
  br label %output36

output36:                                         ; preds = %call35
  br label %continue37

continue37:                                       ; preds = %output36
  store float %call60, float* %temp, align 4
  br label %continue30

input38:                                          ; preds = %input34
  %7 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance, i32 0, i32 0
  %load_tx42 = load i64, i64* %tx, align 4
  %MULTIME_instance = alloca %MULTIME_interface, align 8
  br label %input43

call39:                                           ; preds = %continue46
  %call51 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance)
  br label %output40

output40:                                         ; preds = %call39
  br label %continue41

continue41:                                       ; preds = %output40
  %TIME_TO_REAL_instance52 = alloca %TIME_TO_REAL_interface, align 8
  br label %input53

input43:                                          ; preds = %input38
  %8 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance, i32 0, i32 0
  %load_pt47 = load i64, i64* %PT, align 4
  store i64 %load_pt47, i64* %8, align 4
  %9 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance, i32 0, i32 1
  %load_dl48 = load float, float* %DL, align 4
  store float %load_dl48, float* %9, align 4
  br label %call44

call44:                                           ; preds = %input43
  %call49 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance)
  br label %output45

output45:                                         ; preds = %call44
  br label %continue46

continue46:                                       ; preds = %output45
  %tmpVar50 = add i64 %load_tx42, %call49
  store i64 %tmpVar50, i64* %7, align 4
  br label %call39

input53:                                          ; preds = %continue41
  %10 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance52, i32 0, i32 0
  %load_pt57 = load i64, i64* %PT, align 4
  store i64 %load_pt57, i64* %10, align 4
  br label %call54

call54:                                           ; preds = %input53
  %call58 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance52)
  br label %output55

output55:                                         ; preds = %call54
  br label %continue56

continue56:                                       ; preds = %output55
  %tmpVar59 = fdiv float %call51, %call58
  store float %tmpVar59, float* %6, align 4
  br label %call35
}

define void @GEN_SIN(%GEN_SIN_interface* %0) {
entry:
  %PT = getelementptr inbounds %GEN_SIN_interface, %GEN_SIN_interface* %0, i32 0, i32 0
  %AM = getelementptr inbounds %GEN_SIN_interface, %GEN_SIN_interface* %0, i32 0, i32 1
  %OS = getelementptr inbounds %GEN_SIN_interface, %GEN_SIN_interface* %0, i32 0, i32 2
  %DL = getelementptr inbounds %GEN_SIN_interface, %GEN_SIN_interface* %0, i32 0, i32 3
  %Q = getelementptr inbounds %GEN_SIN_interface, %GEN_SIN_interface* %0, i32 0, i32 4
  %Out = getelementptr inbounds %GEN_SIN_interface, %GEN_SIN_interface* %0, i32 0, i32 5
  %tx = getelementptr inbounds %GEN_SIN_interface, %GEN_SIN_interface* %0, i32 0, i32 6
  %last = getelementptr inbounds %GEN_SIN_interface, %GEN_SIN_interface* %0, i32 0, i32 7
  %init = getelementptr inbounds %GEN_SIN_interface, %GEN_SIN_interface* %0, i32 0, i32 8
  %temp = getelementptr inbounds %GEN_SIN_interface, %GEN_SIN_interface* %0, i32 0, i32 9
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_last = load i64, i64* %last, align 4
  %tmpVar = sub i64 %call6, %load_last
  store i64 %tmpVar, i64* %tx, align 4
  %MODR_instance = alloca %MODR_interface, align 8
  br label %input7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

input7:                                           ; preds = %continue
  %2 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 0
  %load_dl = load float, float* %DL, align 4
  store float %load_dl, float* %2, align 4
  %3 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 1
  store float 1.000000e+00, float* %3, align 4
  br label %call8

call8:                                            ; preds = %input7
  %call11 = call float @MODR(%MODR_interface* %MODR_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  store float %call11, float* %DL, align 4
  %load_dl13 = load float, float* %DL, align 4
  %tmpVar14 = fcmp olt float %load_dl13, 0.000000e+00
  br i1 %tmpVar14, label %condition_body, label %continue12

condition_body:                                   ; preds = %continue10
  %load_dl15 = load float, float* %DL, align 4
  %tmpVar16 = fsub float 1.000000e+00, %load_dl15
  store float %tmpVar16, float* %DL, align 4
  br label %continue12

continue12:                                       ; preds = %condition_body, %continue10
  %load_init = load i8, i8* %init, align 1
  %tmpVar19 = xor i8 %load_init, -1
  %4 = icmp ne i8 %tmpVar19, 0
  br i1 %4, label %condition_body18, label %continue17

condition_body18:                                 ; preds = %continue12
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  store i64 0, i64* %tx, align 4
  br label %continue17

continue17:                                       ; preds = %condition_body18, %continue12
  %load_tx22 = load i64, i64* %tx, align 4
  %load_pt = load i64, i64* %PT, align 4
  %tmpVar23 = icmp sge i64 %load_tx22, %load_pt
  br i1 %tmpVar23, label %condition_body21, label %continue20

condition_body21:                                 ; preds = %continue17
  %load_last24 = load i64, i64* %last, align 4
  %load_pt25 = load i64, i64* %PT, align 4
  %tmpVar26 = add i64 %load_last24, %load_pt25
  store i64 %tmpVar26, i64* %last, align 4
  %load_tx27 = load i64, i64* %tx, align 4
  %load_pt28 = load i64, i64* %PT, align 4
  %tmpVar29 = sub i64 %load_tx27, %load_pt28
  store i64 %tmpVar29, i64* %tx, align 4
  br label %continue20

continue20:                                       ; preds = %condition_body21, %continue17
  %load_pt32 = load i64, i64* %PT, align 4
  %tmpVar33 = icmp sgt i64 %load_pt32, 0
  br i1 %tmpVar33, label %condition_body31, label %continue30

condition_body31:                                 ; preds = %continue20
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input34

continue30:                                       ; preds = %continue37, %continue20
  %load_am = load float, float* %AM, align 4
  %tmpVar73 = fmul float %load_am, 5.000000e-01
  %load_temp = load float, float* %temp, align 4
  %tmpVar74 = fmul float %tmpVar73, %load_temp
  %load_os = load float, float* %OS, align 4
  %tmpVar75 = fadd float %tmpVar74, %load_os
  store float %tmpVar75, float* %Out, align 4
  %SIGN_R_instance = alloca %SIGN_R_interface, align 8
  br label %input76

input34:                                          ; preds = %condition_body31
  %5 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 1), align 4
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input38

call35:                                           ; preds = %continue62
  %call72 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output36

output36:                                         ; preds = %call35
  br label %continue37

continue37:                                       ; preds = %output36
  %6 = fptrunc double %call72 to float
  store float %6, float* %temp, align 4
  br label %continue30

input38:                                          ; preds = %input34
  %7 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input42

call39:                                           ; preds = %continue45
  %call56 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output40

output40:                                         ; preds = %call39
  br label %continue41

continue41:                                       ; preds = %output40
  %tmpVar57 = fmul float %load_, %call56
  %DWORD_TO_REAL_instance58 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input59

input42:                                          ; preds = %input38
  %8 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_tx46 = load i64, i64* %tx, align 4
  %MULTIME_instance = alloca %MULTIME_interface, align 8
  br label %input47

call43:                                           ; preds = %continue50
  %call55 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output44

output44:                                         ; preds = %call43
  br label %continue45

continue45:                                       ; preds = %output44
  store i32 %call55, i32* %7, align 4
  br label %call39

input47:                                          ; preds = %input42
  %9 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance, i32 0, i32 0
  %load_pt51 = load i64, i64* %PT, align 4
  store i64 %load_pt51, i64* %9, align 4
  %10 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance, i32 0, i32 1
  %load_dl52 = load float, float* %DL, align 4
  store float %load_dl52, float* %10, align 4
  br label %call48

call48:                                           ; preds = %input47
  %call53 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance)
  br label %output49

output49:                                         ; preds = %call48
  br label %continue50

continue50:                                       ; preds = %output49
  %tmpVar54 = add i64 %load_tx46, %call53
  store i64 %tmpVar54, i64* %8, align 4
  br label %call43

input59:                                          ; preds = %continue41
  %11 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance58, i32 0, i32 0
  %TIME_TO_DWORD_instance63 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input64

call60:                                           ; preds = %continue67
  %call70 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance58)
  br label %output61

output61:                                         ; preds = %call60
  br label %continue62

continue62:                                       ; preds = %output61
  %tmpVar71 = fdiv float %tmpVar57, %call70
  %12 = fptosi float %tmpVar71 to i32
  store i32 %12, i32* %5, align 4
  br label %call35

input64:                                          ; preds = %input59
  %13 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance63, i32 0, i32 0
  %load_pt68 = load i64, i64* %PT, align 4
  store i64 %load_pt68, i64* %13, align 4
  br label %call65

call65:                                           ; preds = %input64
  %call69 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance63)
  br label %output66

output66:                                         ; preds = %call65
  br label %continue67

continue67:                                       ; preds = %output66
  store i32 %call69, i32* %11, align 4
  br label %call60

input76:                                          ; preds = %continue30
  %14 = getelementptr inbounds %SIGN_R_interface, %SIGN_R_interface* %SIGN_R_instance, i32 0, i32 0
  %load_temp80 = load float, float* %temp, align 4
  store float %load_temp80, float* %14, align 4
  br label %call77

call77:                                           ; preds = %input76
  %call81 = call i8 @SIGN_R(%SIGN_R_interface* %SIGN_R_instance)
  br label %output78

output78:                                         ; preds = %call77
  br label %continue79

continue79:                                       ; preds = %output78
  %tmpVar82 = xor i8 %call81, -1
  store i8 %tmpVar82, i8* %Q, align 1
  ret void
}

define void @GEN_SQR(%GEN_SQR_interface* %0) {
entry:
  %PT = getelementptr inbounds %GEN_SQR_interface, %GEN_SQR_interface* %0, i32 0, i32 0
  %AM = getelementptr inbounds %GEN_SQR_interface, %GEN_SQR_interface* %0, i32 0, i32 1
  %OS = getelementptr inbounds %GEN_SQR_interface, %GEN_SQR_interface* %0, i32 0, i32 2
  %DC = getelementptr inbounds %GEN_SQR_interface, %GEN_SQR_interface* %0, i32 0, i32 3
  %DL = getelementptr inbounds %GEN_SQR_interface, %GEN_SQR_interface* %0, i32 0, i32 4
  %Q = getelementptr inbounds %GEN_SQR_interface, %GEN_SQR_interface* %0, i32 0, i32 5
  %Out = getelementptr inbounds %GEN_SQR_interface, %GEN_SQR_interface* %0, i32 0, i32 6
  %tx = getelementptr inbounds %GEN_SQR_interface, %GEN_SQR_interface* %0, i32 0, i32 7
  %last = getelementptr inbounds %GEN_SQR_interface, %GEN_SQR_interface* %0, i32 0, i32 8
  %init = getelementptr inbounds %GEN_SQR_interface, %GEN_SQR_interface* %0, i32 0, i32 9
  %load_dc = load float, float* %DC, align 4
  %tmpVar = fcmp oeq float %load_dc, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  %load_am = load float, float* %AM, align 4
  %tmpVar1 = fneg float %load_am
  %tmpVar2 = fmul float %tmpVar1, 5.000000e-01
  %load_os = load float, float* %OS, align 4
  %tmpVar3 = fadd float %tmpVar2, %load_os
  store float %tmpVar3, float* %Out, align 4
  store i8 0, i8* %Q, align 1
  ret void

buffer_block:                                     ; No predecessors!
  br label %continue

branch:                                           ; preds = %entry
  %load_dc5 = load float, float* %DC, align 4
  %tmpVar6 = fcmp oeq float %load_dc5, 1.000000e+00
  br i1 %tmpVar6, label %condition_body4, label %continue

condition_body4:                                  ; preds = %branch
  %load_am7 = load float, float* %AM, align 4
  %tmpVar8 = fmul float %load_am7, 5.000000e-01
  %load_os9 = load float, float* %OS, align 4
  %tmpVar10 = fadd float %tmpVar8, %load_os9
  store float %tmpVar10, float* %Out, align 4
  store i8 1, i8* %Q, align 1
  ret void

buffer_block11:                                   ; No predecessors!
  br label %continue

continue:                                         ; preds = %buffer_block11, %branch, %buffer_block
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %continue
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input13

call:                                             ; preds = %continue16
  %call18 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue12

continue12:                                       ; preds = %output
  %load_last = load i64, i64* %last, align 4
  %tmpVar19 = sub i64 %call18, %load_last
  store i64 %tmpVar19, i64* %tx, align 4
  %MODR_instance = alloca %MODR_interface, align 8
  br label %input20

input13:                                          ; preds = %input
  br label %call14

call14:                                           ; preds = %input13
  %call17 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  store i32 %call17, i32* %1, align 4
  br label %call

input20:                                          ; preds = %continue12
  %2 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 0
  %load_dl = load float, float* %DL, align 4
  store float %load_dl, float* %2, align 4
  %3 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 1
  store float 1.000000e+00, float* %3, align 4
  br label %call21

call21:                                           ; preds = %input20
  %call24 = call float @MODR(%MODR_interface* %MODR_instance)
  br label %output22

output22:                                         ; preds = %call21
  br label %continue23

continue23:                                       ; preds = %output22
  store float %call24, float* %DL, align 4
  %load_dl27 = load float, float* %DL, align 4
  %tmpVar28 = fcmp olt float %load_dl27, 0.000000e+00
  br i1 %tmpVar28, label %condition_body26, label %continue25

condition_body26:                                 ; preds = %continue23
  %load_dl29 = load float, float* %DL, align 4
  %tmpVar30 = fsub float 1.000000e+00, %load_dl29
  store float %tmpVar30, float* %DL, align 4
  br label %continue25

continue25:                                       ; preds = %condition_body26, %continue23
  %MODR_instance31 = alloca %MODR_interface, align 8
  br label %input32

input32:                                          ; preds = %continue25
  %4 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance31, i32 0, i32 0
  %load_dc36 = load float, float* %DC, align 4
  store float %load_dc36, float* %4, align 4
  %5 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance31, i32 0, i32 1
  store float 1.000000e+00, float* %5, align 4
  br label %call33

call33:                                           ; preds = %input32
  %call37 = call float @MODR(%MODR_interface* %MODR_instance31)
  br label %output34

output34:                                         ; preds = %call33
  br label %continue35

continue35:                                       ; preds = %output34
  store float %call37, float* %DC, align 4
  %load_dc40 = load float, float* %DC, align 4
  %tmpVar41 = fcmp olt float %load_dc40, 0.000000e+00
  br i1 %tmpVar41, label %condition_body39, label %continue38

condition_body39:                                 ; preds = %continue35
  %load_dc42 = load float, float* %DC, align 4
  %tmpVar43 = fsub float 1.000000e+00, %load_dc42
  store float %tmpVar43, float* %DC, align 4
  br label %continue38

continue38:                                       ; preds = %condition_body39, %continue35
  %load_init = load i8, i8* %init, align 1
  %tmpVar46 = xor i8 %load_init, -1
  %6 = icmp ne i8 %tmpVar46, 0
  br i1 %6, label %condition_body45, label %continue44

condition_body45:                                 ; preds = %continue38
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  store i64 0, i64* %tx, align 4
  br label %continue44

continue44:                                       ; preds = %condition_body45, %continue38
  %load_tx49 = load i64, i64* %tx, align 4
  %load_pt = load i64, i64* %PT, align 4
  %tmpVar50 = icmp sge i64 %load_tx49, %load_pt
  br i1 %tmpVar50, label %condition_body48, label %continue47

condition_body48:                                 ; preds = %continue44
  %load_last51 = load i64, i64* %last, align 4
  %load_pt52 = load i64, i64* %PT, align 4
  %tmpVar53 = add i64 %load_last51, %load_pt52
  store i64 %tmpVar53, i64* %last, align 4
  %load_tx54 = load i64, i64* %tx, align 4
  %load_pt55 = load i64, i64* %PT, align 4
  %tmpVar56 = sub i64 %load_tx54, %load_pt55
  store i64 %tmpVar56, i64* %tx, align 4
  br label %continue47

continue47:                                       ; preds = %condition_body48, %continue44
  %MULTIME_instance = alloca %MULTIME_interface, align 8
  br label %input59

condition_body58:                                 ; preds = %continue62
  %load_tx72 = load i64, i64* %tx, align 4
  %MULTIME_instance73 = alloca %MULTIME_interface, align 8
  br label %input74

else:                                             ; preds = %continue62
  %load_tx108 = load i64, i64* %tx, align 4
  %MULTIME_instance109 = alloca %MULTIME_interface, align 8
  br label %input110

continue57:                                       ; preds = %continue122, %continue90
  ret void

input59:                                          ; preds = %continue47
  %7 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance, i32 0, i32 0
  %load_pt63 = load i64, i64* %PT, align 4
  store i64 %load_pt63, i64* %7, align 4
  %8 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance, i32 0, i32 1
  %load_dl64 = load float, float* %DL, align 4
  %load_dc65 = load float, float* %DC, align 4
  %tmpVar66 = fadd float %load_dl64, %load_dc65
  store float %tmpVar66, float* %8, align 4
  br label %call60

call60:                                           ; preds = %input59
  %call67 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance)
  br label %output61

output61:                                         ; preds = %call60
  br label %continue62

continue62:                                       ; preds = %output61
  %load_pt68 = load i64, i64* %PT, align 4
  %tmpVar69 = icmp sge i64 %call67, %load_pt68
  br i1 %tmpVar69, label %condition_body58, label %else

condition_body71:                                 ; preds = %continue77
  %load_am85 = load float, float* %AM, align 4
  %tmpVar86 = fneg float %load_am85
  %tmpVar87 = fmul float %tmpVar86, 5.000000e-01
  %load_os88 = load float, float* %OS, align 4
  %tmpVar89 = fadd float %tmpVar87, %load_os88
  store float %tmpVar89, float* %Out, align 4
  store i8 0, i8* %Q, align 1
  br label %continue70

continue70:                                       ; preds = %condition_body71, %continue77
  %load_tx92 = load i64, i64* %tx, align 4
  %MULTIME_instance93 = alloca %MULTIME_interface, align 8
  br label %input94

input74:                                          ; preds = %condition_body58
  %9 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance73, i32 0, i32 0
  %load_pt78 = load i64, i64* %PT, align 4
  store i64 %load_pt78, i64* %9, align 4
  %10 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance73, i32 0, i32 1
  %load_dl79 = load float, float* %DL, align 4
  %load_dc80 = load float, float* %DC, align 4
  %tmpVar81 = fadd float %load_dl79, %load_dc80
  %tmpVar82 = fsub float %tmpVar81, 1.000000e+00
  store float %tmpVar82, float* %10, align 4
  br label %call75

call75:                                           ; preds = %input74
  %call83 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance73)
  br label %output76

output76:                                         ; preds = %call75
  br label %continue77

continue77:                                       ; preds = %output76
  %tmpVar84 = icmp sge i64 %load_tx72, %call83
  br i1 %tmpVar84, label %condition_body71, label %continue70

condition_body91:                                 ; preds = %continue97
  %load_am102 = load float, float* %AM, align 4
  %tmpVar103 = fmul float %load_am102, 5.000000e-01
  %load_os104 = load float, float* %OS, align 4
  %tmpVar105 = fadd float %tmpVar103, %load_os104
  store float %tmpVar105, float* %Out, align 4
  store i8 1, i8* %Q, align 1
  br label %continue90

continue90:                                       ; preds = %condition_body91, %continue97
  br label %continue57

input94:                                          ; preds = %continue70
  %11 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance93, i32 0, i32 0
  %load_pt98 = load i64, i64* %PT, align 4
  store i64 %load_pt98, i64* %11, align 4
  %12 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance93, i32 0, i32 1
  %load_dl99 = load float, float* %DL, align 4
  store float %load_dl99, float* %12, align 4
  br label %call95

call95:                                           ; preds = %input94
  %call100 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance93)
  br label %output96

output96:                                         ; preds = %call95
  br label %continue97

continue97:                                       ; preds = %output96
  %tmpVar101 = icmp sge i64 %load_tx92, %call100
  br i1 %tmpVar101, label %condition_body91, label %continue90

condition_body107:                                ; preds = %continue113
  %load_am118 = load float, float* %AM, align 4
  %tmpVar119 = fmul float %load_am118, 5.000000e-01
  %load_os120 = load float, float* %OS, align 4
  %tmpVar121 = fadd float %tmpVar119, %load_os120
  store float %tmpVar121, float* %Out, align 4
  store i8 1, i8* %Q, align 1
  br label %continue106

continue106:                                      ; preds = %condition_body107, %continue113
  %load_tx124 = load i64, i64* %tx, align 4
  %MULTIME_instance125 = alloca %MULTIME_interface, align 8
  br label %input126

input110:                                         ; preds = %else
  %13 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance109, i32 0, i32 0
  %load_pt114 = load i64, i64* %PT, align 4
  store i64 %load_pt114, i64* %13, align 4
  %14 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance109, i32 0, i32 1
  %load_dl115 = load float, float* %DL, align 4
  store float %load_dl115, float* %14, align 4
  br label %call111

call111:                                          ; preds = %input110
  %call116 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance109)
  br label %output112

output112:                                        ; preds = %call111
  br label %continue113

continue113:                                      ; preds = %output112
  %tmpVar117 = icmp sge i64 %load_tx108, %call116
  br i1 %tmpVar117, label %condition_body107, label %continue106

condition_body123:                                ; preds = %continue129
  %load_am136 = load float, float* %AM, align 4
  %tmpVar137 = fneg float %load_am136
  %tmpVar138 = fmul float %tmpVar137, 5.000000e-01
  %load_os139 = load float, float* %OS, align 4
  %tmpVar140 = fadd float %tmpVar138, %load_os139
  store float %tmpVar140, float* %Out, align 4
  store i8 0, i8* %Q, align 1
  br label %continue122

continue122:                                      ; preds = %condition_body123, %continue129
  br label %continue57

input126:                                         ; preds = %continue106
  %15 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance125, i32 0, i32 0
  %load_pt130 = load i64, i64* %PT, align 4
  store i64 %load_pt130, i64* %15, align 4
  %16 = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %MULTIME_instance125, i32 0, i32 1
  %load_dl131 = load float, float* %DL, align 4
  %load_dc132 = load float, float* %DC, align 4
  %tmpVar133 = fadd float %load_dl131, %load_dc132
  store float %tmpVar133, float* %16, align 4
  br label %call127

call127:                                          ; preds = %input126
  %call134 = call i64 @MULTIME(%MULTIME_interface* %MULTIME_instance125)
  br label %output128

output128:                                        ; preds = %call127
  br label %continue129

continue129:                                      ; preds = %output128
  %tmpVar135 = icmp sge i64 %load_tx124, %call134
  br i1 %tmpVar135, label %condition_body123, label %continue122
}

define void @PWM_DC(%PWM_DC_interface* %0) {
entry:
  %F = getelementptr inbounds %PWM_DC_interface, %PWM_DC_interface* %0, i32 0, i32 0
  %DC = getelementptr inbounds %PWM_DC_interface, %PWM_DC_interface* %0, i32 0, i32 1
  %Q = getelementptr inbounds %PWM_DC_interface, %PWM_DC_interface* %0, i32 0, i32 2
  %clk = getelementptr inbounds %PWM_DC_interface, %PWM_DC_interface* %0, i32 0, i32 3
  %pulse = getelementptr inbounds %PWM_DC_interface, %PWM_DC_interface* %0, i32 0, i32 4
  %tmp = getelementptr inbounds %PWM_DC_interface, %PWM_DC_interface* %0, i32 0, i32 5
  %load_F = load float, float* %F, align 4
  %tmpVar = fcmp ogt float %load_F, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %load_F1 = load float, float* %F, align 4
  %tmpVar2 = fdiv float 1.000000e+03, %load_F1
  store float %tmpVar2, float* %tmp, align 4
  br label %input

continue:                                         ; preds = %continue12, %entry
  ret void

input:                                            ; preds = %condition_body
  %1 = getelementptr inbounds %CLK_PRG_interface, %CLK_PRG_interface* %clk, i32 0, i32 0
  %REAL_TO_TIME_instance = alloca %REAL_TO_TIME_interface, align 8
  br label %input4

call:                                             ; preds = %continue7
  call void @CLK_PRG(%CLK_PRG_interface* %clk)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  br label %input9

input4:                                           ; preds = %input
  %2 = getelementptr inbounds %REAL_TO_TIME_interface, %REAL_TO_TIME_interface* %REAL_TO_TIME_instance, i32 0, i32 0
  %load_tmp = load float, float* %tmp, align 4
  store float %load_tmp, float* %2, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call i64 @REAL_TO_TIME(%REAL_TO_TIME_interface* %REAL_TO_TIME_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  store i64 %call8, i64* %1, align 4
  br label %call

input9:                                           ; preds = %continue3
  %3 = getelementptr inbounds %TP_X_interface, %TP_X_interface* %pulse, i32 0, i32 0
  %Q13 = getelementptr inbounds %CLK_PRG_interface, %CLK_PRG_interface* %clk, i32 0, i32 1
  %load_ = load i8, i8* %Q13, align 1
  store i8 %load_, i8* %3, align 1
  %4 = getelementptr inbounds %TP_X_interface, %TP_X_interface* %pulse, i32 0, i32 1
  %REAL_TO_TIME_instance14 = alloca %REAL_TO_TIME_interface, align 8
  br label %input15

call10:                                           ; preds = %continue18
  call void @TP_X(%TP_X_interface* %pulse)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  %Q22 = getelementptr inbounds %TP_X_interface, %TP_X_interface* %pulse, i32 0, i32 2
  %load_23 = load i8, i8* %Q22, align 1
  store i8 %load_23, i8* %Q, align 1
  br label %continue

input15:                                          ; preds = %input9
  %5 = getelementptr inbounds %REAL_TO_TIME_interface, %REAL_TO_TIME_interface* %REAL_TO_TIME_instance14, i32 0, i32 0
  %load_tmp19 = load float, float* %tmp, align 4
  %load_DC = load float, float* %DC, align 4
  %tmpVar20 = fmul float %load_tmp19, %load_DC
  store float %tmpVar20, float* %5, align 4
  br label %call16

call16:                                           ; preds = %input15
  %call21 = call i64 @REAL_TO_TIME(%REAL_TO_TIME_interface* %REAL_TO_TIME_instance14)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  store i64 %call21, i64* %4, align 4
  br label %call10
}

define void @PWM_PW(%PWM_PW_interface* %0) {
entry:
  %F = getelementptr inbounds %PWM_PW_interface, %PWM_PW_interface* %0, i32 0, i32 0
  %PW = getelementptr inbounds %PWM_PW_interface, %PWM_PW_interface* %0, i32 0, i32 1
  %Q = getelementptr inbounds %PWM_PW_interface, %PWM_PW_interface* %0, i32 0, i32 2
  %clk = getelementptr inbounds %PWM_PW_interface, %PWM_PW_interface* %0, i32 0, i32 3
  %pulse = getelementptr inbounds %PWM_PW_interface, %PWM_PW_interface* %0, i32 0, i32 4
  %load_F = load float, float* %F, align 4
  %tmpVar = fcmp ogt float %load_F, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  br label %input

continue:                                         ; preds = %continue12, %entry
  ret void

input:                                            ; preds = %condition_body
  %1 = getelementptr inbounds %CLK_PRG_interface, %CLK_PRG_interface* %clk, i32 0, i32 0
  %REAL_TO_TIME_instance = alloca %REAL_TO_TIME_interface, align 8
  br label %input2

call:                                             ; preds = %continue5
  call void @CLK_PRG(%CLK_PRG_interface* %clk)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  br label %input9

input2:                                           ; preds = %input
  %2 = getelementptr inbounds %REAL_TO_TIME_interface, %REAL_TO_TIME_interface* %REAL_TO_TIME_instance, i32 0, i32 0
  %load_F6 = load float, float* %F, align 4
  %tmpVar7 = fdiv float 1.000000e+03, %load_F6
  store float %tmpVar7, float* %2, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call8 = call i64 @REAL_TO_TIME(%REAL_TO_TIME_interface* %REAL_TO_TIME_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i64 %call8, i64* %1, align 4
  br label %call

input9:                                           ; preds = %continue1
  %3 = getelementptr inbounds %TP_X_interface, %TP_X_interface* %pulse, i32 0, i32 0
  %Q13 = getelementptr inbounds %CLK_PRG_interface, %CLK_PRG_interface* %clk, i32 0, i32 1
  %load_ = load i8, i8* %Q13, align 1
  store i8 %load_, i8* %3, align 1
  %4 = getelementptr inbounds %TP_X_interface, %TP_X_interface* %pulse, i32 0, i32 1
  %load_pw = load i64, i64* %PW, align 4
  store i64 %load_pw, i64* %4, align 4
  br label %call10

call10:                                           ; preds = %input9
  call void @TP_X(%TP_X_interface* %pulse)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  %Q14 = getelementptr inbounds %TP_X_interface, %TP_X_interface* %pulse, i32 0, i32 2
  %load_15 = load i8, i8* %Q14, align 1
  store i8 %load_15, i8* %Q, align 1
  br label %continue
}

define void @RMP_B(%RMP_B_interface* %0) {
entry:
  %SET = getelementptr inbounds %RMP_B_interface, %RMP_B_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %RMP_B_interface, %RMP_B_interface* %0, i32 0, i32 1
  %E = getelementptr inbounds %RMP_B_interface, %RMP_B_interface* %0, i32 0, i32 2
  %UP = getelementptr inbounds %RMP_B_interface, %RMP_B_interface* %0, i32 0, i32 3
  %RST = getelementptr inbounds %RMP_B_interface, %RMP_B_interface* %0, i32 0, i32 4
  %OUT = getelementptr inbounds %RMP_B_interface, %RMP_B_interface* %0, i32 0, i32 5
  %BUSY = getelementptr inbounds %RMP_B_interface, %RMP_B_interface* %0, i32 0, i32 6
  %HIGH = getelementptr inbounds %RMP_B_interface, %RMP_B_interface* %0, i32 0, i32 7
  %LOW = getelementptr inbounds %RMP_B_interface, %RMP_B_interface* %0, i32 0, i32 8
  %rmp = getelementptr inbounds %RMP_B_interface, %RMP_B_interface* %0, i32 0, i32 9
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 0
  %load_UP = load i8, i8* %UP, align 1
  store i8 %load_UP, i8* %1, align 1
  %2 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 1
  %load_E = load i8, i8* %E, align 1
  store i8 %load_E, i8* %2, align 1
  %3 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 2
  %load_PT = load i64, i64* %PT, align 4
  store i64 %load_PT, i64* %3, align 4
  %4 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 3
  store i8* %OUT, i8** %4, align 8
  br label %call

call:                                             ; preds = %input
  call void @_RMP_B(%_RMP_B_interface* %rmp)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_RST = load i8, i8* %RST, align 1
  %5 = icmp ne i8 %load_RST, 0
  br i1 %5, label %condition_body, label %branch

condition_body:                                   ; preds = %continue
  store i8 0, i8* %OUT, align 1
  br label %continue1

branch:                                           ; preds = %continue
  %load_SET = load i8, i8* %SET, align 1
  %6 = icmp ne i8 %load_SET, 0
  br i1 %6, label %condition_body2, label %continue1

condition_body2:                                  ; preds = %branch
  store i8 -1, i8* %OUT, align 1
  br label %continue1

continue1:                                        ; preds = %condition_body2, %branch, %condition_body
  %load_out = load i8, i8* %OUT, align 1
  %7 = zext i8 %load_out to i32
  %tmpVar = icmp eq i32 %7, 0
  %8 = zext i1 %tmpVar to i8
  store i8 %8, i8* %LOW, align 1
  %load_out3 = load i8, i8* %OUT, align 1
  %9 = zext i8 %load_out3 to i32
  %tmpVar4 = icmp eq i32 %9, 255
  %10 = zext i1 %tmpVar4 to i8
  store i8 %10, i8* %HIGH, align 1
  %load_low = load i8, i8* %LOW, align 1
  %11 = zext i8 %load_low to i32
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %19, label %17

13:                                               ; preds = %19
  %load_E6 = load i8, i8* %E, align 1
  %14 = zext i8 %load_E6 to i32
  br label %15

15:                                               ; preds = %13, %19
  %16 = phi i32 [ %tmpVar5, %19 ], [ %14, %13 ]
  store i32 %16, i8* %BUSY, align 4
  ret void

17:                                               ; preds = %continue1
  %load_high = load i8, i8* %HIGH, align 1
  %18 = zext i8 %load_high to i32
  br label %19

19:                                               ; preds = %17, %continue1
  %20 = phi i32 [ %11, %continue1 ], [ %18, %17 ]
  %tmpVar5 = xor i32 %20, -1
  %21 = icmp ne i32 %tmpVar5, 0
  br i1 %21, label %13, label %15
}

define void @RMP_SOFT(%RMP_SOFT_interface* %0) {
entry:
  %IN = getelementptr inbounds %RMP_SOFT_interface, %RMP_SOFT_interface* %0, i32 0, i32 0
  %VAL = getelementptr inbounds %RMP_SOFT_interface, %RMP_SOFT_interface* %0, i32 0, i32 1
  %PT_ON = getelementptr inbounds %RMP_SOFT_interface, %RMP_SOFT_interface* %0, i32 0, i32 2
  %PT_OFF = getelementptr inbounds %RMP_SOFT_interface, %RMP_SOFT_interface* %0, i32 0, i32 3
  %OUT = getelementptr inbounds %RMP_SOFT_interface, %RMP_SOFT_interface* %0, i32 0, i32 4
  %rmp = getelementptr inbounds %RMP_SOFT_interface, %RMP_SOFT_interface* %0, i32 0, i32 5
  %tmp = getelementptr inbounds %RMP_SOFT_interface, %RMP_SOFT_interface* %0, i32 0, i32 6
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_in = load i8, i8* %IN, align 1
  store i8 %load_in, i8* %1, align 1
  %2 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  store i64 0, i64* %2, align 4
  %3 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_val = load i8, i8* %VAL, align 1
  %4 = zext i8 %load_val to i64
  store i64 %4, i64* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = trunc i64 %call1 to i8
  store i8 %5, i8* %tmp, align 1
  %load_tmp = load i8, i8* %tmp, align 1
  %6 = zext i8 %load_tmp to i32
  %load_out = load i8, i8* %OUT, align 1
  %7 = zext i8 %load_out to i32
  %tmpVar = icmp sgt i32 %6, %7
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %continue
  br label %input3

branch:                                           ; preds = %continue
  %load_tmp15 = load i8, i8* %tmp, align 1
  %8 = zext i8 %load_tmp15 to i32
  %load_out16 = load i8, i8* %OUT, align 1
  %9 = zext i8 %load_out16 to i32
  %tmpVar17 = icmp slt i32 %8, %9
  br i1 %tmpVar17, label %condition_body14, label %else

condition_body14:                                 ; preds = %branch
  br label %input18

else:                                             ; preds = %branch
  br label %input29

continue2:                                        ; preds = %continue32, %continue25, %continue10
  ret void

input3:                                           ; preds = %condition_body
  %10 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 0
  store i8 1, i8* %10, align 1
  %11 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 1
  store i8 1, i8* %11, align 1
  %12 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 2
  %load_PT_ON = load i64, i64* %PT_ON, align 4
  store i64 %load_PT_ON, i64* %12, align 4
  %13 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 3
  store i8* %OUT, i8** %13, align 8
  br label %call4

call4:                                            ; preds = %input3
  call void @_RMP_B(%_RMP_B_interface* %rmp)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input7

input7:                                           ; preds = %continue6
  %14 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_out11 = load i8, i8* %OUT, align 1
  %15 = zext i8 %load_out11 to i64
  store i64 %15, i64* %14, align 4
  %16 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_tmp12 = load i8, i8* %tmp, align 1
  %17 = zext i8 %load_tmp12 to i64
  store i64 %17, i64* %16, align 4
  br label %call8

call8:                                            ; preds = %input7
  %call13 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %18 = trunc i64 %call13 to i8
  store i8 %18, i8* %OUT, align 1
  br label %continue2

input18:                                          ; preds = %condition_body14
  %19 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 0
  store i8 0, i8* %19, align 1
  %20 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 1
  store i8 1, i8* %20, align 1
  %21 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 2
  %load_PT_OFF = load i64, i64* %PT_OFF, align 4
  store i64 %load_PT_OFF, i64* %21, align 4
  %22 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 3
  store i8* %OUT, i8** %22, align 8
  br label %call19

call19:                                           ; preds = %input18
  call void @_RMP_B(%_RMP_B_interface* %rmp)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %MAX_instance = alloca %MAX_interface, align 8
  br label %input22

input22:                                          ; preds = %continue21
  %23 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 0
  %load_out26 = load i8, i8* %OUT, align 1
  %24 = zext i8 %load_out26 to i64
  store i64 %24, i64* %23, align 4
  %25 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 1
  %load_tmp27 = load i8, i8* %tmp, align 1
  %26 = zext i8 %load_tmp27 to i64
  store i64 %26, i64* %25, align 4
  br label %call23

call23:                                           ; preds = %input22
  %call28 = call i64 @MAX(%MAX_interface* %MAX_instance)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %27 = trunc i64 %call28 to i8
  store i8 %27, i8* %OUT, align 1
  br label %continue2

input29:                                          ; preds = %else
  %28 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 1
  store i8 0, i8* %28, align 1
  %29 = getelementptr inbounds %_RMP_B_interface, %_RMP_B_interface* %rmp, i32 0, i32 3
  store i8* %OUT, i8** %29, align 8
  br label %call30

call30:                                           ; preds = %input29
  call void @_RMP_B(%_RMP_B_interface* %rmp)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  br label %continue2
}

define void @RMP_W(%RMP_W_interface* %0) {
entry:
  %SET = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %0, i32 0, i32 1
  %E = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %0, i32 0, i32 2
  %UP = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %0, i32 0, i32 3
  %RST = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %0, i32 0, i32 4
  %out = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %0, i32 0, i32 5
  %busy = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %0, i32 0, i32 6
  %high = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %0, i32 0, i32 7
  %low = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %0, i32 0, i32 8
  %rmp = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %0, i32 0, i32 9
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %rmp, i32 0, i32 0
  %load_UP = load i8, i8* %UP, align 1
  store i8 %load_UP, i8* %1, align 1
  %2 = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %rmp, i32 0, i32 1
  %load_E = load i8, i8* %E, align 1
  store i8 %load_E, i8* %2, align 1
  %3 = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %rmp, i32 0, i32 2
  %load_PT = load i64, i64* %PT, align 4
  store i64 %load_PT, i64* %3, align 4
  %4 = getelementptr inbounds %_RMP_W_interface, %_RMP_W_interface* %rmp, i32 0, i32 3
  store i16* %out, i16** %4, align 8
  br label %call

call:                                             ; preds = %input
  call void @_RMP_W(%_RMP_W_interface* %rmp)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_RST = load i8, i8* %RST, align 1
  %5 = icmp ne i8 %load_RST, 0
  br i1 %5, label %condition_body, label %branch

condition_body:                                   ; preds = %continue
  store i16 0, i16* %out, align 2
  br label %continue1

branch:                                           ; preds = %continue
  %load_SET = load i8, i8* %SET, align 1
  %6 = icmp ne i8 %load_SET, 0
  br i1 %6, label %condition_body2, label %continue1

condition_body2:                                  ; preds = %branch
  store i16 -1, i16* %out, align 2
  br label %continue1

continue1:                                        ; preds = %condition_body2, %branch, %condition_body
  %load_out = load i16, i16* %out, align 2
  %7 = zext i16 %load_out to i32
  %tmpVar = icmp eq i32 %7, 0
  %8 = zext i1 %tmpVar to i8
  store i8 %8, i8* %low, align 1
  %load_out3 = load i16, i16* %out, align 2
  %9 = zext i16 %load_out3 to i32
  %tmpVar4 = icmp eq i32 %9, 65535
  %10 = zext i1 %tmpVar4 to i8
  store i8 %10, i8* %high, align 1
  %load_low = load i8, i8* %low, align 1
  %11 = zext i8 %load_low to i32
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %19, label %17

13:                                               ; preds = %19
  %load_E6 = load i8, i8* %E, align 1
  %14 = zext i8 %load_E6 to i32
  br label %15

15:                                               ; preds = %13, %19
  %16 = phi i32 [ %tmpVar5, %19 ], [ %14, %13 ]
  store i32 %16, i8* %busy, align 4
  ret void

17:                                               ; preds = %continue1
  %load_high = load i8, i8* %high, align 1
  %18 = zext i8 %load_high to i32
  br label %19

19:                                               ; preds = %17, %continue1
  %20 = phi i32 [ %11, %continue1 ], [ %18, %17 ]
  %tmpVar5 = xor i32 %20, -1
  %21 = icmp ne i32 %tmpVar5, 0
  br i1 %21, label %13, label %15
}

define float @AIN(%AIN_interface* %0) {
entry:
  %in = getelementptr inbounds %AIN_interface, %AIN_interface* %0, i32 0, i32 0
  %Bits = getelementptr inbounds %AIN_interface, %AIN_interface* %0, i32 0, i32 1
  %sign = getelementptr inbounds %AIN_interface, %AIN_interface* %0, i32 0, i32 2
  %low = getelementptr inbounds %AIN_interface, %AIN_interface* %0, i32 0, i32 3
  %high = getelementptr inbounds %AIN_interface, %AIN_interface* %0, i32 0, i32 4
  %ff = getelementptr inbounds %AIN_interface, %AIN_interface* %0, i32 0, i32 5
  %temp1 = getelementptr inbounds %AIN_interface, %AIN_interface* %0, i32 0, i32 6
  %temp2 = getelementptr inbounds %AIN_interface, %AIN_interface* %0, i32 0, i32 7
  %sx = getelementptr inbounds %AIN_interface, %AIN_interface* %0, i32 0, i32 8
  %AIN = alloca float, align 4
  store i32 -1, i32* %ff, align 4
  store i32 0, i32* %temp1, align 4
  store i32 0, i32* %temp2, align 4
  store i8 0, i8* %sx, align 1
  store float 0.000000e+00, float* %AIN, align 4
  %load_sign = load i8, i8* %sign, align 1
  %1 = zext i8 %load_sign to i32
  %tmpVar = icmp slt i32 %1, 32
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

else:                                             ; preds = %entry
  store i8 0, i8* %sx, align 1
  br label %continue

continue:                                         ; preds = %else, %continue1
  %SHR_instance4 = alloca %SHR_interface, align 8
  br label %input5

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in = load i32, i32* %in, align 4
  %3 = zext i32 %load_in to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %load_sign2 = load i8, i8* %sign, align 1
  %5 = zext i8 %load_sign2 to i16
  store i16 %5, i16* %4, align 2
  br label %call

call:                                             ; preds = %input
  %call3 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %6 = trunc i64 %call3 to i32
  store i32 %6, i32* %temp1, align 4
  %load_temp1 = load i32, i32* %temp1, align 4
  %shift = lshr i32 %load_temp1, 0
  %7 = trunc i32 %shift to i8
  store i8 %7, i8* %sx, align 1
  br label %continue

input5:                                           ; preds = %continue
  %8 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance4, i32 0, i32 0
  %load_ff = load i32, i32* %ff, align 4
  %9 = zext i32 %load_ff to i64
  store i64 %9, i64* %8, align 4
  %10 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance4, i32 0, i32 1
  %load_bits = load i8, i8* %Bits, align 1
  %11 = zext i8 %load_bits to i32
  %tmpVar9 = sub i32 32, %11
  %12 = trunc i32 %tmpVar9 to i16
  store i16 %12, i16* %10, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call10 = call i64 @SHR(%SHR_interface* %SHR_instance4)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %13 = trunc i64 %call10 to i32
  store i32 %13, i32* %temp1, align 4
  %load_in11 = load i32, i32* %in, align 4
  %14 = icmp ne i32 %load_in11, 0
  br i1 %14, label %15, label %16

15:                                               ; preds = %continue8
  %load_temp112 = load i32, i32* %temp1, align 4
  br label %16

16:                                               ; preds = %15, %continue8
  %17 = phi i32 [ %load_in11, %continue8 ], [ %load_temp112, %15 ]
  store i32 %17, i32* %temp2, align 4
  %load_high = load float, float* %high, align 4
  %load_low = load float, float* %low, align 4
  %tmpVar13 = fsub float %load_high, %load_low
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input14

input14:                                          ; preds = %16
  %18 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_temp2 = load i32, i32* %temp2, align 4
  store i32 %load_temp2, i32* %18, align 4
  br label %call15

call15:                                           ; preds = %input14
  %call18 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %tmpVar19 = fmul float %tmpVar13, %call18
  %DWORD_TO_REAL_instance20 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input21

input21:                                          ; preds = %continue17
  %19 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance20, i32 0, i32 0
  %load_temp125 = load i32, i32* %temp1, align 4
  store i32 %load_temp125, i32* %19, align 4
  br label %call22

call22:                                           ; preds = %input21
  %call26 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance20)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %tmpVar27 = fdiv float %tmpVar19, %call26
  %load_low28 = load float, float* %low, align 4
  %tmpVar29 = fadd float %tmpVar27, %load_low28
  store float %tmpVar29, float* %AIN, align 4
  %load_sx = load i8, i8* %sx, align 1
  %20 = icmp ne i8 %load_sx, 0
  br i1 %20, label %condition_body31, label %continue30

condition_body31:                                 ; preds = %continue24
  %load_AIN = load float, float* %AIN, align 4
  %tmpVar32 = fneg float %load_AIN
  store float %tmpVar32, float* %AIN, align 4
  br label %continue30

continue30:                                       ; preds = %condition_body31, %continue24
  %AIN_ret = load float, float* %AIN, align 4
  ret float %AIN_ret
}

define void @AIN1(%AIN1_interface* %0) {
entry:
  %in = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 0
  %sign_bit = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 1
  %error_bit = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 2
  %error_code_en = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 3
  %error_code = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 4
  %overflow_bit = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 5
  %overflow_code_en = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 6
  %overflow_code = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 7
  %Bit_0 = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 8
  %Bit_N = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 9
  %out_min = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 10
  %out_max = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 11
  %code_min = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 12
  %code_max = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 13
  %error_output = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 14
  %overflow_output = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 15
  %out = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 16
  %sign = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 17
  %error = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 18
  %overflow = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 19
  %tB = getelementptr inbounds %AIN1_interface, %AIN1_interface* %0, i32 0, i32 20
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

1:                                                ; preds = %8
  %load_error_code_en = load i8, i8* %error_code_en, align 1
  %2 = zext i8 %load_error_code_en to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %16, label %18

4:                                                ; preds = %18, %8
  %5 = phi i32 [ %10, %8 ], [ %19, %18 ]
  store i32 %5, i8* %error, align 4
  %load_error = load i8, i8* %error, align 1
  %6 = icmp ne i8 %load_error, 0
  br i1 %6, label %condition_body, label %continue4

7:                                                ; preds = %continue
  br label %8

8:                                                ; preds = %7, %continue
  %9 = phi i64 [ %call1, %continue ], [ 1, %7 ]
  %tmpVar = icmp eq i64 %9, i32 1
  %10 = zext i1 %tmpVar to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %4, label %1

input:                                            ; preds = %entry
  %12 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in = load i32, i32* %in, align 4
  %13 = zext i32 %load_in to i64
  store i64 %13, i64* %12, align 4
  %14 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %load_error_bit = load i16, i16* %error_bit, align 2
  store i16 %load_error_bit, i16* %14, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %15 = icmp ne i64 %call1, 0
  br i1 %15, label %7, label %8

16:                                               ; preds = %1
  %load_error_code = load i32, i32* %error_code, align 4
  %load_in2 = load i32, i32* %in, align 4
  %tmpVar3 = icmp eq i32 %load_error_code, %load_in2
  %17 = zext i1 %tmpVar3 to i32
  br label %18

18:                                               ; preds = %16, %1
  %19 = phi i32 [ %2, %1 ], [ %17, %16 ]
  br label %4

condition_body:                                   ; preds = %4
  %load_error_output = load float, float* %error_output, align 4
  store float %load_error_output, float* %out, align 4
  ret void

buffer_block:                                     ; No predecessors!
  br label %continue4

continue4:                                        ; preds = %buffer_block, %4
  %SHR_instance5 = alloca %SHR_interface, align 8
  br label %input6

input6:                                           ; preds = %continue4
  %20 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance5, i32 0, i32 0
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input10

call7:                                            ; preds = %continue13
  %call20 = call i64 @SHR(%SHR_interface* %SHR_instance5)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %21 = trunc i64 %call20 to i32
  store i32 %21, i32* %tB, align 4
  %SHR_instance21 = alloca %SHR_interface, align 8
  br label %input22

input10:                                          ; preds = %input6
  %22 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_in14 = load i32, i32* %in, align 4
  %23 = zext i32 %load_in14 to i64
  store i64 %23, i64* %22, align 4
  %24 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_bit_N = load i16, i16* %Bit_N, align 2
  %25 = sext i16 %load_bit_N to i32
  %tmpVar15 = sub i32 31, %25
  %26 = trunc i32 %tmpVar15 to i16
  store i16 %26, i16* %24, align 2
  br label %call11

call11:                                           ; preds = %input10
  %call16 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  store i64 %call16, i64* %20, align 4
  %27 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance5, i32 0, i32 1
  %load_bit_N17 = load i16, i16* %Bit_N, align 2
  %28 = sext i16 %load_bit_N17 to i32
  %tmpVar18 = sub i32 31, %28
  %load_Bit_0 = load i16, i16* %Bit_0, align 2
  %29 = sext i16 %load_Bit_0 to i32
  %tmpVar19 = add i32 %tmpVar18, %29
  %30 = trunc i32 %tmpVar19 to i16
  store i16 %30, i16* %27, align 2
  br label %call7

31:                                               ; preds = %40
  %load_tb = load i32, i32* %tB, align 4
  %load_code_min = load i32, i32* %code_min, align 4
  %tmpVar31 = icmp slt i32 %load_tb, %load_code_min
  %32 = zext i1 %tmpVar31 to i32
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %58, label %56

34:                                               ; preds = %58, %40
  %35 = phi i32 [ %41, %40 ], [ %59, %58 ]
  store i32 %35, i8* %overflow, align 4
  %load_overflow = load i8, i8* %overflow, align 1
  %36 = icmp ne i8 %load_overflow, 0
  br i1 %36, label %condition_body35, label %continue34

37:                                               ; preds = %44
  %load_overflow_code_en = load i8, i8* %overflow_code_en, align 1
  %38 = zext i8 %load_overflow_code_en to i32
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %52, label %54

40:                                               ; preds = %54, %44
  %41 = phi i32 [ %46, %44 ], [ %55, %54 ]
  %42 = icmp ne i32 %41, 0
  br i1 %42, label %34, label %31

43:                                               ; preds = %continue25
  br label %44

44:                                               ; preds = %43, %continue25
  %45 = phi i64 [ %call27, %continue25 ], [ 1, %43 ]
  %tmpVar28 = icmp eq i64 %45, i32 1
  %46 = zext i1 %tmpVar28 to i32
  %47 = icmp ne i32 %46, 0
  br i1 %47, label %40, label %37

input22:                                          ; preds = %continue9
  %48 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance21, i32 0, i32 0
  %load_in26 = load i32, i32* %in, align 4
  %49 = zext i32 %load_in26 to i64
  store i64 %49, i64* %48, align 4
  %50 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance21, i32 0, i32 1
  %load_overflow_bit = load i16, i16* %overflow_bit, align 2
  store i16 %load_overflow_bit, i16* %50, align 2
  br label %call23

call23:                                           ; preds = %input22
  %call27 = call i64 @SHR(%SHR_interface* %SHR_instance21)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %51 = icmp ne i64 %call27, 0
  br i1 %51, label %43, label %44

52:                                               ; preds = %37
  %load_overflow_code = load i32, i32* %overflow_code, align 4
  %load_in29 = load i32, i32* %in, align 4
  %tmpVar30 = icmp eq i32 %load_overflow_code, %load_in29
  %53 = zext i1 %tmpVar30 to i32
  br label %54

54:                                               ; preds = %52, %37
  %55 = phi i32 [ %38, %37 ], [ %53, %52 ]
  br label %40

56:                                               ; preds = %31
  %load_tb32 = load i32, i32* %tB, align 4
  %load_code_max = load i32, i32* %code_max, align 4
  %tmpVar33 = icmp sgt i32 %load_tb32, %load_code_max
  %57 = zext i1 %tmpVar33 to i32
  br label %58

58:                                               ; preds = %56, %31
  %59 = phi i32 [ %32, %31 ], [ %57, %56 ]
  br label %34

condition_body35:                                 ; preds = %34
  %load_overflow_output = load float, float* %overflow_output, align 4
  store float %load_overflow_output, float* %out, align 4
  ret void

buffer_block36:                                   ; No predecessors!
  br label %continue34

continue34:                                       ; preds = %buffer_block36, %34
  %SHR_instance37 = alloca %SHR_interface, align 8
  br label %input38

60:                                               ; preds = %continue41
  br label %61

61:                                               ; preds = %60, %continue41
  %62 = phi i64 [ %call43, %continue41 ], [ 1, %60 ]
  %tmpVar44 = icmp eq i64 %62, i32 1
  %63 = zext i1 %tmpVar44 to i8
  store i8 %63, i8* %sign, align 1
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input45

input38:                                          ; preds = %continue34
  %64 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance37, i32 0, i32 0
  %load_in42 = load i32, i32* %in, align 4
  %65 = zext i32 %load_in42 to i64
  store i64 %65, i64* %64, align 4
  %66 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance37, i32 0, i32 1
  %load_sign_bit = load i16, i16* %sign_bit, align 2
  store i16 %load_sign_bit, i16* %66, align 2
  br label %call39

call39:                                           ; preds = %input38
  %call43 = call i64 @SHR(%SHR_interface* %SHR_instance37)
  br label %output40

output40:                                         ; preds = %call39
  br label %continue41

continue41:                                       ; preds = %output40
  %67 = icmp ne i64 %call43, 0
  br i1 %67, label %60, label %61

input45:                                          ; preds = %61
  %68 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_tb49 = load i32, i32* %tB, align 4
  %load_code_min50 = load i32, i32* %code_min, align 4
  %tmpVar51 = sub i32 %load_tb49, %load_code_min50
  store i32 %tmpVar51, i32* %68, align 4
  br label %call46

call46:                                           ; preds = %input45
  %call52 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output47

output47:                                         ; preds = %call46
  br label %continue48

continue48:                                       ; preds = %output47
  %load_out_max = load float, float* %out_max, align 4
  %load_out_min = load float, float* %out_min, align 4
  %tmpVar53 = fsub float %load_out_max, %load_out_min
  %tmpVar54 = fmul float %call52, %tmpVar53
  %DWORD_TO_REAL_instance55 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input56

input56:                                          ; preds = %continue48
  %69 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance55, i32 0, i32 0
  %load_code_max60 = load i32, i32* %code_max, align 4
  %load_code_min61 = load i32, i32* %code_min, align 4
  %tmpVar62 = sub i32 %load_code_max60, %load_code_min61
  store i32 %tmpVar62, i32* %69, align 4
  br label %call57

call57:                                           ; preds = %input56
  %call63 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance55)
  br label %output58

output58:                                         ; preds = %call57
  br label %continue59

continue59:                                       ; preds = %output58
  %tmpVar64 = fdiv float %tmpVar54, %call63
  %load_out_min65 = load float, float* %out_min, align 4
  %tmpVar66 = fadd float %tmpVar64, %load_out_min65
  store float %tmpVar66, float* %out, align 4
  %load_sign = load i8, i8* %sign, align 1
  %70 = icmp ne i8 %load_sign, 0
  br i1 %70, label %condition_body68, label %continue67

condition_body68:                                 ; preds = %continue59
  %load_out = load float, float* %out, align 4
  %tmpVar69 = fmul float %load_out, -1.000000e+00
  store float %tmpVar69, float* %out, align 4
  br label %continue67

continue67:                                       ; preds = %condition_body68, %continue59
  ret void
}

define i32 @AOUT(%AOUT_interface* %0) {
entry:
  %in = getelementptr inbounds %AOUT_interface, %AOUT_interface* %0, i32 0, i32 0
  %Bits = getelementptr inbounds %AOUT_interface, %AOUT_interface* %0, i32 0, i32 1
  %sign = getelementptr inbounds %AOUT_interface, %AOUT_interface* %0, i32 0, i32 2
  %low = getelementptr inbounds %AOUT_interface, %AOUT_interface* %0, i32 0, i32 3
  %high = getelementptr inbounds %AOUT_interface, %AOUT_interface* %0, i32 0, i32 4
  %ff = getelementptr inbounds %AOUT_interface, %AOUT_interface* %0, i32 0, i32 5
  %in2 = getelementptr inbounds %AOUT_interface, %AOUT_interface* %0, i32 0, i32 6
  %sx = getelementptr inbounds %AOUT_interface, %AOUT_interface* %0, i32 0, i32 7
  %AOUT = alloca i32, align 4
  store i32 1, i32* %ff, align 4
  store float 0.000000e+00, float* %in2, align 4
  store i8 0, i8* %sx, align 1
  store i32 0, i32* %AOUT, align 4
  %load_sign = load i8, i8* %sign, align 1
  %1 = zext i8 %load_sign to i32
  %tmpVar = icmp slt i32 %1, 32
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %SIGN_R_instance = alloca %SIGN_R_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %load_in9 = load float, float* %in, align 4
  store float %load_in9, float* %in2, align 4
  br label %continue

continue:                                         ; preds = %else, %continue6
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input10

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %SIGN_R_interface, %SIGN_R_interface* %SIGN_R_instance, i32 0, i32 0
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i8 @SIGN_R(%SIGN_R_interface* %SIGN_R_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store i8 %call2, i8* %sx, align 1
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input3

input3:                                           ; preds = %continue1
  %3 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_in7 = load float, float* %in, align 4
  %4 = fptoui float %load_in7 to i64
  store i64 %4, i64* %3, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %5 = uitofp i64 %call8 to float
  store float %5, float* %in2, align 4
  br label %continue

input10:                                          ; preds = %continue
  %6 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_low = load float, float* %low, align 4
  %7 = fptoui float %load_low to i64
  store i64 %7, i64* %6, align 4
  %8 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_in2 = load float, float* %in2, align 4
  %9 = fptoui float %load_in2 to i64
  store i64 %9, i64* %8, align 4
  %10 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_high = load float, float* %high, align 4
  %11 = fptoui float %load_high to i64
  store i64 %11, i64* %10, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call14 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %12 = uitofp i64 %call14 to float
  store float %12, float* %in2, align 4
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input15

input15:                                          ; preds = %continue13
  %13 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %load_in219 = load float, float* %in2, align 4
  %load_low20 = load float, float* %low, align 4
  %tmpVar21 = fsub float %load_in219, %load_low20
  %load_high22 = load float, float* %high, align 4
  %load_low23 = load float, float* %low, align 4
  %tmpVar24 = fsub float %load_high22, %load_low23
  %tmpVar25 = fdiv float %tmpVar21, %tmpVar24
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input26

call16:                                           ; preds = %continue29
  %call38 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  store i32 %call38, i32* %AOUT, align 4
  %load_sx = load i8, i8* %sx, align 1
  %14 = icmp ne i8 %load_sx, 0
  br i1 %14, label %condition_body40, label %continue39

input26:                                          ; preds = %input15
  %15 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input30

call27:                                           ; preds = %continue33
  %call36 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  %tmpVar37 = fmul float %tmpVar25, %call36
  store float %tmpVar37, float* %13, align 4
  br label %call16

input30:                                          ; preds = %input26
  %16 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_ff = load i32, i32* %ff, align 4
  %17 = zext i32 %load_ff to i64
  store i64 %17, i64* %16, align 4
  %18 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_bits = load i8, i8* %Bits, align 1
  %19 = zext i8 %load_bits to i16
  store i16 %19, i16* %18, align 2
  br label %call31

call31:                                           ; preds = %input30
  %call34 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output32

output32:                                         ; preds = %call31
  br label %continue33

continue33:                                       ; preds = %output32
  %tmpVar35 = sub i64 %call34, 1
  %20 = trunc i64 %tmpVar35 to i32
  store i32 %20, i32* %15, align 4
  br label %call27

condition_body40:                                 ; preds = %continue18
  %SHL_instance41 = alloca %SHL_interface, align 8
  br label %input42

continue39:                                       ; preds = %23, %continue18
  %AOUT_ret = load i32, i32* %AOUT, align 4
  ret i32 %AOUT_ret

21:                                               ; preds = %continue45
  %load_Aout = load i32, i32* %AOUT, align 4
  %22 = zext i32 %load_Aout to i64
  br label %23

23:                                               ; preds = %21, %continue45
  %24 = phi i64 [ %call48, %continue45 ], [ %22, %21 ]
  store i64 %24, i32* %AOUT, align 4
  br label %continue39

input42:                                          ; preds = %condition_body40
  %25 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance41, i32 0, i32 0
  %load_ff46 = load i32, i32* %ff, align 4
  %26 = zext i32 %load_ff46 to i64
  store i64 %26, i64* %25, align 4
  %27 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance41, i32 0, i32 1
  %load_sign47 = load i8, i8* %sign, align 1
  %28 = zext i8 %load_sign47 to i16
  store i16 %28, i16* %27, align 2
  br label %call43

call43:                                           ; preds = %input42
  %call48 = call i64 @SHL(%SHL_interface* %SHL_instance41)
  br label %output44

output44:                                         ; preds = %call43
  br label %continue45

continue45:                                       ; preds = %output44
  %29 = icmp ne i64 %call48, 0
  br i1 %29, label %23, label %21
}

define i32 @AOUT1(%AOUT1_interface* %0) {
entry:
  %in = getelementptr inbounds %AOUT1_interface, %AOUT1_interface* %0, i32 0, i32 0
  %Bit_0 = getelementptr inbounds %AOUT1_interface, %AOUT1_interface* %0, i32 0, i32 1
  %Bit_N = getelementptr inbounds %AOUT1_interface, %AOUT1_interface* %0, i32 0, i32 2
  %sign = getelementptr inbounds %AOUT1_interface, %AOUT1_interface* %0, i32 0, i32 3
  %low = getelementptr inbounds %AOUT1_interface, %AOUT1_interface* %0, i32 0, i32 4
  %high = getelementptr inbounds %AOUT1_interface, %AOUT1_interface* %0, i32 0, i32 5
  %ff = getelementptr inbounds %AOUT1_interface, %AOUT1_interface* %0, i32 0, i32 6
  %sx = getelementptr inbounds %AOUT1_interface, %AOUT1_interface* %0, i32 0, i32 7
  %in2 = getelementptr inbounds %AOUT1_interface, %AOUT1_interface* %0, i32 0, i32 8
  %AOUT1 = alloca i32, align 4
  store i32 1, i32* %ff, align 4
  store i8 0, i8* %sx, align 1
  store float 0.000000e+00, float* %in2, align 4
  store i32 0, i32* %AOUT1, align 4
  %load_sign = load i16, i16* %sign, align 2
  %1 = sext i16 %load_sign to i32
  %tmpVar = icmp slt i32 %1, 32
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %SIGN_R_instance = alloca %SIGN_R_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %load_in9 = load float, float* %in, align 4
  store float %load_in9, float* %in2, align 4
  br label %continue

continue:                                         ; preds = %else, %continue6
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input10

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %SIGN_R_interface, %SIGN_R_interface* %SIGN_R_instance, i32 0, i32 0
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i8 @SIGN_R(%SIGN_R_interface* %SIGN_R_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store i8 %call2, i8* %sx, align 1
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input3

input3:                                           ; preds = %continue1
  %3 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_in7 = load float, float* %in, align 4
  %4 = fptoui float %load_in7 to i64
  store i64 %4, i64* %3, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %5 = uitofp i64 %call8 to float
  store float %5, float* %in2, align 4
  br label %continue

input10:                                          ; preds = %continue
  %6 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_low = load float, float* %low, align 4
  %7 = fptoui float %load_low to i64
  store i64 %7, i64* %6, align 4
  %8 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_in2 = load float, float* %in2, align 4
  %9 = fptoui float %load_in2 to i64
  store i64 %9, i64* %8, align 4
  %10 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_high = load float, float* %high, align 4
  %11 = fptoui float %load_high to i64
  store i64 %11, i64* %10, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call14 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %12 = uitofp i64 %call14 to float
  store float %12, float* %in2, align 4
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input15

input15:                                          ; preds = %continue13
  %13 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input19

call16:                                           ; preds = %continue22
  %call47 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %14 = trunc i64 %call47 to i32
  store i32 %14, i32* %AOUT1, align 4
  %load_sx = load i8, i8* %sx, align 1
  %15 = icmp ne i8 %load_sx, 0
  br i1 %15, label %condition_body49, label %continue48

input19:                                          ; preds = %input15
  %16 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %load_in223 = load float, float* %in2, align 4
  %load_low24 = load float, float* %low, align 4
  %tmpVar25 = fsub float %load_in223, %load_low24
  %load_high26 = load float, float* %high, align 4
  %load_low27 = load float, float* %low, align 4
  %tmpVar28 = fsub float %load_high26, %load_low27
  %tmpVar29 = fdiv float %tmpVar25, %tmpVar28
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input30

call20:                                           ; preds = %continue33
  %call45 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  %17 = zext i32 %call45 to i64
  store i64 %17, i64* %13, align 4
  %18 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_Bit_046 = load i16, i16* %Bit_0, align 2
  store i16 %load_Bit_046, i16* %18, align 2
  br label %call16

input30:                                          ; preds = %input19
  %19 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %SHL_instance34 = alloca %SHL_interface, align 8
  br label %input35

call31:                                           ; preds = %continue38
  %call43 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output32

output32:                                         ; preds = %call31
  br label %continue33

continue33:                                       ; preds = %output32
  %tmpVar44 = fmul float %tmpVar29, %call43
  store float %tmpVar44, float* %16, align 4
  br label %call20

input35:                                          ; preds = %input30
  %20 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance34, i32 0, i32 0
  %load_ff = load i32, i32* %ff, align 4
  %21 = zext i32 %load_ff to i64
  store i64 %21, i64* %20, align 4
  %22 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance34, i32 0, i32 1
  %load_bit_n = load i16, i16* %Bit_N, align 2
  %23 = sext i16 %load_bit_n to i32
  %load_Bit_0 = load i16, i16* %Bit_0, align 2
  %24 = sext i16 %load_Bit_0 to i32
  %tmpVar39 = sub i32 %23, %24
  %tmpVar40 = add i32 %tmpVar39, 1
  %25 = trunc i32 %tmpVar40 to i16
  store i16 %25, i16* %22, align 2
  br label %call36

call36:                                           ; preds = %input35
  %call41 = call i64 @SHL(%SHL_interface* %SHL_instance34)
  br label %output37

output37:                                         ; preds = %call36
  br label %continue38

continue38:                                       ; preds = %output37
  %tmpVar42 = sub i64 %call41, 1
  %26 = trunc i64 %tmpVar42 to i32
  store i32 %26, i32* %19, align 4
  br label %call31

condition_body49:                                 ; preds = %continue18
  %SHL_instance50 = alloca %SHL_interface, align 8
  br label %input51

continue48:                                       ; preds = %29, %continue18
  %AOUT1_ret = load i32, i32* %AOUT1, align 4
  ret i32 %AOUT1_ret

27:                                               ; preds = %continue54
  %load_AOUT1 = load i32, i32* %AOUT1, align 4
  %28 = zext i32 %load_AOUT1 to i64
  br label %29

29:                                               ; preds = %27, %continue54
  %30 = phi i64 [ %call57, %continue54 ], [ %28, %27 ]
  store i64 %30, i32* %AOUT1, align 4
  br label %continue48

input51:                                          ; preds = %condition_body49
  %31 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance50, i32 0, i32 0
  %load_ff55 = load i32, i32* %ff, align 4
  %32 = zext i32 %load_ff55 to i64
  store i64 %32, i64* %31, align 4
  %33 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance50, i32 0, i32 1
  %load_sign56 = load i16, i16* %sign, align 2
  store i16 %load_sign56, i16* %33, align 2
  br label %call52

call52:                                           ; preds = %input51
  %call57 = call i64 @SHL(%SHL_interface* %SHL_instance50)
  br label %output53

output53:                                         ; preds = %call52
  br label %continue54

continue54:                                       ; preds = %output53
  %34 = icmp ne i64 %call57, 0
  br i1 %34, label %29, label %27
}

define float @BYTE_TO_RANGE(%BYTE_TO_RANGE_interface* %0) {
entry:
  %X = getelementptr inbounds %BYTE_TO_RANGE_interface, %BYTE_TO_RANGE_interface* %0, i32 0, i32 0
  %low = getelementptr inbounds %BYTE_TO_RANGE_interface, %BYTE_TO_RANGE_interface* %0, i32 0, i32 1
  %high = getelementptr inbounds %BYTE_TO_RANGE_interface, %BYTE_TO_RANGE_interface* %0, i32 0, i32 2
  %BYTE_TO_RANGE = alloca float, align 4
  store float 0.000000e+00, float* %BYTE_TO_RANGE, align 4
  %load_high = load float, float* %high, align 4
  %load_low = load float, float* %low, align 4
  %tmpVar = fsub float %load_high, %load_low
  %load_X = load i8, i8* %X, align 1
  %1 = uitofp i8 %load_X to float
  %tmpVar1 = fmul float %tmpVar, %1
  %tmpVar2 = fdiv float %tmpVar1, 2.550000e+02
  %load_low3 = load float, float* %low, align 4
  %tmpVar4 = fadd float %tmpVar2, %load_low3
  store float %tmpVar4, float* %BYTE_TO_RANGE, align 4
  %BYTE_TO_RANGE_ret = load float, float* %BYTE_TO_RANGE, align 4
  ret float %BYTE_TO_RANGE_ret
}

define void @DELAY(%DELAY_interface* %0) {
entry:
  %IN = getelementptr inbounds %DELAY_interface, %DELAY_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %DELAY_interface, %DELAY_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %DELAY_interface, %DELAY_interface* %0, i32 0, i32 2
  %OUT = getelementptr inbounds %DELAY_interface, %DELAY_interface* %0, i32 0, i32 3
  %buf = getelementptr inbounds %DELAY_interface, %DELAY_interface* %0, i32 0, i32 4
  %i = getelementptr inbounds %DELAY_interface, %DELAY_interface* %0, i32 0, i32 5
  %init = getelementptr inbounds %DELAY_interface, %DELAY_interface* %0, i32 0, i32 6
  %stop = getelementptr inbounds %DELAY_interface, %DELAY_interface* %0, i32 0, i32 7
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %1, align 4
  %2 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %3 = sext i16 %load_N to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 32, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = sub i64 %call1, 1
  %5 = trunc i64 %tmpVar to i16
  store i16 %5, i16* %stop, align 2
  %load_rst = load i8, i8* %RST, align 1
  %6 = zext i8 %load_rst to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %13, label %11

condition_body:                                   ; preds = %13
  store i8 1, i8* %init, align 1
  store i16 0, i16* %i, align 2
  br label %condition_check

branch:                                           ; preds = %13
  %load_stop21 = load i16, i16* %stop, align 2
  %8 = sext i16 %load_stop21 to i32
  %tmpVar22 = icmp slt i32 %8, 0
  br i1 %tmpVar22, label %condition_body20, label %else

condition_body20:                                 ; preds = %branch
  %load_in23 = load float, float* %IN, align 4
  store float %load_in23, float* %OUT, align 4
  br label %continue2

else:                                             ; preds = %branch
  %load_i24 = load i16, i16* %i, align 2
  %9 = sext i16 %load_i24 to i32
  %tmpVar25 = mul i32 1, %9
  %tmpVar26 = add i32 %tmpVar25, 0
  %tmpVar27 = getelementptr inbounds [32 x float], [32 x float]* %buf, i32 0, i32 %tmpVar26
  %load_tmpVar = load float, float* %tmpVar27, align 4
  store float %load_tmpVar, float* %OUT, align 4
  %load_i28 = load i16, i16* %i, align 2
  %10 = sext i16 %load_i28 to i32
  %tmpVar29 = mul i32 1, %10
  %tmpVar30 = add i32 %tmpVar29, 0
  %tmpVar31 = getelementptr inbounds [32 x float], [32 x float]* %buf, i32 0, i32 %tmpVar30
  %load_in32 = load float, float* %IN, align 4
  store float %load_in32, float* %tmpVar31, align 4
  %INC1_instance = alloca %INC1_interface, align 8
  br label %input33

continue2:                                        ; preds = %continue36, %condition_body20, %continue4
  ret void

11:                                               ; preds = %continue
  %load_init = load i8, i8* %init, align 1
  %tmpVar3 = xor i8 %load_init, -1
  %12 = zext i8 %tmpVar3 to i32
  br label %13

13:                                               ; preds = %11, %continue
  %14 = phi i32 [ %6, %continue ], [ %12, %11 ]
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %condition_body, label %branch

condition_check:                                  ; preds = %increment, %condition_body
  %load_i = load i16, i16* %i, align 2
  %load_i5 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar6 = icmp sle i16 %load_i5, %load_stop
  %16 = icmp ne i1 %tmpVar6, false
  br i1 %16, label %22, label %23

for_body:                                         ; preds = %20
  %load_i14 = load i16, i16* %i, align 2
  %17 = sext i16 %load_i14 to i32
  %tmpVar15 = mul i32 1, %17
  %tmpVar16 = add i32 %tmpVar15, 0
  %tmpVar17 = getelementptr inbounds [32 x float], [32 x float]* %buf, i32 0, i32 %tmpVar16
  %load_in = load float, float* %IN, align 4
  store float %load_in, float* %tmpVar17, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar18 = add i16 %load_i, 1
  store i16 %tmpVar18, i16* %i, align 2
  br label %condition_check

continue4:                                        ; preds = %20
  %load_in19 = load float, float* %IN, align 4
  store float %load_in19, float* %OUT, align 4
  store i16 0, i16* %i, align 2
  br label %continue2

18:                                               ; preds = %23
  %load_i9 = load i16, i16* %i, align 2
  %load_stop10 = load i16, i16* %stop, align 2
  %tmpVar11 = icmp sge i16 %load_i9, %load_stop10
  %19 = icmp ne i1 %tmpVar11, false
  br i1 %19, label %26, label %27

20:                                               ; preds = %27, %23
  %21 = phi i1 [ %24, %23 ], [ %28, %27 ]
  br i1 %21, label %for_body, label %continue4

22:                                               ; preds = %condition_check
  %load_i7 = load i16, i16* %i, align 2
  %tmpVar8 = icmp sge i16 %load_i7, 0
  br label %23

23:                                               ; preds = %22, %condition_check
  %24 = phi i1 [ %tmpVar6, %condition_check ], [ %tmpVar8, %22 ]
  %25 = icmp ne i1 %24, false
  br i1 %25, label %20, label %18

26:                                               ; preds = %18
  %load_i12 = load i16, i16* %i, align 2
  %tmpVar13 = icmp sle i16 %load_i12, 0
  br label %27

27:                                               ; preds = %26, %18
  %28 = phi i1 [ %tmpVar11, %18 ], [ %tmpVar13, %26 ]
  br label %20

input33:                                          ; preds = %else
  %29 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 0
  %load_i37 = load i16, i16* %i, align 2
  store i16 %load_i37, i16* %29, align 2
  %30 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 1
  %load_N38 = load i16, i16* %N, align 2
  store i16 %load_N38, i16* %30, align 2
  br label %call34

call34:                                           ; preds = %input33
  %call39 = call i16 @INC1(%INC1_interface* %INC1_instance)
  br label %output35

output35:                                         ; preds = %call34
  br label %continue36

continue36:                                       ; preds = %output35
  store i16 %call39, i16* %i, align 2
  br label %continue2
}

define void @DELAY_4(%DELAY_4_interface* %0) {
entry:
  %in = getelementptr inbounds %DELAY_4_interface, %DELAY_4_interface* %0, i32 0, i32 0
  %out1 = getelementptr inbounds %DELAY_4_interface, %DELAY_4_interface* %0, i32 0, i32 1
  %out2 = getelementptr inbounds %DELAY_4_interface, %DELAY_4_interface* %0, i32 0, i32 2
  %out3 = getelementptr inbounds %DELAY_4_interface, %DELAY_4_interface* %0, i32 0, i32 3
  %out4 = getelementptr inbounds %DELAY_4_interface, %DELAY_4_interface* %0, i32 0, i32 4
  %temp = getelementptr inbounds %DELAY_4_interface, %DELAY_4_interface* %0, i32 0, i32 5
  %load_out3 = load float, float* %out3, align 4
  store float %load_out3, float* %out4, align 4
  %load_out2 = load float, float* %out2, align 4
  store float %load_out2, float* %out3, align 4
  %load_out1 = load float, float* %out1, align 4
  store float %load_out1, float* %out2, align 4
  %load_temp = load float, float* %temp, align 4
  store float %load_temp, float* %out1, align 4
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %temp, align 4
  ret void
}

define void @FADE(%FADE_interface* %0) {
entry:
  %IN1 = getelementptr inbounds %FADE_interface, %FADE_interface* %0, i32 0, i32 0
  %IN2 = getelementptr inbounds %FADE_interface, %FADE_interface* %0, i32 0, i32 1
  %F = getelementptr inbounds %FADE_interface, %FADE_interface* %0, i32 0, i32 2
  %TF = getelementptr inbounds %FADE_interface, %FADE_interface* %0, i32 0, i32 3
  %rst = getelementptr inbounds %FADE_interface, %FADE_interface* %0, i32 0, i32 4
  %Y = getelementptr inbounds %FADE_interface, %FADE_interface* %0, i32 0, i32 5
  %rmx = getelementptr inbounds %FADE_interface, %FADE_interface* %0, i32 0, i32 6
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %rmx, i32 0, i32 4
  %load_rst = load i8, i8* %rst, align 1
  %2 = zext i8 %load_rst to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %9, label %11
  %4 = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %rmx, i32 0, i32 0
  %load_rst1 = load i8, i8* %rst, align 1
  %5 = zext i8 %load_rst1 to i32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %13, label %15
  %7 = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %rmx, i32 0, i32 1
  %load_TF = load i64, i64* %TF, align 4
  store i64 %load_TF, i64* %7, align 4
  %8 = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %rmx, i32 0, i32 3
  %load_F3 = load i8, i8* %F, align 1
  store i8 %load_F3, i8* %8, align 1
  br label %call

call:                                             ; preds = %input
  call void @RMP_W(%RMP_W_interface* %rmx)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_in2 = load float, float* %IN2, align 4
  %load_In1 = load float, float* %IN1, align 4
  %tmpVar4 = fsub float %load_in2, %load_In1
  %tmpVar5 = fdiv float %tmpVar4, 6.553500e+04
  %WORD_TO_REAL_instance = alloca %WORD_TO_REAL_interface, align 8
  br label %input6

9:                                                ; preds = %input
  %load_F = load i8, i8* %F, align 1
  %tmpVar = xor i8 %load_F, -1
  %10 = zext i8 %tmpVar to i32
  br label %11

11:                                               ; preds = %9, %input
  %12 = phi i32 [ %2, %input ], [ %10, %9 ]
  store i32 %12, i8* %1, align 4

13:                                               ; preds = %input
  %load_F2 = load i8, i8* %F, align 1
  %14 = zext i8 %load_F2 to i32
  br label %15

15:                                               ; preds = %13, %input
  %16 = phi i32 [ %5, %input ], [ %14, %13 ]
  store i32 %16, i8* %4, align 4

input6:                                           ; preds = %continue
  %17 = getelementptr inbounds %WORD_TO_REAL_interface, %WORD_TO_REAL_interface* %WORD_TO_REAL_instance, i32 0, i32 0
  %out = getelementptr inbounds %RMP_W_interface, %RMP_W_interface* %rmx, i32 0, i32 5
  %load_ = load i16, i16* %out, align 2
  store i16 %load_, i16* %17, align 2
  br label %call7

call7:                                            ; preds = %input6
  %call10 = call float @WORD_TO_REAL(%WORD_TO_REAL_interface* %WORD_TO_REAL_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %tmpVar11 = fmul float %tmpVar5, %call10
  %load_in1 = load float, float* %IN1, align 4
  %tmpVar12 = fadd float %tmpVar11, %load_in1
  store float %tmpVar12, float* %Y, align 4
  ret void
}

define void @FILTER_DW(%FILTER_DW_interface* %0) {
entry:
  %X = getelementptr inbounds %FILTER_DW_interface, %FILTER_DW_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %FILTER_DW_interface, %FILTER_DW_interface* %0, i32 0, i32 1
  %Y = getelementptr inbounds %FILTER_DW_interface, %FILTER_DW_interface* %0, i32 0, i32 2
  %last = getelementptr inbounds %FILTER_DW_interface, %FILTER_DW_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %FILTER_DW_interface, %FILTER_DW_interface* %0, i32 0, i32 4
  %init = getelementptr inbounds %FILTER_DW_interface, %FILTER_DW_interface* %0, i32 0, i32 5
  %Yi = getelementptr inbounds %FILTER_DW_interface, %FILTER_DW_interface* %0, i32 0, i32 6
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = zext i8 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %5, label %3

condition_body:                                   ; preds = %5
  store i8 1, i8* %init, align 1
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input4

else:                                             ; preds = %5
  %load_Yi = load float, float* %Yi, align 4
  %DWORD_TO_REAL_instance9 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input10

continue2:                                        ; preds = %continue34, %continue7
  %load_tx39 = load i32, i32* %tx, align 4
  store i32 %load_tx39, i32* %last, align 4
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input40

3:                                                ; preds = %continue
  %load_T = load i64, i64* %T, align 4
  %tmpVar3 = icmp eq i64 %load_T, 0
  %4 = zext i1 %tmpVar3 to i32
  br label %5

5:                                                ; preds = %3, %continue
  %6 = phi i32 [ %1, %continue ], [ %4, %3 ]
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %condition_body, label %else

input4:                                           ; preds = %condition_body
  %8 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_X = load i32, i32* %X, align 4
  store i32 %load_X, i32* %8, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  store float %call8, float* %Yi, align 4
  br label %continue2

input10:                                          ; preds = %else
  %9 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance9, i32 0, i32 0
  %load_X14 = load i32, i32* %X, align 4
  store i32 %load_X14, i32* %9, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call15 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance9)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %DWORD_TO_REAL_instance16 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input17

input17:                                          ; preds = %continue13
  %10 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance16, i32 0, i32 0
  %load_Y = load i32, i32* %Y, align 4
  store i32 %load_Y, i32* %10, align 4
  br label %call18

call18:                                           ; preds = %input17
  %call21 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance16)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %tmpVar22 = fsub float %call15, %call21
  %DWORD_TO_REAL_instance23 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input24

input24:                                          ; preds = %continue20
  %11 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance23, i32 0, i32 0
  %load_tx = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar28 = sub i32 %load_tx, %load_last
  store i32 %tmpVar28, i32* %11, align 4
  br label %call25

call25:                                           ; preds = %input24
  %call29 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance23)
  br label %output26

output26:                                         ; preds = %call25
  br label %continue27

continue27:                                       ; preds = %output26
  %tmpVar30 = fmul float %tmpVar22, %call29
  %TIME_TO_REAL_instance = alloca %TIME_TO_REAL_interface, align 8
  br label %input31

input31:                                          ; preds = %continue27
  %12 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance, i32 0, i32 0
  %load_T35 = load i64, i64* %T, align 4
  store i64 %load_T35, i64* %12, align 4
  br label %call32

call32:                                           ; preds = %input31
  %call36 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  %tmpVar37 = fdiv float %tmpVar30, %call36
  %tmpVar38 = fadd float %load_Yi, %tmpVar37
  store float %tmpVar38, float* %Yi, align 4
  br label %continue2

input40:                                          ; preds = %continue2
  %13 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %load_Yi44 = load float, float* %Yi, align 4
  store float %load_Yi44, float* %13, align 4
  br label %call41

call41:                                           ; preds = %input40
  %call45 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output42

output42:                                         ; preds = %call41
  br label %continue43

continue43:                                       ; preds = %output42
  store i32 %call45, i32* %Y, align 4
  ret void
}

define void @FILTER_I(%FILTER_I_interface* %0) {
entry:
  %X = getelementptr inbounds %FILTER_I_interface, %FILTER_I_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %FILTER_I_interface, %FILTER_I_interface* %0, i32 0, i32 1
  %Y = getelementptr inbounds %FILTER_I_interface, %FILTER_I_interface* %0, i32 0, i32 2
  %Yi = getelementptr inbounds %FILTER_I_interface, %FILTER_I_interface* %0, i32 0, i32 3
  %last = getelementptr inbounds %FILTER_I_interface, %FILTER_I_interface* %0, i32 0, i32 4
  %tx = getelementptr inbounds %FILTER_I_interface, %FILTER_I_interface* %0, i32 0, i32 5
  %init = getelementptr inbounds %FILTER_I_interface, %FILTER_I_interface* %0, i32 0, i32 6
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = zext i8 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %5, label %3

condition_body:                                   ; preds = %5
  store i8 1, i8* %init, align 1
  %INT_TO_DINT_instance = alloca %INT_TO_DINT_interface, align 8
  br label %input4

else:                                             ; preds = %5
  %load_Yi = load i32, i32* %Yi, align 4
  %INT_TO_DINT_instance10 = alloca %INT_TO_DINT_interface, align 8
  br label %input11

continue2:                                        ; preds = %continue29, %continue7
  %load_tx34 = load i32, i32* %tx, align 4
  store i32 %load_tx34, i32* %last, align 4
  %DINT_TO_INT_instance = alloca %DINT_TO_INT_interface, align 8
  br label %input35

3:                                                ; preds = %continue
  %load_T = load i64, i64* %T, align 4
  %tmpVar3 = icmp eq i64 %load_T, 0
  %4 = zext i1 %tmpVar3 to i32
  br label %5

5:                                                ; preds = %3, %continue
  %6 = phi i32 [ %1, %continue ], [ %4, %3 ]
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %condition_body, label %else

input4:                                           ; preds = %condition_body
  %8 = getelementptr inbounds %INT_TO_DINT_interface, %INT_TO_DINT_interface* %INT_TO_DINT_instance, i32 0, i32 0
  %load_X = load i16, i16* %X, align 2
  store i16 %load_X, i16* %8, align 2
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call i32 @INT_TO_DINT(%INT_TO_DINT_interface* %INT_TO_DINT_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %tmpVar9 = mul i32 %call8, 1000
  store i32 %tmpVar9, i32* %Yi, align 4
  br label %continue2

input11:                                          ; preds = %else
  %9 = getelementptr inbounds %INT_TO_DINT_interface, %INT_TO_DINT_interface* %INT_TO_DINT_instance10, i32 0, i32 0
  %load_X15 = load i16, i16* %X, align 2
  %10 = sext i16 %load_X15 to i32
  %load_Y = load i16, i16* %Y, align 2
  %11 = sext i16 %load_Y to i32
  %tmpVar16 = sub i32 %10, %11
  %12 = trunc i32 %tmpVar16 to i16
  store i16 %12, i16* %9, align 2
  br label %call12

call12:                                           ; preds = %input11
  %call17 = call i32 @INT_TO_DINT(%INT_TO_DINT_interface* %INT_TO_DINT_instance10)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %DWORD_TO_DINT_instance = alloca %DWORD_TO_DINT_interface, align 8
  br label %input18

input18:                                          ; preds = %continue14
  %13 = getelementptr inbounds %DWORD_TO_DINT_interface, %DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance, i32 0, i32 0
  %load_tx = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar22 = sub i32 %load_tx, %load_last
  store i32 %tmpVar22, i32* %13, align 4
  br label %call19

call19:                                           ; preds = %input18
  %call23 = call i32 @DWORD_TO_DINT(%DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %tmpVar24 = mul i32 %call17, %call23
  %tmpVar25 = mul i32 %tmpVar24, 1000
  %TIME_TO_DINT_instance = alloca %TIME_TO_DINT_interface, align 8
  br label %input26

input26:                                          ; preds = %continue21
  %14 = getelementptr inbounds %TIME_TO_DINT_interface, %TIME_TO_DINT_interface* %TIME_TO_DINT_instance, i32 0, i32 0
  %load_T30 = load i64, i64* %T, align 4
  store i64 %load_T30, i64* %14, align 4
  br label %call27

call27:                                           ; preds = %input26
  %call31 = call i32 @TIME_TO_DINT(%TIME_TO_DINT_interface* %TIME_TO_DINT_instance)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  %tmpVar32 = sdiv i32 %tmpVar25, %call31
  %tmpVar33 = add i32 %load_Yi, %tmpVar32
  store i32 %tmpVar33, i32* %Yi, align 4
  br label %continue2

input35:                                          ; preds = %continue2
  %15 = getelementptr inbounds %DINT_TO_INT_interface, %DINT_TO_INT_interface* %DINT_TO_INT_instance, i32 0, i32 0
  %load_yi = load i32, i32* %Yi, align 4
  %tmpVar39 = sdiv i32 %load_yi, 1000
  store i32 %tmpVar39, i32* %15, align 4
  br label %call36

call36:                                           ; preds = %input35
  %call40 = call i16 @DINT_TO_INT(%DINT_TO_INT_interface* %DINT_TO_INT_instance)
  br label %output37

output37:                                         ; preds = %call36
  br label %continue38

continue38:                                       ; preds = %output37
  store i16 %call40, i16* %Y, align 2
  ret void
}

define void @FILTER_MAV_DW(%FILTER_MAV_DW_interface* %0) {
entry:
  %X = getelementptr inbounds %FILTER_MAV_DW_interface, %FILTER_MAV_DW_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %FILTER_MAV_DW_interface, %FILTER_MAV_DW_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %FILTER_MAV_DW_interface, %FILTER_MAV_DW_interface* %0, i32 0, i32 2
  %Y = getelementptr inbounds %FILTER_MAV_DW_interface, %FILTER_MAV_DW_interface* %0, i32 0, i32 3
  %init = getelementptr inbounds %FILTER_MAV_DW_interface, %FILTER_MAV_DW_interface* %0, i32 0, i32 4
  %buffer = getelementptr inbounds %FILTER_MAV_DW_interface, %FILTER_MAV_DW_interface* %0, i32 0, i32 5
  %i = getelementptr inbounds %FILTER_MAV_DW_interface, %FILTER_MAV_DW_interface* %0, i32 0, i32 6
  %tmp = alloca i16, align 2
  store i16 0, i16* %tmp, align 2
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_N = load i16, i16* %N, align 2
  %2 = zext i16 %load_N to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  store i64 32, i64* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = trunc i64 %call1 to i16
  store i16 %4, i16* %N, align 2
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %5 = zext i8 %tmpVar to i32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %15, label %13

condition_body:                                   ; preds = %10
  store i8 1, i8* %init, align 1
  %UINT_TO_INT_instance = alloca %UINT_TO_INT_interface, align 8
  br label %input5

else:                                             ; preds = %10
  %UINT_TO_INT_instance28 = alloca %UINT_TO_INT_interface, align 8
  br label %input29

continue2:                                        ; preds = %continue38, %continue12
  ret void

7:                                                ; preds = %15
  %load_N3 = load i16, i16* %N, align 2
  %8 = zext i16 %load_N3 to i32
  %tmpVar4 = icmp eq i32 %8, 0
  %9 = zext i1 %tmpVar4 to i32
  br label %10

10:                                               ; preds = %7, %15
  %11 = phi i32 [ %16, %15 ], [ %9, %7 ]
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %condition_body, label %else

13:                                               ; preds = %continue
  %load_rst = load i8, i8* %RST, align 1
  %14 = zext i8 %load_rst to i32
  br label %15

15:                                               ; preds = %13, %continue
  %16 = phi i32 [ %5, %continue ], [ %14, %13 ]
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %10, label %7

input5:                                           ; preds = %condition_body
  %18 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance, i32 0, i32 0
  %load_N9 = load i16, i16* %N, align 2
  store i16 %load_N9, i16* %18, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call10 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %19 = sext i16 %call10 to i32
  %tmpVar11 = sub i32 %19, 1
  %20 = trunc i32 %tmpVar11 to i16
  store i16 %20, i16* %tmp, align 2
  store i16 0, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue8
  %load_i = load i16, i16* %i, align 2
  %load_i13 = load i16, i16* %i, align 2
  %load_tmp = load i16, i16* %tmp, align 2
  %tmpVar14 = icmp sle i16 %load_i13, %load_tmp
  %21 = icmp ne i1 %tmpVar14, false
  br i1 %21, label %27, label %28

for_body:                                         ; preds = %25
  %load_i22 = load i16, i16* %i, align 2
  %22 = sext i16 %load_i22 to i32
  %tmpVar23 = mul i32 1, %22
  %tmpVar24 = add i32 %tmpVar23, 0
  %tmpVar25 = getelementptr inbounds [32 x i32], [32 x i32]* %buffer, i32 0, i32 %tmpVar24
  %load_X = load i32, i32* %X, align 4
  store i32 %load_X, i32* %tmpVar25, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar26 = add i16 %load_i, 1
  store i16 %tmpVar26, i16* %i, align 2
  br label %condition_check

continue12:                                       ; preds = %25
  %load_X27 = load i32, i32* %X, align 4
  store i32 %load_X27, i32* %Y, align 4
  br label %continue2

23:                                               ; preds = %28
  %load_i17 = load i16, i16* %i, align 2
  %load_tmp18 = load i16, i16* %tmp, align 2
  %tmpVar19 = icmp sge i16 %load_i17, %load_tmp18
  %24 = icmp ne i1 %tmpVar19, false
  br i1 %24, label %31, label %32

25:                                               ; preds = %32, %28
  %26 = phi i1 [ %29, %28 ], [ %33, %32 ]
  br i1 %26, label %for_body, label %continue12

27:                                               ; preds = %condition_check
  %load_i15 = load i16, i16* %i, align 2
  %tmpVar16 = icmp sge i16 %load_i15, 0
  br label %28

28:                                               ; preds = %27, %condition_check
  %29 = phi i1 [ %tmpVar14, %condition_check ], [ %tmpVar16, %27 ]
  %30 = icmp ne i1 %29, false
  br i1 %30, label %25, label %23

31:                                               ; preds = %23
  %load_i20 = load i16, i16* %i, align 2
  %tmpVar21 = icmp sle i16 %load_i20, 0
  br label %32

32:                                               ; preds = %31, %23
  %33 = phi i1 [ %tmpVar19, %23 ], [ %tmpVar21, %31 ]
  br label %25

input29:                                          ; preds = %else
  %34 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance28, i32 0, i32 0
  %load_N33 = load i16, i16* %N, align 2
  store i16 %load_N33, i16* %34, align 2
  br label %call30

call30:                                           ; preds = %input29
  %call34 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance28)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  store i16 %call34, i16* %tmp, align 2
  %INC1_instance = alloca %INC1_interface, align 8
  br label %input35

input35:                                          ; preds = %continue32
  %35 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 0
  %load_i39 = load i16, i16* %i, align 2
  store i16 %load_i39, i16* %35, align 2
  %36 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 1
  %load_tmp40 = load i16, i16* %tmp, align 2
  store i16 %load_tmp40, i16* %36, align 2
  br label %call36

call36:                                           ; preds = %input35
  %call41 = call i16 @INC1(%INC1_interface* %INC1_instance)
  br label %output37

output37:                                         ; preds = %call36
  br label %continue38

continue38:                                       ; preds = %output37
  store i16 %call41, i16* %i, align 2
  %load_Y = load i32, i32* %Y, align 4
  %load_X42 = load i32, i32* %X, align 4
  %load_i43 = load i16, i16* %i, align 2
  %37 = sext i16 %load_i43 to i32
  %tmpVar44 = mul i32 1, %37
  %tmpVar45 = add i32 %tmpVar44, 0
  %tmpVar46 = getelementptr inbounds [32 x i32], [32 x i32]* %buffer, i32 0, i32 %tmpVar45
  %load_tmpVar = load i32, i32* %tmpVar46, align 4
  %tmpVar47 = sub i32 %load_X42, %load_tmpVar
  %load_N48 = load i16, i16* %N, align 2
  %38 = zext i16 %load_N48 to i32
  %tmpVar49 = sdiv i32 %tmpVar47, %38
  %tmpVar50 = add i32 %load_Y, %tmpVar49
  store i32 %tmpVar50, i32* %Y, align 4
  %load_i51 = load i16, i16* %i, align 2
  %39 = sext i16 %load_i51 to i32
  %tmpVar52 = mul i32 1, %39
  %tmpVar53 = add i32 %tmpVar52, 0
  %tmpVar54 = getelementptr inbounds [32 x i32], [32 x i32]* %buffer, i32 0, i32 %tmpVar53
  %load_X55 = load i32, i32* %X, align 4
  store i32 %load_X55, i32* %tmpVar54, align 4
  br label %continue2
}

define void @FILTER_MAV_W(%FILTER_MAV_W_interface* %0) {
entry:
  %X = getelementptr inbounds %FILTER_MAV_W_interface, %FILTER_MAV_W_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %FILTER_MAV_W_interface, %FILTER_MAV_W_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %FILTER_MAV_W_interface, %FILTER_MAV_W_interface* %0, i32 0, i32 2
  %Y = getelementptr inbounds %FILTER_MAV_W_interface, %FILTER_MAV_W_interface* %0, i32 0, i32 3
  %init = getelementptr inbounds %FILTER_MAV_W_interface, %FILTER_MAV_W_interface* %0, i32 0, i32 4
  %buffer = getelementptr inbounds %FILTER_MAV_W_interface, %FILTER_MAV_W_interface* %0, i32 0, i32 5
  %i = getelementptr inbounds %FILTER_MAV_W_interface, %FILTER_MAV_W_interface* %0, i32 0, i32 6
  %sum = getelementptr inbounds %FILTER_MAV_W_interface, %FILTER_MAV_W_interface* %0, i32 0, i32 7
  %tmp = alloca i16, align 2
  store i16 0, i16* %tmp, align 2
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_N = load i16, i16* %N, align 2
  %2 = zext i16 %load_N to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  store i64 32, i64* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = trunc i64 %call1 to i16
  store i16 %4, i16* %N, align 2
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %5 = zext i8 %tmpVar to i32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %15, label %13

condition_body:                                   ; preds = %10
  store i8 1, i8* %init, align 1
  %UINT_TO_INT_instance = alloca %UINT_TO_INT_interface, align 8
  br label %input5

else:                                             ; preds = %10
  %UINT_TO_INT_instance30 = alloca %UINT_TO_INT_interface, align 8
  br label %input31

continue2:                                        ; preds = %continue54, %continue12
  ret void

7:                                                ; preds = %15
  %load_N3 = load i16, i16* %N, align 2
  %8 = zext i16 %load_N3 to i32
  %tmpVar4 = icmp eq i32 %8, 0
  %9 = zext i1 %tmpVar4 to i32
  br label %10

10:                                               ; preds = %7, %15
  %11 = phi i32 [ %16, %15 ], [ %9, %7 ]
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %condition_body, label %else

13:                                               ; preds = %continue
  %load_rst = load i8, i8* %RST, align 1
  %14 = zext i8 %load_rst to i32
  br label %15

15:                                               ; preds = %13, %continue
  %16 = phi i32 [ %5, %continue ], [ %14, %13 ]
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %10, label %7

input5:                                           ; preds = %condition_body
  %18 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance, i32 0, i32 0
  %load_N9 = load i16, i16* %N, align 2
  store i16 %load_N9, i16* %18, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call10 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %19 = sext i16 %call10 to i32
  %tmpVar11 = sub i32 %19, 1
  %20 = trunc i32 %tmpVar11 to i16
  store i16 %20, i16* %tmp, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue8
  %load_i = load i16, i16* %i, align 2
  %load_i13 = load i16, i16* %i, align 2
  %load_tmp = load i16, i16* %tmp, align 2
  %tmpVar14 = icmp sle i16 %load_i13, %load_tmp
  %21 = icmp ne i1 %tmpVar14, false
  br i1 %21, label %30, label %31

for_body:                                         ; preds = %28
  %load_i22 = load i16, i16* %i, align 2
  %22 = sub i16 %load_i22, 1
  %23 = sext i16 %22 to i32
  %tmpVar23 = mul i32 1, %23
  %tmpVar24 = add i32 %tmpVar23, 0
  %tmpVar25 = getelementptr inbounds [32 x i16], [32 x i16]* %buffer, i32 0, i32 %tmpVar24
  %load_X = load i16, i16* %X, align 2
  store i16 %load_X, i16* %tmpVar25, align 2
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar26 = add i16 %load_i, 1
  store i16 %tmpVar26, i16* %i, align 2
  br label %condition_check

continue12:                                       ; preds = %28
  %load_Y = load i16, i16* %Y, align 2
  %24 = zext i16 %load_Y to i32
  %load_N27 = load i16, i16* %N, align 2
  %25 = zext i16 %load_N27 to i32
  %tmpVar28 = mul i32 %24, %25
  store i32 %tmpVar28, i32* %sum, align 4
  %load_X29 = load i16, i16* %X, align 2
  store i16 %load_X29, i16* %Y, align 2
  br label %continue2

26:                                               ; preds = %31
  %load_i17 = load i16, i16* %i, align 2
  %load_tmp18 = load i16, i16* %tmp, align 2
  %tmpVar19 = icmp sge i16 %load_i17, %load_tmp18
  %27 = icmp ne i1 %tmpVar19, false
  br i1 %27, label %34, label %35

28:                                               ; preds = %35, %31
  %29 = phi i1 [ %32, %31 ], [ %36, %35 ]
  br i1 %29, label %for_body, label %continue12

30:                                               ; preds = %condition_check
  %load_i15 = load i16, i16* %i, align 2
  %tmpVar16 = icmp sge i16 %load_i15, 1
  br label %31

31:                                               ; preds = %30, %condition_check
  %32 = phi i1 [ %tmpVar14, %condition_check ], [ %tmpVar16, %30 ]
  %33 = icmp ne i1 %32, false
  br i1 %33, label %28, label %26

34:                                               ; preds = %26
  %load_i20 = load i16, i16* %i, align 2
  %tmpVar21 = icmp sle i16 %load_i20, 1
  br label %35

35:                                               ; preds = %34, %26
  %36 = phi i1 [ %tmpVar19, %26 ], [ %tmpVar21, %34 ]
  br label %28

input31:                                          ; preds = %else
  %37 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance30, i32 0, i32 0
  %load_N35 = load i16, i16* %N, align 2
  store i16 %load_N35, i16* %37, align 2
  br label %call32

call32:                                           ; preds = %input31
  %call36 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance30)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  store i16 %call36, i16* %tmp, align 2
  %INC1_instance = alloca %INC1_interface, align 8
  br label %input37

input37:                                          ; preds = %continue34
  %38 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 0
  %load_i41 = load i16, i16* %i, align 2
  store i16 %load_i41, i16* %38, align 2
  %39 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 1
  %load_tmp42 = load i16, i16* %tmp, align 2
  store i16 %load_tmp42, i16* %39, align 2
  br label %call38

call38:                                           ; preds = %input37
  %call43 = call i16 @INC1(%INC1_interface* %INC1_instance)
  br label %output39

output39:                                         ; preds = %call38
  br label %continue40

continue40:                                       ; preds = %output39
  store i16 %call43, i16* %i, align 2
  %load_sum = load i32, i32* %sum, align 4
  %load_X44 = load i16, i16* %X, align 2
  %40 = zext i16 %load_X44 to i32
  %tmpVar45 = add i32 %load_sum, %40
  %load_i46 = load i16, i16* %i, align 2
  %41 = sub i16 %load_i46, 1
  %42 = sext i16 %41 to i32
  %tmpVar47 = mul i32 1, %42
  %tmpVar48 = add i32 %tmpVar47, 0
  %tmpVar49 = getelementptr inbounds [32 x i16], [32 x i16]* %buffer, i32 0, i32 %tmpVar48
  %load_tmpVar = load i16, i16* %tmpVar49, align 2
  %43 = zext i16 %load_tmpVar to i32
  %tmpVar50 = sub i32 %tmpVar45, %43
  store i32 %tmpVar50, i32* %sum, align 4
  %DWORD_TO_WORD_instance = alloca %DWORD_TO_WORD_interface, align 8
  br label %input51

input51:                                          ; preds = %continue40
  %44 = getelementptr inbounds %DWORD_TO_WORD_interface, %DWORD_TO_WORD_interface* %DWORD_TO_WORD_instance, i32 0, i32 0
  %load_sum55 = load i32, i32* %sum, align 4
  %load_N56 = load i16, i16* %N, align 2
  %45 = zext i16 %load_N56 to i32
  %tmpVar57 = sdiv i32 %load_sum55, %45
  store i32 %tmpVar57, i32* %44, align 4
  br label %call52

call52:                                           ; preds = %input51
  %call58 = call i16 @DWORD_TO_WORD(%DWORD_TO_WORD_interface* %DWORD_TO_WORD_instance)
  br label %output53

output53:                                         ; preds = %call52
  br label %continue54

continue54:                                       ; preds = %output53
  store i16 %call58, i16* %Y, align 2
  %load_i59 = load i16, i16* %i, align 2
  %46 = sub i16 %load_i59, 1
  %47 = sext i16 %46 to i32
  %tmpVar60 = mul i32 1, %47
  %tmpVar61 = add i32 %tmpVar60, 0
  %tmpVar62 = getelementptr inbounds [32 x i16], [32 x i16]* %buffer, i32 0, i32 %tmpVar61
  %load_X63 = load i16, i16* %X, align 2
  store i16 %load_X63, i16* %tmpVar62, align 2
  br label %continue2
}

define void @FILTER_W(%FILTER_W_interface* %0) {
entry:
  %X = getelementptr inbounds %FILTER_W_interface, %FILTER_W_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %FILTER_W_interface, %FILTER_W_interface* %0, i32 0, i32 1
  %Y = getelementptr inbounds %FILTER_W_interface, %FILTER_W_interface* %0, i32 0, i32 2
  %last = getelementptr inbounds %FILTER_W_interface, %FILTER_W_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %FILTER_W_interface, %FILTER_W_interface* %0, i32 0, i32 4
  %init = getelementptr inbounds %FILTER_W_interface, %FILTER_W_interface* %0, i32 0, i32 5
  %tmp = getelementptr inbounds %FILTER_W_interface, %FILTER_W_interface* %0, i32 0, i32 6
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = zext i8 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %7, label %5

condition_body:                                   ; preds = %7
  store i8 1, i8* %init, align 1
  %load_tx = load i32, i32* %tx, align 4
  store i32 %load_tx, i32* %last, align 4
  %load_X = load i16, i16* %X, align 2
  store i16 %load_X, i16* %Y, align 2
  br label %continue2

branch:                                           ; preds = %7
  %load_Y = load i16, i16* %Y, align 2
  %3 = zext i16 %load_Y to i32
  %load_X5 = load i16, i16* %X, align 2
  %4 = zext i16 %load_X5 to i32
  %tmpVar6 = icmp eq i32 %3, %4
  br i1 %tmpVar6, label %condition_body4, label %else

condition_body4:                                  ; preds = %branch
  %load_tx7 = load i32, i32* %tx, align 4
  store i32 %load_tx7, i32* %last, align 4
  br label %continue2

else:                                             ; preds = %branch
  %WORD_TO_DWORD_instance = alloca %WORD_TO_DWORD_interface, align 8
  br label %input8

continue2:                                        ; preds = %continue26, %condition_body4, %condition_body
  ret void

5:                                                ; preds = %continue
  %load_T = load i64, i64* %T, align 4
  %tmpVar3 = icmp eq i64 %load_T, 0
  %6 = zext i1 %tmpVar3 to i32
  br label %7

7:                                                ; preds = %5, %continue
  %8 = phi i32 [ %1, %continue ], [ %6, %5 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body, label %branch

input8:                                           ; preds = %else
  %10 = getelementptr inbounds %WORD_TO_DWORD_interface, %WORD_TO_DWORD_interface* %WORD_TO_DWORD_instance, i32 0, i32 0
  %load_X12 = load i16, i16* %X, align 2
  %11 = zext i16 %load_X12 to i32
  %load_Y13 = load i16, i16* %Y, align 2
  %12 = zext i16 %load_Y13 to i32
  %tmpVar14 = sub i32 %11, %12
  %13 = trunc i32 %tmpVar14 to i16
  store i16 %13, i16* %10, align 2
  br label %call9

call9:                                            ; preds = %input8
  %call15 = call i32 @WORD_TO_DWORD(%WORD_TO_DWORD_interface* %WORD_TO_DWORD_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %load_tx16 = load i32, i32* %tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar17 = sub i32 %load_tx16, %load_last
  %tmpVar18 = mul i32 %call15, %tmpVar17
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input19

input19:                                          ; preds = %continue11
  %14 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_T23 = load i64, i64* %T, align 4
  store i64 %load_T23, i64* %14, align 4
  br label %call20

call20:                                           ; preds = %input19
  %call24 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  %tmpVar25 = sdiv i32 %tmpVar18, %call24
  store i32 %tmpVar25, i32* %tmp, align 4
  %load_tmp = load i32, i32* %tmp, align 4
  %tmpVar28 = icmp ne i32 %load_tmp, 0
  br i1 %tmpVar28, label %condition_body27, label %continue26

condition_body27:                                 ; preds = %continue22
  %DINT_TO_WORD_instance = alloca %DINT_TO_WORD_interface, align 8
  br label %input29

continue26:                                       ; preds = %continue32, %continue22
  br label %continue2

input29:                                          ; preds = %condition_body27
  %15 = getelementptr inbounds %DINT_TO_WORD_interface, %DINT_TO_WORD_interface* %DINT_TO_WORD_instance, i32 0, i32 0
  %WORD_TO_DINT_instance = alloca %WORD_TO_DINT_interface, align 8
  br label %input33

call30:                                           ; preds = %continue42
  %call46 = call i16 @DINT_TO_WORD(%DINT_TO_WORD_interface* %DINT_TO_WORD_instance)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  store i16 %call46, i16* %Y, align 2
  %load_tx47 = load i32, i32* %tx, align 4
  store i32 %load_tx47, i32* %last, align 4
  br label %continue26

input33:                                          ; preds = %input29
  %16 = getelementptr inbounds %WORD_TO_DINT_interface, %WORD_TO_DINT_interface* %WORD_TO_DINT_instance, i32 0, i32 0
  %load_Y37 = load i16, i16* %Y, align 2
  store i16 %load_Y37, i16* %16, align 2
  br label %call34

call34:                                           ; preds = %input33
  %call38 = call i32 @WORD_TO_DINT(%WORD_TO_DINT_interface* %WORD_TO_DINT_instance)
  br label %output35

output35:                                         ; preds = %call34
  br label %continue36

continue36:                                       ; preds = %output35
  %DWORD_TO_DINT_instance = alloca %DWORD_TO_DINT_interface, align 8
  br label %input39

input39:                                          ; preds = %continue36
  %17 = getelementptr inbounds %DWORD_TO_DINT_interface, %DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance, i32 0, i32 0
  %load_tmp43 = load i32, i32* %tmp, align 4
  store i32 %load_tmp43, i32* %17, align 4
  br label %call40

call40:                                           ; preds = %input39
  %call44 = call i32 @DWORD_TO_DINT(%DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance)
  br label %output41

output41:                                         ; preds = %call40
  br label %continue42

continue42:                                       ; preds = %output41
  %tmpVar45 = add i32 %call38, %call44
  store i32 %tmpVar45, i32* %15, align 4
  br label %call30
}

define void @FILTER_WAV(%FILTER_WAV_interface* %0) {
entry:
  %X = getelementptr inbounds %FILTER_WAV_interface, %FILTER_WAV_interface* %0, i32 0, i32 0
  %W = getelementptr inbounds %FILTER_WAV_interface, %FILTER_WAV_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %FILTER_WAV_interface, %FILTER_WAV_interface* %0, i32 0, i32 2
  %Y = getelementptr inbounds %FILTER_WAV_interface, %FILTER_WAV_interface* %0, i32 0, i32 3
  %init = getelementptr inbounds %FILTER_WAV_interface, %FILTER_WAV_interface* %0, i32 0, i32 4
  %buffer = getelementptr inbounds %FILTER_WAV_interface, %FILTER_WAV_interface* %0, i32 0, i32 5
  %i = getelementptr inbounds %FILTER_WAV_interface, %FILTER_WAV_interface* %0, i32 0, i32 6
  %n = getelementptr inbounds %FILTER_WAV_interface, %FILTER_WAV_interface* %0, i32 0, i32 7
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = zext i8 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %5, label %3

condition_body:                                   ; preds = %5
  store i8 1, i8* %init, align 1
  store i16 0, i16* %i, align 2
  br label %condition_check

else:                                             ; preds = %5
  %INC1_instance = alloca %INC1_interface, align 8
  br label %input

continue:                                         ; preds = %continue16, %continue1
  store float 0.000000e+00, float* %Y, align 4
  store i16 0, i16* %n, align 2
  br label %condition_check24

3:                                                ; preds = %entry
  %load_rst = load i8, i8* %RST, align 1
  %4 = zext i8 %load_rst to i32
  br label %5

5:                                                ; preds = %3, %entry
  %6 = phi i32 [ %1, %entry ], [ %4, %3 ]
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %condition_body, label %else

condition_check:                                  ; preds = %increment, %condition_body
  %load_i = load i16, i16* %i, align 2
  %load_i2 = load i16, i16* %i, align 2
  %tmpVar3 = icmp sle i16 %load_i2, 15
  %8 = icmp ne i1 %tmpVar3, false
  br i1 %8, label %14, label %15

for_body:                                         ; preds = %12
  %load_i10 = load i16, i16* %i, align 2
  %9 = sext i16 %load_i10 to i32
  %tmpVar11 = mul i32 1, %9
  %tmpVar12 = add i32 %tmpVar11, 0
  %tmpVar13 = getelementptr inbounds [16 x float], [16 x float]* %buffer, i32 0, i32 %tmpVar12
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %tmpVar13, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar14 = add i16 %load_i, 1
  store i16 %tmpVar14, i16* %i, align 2
  br label %condition_check

continue1:                                        ; preds = %12
  store i16 15, i16* %i, align 2
  %load_X15 = load float, float* %X, align 4
  store float %load_X15, float* %Y, align 4
  br label %continue

10:                                               ; preds = %15
  %load_i6 = load i16, i16* %i, align 2
  %tmpVar7 = icmp sge i16 %load_i6, 15
  %11 = icmp ne i1 %tmpVar7, false
  br i1 %11, label %18, label %19

12:                                               ; preds = %19, %15
  %13 = phi i1 [ %16, %15 ], [ %20, %19 ]
  br i1 %13, label %for_body, label %continue1

14:                                               ; preds = %condition_check
  %load_i4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_i4, 0
  br label %15

15:                                               ; preds = %14, %condition_check
  %16 = phi i1 [ %tmpVar3, %condition_check ], [ %tmpVar5, %14 ]
  %17 = icmp ne i1 %16, false
  br i1 %17, label %12, label %10

18:                                               ; preds = %10
  %load_i8 = load i16, i16* %i, align 2
  %tmpVar9 = icmp sle i16 %load_i8, 0
  br label %19

19:                                               ; preds = %18, %10
  %20 = phi i1 [ %tmpVar7, %10 ], [ %tmpVar9, %18 ]
  br label %12

input:                                            ; preds = %else
  %21 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 0
  %load_i17 = load i16, i16* %i, align 2
  store i16 %load_i17, i16* %21, align 2
  %22 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 1
  store i16 16, i16* %22, align 2
  br label %call

call:                                             ; preds = %input
  %call18 = call i16 @INC1(%INC1_interface* %INC1_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue16

continue16:                                       ; preds = %output
  store i16 %call18, i16* %i, align 2
  %load_i19 = load i16, i16* %i, align 2
  %23 = sext i16 %load_i19 to i32
  %tmpVar20 = mul i32 1, %23
  %tmpVar21 = add i32 %tmpVar20, 0
  %tmpVar22 = getelementptr inbounds [16 x float], [16 x float]* %buffer, i32 0, i32 %tmpVar21
  %load_X23 = load float, float* %X, align 4
  store float %load_X23, float* %tmpVar22, align 4
  br label %continue

condition_check24:                                ; preds = %increment26, %continue
  %load_n = load i16, i16* %n, align 2
  %load_n28 = load i16, i16* %n, align 2
  %tmpVar29 = icmp sle i16 %load_n28, 15
  %24 = icmp ne i1 %tmpVar29, false
  br i1 %24, label %31, label %32

for_body25:                                       ; preds = %29
  %load_i36 = load i16, i16* %i, align 2
  %25 = sext i16 %load_i36 to i32
  %tmpVar37 = mul i32 1, %25
  %tmpVar38 = add i32 %tmpVar37, 0
  %tmpVar39 = getelementptr inbounds [16 x float], [16 x float]* %buffer, i32 0, i32 %tmpVar38
  %load_tmpVar = load float, float* %tmpVar39, align 4
  %load_n40 = load i16, i16* %n, align 2
  %26 = sext i16 %load_n40 to i32
  %tmpVar41 = mul i32 1, %26
  %tmpVar42 = add i32 %tmpVar41, 0
  %tmpVar43 = getelementptr inbounds [16 x float], [16 x float]* %W, i32 0, i32 %tmpVar42
  %load_tmpVar44 = load float, float* %tmpVar43, align 4
  %tmpVar45 = fmul float %load_tmpVar, %load_tmpVar44
  %load_Y = load float, float* %Y, align 4
  %tmpVar46 = fadd float %tmpVar45, %load_Y
  store float %tmpVar46, float* %Y, align 4
  %DEC1_instance = alloca %DEC1_interface, align 8
  br label %input47

increment26:                                      ; preds = %continue50
  %tmpVar53 = add i16 %load_n, 1
  store i16 %tmpVar53, i16* %n, align 2
  br label %condition_check24

continue27:                                       ; preds = %29
  ret void

27:                                               ; preds = %32
  %load_n32 = load i16, i16* %n, align 2
  %tmpVar33 = icmp sge i16 %load_n32, 15
  %28 = icmp ne i1 %tmpVar33, false
  br i1 %28, label %35, label %36

29:                                               ; preds = %36, %32
  %30 = phi i1 [ %33, %32 ], [ %37, %36 ]
  br i1 %30, label %for_body25, label %continue27

31:                                               ; preds = %condition_check24
  %load_n30 = load i16, i16* %n, align 2
  %tmpVar31 = icmp sge i16 %load_n30, 0
  br label %32

32:                                               ; preds = %31, %condition_check24
  %33 = phi i1 [ %tmpVar29, %condition_check24 ], [ %tmpVar31, %31 ]
  %34 = icmp ne i1 %33, false
  br i1 %34, label %29, label %27

35:                                               ; preds = %27
  %load_n34 = load i16, i16* %n, align 2
  %tmpVar35 = icmp sle i16 %load_n34, 0
  br label %36

36:                                               ; preds = %35, %27
  %37 = phi i1 [ %tmpVar33, %27 ], [ %tmpVar35, %35 ]
  br label %29

input47:                                          ; preds = %for_body25
  %38 = getelementptr inbounds %DEC1_interface, %DEC1_interface* %DEC1_instance, i32 0, i32 0
  %load_i51 = load i16, i16* %i, align 2
  store i16 %load_i51, i16* %38, align 2
  %39 = getelementptr inbounds %DEC1_interface, %DEC1_interface* %DEC1_instance, i32 0, i32 1
  store i16 16, i16* %39, align 2
  br label %call48

call48:                                           ; preds = %input47
  %call52 = call i16 @DEC1(%DEC1_interface* %DEC1_instance)
  br label %output49

output49:                                         ; preds = %call48
  br label %continue50

continue50:                                       ; preds = %output49
  store i16 %call52, i16* %i, align 2
  br label %increment26
}

define float @MIX(%MIX_interface* %0) {
entry:
  %A = getelementptr inbounds %MIX_interface, %MIX_interface* %0, i32 0, i32 0
  %B = getelementptr inbounds %MIX_interface, %MIX_interface* %0, i32 0, i32 1
  %M = getelementptr inbounds %MIX_interface, %MIX_interface* %0, i32 0, i32 2
  %MIX = alloca float, align 4
  store float 0.000000e+00, float* %MIX, align 4
  %load_M = load float, float* %M, align 4
  %tmpVar = fsub float 1.000000e+00, %load_M
  %load_A = load float, float* %A, align 4
  %tmpVar1 = fmul float %tmpVar, %load_A
  %load_M2 = load float, float* %M, align 4
  %load_B = load float, float* %B, align 4
  %tmpVar3 = fmul float %load_M2, %load_B
  %tmpVar4 = fadd float %tmpVar1, %tmpVar3
  store float %tmpVar4, float* %MIX, align 4
  %MIX_ret = load float, float* %MIX, align 4
  ret float %MIX_ret
}

define float @MUX_R2(%MUX_R2_interface* %0) {
entry:
  %IN0 = getelementptr inbounds %MUX_R2_interface, %MUX_R2_interface* %0, i32 0, i32 0
  %IN1 = getelementptr inbounds %MUX_R2_interface, %MUX_R2_interface* %0, i32 0, i32 1
  %A = getelementptr inbounds %MUX_R2_interface, %MUX_R2_interface* %0, i32 0, i32 2
  %MUX_R2 = alloca float, align 4
  store float 0.000000e+00, float* %MUX_R2, align 4
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_A = load i8, i8* %A, align 1
  store i8 %load_A, i8* %1, align 1
  %2 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_IN0 = load float, float* %IN0, align 4
  %3 = fptoui float %load_IN0 to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_IN1 = load float, float* %IN1, align 4
  %5 = fptoui float %load_IN1 to i64
  store i64 %5, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %6 = uitofp i64 %call1 to float
  store float %6, float* %MUX_R2, align 4
  %MUX_R2_ret = load float, float* %MUX_R2, align 4
  ret float %MUX_R2_ret
}

define float @MUX_R4(%MUX_R4_interface* %0) {
entry:
  %IN0 = getelementptr inbounds %MUX_R4_interface, %MUX_R4_interface* %0, i32 0, i32 0
  %IN1 = getelementptr inbounds %MUX_R4_interface, %MUX_R4_interface* %0, i32 0, i32 1
  %IN2 = getelementptr inbounds %MUX_R4_interface, %MUX_R4_interface* %0, i32 0, i32 2
  %IN3 = getelementptr inbounds %MUX_R4_interface, %MUX_R4_interface* %0, i32 0, i32 3
  %A0 = getelementptr inbounds %MUX_R4_interface, %MUX_R4_interface* %0, i32 0, i32 4
  %A1 = getelementptr inbounds %MUX_R4_interface, %MUX_R4_interface* %0, i32 0, i32 5
  %MUX_R4 = alloca float, align 4
  store float 0.000000e+00, float* %MUX_R4, align 4
  %load_A1 = load i8, i8* %A1, align 1
  %1 = icmp ne i8 %load_A1, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %SEL_instance3 = alloca %SEL_interface, align 8
  br label %input4

continue:                                         ; preds = %continue7, %continue1
  %MUX_R4_ret = load float, float* %MUX_R4, align 4
  ret float %MUX_R4_ret

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_A0 = load i8, i8* %A0, align 1
  store i8 %load_A0, i8* %2, align 1
  %3 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_IN2 = load float, float* %IN2, align 4
  %4 = fptoui float %load_IN2 to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_IN3 = load float, float* %IN3, align 4
  %6 = fptoui float %load_IN3 to i64
  store i64 %6, i64* %5, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %7 = uitofp i64 %call2 to float
  store float %7, float* %MUX_R4, align 4
  br label %continue

input4:                                           ; preds = %else
  %8 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance3, i32 0, i32 0
  %load_A08 = load i8, i8* %A0, align 1
  store i8 %load_A08, i8* %8, align 1
  %9 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance3, i32 0, i32 1
  %load_IN0 = load float, float* %IN0, align 4
  %10 = fptoui float %load_IN0 to i64
  store i64 %10, i64* %9, align 4
  %11 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance3, i32 0, i32 2
  %load_IN1 = load float, float* %IN1, align 4
  %12 = fptoui float %load_IN1 to i64
  store i64 %12, i64* %11, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call9 = call i64 @SEL(%SEL_interface* %SEL_instance3)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %13 = uitofp i64 %call9 to float
  store float %13, float* %MUX_R4, align 4
  br label %continue
}

define float @OFFSET(%OFFSET_interface* %0) {
entry:
  %X = getelementptr inbounds %OFFSET_interface, %OFFSET_interface* %0, i32 0, i32 0
  %O1 = getelementptr inbounds %OFFSET_interface, %OFFSET_interface* %0, i32 0, i32 1
  %O2 = getelementptr inbounds %OFFSET_interface, %OFFSET_interface* %0, i32 0, i32 2
  %O3 = getelementptr inbounds %OFFSET_interface, %OFFSET_interface* %0, i32 0, i32 3
  %O4 = getelementptr inbounds %OFFSET_interface, %OFFSET_interface* %0, i32 0, i32 4
  %D = getelementptr inbounds %OFFSET_interface, %OFFSET_interface* %0, i32 0, i32 5
  %Offset_1 = getelementptr inbounds %OFFSET_interface, %OFFSET_interface* %0, i32 0, i32 6
  %Offset_2 = getelementptr inbounds %OFFSET_interface, %OFFSET_interface* %0, i32 0, i32 7
  %Offset_3 = getelementptr inbounds %OFFSET_interface, %OFFSET_interface* %0, i32 0, i32 8
  %Offset_4 = getelementptr inbounds %OFFSET_interface, %OFFSET_interface* %0, i32 0, i32 9
  %default = getelementptr inbounds %OFFSET_interface, %OFFSET_interface* %0, i32 0, i32 10
  %OFFSET = alloca float, align 4
  store float 0.000000e+00, float* %OFFSET, align 4
  %load_D = load i8, i8* %D, align 1
  %1 = icmp ne i8 %load_D, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_default = load float, float* %default, align 4
  store float %load_default, float* %OFFSET, align 4
  br label %continue

else:                                             ; preds = %entry
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %OFFSET, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body
  %load_O1 = load i8, i8* %O1, align 1
  %2 = icmp ne i8 %load_O1, 0
  br i1 %2, label %condition_body2, label %continue1

condition_body2:                                  ; preds = %continue
  %load_OFFSET = load float, float* %OFFSET, align 4
  %load_offset_1 = load float, float* %Offset_1, align 4
  %tmpVar = fadd float %load_OFFSET, %load_offset_1
  store float %tmpVar, float* %OFFSET, align 4
  br label %continue1

continue1:                                        ; preds = %condition_body2, %continue
  %load_O2 = load i8, i8* %O2, align 1
  %3 = icmp ne i8 %load_O2, 0
  br i1 %3, label %condition_body4, label %continue3

condition_body4:                                  ; preds = %continue1
  %load_OFFSET5 = load float, float* %OFFSET, align 4
  %load_offset_2 = load float, float* %Offset_2, align 4
  %tmpVar6 = fadd float %load_OFFSET5, %load_offset_2
  store float %tmpVar6, float* %OFFSET, align 4
  br label %continue3

continue3:                                        ; preds = %condition_body4, %continue1
  %load_O3 = load i8, i8* %O3, align 1
  %4 = icmp ne i8 %load_O3, 0
  br i1 %4, label %condition_body8, label %continue7

condition_body8:                                  ; preds = %continue3
  %load_OFFSET9 = load float, float* %OFFSET, align 4
  %load_offset_3 = load float, float* %Offset_3, align 4
  %tmpVar10 = fadd float %load_OFFSET9, %load_offset_3
  store float %tmpVar10, float* %OFFSET, align 4
  br label %continue7

continue7:                                        ; preds = %condition_body8, %continue3
  %load_O4 = load i8, i8* %O4, align 1
  %5 = icmp ne i8 %load_O4, 0
  br i1 %5, label %condition_body12, label %continue11

condition_body12:                                 ; preds = %continue7
  %load_OFFSET13 = load float, float* %OFFSET, align 4
  %load_offset_4 = load float, float* %Offset_4, align 4
  %tmpVar14 = fadd float %load_OFFSET13, %load_offset_4
  store float %tmpVar14, float* %OFFSET, align 4
  br label %continue11

continue11:                                       ; preds = %condition_body12, %continue7
  %OFFSET_ret = load float, float* %OFFSET, align 4
  ret float %OFFSET_ret
}

define float @OFFSET2(%OFFSET2_interface* %0) {
entry:
  %X = getelementptr inbounds %OFFSET2_interface, %OFFSET2_interface* %0, i32 0, i32 0
  %O1 = getelementptr inbounds %OFFSET2_interface, %OFFSET2_interface* %0, i32 0, i32 1
  %O2 = getelementptr inbounds %OFFSET2_interface, %OFFSET2_interface* %0, i32 0, i32 2
  %O3 = getelementptr inbounds %OFFSET2_interface, %OFFSET2_interface* %0, i32 0, i32 3
  %O4 = getelementptr inbounds %OFFSET2_interface, %OFFSET2_interface* %0, i32 0, i32 4
  %D = getelementptr inbounds %OFFSET2_interface, %OFFSET2_interface* %0, i32 0, i32 5
  %Offset_1 = getelementptr inbounds %OFFSET2_interface, %OFFSET2_interface* %0, i32 0, i32 6
  %Offset_2 = getelementptr inbounds %OFFSET2_interface, %OFFSET2_interface* %0, i32 0, i32 7
  %Offset_3 = getelementptr inbounds %OFFSET2_interface, %OFFSET2_interface* %0, i32 0, i32 8
  %Offset_4 = getelementptr inbounds %OFFSET2_interface, %OFFSET2_interface* %0, i32 0, i32 9
  %default = getelementptr inbounds %OFFSET2_interface, %OFFSET2_interface* %0, i32 0, i32 10
  %OFFSET2 = alloca float, align 4
  store float 0.000000e+00, float* %OFFSET2, align 4
  %load_D = load i8, i8* %D, align 1
  %1 = icmp ne i8 %load_D, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_default = load float, float* %default, align 4
  store float %load_default, float* %OFFSET2, align 4
  br label %continue

else:                                             ; preds = %entry
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %OFFSET2, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body
  %load_O4 = load i8, i8* %O4, align 1
  %2 = icmp ne i8 %load_O4, 0
  br i1 %2, label %condition_body4, label %branch

condition_body4:                                  ; preds = %continue
  %load_OFFSET2 = load float, float* %OFFSET2, align 4
  %load_offset_4 = load float, float* %Offset_4, align 4
  %tmpVar = fadd float %load_OFFSET2, %load_offset_4
  store float %tmpVar, float* %OFFSET2, align 4
  br label %continue3

branch:                                           ; preds = %continue
  %load_O3 = load i8, i8* %O3, align 1
  %3 = icmp ne i8 %load_O3, 0
  br i1 %3, label %condition_body5, label %branch1

condition_body5:                                  ; preds = %branch
  %load_OFFSET26 = load float, float* %OFFSET2, align 4
  %load_offset_3 = load float, float* %Offset_3, align 4
  %tmpVar7 = fadd float %load_OFFSET26, %load_offset_3
  store float %tmpVar7, float* %OFFSET2, align 4
  br label %continue3

branch1:                                          ; preds = %branch
  %load_O2 = load i8, i8* %O2, align 1
  %4 = icmp ne i8 %load_O2, 0
  br i1 %4, label %condition_body8, label %branch2

condition_body8:                                  ; preds = %branch1
  %load_OFFSET29 = load float, float* %OFFSET2, align 4
  %load_offset_2 = load float, float* %Offset_2, align 4
  %tmpVar10 = fadd float %load_OFFSET29, %load_offset_2
  store float %tmpVar10, float* %OFFSET2, align 4
  br label %continue3

branch2:                                          ; preds = %branch1
  %load_O1 = load i8, i8* %O1, align 1
  %5 = icmp ne i8 %load_O1, 0
  br i1 %5, label %condition_body11, label %continue3

condition_body11:                                 ; preds = %branch2
  %load_OFFSET212 = load float, float* %OFFSET2, align 4
  %load_offset_1 = load float, float* %Offset_1, align 4
  %tmpVar13 = fadd float %load_OFFSET212, %load_offset_1
  store float %tmpVar13, float* %OFFSET2, align 4
  br label %continue3

continue3:                                        ; preds = %condition_body11, %branch2, %condition_body8, %condition_body5, %condition_body4
  %OFFSET2_ret = load float, float* %OFFSET2, align 4
  ret float %OFFSET2_ret
}

define float @_OVERRIDE(%_OVERRIDE_interface* %0) {
entry:
  %X1 = getelementptr inbounds %_OVERRIDE_interface, %_OVERRIDE_interface* %0, i32 0, i32 0
  %X2 = getelementptr inbounds %_OVERRIDE_interface, %_OVERRIDE_interface* %0, i32 0, i32 1
  %X3 = getelementptr inbounds %_OVERRIDE_interface, %_OVERRIDE_interface* %0, i32 0, i32 2
  %E1 = getelementptr inbounds %_OVERRIDE_interface, %_OVERRIDE_interface* %0, i32 0, i32 3
  %E2 = getelementptr inbounds %_OVERRIDE_interface, %_OVERRIDE_interface* %0, i32 0, i32 4
  %E3 = getelementptr inbounds %_OVERRIDE_interface, %_OVERRIDE_interface* %0, i32 0, i32 5
  %_OVERRIDE = alloca float, align 4
  store float 0.000000e+00, float* %_OVERRIDE, align 4
  %load_E1 = load i8, i8* %E1, align 1
  %1 = icmp ne i8 %load_E1, 0
  br i1 %1, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %load_X1 = load float, float* %X1, align 4
  store float %load_X1, float* %_OVERRIDE, align 4
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  %load_E2 = load i8, i8* %E2, align 1
  %2 = zext i8 %load_E2 to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %6, label %7

condition_body2:                                  ; preds = %7
  %load_X2 = load float, float* %X2, align 4
  store float %load_X2, float* %_OVERRIDE, align 4
  br label %continue1

continue1:                                        ; preds = %condition_body2, %7
  %load_E3 = load i8, i8* %E3, align 1
  %4 = zext i8 %load_E3 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %15, label %16

6:                                                ; preds = %continue
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input

7:                                                ; preds = %continue9, %continue
  %8 = phi i32 [ %2, %continue ], [ %14, %continue9 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body2, label %continue1

input:                                            ; preds = %6
  %10 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_x2 = load float, float* %X2, align 4
  %11 = fptoui float %load_x2 to i64
  store i64 %11, i64* %10, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  %ABS_instance5 = alloca %ABS_interface, align 8
  br label %input6

input6:                                           ; preds = %continue3
  %12 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance5, i32 0, i32 0
  %load__OVERRIDE = load float, float* %_OVERRIDE, align 4
  %13 = fptoui float %load__OVERRIDE to i64
  store i64 %13, i64* %12, align 4
  br label %call7

call7:                                            ; preds = %input6
  %call10 = call i64 @ABS(%ABS_interface* %ABS_instance5)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %tmpVar = icmp sgt i64 %call4, %call10
  %14 = zext i1 %tmpVar to i32
  br label %7

condition_body12:                                 ; preds = %16
  %load_X3 = load float, float* %X3, align 4
  store float %load_X3, float* %_OVERRIDE, align 4
  br label %continue11

continue11:                                       ; preds = %condition_body12, %16
  %_OVERRIDE_ret = load float, float* %_OVERRIDE, align 4
  ret float %_OVERRIDE_ret

15:                                               ; preds = %continue1
  %ABS_instance13 = alloca %ABS_interface, align 8
  br label %input14

16:                                               ; preds = %continue23, %continue1
  %17 = phi i32 [ %4, %continue1 ], [ %23, %continue23 ]
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %condition_body12, label %continue11

input14:                                          ; preds = %15
  %19 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance13, i32 0, i32 0
  %load_x3 = load float, float* %X3, align 4
  %20 = fptoui float %load_x3 to i64
  store i64 %20, i64* %19, align 4
  br label %call15

call15:                                           ; preds = %input14
  %call18 = call i64 @ABS(%ABS_interface* %ABS_instance13)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %ABS_instance19 = alloca %ABS_interface, align 8
  br label %input20

input20:                                          ; preds = %continue17
  %21 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance19, i32 0, i32 0
  %load__OVERRIDE24 = load float, float* %_OVERRIDE, align 4
  %22 = fptoui float %load__OVERRIDE24 to i64
  store i64 %22, i64* %21, align 4
  br label %call21

call21:                                           ; preds = %input20
  %call25 = call i64 @ABS(%ABS_interface* %ABS_instance19)
  br label %output22

output22:                                         ; preds = %call21
  br label %continue23

continue23:                                       ; preds = %output22
  %tmpVar26 = icmp sgt i64 %call18, %call25
  %23 = zext i1 %tmpVar26 to i32
  br label %16
}

define i8 @RANGE_TO_BYTE(%RANGE_TO_BYTE_interface* %0) {
entry:
  %X = getelementptr inbounds %RANGE_TO_BYTE_interface, %RANGE_TO_BYTE_interface* %0, i32 0, i32 0
  %low = getelementptr inbounds %RANGE_TO_BYTE_interface, %RANGE_TO_BYTE_interface* %0, i32 0, i32 1
  %high = getelementptr inbounds %RANGE_TO_BYTE_interface, %RANGE_TO_BYTE_interface* %0, i32 0, i32 2
  %RANGE_TO_BYTE = alloca i8, align 1
  store i8 0, i8* %RANGE_TO_BYTE, align 1
  %INT_TO_BYTE_instance = alloca %INT_TO_BYTE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %INT_TO_BYTE_interface, %INT_TO_BYTE_interface* %INT_TO_BYTE_instance, i32 0, i32 0
  %TRUNC_instance = alloca %TRUNC_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call17 = call i8 @INT_TO_BYTE(%INT_TO_BYTE_interface* %INT_TO_BYTE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i8 %call17, i8* %RANGE_TO_BYTE, align 1
  %RANGE_TO_BYTE_ret = load i8, i8* %RANGE_TO_BYTE, align 1
  ret i8 %RANGE_TO_BYTE_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %TRUNC_interface, %TRUNC_interface* %TRUNC_instance, i32 0, i32 0
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  %call16 = call i16 @TRUNC(%TRUNC_interface* %TRUNC_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i16 %call16, i16* %1, align 2
  br label %call

input5:                                           ; preds = %input1
  %3 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_low = load float, float* %low, align 4
  %4 = fptoui float %load_low to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_X = load float, float* %X, align 4
  %6 = fptoui float %load_X to i64
  store i64 %6, i64* %5, align 4
  %7 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_high = load float, float* %high, align 4
  %8 = fptoui float %load_high to i64
  store i64 %8, i64* %7, align 4
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %9 = uitofp i64 %call9 to double
  %load_low10 = load float, float* %low, align 4
  %10 = fpext float %load_low10 to double
  %tmpVar = fsub double %9, %10
  %tmpVar11 = fmul double %tmpVar, 2.550000e+02
  %load_high12 = load float, float* %high, align 4
  %load_low13 = load float, float* %low, align 4
  %tmpVar14 = fsub float %load_high12, %load_low13
  %11 = fpext float %tmpVar14 to double
  %tmpVar15 = fdiv double %tmpVar11, %11
  store double %tmpVar15, double* %2, align 8
  br label %call2
}

define i16 @RANGE_TO_WORD(%RANGE_TO_WORD_interface* %0) {
entry:
  %X = getelementptr inbounds %RANGE_TO_WORD_interface, %RANGE_TO_WORD_interface* %0, i32 0, i32 0
  %low = getelementptr inbounds %RANGE_TO_WORD_interface, %RANGE_TO_WORD_interface* %0, i32 0, i32 1
  %high = getelementptr inbounds %RANGE_TO_WORD_interface, %RANGE_TO_WORD_interface* %0, i32 0, i32 2
  %RANGE_TO_WORD = alloca i16, align 2
  store i16 0, i16* %RANGE_TO_WORD, align 2
  %DINT_TO_WORD_instance = alloca %DINT_TO_WORD_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DINT_TO_WORD_interface, %DINT_TO_WORD_interface* %DINT_TO_WORD_instance, i32 0, i32 0
  %TRUNC_instance = alloca %TRUNC_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call17 = call i16 @DINT_TO_WORD(%DINT_TO_WORD_interface* %DINT_TO_WORD_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call17, i16* %RANGE_TO_WORD, align 2
  %RANGE_TO_WORD_ret = load i16, i16* %RANGE_TO_WORD, align 2
  ret i16 %RANGE_TO_WORD_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %TRUNC_interface, %TRUNC_interface* %TRUNC_instance, i32 0, i32 0
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  %call16 = call i16 @TRUNC(%TRUNC_interface* %TRUNC_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %3 = sext i16 %call16 to i32
  store i32 %3, i32* %1, align 4
  br label %call

input5:                                           ; preds = %input1
  %4 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_low = load float, float* %low, align 4
  %5 = fptoui float %load_low to i64
  store i64 %5, i64* %4, align 4
  %6 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_X = load float, float* %X, align 4
  %7 = fptoui float %load_X to i64
  store i64 %7, i64* %6, align 4
  %8 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_high = load float, float* %high, align 4
  %9 = fptoui float %load_high to i64
  store i64 %9, i64* %8, align 4
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %10 = uitofp i64 %call9 to double
  %load_low10 = load float, float* %low, align 4
  %11 = fpext float %load_low10 to double
  %tmpVar = fsub double %10, %11
  %tmpVar11 = fmul double %tmpVar, 6.553500e+04
  %load_high12 = load float, float* %high, align 4
  %load_low13 = load float, float* %low, align 4
  %tmpVar14 = fsub float %load_high12, %load_low13
  %12 = fpext float %tmpVar14 to double
  %tmpVar15 = fdiv double %tmpVar11, %12
  store double %tmpVar15, double* %2, align 8
  br label %call2
}

define float @SCALE(%SCALE_interface* %0) {
entry:
  %X = getelementptr inbounds %SCALE_interface, %SCALE_interface* %0, i32 0, i32 0
  %K = getelementptr inbounds %SCALE_interface, %SCALE_interface* %0, i32 0, i32 1
  %O = getelementptr inbounds %SCALE_interface, %SCALE_interface* %0, i32 0, i32 2
  %MX = getelementptr inbounds %SCALE_interface, %SCALE_interface* %0, i32 0, i32 3
  %MN = getelementptr inbounds %SCALE_interface, %SCALE_interface* %0, i32 0, i32 4
  %SCALE = alloca float, align 4
  store float 0.000000e+00, float* %SCALE, align 4
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_MN = load float, float* %MN, align 4
  %2 = fptoui float %load_MN to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_X = load float, float* %X, align 4
  %load_K = load float, float* %K, align 4
  %tmpVar = fmul float %load_X, %load_K
  %load_O = load float, float* %O, align 4
  %tmpVar1 = fadd float %tmpVar, %load_O
  %4 = fptoui float %tmpVar1 to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_MX = load float, float* %MX, align 4
  %6 = fptoui float %load_MX to i64
  store i64 %6, i64* %5, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %7 = uitofp i64 %call2 to float
  store float %7, float* %SCALE, align 4
  %SCALE_ret = load float, float* %SCALE, align 4
  ret float %SCALE_ret
}

define float @SCALE_B(%SCALE_B_interface* %0) {
entry:
  %X = getelementptr inbounds %SCALE_B_interface, %SCALE_B_interface* %0, i32 0, i32 0
  %I_LO = getelementptr inbounds %SCALE_B_interface, %SCALE_B_interface* %0, i32 0, i32 1
  %I_HI = getelementptr inbounds %SCALE_B_interface, %SCALE_B_interface* %0, i32 0, i32 2
  %O_LO = getelementptr inbounds %SCALE_B_interface, %SCALE_B_interface* %0, i32 0, i32 3
  %O_HI = getelementptr inbounds %SCALE_B_interface, %SCALE_B_interface* %0, i32 0, i32 4
  %SCALE_B = alloca float, align 4
  store float 0.000000e+00, float* %SCALE_B, align 4
  %load_I_HI = load i8, i8* %I_HI, align 1
  %1 = zext i8 %load_I_HI to i32
  %load_I_LO = load i8, i8* %I_LO, align 1
  %2 = zext i8 %load_I_LO to i32
  %tmpVar = icmp eq i32 %1, %2
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_O_LO = load float, float* %O_LO, align 4
  store float %load_O_LO, float* %SCALE_B, align 4
  br label %continue

else:                                             ; preds = %entry
  %load_O_HI = load float, float* %O_HI, align 4
  %load_O_LO1 = load float, float* %O_LO, align 4
  %tmpVar2 = fsub float %load_O_HI, %load_O_LO1
  %BYTE_TO_REAL_instance = alloca %BYTE_TO_REAL_interface, align 8
  br label %input

continue:                                         ; preds = %continue13, %condition_body
  %SCALE_B_ret = load float, float* %SCALE_B, align 4
  ret float %SCALE_B_ret

input:                                            ; preds = %else
  %3 = getelementptr inbounds %BYTE_TO_REAL_interface, %BYTE_TO_REAL_interface* %BYTE_TO_REAL_instance, i32 0, i32 0
  %load_I_HI4 = load i8, i8* %I_HI, align 1
  %4 = zext i8 %load_I_HI4 to i32
  %load_I_LO5 = load i8, i8* %I_LO, align 1
  %5 = zext i8 %load_I_LO5 to i32
  %tmpVar6 = sub i32 %4, %5
  %6 = trunc i32 %tmpVar6 to i8
  store i8 %6, i8* %3, align 1
  br label %call

call:                                             ; preds = %input
  %call7 = call float @BYTE_TO_REAL(%BYTE_TO_REAL_interface* %BYTE_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  %tmpVar8 = fdiv float %tmpVar2, %call7
  %BYTE_TO_REAL_instance9 = alloca %BYTE_TO_REAL_interface, align 8
  br label %input10

input10:                                          ; preds = %continue3
  %7 = getelementptr inbounds %BYTE_TO_REAL_interface, %BYTE_TO_REAL_interface* %BYTE_TO_REAL_instance9, i32 0, i32 0
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input14

call11:                                           ; preds = %continue17
  %call21 = call float @BYTE_TO_REAL(%BYTE_TO_REAL_interface* %BYTE_TO_REAL_instance9)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %tmpVar22 = fmul float %tmpVar8, %call21
  store float %tmpVar22, float* %SCALE_B, align 4
  br label %continue

input14:                                          ; preds = %input10
  %8 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_I_LO18 = load i8, i8* %I_LO, align 1
  %9 = zext i8 %load_I_LO18 to i64
  store i64 %9, i64* %8, align 4
  %10 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_X = load i8, i8* %X, align 1
  %11 = zext i8 %load_X to i64
  store i64 %11, i64* %10, align 4
  %12 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_I_HI19 = load i8, i8* %I_HI, align 1
  %13 = zext i8 %load_I_HI19 to i64
  store i64 %13, i64* %12, align 4
  br label %call15

call15:                                           ; preds = %input14
  %call20 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %14 = trunc i64 %call20 to i8
  store i8 %14, i8* %7, align 1
  br label %call11
}

define float @SCALE_B2(%SCALE_B2_interface* %0) {
entry:
  %in1 = getelementptr inbounds %SCALE_B2_interface, %SCALE_B2_interface* %0, i32 0, i32 0
  %in2 = getelementptr inbounds %SCALE_B2_interface, %SCALE_B2_interface* %0, i32 0, i32 1
  %K = getelementptr inbounds %SCALE_B2_interface, %SCALE_B2_interface* %0, i32 0, i32 2
  %O = getelementptr inbounds %SCALE_B2_interface, %SCALE_B2_interface* %0, i32 0, i32 3
  %in1_min = getelementptr inbounds %SCALE_B2_interface, %SCALE_B2_interface* %0, i32 0, i32 4
  %in1_max = getelementptr inbounds %SCALE_B2_interface, %SCALE_B2_interface* %0, i32 0, i32 5
  %in2_min = getelementptr inbounds %SCALE_B2_interface, %SCALE_B2_interface* %0, i32 0, i32 6
  %in2_max = getelementptr inbounds %SCALE_B2_interface, %SCALE_B2_interface* %0, i32 0, i32 7
  %SCALE_B2 = alloca float, align 4
  store float 0.000000e+00, float* %SCALE_B2, align 4
  %load_in1_max = load float, float* %in1_max, align 4
  %load_in1_min = load float, float* %in1_min, align 4
  %tmpVar = fsub float %load_in1_max, %load_in1_min
  %load_in1 = load i8, i8* %in1, align 1
  %1 = uitofp i8 %load_in1 to float
  %tmpVar1 = fmul float %tmpVar, %1
  %load_in2_max = load float, float* %in2_max, align 4
  %load_in2_min = load float, float* %in2_min, align 4
  %tmpVar2 = fsub float %load_in2_max, %load_in2_min
  %load_in2 = load i8, i8* %in2, align 1
  %2 = uitofp i8 %load_in2 to float
  %tmpVar3 = fmul float %tmpVar2, %2
  %tmpVar4 = fadd float %tmpVar1, %tmpVar3
  %tmpVar5 = fmul float %tmpVar4, 0x3F70101020000000
  %load_in1_min6 = load float, float* %in1_min, align 4
  %tmpVar7 = fadd float %tmpVar5, %load_in1_min6
  %load_in2_min8 = load float, float* %in2_min, align 4
  %tmpVar9 = fadd float %tmpVar7, %load_in2_min8
  %load_K = load float, float* %K, align 4
  %tmpVar10 = fmul float %tmpVar9, %load_K
  %load_O = load float, float* %O, align 4
  %tmpVar11 = fadd float %tmpVar10, %load_O
  store float %tmpVar11, float* %SCALE_B2, align 4
  %SCALE_B2_ret = load float, float* %SCALE_B2, align 4
  ret float %SCALE_B2_ret
}

define float @SCALE_B4(%SCALE_B4_interface* %0) {
entry:
  %in1 = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 0
  %in2 = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 1
  %in3 = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 2
  %in4 = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 3
  %K = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 4
  %O = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 5
  %in1_min = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 6
  %in1_max = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 7
  %in2_min = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 8
  %in2_max = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 9
  %in3_min = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 10
  %in3_max = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 11
  %in4_min = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 12
  %in4_max = getelementptr inbounds %SCALE_B4_interface, %SCALE_B4_interface* %0, i32 0, i32 13
  %SCALE_B4 = alloca float, align 4
  store float 0.000000e+00, float* %SCALE_B4, align 4
  %load_in1_max = load float, float* %in1_max, align 4
  %load_in1_min = load float, float* %in1_min, align 4
  %tmpVar = fsub float %load_in1_max, %load_in1_min
  %load_in1 = load i8, i8* %in1, align 1
  %1 = uitofp i8 %load_in1 to float
  %tmpVar1 = fmul float %tmpVar, %1
  %load_in2_max = load float, float* %in2_max, align 4
  %load_in2_min = load float, float* %in2_min, align 4
  %tmpVar2 = fsub float %load_in2_max, %load_in2_min
  %load_in2 = load i8, i8* %in2, align 1
  %2 = uitofp i8 %load_in2 to float
  %tmpVar3 = fmul float %tmpVar2, %2
  %tmpVar4 = fadd float %tmpVar1, %tmpVar3
  %load_in3_max = load float, float* %in3_max, align 4
  %load_in3_min = load float, float* %in3_min, align 4
  %tmpVar5 = fsub float %load_in3_max, %load_in3_min
  %load_in3 = load i8, i8* %in3, align 1
  %3 = uitofp i8 %load_in3 to float
  %tmpVar6 = fmul float %tmpVar5, %3
  %tmpVar7 = fadd float %tmpVar4, %tmpVar6
  %load_in4_max = load float, float* %in4_max, align 4
  %load_in4_min = load float, float* %in4_min, align 4
  %tmpVar8 = fsub float %load_in4_max, %load_in4_min
  %load_in4 = load i8, i8* %in4, align 1
  %4 = uitofp i8 %load_in4 to float
  %tmpVar9 = fmul float %tmpVar8, %4
  %tmpVar10 = fadd float %tmpVar7, %tmpVar9
  %tmpVar11 = fmul float %tmpVar10, 0x3F70101020000000
  %load_in1_min12 = load float, float* %in1_min, align 4
  %tmpVar13 = fadd float %tmpVar11, %load_in1_min12
  %load_in2_min14 = load float, float* %in2_min, align 4
  %tmpVar15 = fadd float %tmpVar13, %load_in2_min14
  %load_in3_min16 = load float, float* %in3_min, align 4
  %tmpVar17 = fadd float %tmpVar15, %load_in3_min16
  %load_in4_min18 = load float, float* %in4_min, align 4
  %tmpVar19 = fadd float %tmpVar17, %load_in4_min18
  %load_K = load float, float* %K, align 4
  %tmpVar20 = fmul float %tmpVar19, %load_K
  %load_O = load float, float* %O, align 4
  %tmpVar21 = fadd float %tmpVar20, %load_O
  store float %tmpVar21, float* %SCALE_B4, align 4
  %SCALE_B4_ret = load float, float* %SCALE_B4, align 4
  ret float %SCALE_B4_ret
}

define float @SCALE_B8(%SCALE_B8_interface* %0) {
entry:
  %in1 = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 0
  %in2 = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 1
  %in3 = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 2
  %in4 = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 3
  %in5 = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 4
  %in6 = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 5
  %in7 = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 6
  %in8 = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 7
  %K = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 8
  %O = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 9
  %in1_min = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 10
  %in1_max = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 11
  %in2_min = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 12
  %in2_max = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 13
  %in3_min = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 14
  %in3_max = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 15
  %in4_min = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 16
  %in4_max = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 17
  %in5_min = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 18
  %in5_max = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 19
  %in6_min = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 20
  %in6_max = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 21
  %in7_min = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 22
  %in7_max = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 23
  %in8_min = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 24
  %in8_max = getelementptr inbounds %SCALE_B8_interface, %SCALE_B8_interface* %0, i32 0, i32 25
  %SCALE_B8 = alloca float, align 4
  store float 0.000000e+00, float* %SCALE_B8, align 4
  %load_in1_max = load float, float* %in1_max, align 4
  %load_in1_min = load float, float* %in1_min, align 4
  %tmpVar = fsub float %load_in1_max, %load_in1_min
  %load_in1 = load i8, i8* %in1, align 1
  %1 = uitofp i8 %load_in1 to float
  %tmpVar1 = fmul float %tmpVar, %1
  %load_in2_max = load float, float* %in2_max, align 4
  %load_in2_min = load float, float* %in2_min, align 4
  %tmpVar2 = fsub float %load_in2_max, %load_in2_min
  %load_in2 = load i8, i8* %in2, align 1
  %2 = uitofp i8 %load_in2 to float
  %tmpVar3 = fmul float %tmpVar2, %2
  %tmpVar4 = fadd float %tmpVar1, %tmpVar3
  %load_in3_max = load float, float* %in3_max, align 4
  %load_in3_min = load float, float* %in3_min, align 4
  %tmpVar5 = fsub float %load_in3_max, %load_in3_min
  %load_in3 = load i8, i8* %in3, align 1
  %3 = uitofp i8 %load_in3 to float
  %tmpVar6 = fmul float %tmpVar5, %3
  %tmpVar7 = fadd float %tmpVar4, %tmpVar6
  %load_in4_max = load float, float* %in4_max, align 4
  %load_in4_min = load float, float* %in4_min, align 4
  %tmpVar8 = fsub float %load_in4_max, %load_in4_min
  %load_in4 = load i8, i8* %in4, align 1
  %4 = uitofp i8 %load_in4 to float
  %tmpVar9 = fmul float %tmpVar8, %4
  %tmpVar10 = fadd float %tmpVar7, %tmpVar9
  %load_in5_max = load float, float* %in5_max, align 4
  %load_in5_min = load float, float* %in5_min, align 4
  %tmpVar11 = fsub float %load_in5_max, %load_in5_min
  %load_in5 = load i8, i8* %in5, align 1
  %5 = uitofp i8 %load_in5 to float
  %tmpVar12 = fmul float %tmpVar11, %5
  %tmpVar13 = fadd float %tmpVar10, %tmpVar12
  %load_in6_max = load float, float* %in6_max, align 4
  %load_in6_min = load float, float* %in6_min, align 4
  %tmpVar14 = fsub float %load_in6_max, %load_in6_min
  %load_in6 = load i8, i8* %in6, align 1
  %6 = uitofp i8 %load_in6 to float
  %tmpVar15 = fmul float %tmpVar14, %6
  %tmpVar16 = fadd float %tmpVar13, %tmpVar15
  %load_in7_max = load float, float* %in7_max, align 4
  %load_in7_min = load float, float* %in7_min, align 4
  %tmpVar17 = fsub float %load_in7_max, %load_in7_min
  %load_in7 = load i8, i8* %in7, align 1
  %7 = uitofp i8 %load_in7 to float
  %tmpVar18 = fmul float %tmpVar17, %7
  %tmpVar19 = fadd float %tmpVar16, %tmpVar18
  %load_in8_max = load float, float* %in8_max, align 4
  %load_in8_min = load float, float* %in8_min, align 4
  %tmpVar20 = fsub float %load_in8_max, %load_in8_min
  %load_in8 = load i8, i8* %in8, align 1
  %8 = uitofp i8 %load_in8 to float
  %tmpVar21 = fmul float %tmpVar20, %8
  %tmpVar22 = fadd float %tmpVar19, %tmpVar21
  %tmpVar23 = fmul float %tmpVar22, 0x3F70101020000000
  %load_in1_min24 = load float, float* %in1_min, align 4
  %tmpVar25 = fadd float %tmpVar23, %load_in1_min24
  %load_in2_min26 = load float, float* %in2_min, align 4
  %tmpVar27 = fadd float %tmpVar25, %load_in2_min26
  %load_in3_min28 = load float, float* %in3_min, align 4
  %tmpVar29 = fadd float %tmpVar27, %load_in3_min28
  %load_in4_min30 = load float, float* %in4_min, align 4
  %tmpVar31 = fadd float %tmpVar29, %load_in4_min30
  %load_in5_min32 = load float, float* %in5_min, align 4
  %tmpVar33 = fadd float %tmpVar31, %load_in5_min32
  %load_in6_min34 = load float, float* %in6_min, align 4
  %tmpVar35 = fadd float %tmpVar33, %load_in6_min34
  %load_in7_min36 = load float, float* %in7_min, align 4
  %tmpVar37 = fadd float %tmpVar35, %load_in7_min36
  %load_in8_min38 = load float, float* %in8_min, align 4
  %tmpVar39 = fadd float %tmpVar37, %load_in8_min38
  %load_K = load float, float* %K, align 4
  %tmpVar40 = fmul float %tmpVar39, %load_K
  %load_O = load float, float* %O, align 4
  %tmpVar41 = fadd float %tmpVar40, %load_O
  store float %tmpVar41, float* %SCALE_B8, align 4
  %SCALE_B8_ret = load float, float* %SCALE_B8, align 4
  ret float %SCALE_B8_ret
}

define float @SCALE_D(%SCALE_D_interface* %0) {
entry:
  %X = getelementptr inbounds %SCALE_D_interface, %SCALE_D_interface* %0, i32 0, i32 0
  %I_LO = getelementptr inbounds %SCALE_D_interface, %SCALE_D_interface* %0, i32 0, i32 1
  %I_HI = getelementptr inbounds %SCALE_D_interface, %SCALE_D_interface* %0, i32 0, i32 2
  %O_LO = getelementptr inbounds %SCALE_D_interface, %SCALE_D_interface* %0, i32 0, i32 3
  %O_HI = getelementptr inbounds %SCALE_D_interface, %SCALE_D_interface* %0, i32 0, i32 4
  %SCALE_D = alloca float, align 4
  store float 0.000000e+00, float* %SCALE_D, align 4
  %load_I_HI = load i32, i32* %I_HI, align 4
  %load_I_LO = load i32, i32* %I_LO, align 4
  %tmpVar = icmp eq i32 %load_I_HI, %load_I_LO
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_O_LO = load float, float* %O_LO, align 4
  store float %load_O_LO, float* %SCALE_D, align 4
  br label %continue

else:                                             ; preds = %entry
  %load_O_HI = load float, float* %O_HI, align 4
  %load_O_LO1 = load float, float* %O_LO, align 4
  %tmpVar2 = fsub float %load_O_HI, %load_O_LO1
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input

continue:                                         ; preds = %continue13, %condition_body
  %SCALE_D_ret = load float, float* %SCALE_D, align 4
  ret float %SCALE_D_ret

input:                                            ; preds = %else
  %1 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_I_HI4 = load i32, i32* %I_HI, align 4
  %load_I_LO5 = load i32, i32* %I_LO, align 4
  %tmpVar6 = sub i32 %load_I_HI4, %load_I_LO5
  store i32 %tmpVar6, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call7 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  %tmpVar8 = fdiv float %tmpVar2, %call7
  %DWORD_TO_REAL_instance9 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input10

input10:                                          ; preds = %continue3
  %2 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance9, i32 0, i32 0
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input14

call11:                                           ; preds = %continue17
  %call23 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance9)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %tmpVar24 = fmul float %tmpVar8, %call23
  %load_O_LO25 = load float, float* %O_LO, align 4
  %tmpVar26 = fadd float %tmpVar24, %load_O_LO25
  store float %tmpVar26, float* %SCALE_D, align 4
  br label %continue

input14:                                          ; preds = %input10
  %3 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_I_LO18 = load i32, i32* %I_LO, align 4
  %4 = zext i32 %load_I_LO18 to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_X = load i32, i32* %X, align 4
  %6 = zext i32 %load_X to i64
  store i64 %6, i64* %5, align 4
  %7 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_I_HI19 = load i32, i32* %I_HI, align 4
  %8 = zext i32 %load_I_HI19 to i64
  store i64 %8, i64* %7, align 4
  br label %call15

call15:                                           ; preds = %input14
  %call20 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %load_I_LO21 = load i32, i32* %I_LO, align 4
  %9 = zext i32 %load_I_LO21 to i64
  %tmpVar22 = sub i64 %call20, %9
  %10 = trunc i64 %tmpVar22 to i32
  store i32 %10, i32* %2, align 4
  br label %call11
}

define float @SCALE_R(%SCALE_R_interface* %0) {
entry:
  %X = getelementptr inbounds %SCALE_R_interface, %SCALE_R_interface* %0, i32 0, i32 0
  %I_LO = getelementptr inbounds %SCALE_R_interface, %SCALE_R_interface* %0, i32 0, i32 1
  %I_HI = getelementptr inbounds %SCALE_R_interface, %SCALE_R_interface* %0, i32 0, i32 2
  %O_LO = getelementptr inbounds %SCALE_R_interface, %SCALE_R_interface* %0, i32 0, i32 3
  %O_HI = getelementptr inbounds %SCALE_R_interface, %SCALE_R_interface* %0, i32 0, i32 4
  %SCALE_R = alloca float, align 4
  store float 0.000000e+00, float* %SCALE_R, align 4
  %load_I_LO = load float, float* %I_LO, align 4
  %load_I_HI = load float, float* %I_HI, align 4
  %tmpVar = fcmp oeq float %load_I_LO, %load_I_HI
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_O_LO = load float, float* %O_LO, align 4
  store float %load_O_LO, float* %SCALE_R, align 4
  br label %continue

else:                                             ; preds = %entry
  %load_O_HI = load float, float* %O_HI, align 4
  %load_O_LO1 = load float, float* %O_LO, align 4
  %tmpVar2 = fsub float %load_O_HI, %load_O_LO1
  %load_I_HI3 = load float, float* %I_HI, align 4
  %load_I_LO4 = load float, float* %I_LO, align 4
  %tmpVar5 = fsub float %load_I_HI3, %load_I_LO4
  %tmpVar6 = fdiv float %tmpVar2, %tmpVar5
  %1 = fpext float %tmpVar6 to double
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input

continue:                                         ; preds = %continue7, %condition_body
  %SCALE_R_ret = load float, float* %SCALE_R, align 4
  ret float %SCALE_R_ret

input:                                            ; preds = %else
  %2 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  %load_I_LO8 = load float, float* %I_LO, align 4
  %3 = fptoui float %load_I_LO8 to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_X = load float, float* %X, align 4
  %5 = fptoui float %load_X to i64
  store i64 %5, i64* %4, align 4
  %6 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_I_HI9 = load float, float* %I_HI, align 4
  %7 = fptoui float %load_I_HI9 to i64
  store i64 %7, i64* %6, align 4
  br label %call

call:                                             ; preds = %input
  %call10 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue7

continue7:                                        ; preds = %output
  %8 = uitofp i64 %call10 to double
  %load_I_LO11 = load float, float* %I_LO, align 4
  %9 = fpext float %load_I_LO11 to double
  %tmpVar12 = fsub double %8, %9
  %tmpVar13 = fmul double %1, %tmpVar12
  %load_O_LO14 = load float, float* %O_LO, align 4
  %10 = fpext float %load_O_LO14 to double
  %tmpVar15 = fadd double %tmpVar13, %10
  %11 = fptrunc double %tmpVar15 to float
  store float %11, float* %SCALE_R, align 4
  br label %continue
}

define float @SCALE_X2(%SCALE_X2_interface* %0) {
entry:
  %IN1 = getelementptr inbounds %SCALE_X2_interface, %SCALE_X2_interface* %0, i32 0, i32 0
  %IN2 = getelementptr inbounds %SCALE_X2_interface, %SCALE_X2_interface* %0, i32 0, i32 1
  %K = getelementptr inbounds %SCALE_X2_interface, %SCALE_X2_interface* %0, i32 0, i32 2
  %O = getelementptr inbounds %SCALE_X2_interface, %SCALE_X2_interface* %0, i32 0, i32 3
  %IN1_MIN = getelementptr inbounds %SCALE_X2_interface, %SCALE_X2_interface* %0, i32 0, i32 4
  %IN1_MAX = getelementptr inbounds %SCALE_X2_interface, %SCALE_X2_interface* %0, i32 0, i32 5
  %IN2_MIN = getelementptr inbounds %SCALE_X2_interface, %SCALE_X2_interface* %0, i32 0, i32 6
  %IN2_MAX = getelementptr inbounds %SCALE_X2_interface, %SCALE_X2_interface* %0, i32 0, i32 7
  %SCALE_X2 = alloca float, align 4
  store float 0.000000e+00, float* %SCALE_X2, align 4
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_IN1 = load i8, i8* %IN1, align 1
  store i8 %load_IN1, i8* %1, align 1
  %2 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_IN1_MIN = load float, float* %IN1_MIN, align 4
  %3 = fptoui float %load_IN1_MIN to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_IN1_MAX = load float, float* %IN1_MAX, align 4
  %5 = fptoui float %load_IN1_MAX to i64
  store i64 %5, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %SEL_instance2 = alloca %SEL_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %6 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance2, i32 0, i32 0
  %load_IN2 = load i8, i8* %IN2, align 1
  store i8 %load_IN2, i8* %6, align 1
  %7 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance2, i32 0, i32 1
  %load_IN2_MIN = load float, float* %IN2_MIN, align 4
  %8 = fptoui float %load_IN2_MIN to i64
  store i64 %8, i64* %7, align 4
  %9 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance2, i32 0, i32 2
  %load_IN2_MAX = load float, float* %IN2_MAX, align 4
  %10 = fptoui float %load_IN2_MAX to i64
  store i64 %10, i64* %9, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i64 @SEL(%SEL_interface* %SEL_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %tmpVar = add i64 %call1, %call7
  %11 = uitofp i64 %tmpVar to double
  %load_k = load float, float* %K, align 4
  %12 = fpext float %load_k to double
  %tmpVar8 = fmul double %11, %12
  %load_o = load float, float* %O, align 4
  %13 = fpext float %load_o to double
  %tmpVar9 = fadd double %tmpVar8, %13
  %14 = fptrunc double %tmpVar9 to float
  store float %14, float* %SCALE_X2, align 4
  %SCALE_X2_ret = load float, float* %SCALE_X2, align 4
  ret float %SCALE_X2_ret
}

define float @SCALE_X4(%SCALE_X4_interface* %0) {
entry:
  %IN1 = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 0
  %IN2 = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 1
  %IN3 = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 2
  %IN4 = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 3
  %K = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 4
  %O = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 5
  %IN1_MIN = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 6
  %IN1_MAX = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 7
  %IN2_MIN = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 8
  %IN2_MAX = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 9
  %IN3_MIN = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 10
  %IN3_MAX = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 11
  %IN4_MIN = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 12
  %IN4_MAX = getelementptr inbounds %SCALE_X4_interface, %SCALE_X4_interface* %0, i32 0, i32 13
  %SCALE_X4 = alloca float, align 4
  store float 0.000000e+00, float* %SCALE_X4, align 4
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_IN1 = load i8, i8* %IN1, align 1
  store i8 %load_IN1, i8* %1, align 1
  %2 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_IN1_MIN = load float, float* %IN1_MIN, align 4
  %3 = fptoui float %load_IN1_MIN to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_IN1_MAX = load float, float* %IN1_MAX, align 4
  %5 = fptoui float %load_IN1_MAX to i64
  store i64 %5, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %SEL_instance2 = alloca %SEL_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %6 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance2, i32 0, i32 0
  %load_IN2 = load i8, i8* %IN2, align 1
  store i8 %load_IN2, i8* %6, align 1
  %7 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance2, i32 0, i32 1
  %load_IN2_MIN = load float, float* %IN2_MIN, align 4
  %8 = fptoui float %load_IN2_MIN to i64
  store i64 %8, i64* %7, align 4
  %9 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance2, i32 0, i32 2
  %load_IN2_MAX = load float, float* %IN2_MAX, align 4
  %10 = fptoui float %load_IN2_MAX to i64
  store i64 %10, i64* %9, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i64 @SEL(%SEL_interface* %SEL_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %tmpVar = add i64 %call1, %call7
  %SEL_instance8 = alloca %SEL_interface, align 8
  br label %input9

input9:                                           ; preds = %continue6
  %11 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance8, i32 0, i32 0
  %load_IN3 = load i8, i8* %IN3, align 1
  store i8 %load_IN3, i8* %11, align 1
  %12 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance8, i32 0, i32 1
  %load_IN3_MIN = load float, float* %IN3_MIN, align 4
  %13 = fptoui float %load_IN3_MIN to i64
  store i64 %13, i64* %12, align 4
  %14 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance8, i32 0, i32 2
  %load_IN3_MAX = load float, float* %IN3_MAX, align 4
  %15 = fptoui float %load_IN3_MAX to i64
  store i64 %15, i64* %14, align 4
  br label %call10

call10:                                           ; preds = %input9
  %call13 = call i64 @SEL(%SEL_interface* %SEL_instance8)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  %tmpVar14 = add i64 %tmpVar, %call13
  %SEL_instance15 = alloca %SEL_interface, align 8
  br label %input16

input16:                                          ; preds = %continue12
  %16 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance15, i32 0, i32 0
  %load_IN4 = load i8, i8* %IN4, align 1
  store i8 %load_IN4, i8* %16, align 1
  %17 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance15, i32 0, i32 1
  %load_IN4_MIN = load float, float* %IN4_MIN, align 4
  %18 = fptoui float %load_IN4_MIN to i64
  store i64 %18, i64* %17, align 4
  %19 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance15, i32 0, i32 2
  %load_IN4_MAX = load float, float* %IN4_MAX, align 4
  %20 = fptoui float %load_IN4_MAX to i64
  store i64 %20, i64* %19, align 4
  br label %call17

call17:                                           ; preds = %input16
  %call20 = call i64 @SEL(%SEL_interface* %SEL_instance15)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %tmpVar21 = add i64 %tmpVar14, %call20
  %21 = uitofp i64 %tmpVar21 to double
  %load_k = load float, float* %K, align 4
  %22 = fpext float %load_k to double
  %tmpVar22 = fmul double %21, %22
  %load_o = load float, float* %O, align 4
  %23 = fpext float %load_o to double
  %tmpVar23 = fadd double %tmpVar22, %23
  %24 = fptrunc double %tmpVar23 to float
  store float %24, float* %SCALE_X4, align 4
  %SCALE_X4_ret = load float, float* %SCALE_X4, align 4
  ret float %SCALE_X4_ret
}

define float @SCALE_X8(%SCALE_X8_interface* %0) {
entry:
  %in1 = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 0
  %in2 = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 1
  %in3 = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 2
  %in4 = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 3
  %in5 = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 4
  %in6 = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 5
  %in7 = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 6
  %in8 = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 7
  %K = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 8
  %O = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 9
  %in1_min = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 10
  %in1_max = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 11
  %in2_min = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 12
  %in2_max = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 13
  %in3_min = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 14
  %in3_max = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 15
  %in4_min = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 16
  %in4_max = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 17
  %in5_min = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 18
  %in5_max = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 19
  %in6_min = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 20
  %in6_max = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 21
  %in7_min = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 22
  %in7_max = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 23
  %in8_min = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 24
  %in8_max = getelementptr inbounds %SCALE_X8_interface, %SCALE_X8_interface* %0, i32 0, i32 25
  %SCALE_X8 = alloca float, align 4
  store float 0.000000e+00, float* %SCALE_X8, align 4
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_IN1 = load i8, i8* %in1, align 1
  store i8 %load_IN1, i8* %1, align 1
  %2 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_IN1_MIN = load float, float* %in1_min, align 4
  %3 = fptoui float %load_IN1_MIN to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_IN1_MAX = load float, float* %in1_max, align 4
  %5 = fptoui float %load_IN1_MAX to i64
  store i64 %5, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %SEL_instance2 = alloca %SEL_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %6 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance2, i32 0, i32 0
  %load_IN2 = load i8, i8* %in2, align 1
  store i8 %load_IN2, i8* %6, align 1
  %7 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance2, i32 0, i32 1
  %load_IN2_MIN = load float, float* %in2_min, align 4
  %8 = fptoui float %load_IN2_MIN to i64
  store i64 %8, i64* %7, align 4
  %9 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance2, i32 0, i32 2
  %load_IN2_MAX = load float, float* %in2_max, align 4
  %10 = fptoui float %load_IN2_MAX to i64
  store i64 %10, i64* %9, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i64 @SEL(%SEL_interface* %SEL_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %tmpVar = add i64 %call1, %call7
  %SEL_instance8 = alloca %SEL_interface, align 8
  br label %input9

input9:                                           ; preds = %continue6
  %11 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance8, i32 0, i32 0
  %load_IN3 = load i8, i8* %in3, align 1
  store i8 %load_IN3, i8* %11, align 1
  %12 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance8, i32 0, i32 1
  %load_IN3_MIN = load float, float* %in3_min, align 4
  %13 = fptoui float %load_IN3_MIN to i64
  store i64 %13, i64* %12, align 4
  %14 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance8, i32 0, i32 2
  %load_IN3_MAX = load float, float* %in3_max, align 4
  %15 = fptoui float %load_IN3_MAX to i64
  store i64 %15, i64* %14, align 4
  br label %call10

call10:                                           ; preds = %input9
  %call13 = call i64 @SEL(%SEL_interface* %SEL_instance8)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  %tmpVar14 = add i64 %tmpVar, %call13
  %SEL_instance15 = alloca %SEL_interface, align 8
  br label %input16

input16:                                          ; preds = %continue12
  %16 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance15, i32 0, i32 0
  %load_IN4 = load i8, i8* %in4, align 1
  store i8 %load_IN4, i8* %16, align 1
  %17 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance15, i32 0, i32 1
  %load_IN4_MIN = load float, float* %in4_min, align 4
  %18 = fptoui float %load_IN4_MIN to i64
  store i64 %18, i64* %17, align 4
  %19 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance15, i32 0, i32 2
  %load_IN4_MAX = load float, float* %in4_max, align 4
  %20 = fptoui float %load_IN4_MAX to i64
  store i64 %20, i64* %19, align 4
  br label %call17

call17:                                           ; preds = %input16
  %call20 = call i64 @SEL(%SEL_interface* %SEL_instance15)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %tmpVar21 = add i64 %tmpVar14, %call20
  %SEL_instance22 = alloca %SEL_interface, align 8
  br label %input23

input23:                                          ; preds = %continue19
  %21 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance22, i32 0, i32 0
  %load_IN5 = load i8, i8* %in5, align 1
  store i8 %load_IN5, i8* %21, align 1
  %22 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance22, i32 0, i32 1
  %load_IN5_MIN = load float, float* %in5_min, align 4
  %23 = fptoui float %load_IN5_MIN to i64
  store i64 %23, i64* %22, align 4
  %24 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance22, i32 0, i32 2
  %load_IN5_MAX = load float, float* %in5_max, align 4
  %25 = fptoui float %load_IN5_MAX to i64
  store i64 %25, i64* %24, align 4
  br label %call24

call24:                                           ; preds = %input23
  %call27 = call i64 @SEL(%SEL_interface* %SEL_instance22)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %tmpVar28 = add i64 %tmpVar21, %call27
  %SEL_instance29 = alloca %SEL_interface, align 8
  br label %input30

input30:                                          ; preds = %continue26
  %26 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance29, i32 0, i32 0
  %load_IN6 = load i8, i8* %in6, align 1
  store i8 %load_IN6, i8* %26, align 1
  %27 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance29, i32 0, i32 1
  %load_IN6_MIN = load float, float* %in6_min, align 4
  %28 = fptoui float %load_IN6_MIN to i64
  store i64 %28, i64* %27, align 4
  %29 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance29, i32 0, i32 2
  %load_IN6_MAX = load float, float* %in6_max, align 4
  %30 = fptoui float %load_IN6_MAX to i64
  store i64 %30, i64* %29, align 4
  br label %call31

call31:                                           ; preds = %input30
  %call34 = call i64 @SEL(%SEL_interface* %SEL_instance29)
  br label %output32

output32:                                         ; preds = %call31
  br label %continue33

continue33:                                       ; preds = %output32
  %tmpVar35 = add i64 %tmpVar28, %call34
  %SEL_instance36 = alloca %SEL_interface, align 8
  br label %input37

input37:                                          ; preds = %continue33
  %31 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance36, i32 0, i32 0
  %load_IN7 = load i8, i8* %in7, align 1
  store i8 %load_IN7, i8* %31, align 1
  %32 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance36, i32 0, i32 1
  %load_IN7_MIN = load float, float* %in7_min, align 4
  %33 = fptoui float %load_IN7_MIN to i64
  store i64 %33, i64* %32, align 4
  %34 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance36, i32 0, i32 2
  %load_IN7_MAX = load float, float* %in7_max, align 4
  %35 = fptoui float %load_IN7_MAX to i64
  store i64 %35, i64* %34, align 4
  br label %call38

call38:                                           ; preds = %input37
  %call41 = call i64 @SEL(%SEL_interface* %SEL_instance36)
  br label %output39

output39:                                         ; preds = %call38
  br label %continue40

continue40:                                       ; preds = %output39
  %tmpVar42 = add i64 %tmpVar35, %call41
  %SEL_instance43 = alloca %SEL_interface, align 8
  br label %input44

input44:                                          ; preds = %continue40
  %36 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance43, i32 0, i32 0
  %load_IN8 = load i8, i8* %in8, align 1
  store i8 %load_IN8, i8* %36, align 1
  %37 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance43, i32 0, i32 1
  %load_IN8_MIN = load float, float* %in8_min, align 4
  %38 = fptoui float %load_IN8_MIN to i64
  store i64 %38, i64* %37, align 4
  %39 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance43, i32 0, i32 2
  %load_IN8_MAX = load float, float* %in8_max, align 4
  %40 = fptoui float %load_IN8_MAX to i64
  store i64 %40, i64* %39, align 4
  br label %call45

call45:                                           ; preds = %input44
  %call48 = call i64 @SEL(%SEL_interface* %SEL_instance43)
  br label %output46

output46:                                         ; preds = %call45
  br label %continue47

continue47:                                       ; preds = %output46
  %tmpVar49 = add i64 %tmpVar42, %call48
  %41 = uitofp i64 %tmpVar49 to double
  %load_k = load float, float* %K, align 4
  %42 = fpext float %load_k to double
  %tmpVar50 = fmul double %41, %42
  %load_o = load float, float* %O, align 4
  %43 = fpext float %load_o to double
  %tmpVar51 = fadd double %tmpVar50, %43
  %44 = fptrunc double %tmpVar51 to float
  store float %44, float* %SCALE_X8, align 4
  %SCALE_X8_ret = load float, float* %SCALE_X8, align 4
  ret float %SCALE_X8_ret
}

define void @SEL2_OF_3(%SEL2_OF_3_interface* %0) {
entry:
  %IN1 = getelementptr inbounds %SEL2_OF_3_interface, %SEL2_OF_3_interface* %0, i32 0, i32 0
  %IN2 = getelementptr inbounds %SEL2_OF_3_interface, %SEL2_OF_3_interface* %0, i32 0, i32 1
  %IN3 = getelementptr inbounds %SEL2_OF_3_interface, %SEL2_OF_3_interface* %0, i32 0, i32 2
  %D = getelementptr inbounds %SEL2_OF_3_interface, %SEL2_OF_3_interface* %0, i32 0, i32 3
  %Y = getelementptr inbounds %SEL2_OF_3_interface, %SEL2_OF_3_interface* %0, i32 0, i32 4
  %W = getelementptr inbounds %SEL2_OF_3_interface, %SEL2_OF_3_interface* %0, i32 0, i32 5
  %E = getelementptr inbounds %SEL2_OF_3_interface, %SEL2_OF_3_interface* %0, i32 0, i32 6
  %D12 = getelementptr inbounds %SEL2_OF_3_interface, %SEL2_OF_3_interface* %0, i32 0, i32 7
  %D23 = getelementptr inbounds %SEL2_OF_3_interface, %SEL2_OF_3_interface* %0, i32 0, i32 8
  %D31 = getelementptr inbounds %SEL2_OF_3_interface, %SEL2_OF_3_interface* %0, i32 0, i32 9
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_IN1 = load float, float* %IN1, align 4
  %load_IN2 = load float, float* %IN2, align 4
  %tmpVar = fsub float %load_IN1, %load_IN2
  %2 = fptoui float %tmpVar to i64
  store i64 %2, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = uitofp i64 %call1 to double
  %load_D = load float, float* %D, align 4
  %4 = fpext float %load_D to double
  %tmpVar2 = fcmp ole double %3, %4
  %5 = zext i1 %tmpVar2 to i8
  store i8 %5, i8* %D12, align 1
  %ABS_instance3 = alloca %ABS_interface, align 8
  br label %input4

input4:                                           ; preds = %continue
  %6 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance3, i32 0, i32 0
  %load_IN28 = load float, float* %IN2, align 4
  %load_IN3 = load float, float* %IN3, align 4
  %tmpVar9 = fsub float %load_IN28, %load_IN3
  %7 = fptoui float %tmpVar9 to i64
  store i64 %7, i64* %6, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call10 = call i64 @ABS(%ABS_interface* %ABS_instance3)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %8 = uitofp i64 %call10 to double
  %load_D11 = load float, float* %D, align 4
  %9 = fpext float %load_D11 to double
  %tmpVar12 = fcmp ole double %8, %9
  %10 = zext i1 %tmpVar12 to i8
  store i8 %10, i8* %D23, align 1
  %ABS_instance13 = alloca %ABS_interface, align 8
  br label %input14

input14:                                          ; preds = %continue7
  %11 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance13, i32 0, i32 0
  %load_IN318 = load float, float* %IN3, align 4
  %load_IN119 = load float, float* %IN1, align 4
  %tmpVar20 = fsub float %load_IN318, %load_IN119
  %12 = fptoui float %tmpVar20 to i64
  store i64 %12, i64* %11, align 4
  br label %call15

call15:                                           ; preds = %input14
  %call21 = call i64 @ABS(%ABS_interface* %ABS_instance13)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %13 = uitofp i64 %call21 to double
  %load_D22 = load float, float* %D, align 4
  %14 = fpext float %load_D22 to double
  %tmpVar23 = fcmp ole double %13, %14
  %15 = zext i1 %tmpVar23 to i8
  store i8 %15, i8* %D31, align 1
  %load_D12 = load i8, i8* %D12, align 1
  %16 = zext i8 %load_D12 to i32
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %33, label %35

condition_body:                                   ; preds = %24
  %load_IN130 = load float, float* %IN1, align 4
  %load_IN231 = load float, float* %IN2, align 4
  %tmpVar32 = fadd float %load_IN130, %load_IN231
  %load_IN333 = load float, float* %IN3, align 4
  %tmpVar34 = fadd float %tmpVar32, %load_IN333
  %tmpVar35 = fmul float %tmpVar34, 0x3FD5555560000000
  store float %tmpVar35, float* %Y, align 4
  store i8 0, i8* %E, align 1
  store i16 0, i16* %W, align 2
  br label %continue26

branch:                                           ; preds = %24
  %load_D1237 = load i8, i8* %D12, align 1
  %18 = icmp ne i8 %load_D1237, 0
  br i1 %18, label %condition_body36, label %branch24

condition_body36:                                 ; preds = %branch
  %load_In1 = load float, float* %IN1, align 4
  %load_IN238 = load float, float* %IN2, align 4
  %tmpVar39 = fadd float %load_In1, %load_IN238
  %tmpVar40 = fmul float %tmpVar39, 5.000000e-01
  store float %tmpVar40, float* %Y, align 4
  store i8 0, i8* %E, align 1
  store i16 3, i16* %W, align 2
  br label %continue26

branch24:                                         ; preds = %branch
  %load_D2342 = load i8, i8* %D23, align 1
  %19 = icmp ne i8 %load_D2342, 0
  br i1 %19, label %condition_body41, label %branch25

condition_body41:                                 ; preds = %branch24
  %load_In2 = load float, float* %IN2, align 4
  %load_IN343 = load float, float* %IN3, align 4
  %tmpVar44 = fadd float %load_In2, %load_IN343
  %tmpVar45 = fmul float %tmpVar44, 5.000000e-01
  store float %tmpVar45, float* %Y, align 4
  store i8 0, i8* %E, align 1
  store i16 1, i16* %W, align 2
  br label %continue26

branch25:                                         ; preds = %branch24
  %load_D3147 = load i8, i8* %D31, align 1
  %20 = icmp ne i8 %load_D3147, 0
  br i1 %20, label %condition_body46, label %else

condition_body46:                                 ; preds = %branch25
  %load_In3 = load float, float* %IN3, align 4
  %load_IN148 = load float, float* %IN1, align 4
  %tmpVar49 = fadd float %load_In3, %load_IN148
  %tmpVar50 = fmul float %tmpVar49, 5.000000e-01
  store float %tmpVar50, float* %Y, align 4
  store i8 0, i8* %E, align 1
  store i16 2, i16* %W, align 2
  br label %continue26

else:                                             ; preds = %branch25
  store i8 1, i8* %E, align 1
  store i16 4, i16* %W, align 2
  br label %continue26

continue26:                                       ; preds = %else, %condition_body46, %condition_body41, %condition_body36, %condition_body
  ret void

21:                                               ; preds = %30
  %load_D2328 = load i8, i8* %D23, align 1
  %22 = zext i8 %load_D2328 to i32
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %42, label %44

24:                                               ; preds = %44, %30
  %25 = phi i32 [ %31, %30 ], [ %45, %44 ]
  %26 = icmp ne i32 %25, 0
  br i1 %26, label %condition_body, label %branch

27:                                               ; preds = %35
  %load_D1227 = load i8, i8* %D12, align 1
  %28 = zext i8 %load_D1227 to i32
  %29 = icmp ne i32 %28, 0
  br i1 %29, label %38, label %40

30:                                               ; preds = %40, %35
  %31 = phi i32 [ %36, %35 ], [ %41, %40 ]
  %32 = icmp ne i32 %31, 0
  br i1 %32, label %24, label %21

33:                                               ; preds = %continue17
  %load_D23 = load i8, i8* %D23, align 1
  %34 = zext i8 %load_D23 to i32
  br label %35

35:                                               ; preds = %33, %continue17
  %36 = phi i32 [ %16, %continue17 ], [ %34, %33 ]
  %37 = icmp ne i32 %36, 0
  br i1 %37, label %30, label %27

38:                                               ; preds = %27
  %load_D31 = load i8, i8* %D31, align 1
  %39 = zext i8 %load_D31 to i32
  br label %40

40:                                               ; preds = %38, %27
  %41 = phi i32 [ %28, %27 ], [ %39, %38 ]
  br label %30

42:                                               ; preds = %21
  %load_D3129 = load i8, i8* %D31, align 1
  %43 = zext i8 %load_D3129 to i32
  br label %44

44:                                               ; preds = %42, %21
  %45 = phi i32 [ %22, %21 ], [ %43, %42 ]
  br label %24
}

define void @SEL2_OF_3B(%SEL2_OF_3B_interface* %0) {
entry:
  %IN1 = getelementptr inbounds %SEL2_OF_3B_interface, %SEL2_OF_3B_interface* %0, i32 0, i32 0
  %IN2 = getelementptr inbounds %SEL2_OF_3B_interface, %SEL2_OF_3B_interface* %0, i32 0, i32 1
  %IN3 = getelementptr inbounds %SEL2_OF_3B_interface, %SEL2_OF_3B_interface* %0, i32 0, i32 2
  %TD = getelementptr inbounds %SEL2_OF_3B_interface, %SEL2_OF_3B_interface* %0, i32 0, i32 3
  %Q = getelementptr inbounds %SEL2_OF_3B_interface, %SEL2_OF_3B_interface* %0, i32 0, i32 4
  %W = getelementptr inbounds %SEL2_OF_3B_interface, %SEL2_OF_3B_interface* %0, i32 0, i32 5
  %TDEL = getelementptr inbounds %SEL2_OF_3B_interface, %SEL2_OF_3B_interface* %0, i32 0, i32 6
  %load_IN1 = load i8, i8* %IN1, align 1
  %1 = zext i8 %load_IN1 to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %14, label %16

3:                                                ; preds = %11
  %load_IN22 = load i8, i8* %IN2, align 1
  %4 = zext i8 %load_IN22 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %23, label %25

6:                                                ; preds = %25, %11
  %7 = phi i32 [ %12, %11 ], [ %26, %25 ]
  store i32 %7, i8* %Q, align 4
  br label %input

8:                                                ; preds = %16
  %load_IN11 = load i8, i8* %IN1, align 1
  %9 = zext i8 %load_IN11 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %19, label %21

11:                                               ; preds = %21, %16
  %12 = phi i32 [ %17, %16 ], [ %22, %21 ]
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %6, label %3

14:                                               ; preds = %entry
  %load_IN2 = load i8, i8* %IN2, align 1
  %15 = zext i8 %load_IN2 to i32
  br label %16

16:                                               ; preds = %14, %entry
  %17 = phi i32 [ %1, %entry ], [ %15, %14 ]
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %11, label %8

19:                                               ; preds = %8
  %load_IN3 = load i8, i8* %IN3, align 1
  %20 = zext i8 %load_IN3 to i32
  br label %21

21:                                               ; preds = %19, %8
  %22 = phi i32 [ %9, %8 ], [ %20, %19 ]
  br label %11

23:                                               ; preds = %3
  %load_IN33 = load i8, i8* %IN3, align 1
  %24 = zext i8 %load_IN33 to i32
  br label %25

25:                                               ; preds = %23, %3
  %26 = phi i32 [ %4, %3 ], [ %24, %23 ]
  br label %6

input:                                            ; preds = %6
  %27 = getelementptr inbounds %TON_interface, %TON_interface* %TDEL, i32 0, i32 0
  %load_in1 = load i8, i8* %IN1, align 1
  %28 = zext i8 %load_in1 to i32
  %load_in2 = load i8, i8* %IN2, align 1
  %29 = zext i8 %load_in2 to i32
  %tmpVar = xor i32 %28, %29
  %30 = icmp ne i32 %tmpVar, 0
  br i1 %30, label %40, label %37
  %31 = getelementptr inbounds %TON_interface, %TON_interface* %TDEL, i32 0, i32 1
  %load_TD = load i64, i64* %TD, align 4
  store i64 %load_TD, i64* %31, align 4
  br label %call

call:                                             ; preds = %input
  call void @TON(%TON_interface* %TDEL)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %Q9 = getelementptr inbounds %TON_interface, %TON_interface* %TDEL, i32 0, i32 2
  %load_ = load i8, i8* %Q9, align 1
  store i8 %load_, i8* %W, align 1
  ret void

32:                                               ; preds = %40
  %load_in26 = load i8, i8* %IN2, align 1
  %33 = zext i8 %load_in26 to i32
  %load_in37 = load i8, i8* %IN3, align 1
  %34 = zext i8 %load_in37 to i32
  %tmpVar8 = xor i32 %33, %34
  br label %35

35:                                               ; preds = %32, %40
  %36 = phi i32 [ %41, %40 ], [ %tmpVar8, %32 ]
  store i32 %36, i8* %27, align 4

37:                                               ; preds = %input
  %load_in14 = load i8, i8* %IN1, align 1
  %38 = zext i8 %load_in14 to i32
  %load_in3 = load i8, i8* %IN3, align 1
  %39 = zext i8 %load_in3 to i32
  %tmpVar5 = xor i32 %38, %39
  br label %40

40:                                               ; preds = %37, %input
  %41 = phi i32 [ %tmpVar, %input ], [ %tmpVar5, %37 ]
  %42 = icmp ne i32 %41, 0
  br i1 %42, label %35, label %32
}

define void @SH(%SH_interface* %0) {
entry:
  %in = getelementptr inbounds %SH_interface, %SH_interface* %0, i32 0, i32 0
  %CLK = getelementptr inbounds %SH_interface, %SH_interface* %0, i32 0, i32 1
  %out = getelementptr inbounds %SH_interface, %SH_interface* %0, i32 0, i32 2
  %trig = getelementptr inbounds %SH_interface, %SH_interface* %0, i32 0, i32 3
  %edge = getelementptr inbounds %SH_interface, %SH_interface* %0, i32 0, i32 4
  %load_clk = load i8, i8* %CLK, align 1
  %1 = zext i8 %load_clk to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %3, label %5

condition_body:                                   ; preds = %5
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %out, align 4
  store i8 1, i8* %trig, align 1
  br label %continue

else:                                             ; preds = %5
  store i8 0, i8* %trig, align 1
  br label %continue

continue:                                         ; preds = %else, %condition_body
  %load_clk1 = load i8, i8* %CLK, align 1
  store i8 %load_clk1, i8* %edge, align 1
  ret void

3:                                                ; preds = %entry
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar = xor i8 %load_edge, -1
  %4 = zext i8 %tmpVar to i32
  br label %5

5:                                                ; preds = %3, %entry
  %6 = phi i32 [ %1, %entry ], [ %4, %3 ]
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %condition_body, label %else
}

define void @SH_1(%SH_1_interface* %0) {
entry:
  %in = getelementptr inbounds %SH_1_interface, %SH_1_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %SH_1_interface, %SH_1_interface* %0, i32 0, i32 1
  %out = getelementptr inbounds %SH_1_interface, %SH_1_interface* %0, i32 0, i32 2
  %Trig = getelementptr inbounds %SH_1_interface, %SH_1_interface* %0, i32 0, i32 3
  %last = getelementptr inbounds %SH_1_interface, %SH_1_interface* %0, i32 0, i32 4
  %tx = getelementptr inbounds %SH_1_interface, %SH_1_interface* %0, i32 0, i32 5
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_tx = load i64, i64* %tx, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar = sub i64 %load_tx, %load_last
  %load_PT = load i64, i64* %PT, align 4
  %tmpVar8 = icmp sge i64 %tmpVar, %load_PT
  br i1 %tmpVar8, label %condition_body, label %else

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  %load_tx9 = load i64, i64* %tx, align 4
  store i64 %load_tx9, i64* %last, align 4
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %out, align 4
  store i8 1, i8* %Trig, align 1
  br label %continue7

else:                                             ; preds = %continue
  store i8 0, i8* %Trig, align 1
  br label %continue7

continue7:                                        ; preds = %else, %condition_body
  ret void
}

define void @SH_2(%SH_2_interface* %0) {
entry:
  %in = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 1
  %N = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 2
  %disc = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 3
  %out = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 4
  %trig = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 5
  %avg = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 6
  %high = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 7
  %low = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 8
  %M = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 9
  %buf = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 10
  %buf2 = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 11
  %last = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 12
  %i = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 13
  %start = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 14
  %temp = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 15
  %stop = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 16
  %tx = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 17
  %d2 = getelementptr inbounds %SH_2_interface, %SH_2_interface* %0, i32 0, i32 18
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

input7:                                           ; preds = %continue
  %2 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_disc = load i16, i16* %disc, align 2
  %3 = sext i16 %load_disc to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 1, i16* %4, align 2
  br label %call8

call8:                                            ; preds = %input7
  %call11 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %5 = trunc i64 %call11 to i16
  store i16 %5, i16* %d2, align 2
  %load_tx = load i64, i64* %tx, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar = sub i64 %load_tx, %load_last
  %load_PT = load i64, i64* %PT, align 4
  %tmpVar13 = icmp sge i64 %tmpVar, %load_PT
  br i1 %tmpVar13, label %condition_body, label %else

condition_body:                                   ; preds = %continue10
  %load_tx14 = load i64, i64* %tx, align 4
  store i64 %load_tx14, i64* %last, align 4
  store i8 1, i8* %trig, align 1
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input15

else:                                             ; preds = %continue10
  store i8 0, i8* %trig, align 1
  br label %continue12

continue12:                                       ; preds = %else, %continue161
  ret void

input15:                                          ; preds = %condition_body
  %6 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 1, i64* %6, align 4
  %7 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %8 = sext i16 %load_N to i64
  store i64 %8, i64* %7, align 4
  %9 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 16, i64* %9, align 4
  br label %call16

call16:                                           ; preds = %input15
  %call19 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %10 = trunc i64 %call19 to i16
  store i16 %10, i16* %M, align 2
  %load_M = load i16, i16* %M, align 2
  %11 = sext i16 %load_M to i32
  %tmpVar20 = sub i32 %11, 1
  %12 = trunc i32 %tmpVar20 to i16
  store i16 %12, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue18
  %load_i = load i16, i16* %i, align 2
  %load_i22 = load i16, i16* %i, align 2
  %tmpVar23 = icmp sle i16 %load_i22, 1
  %13 = icmp ne i1 %tmpVar23, false
  br i1 %13, label %20, label %23

for_body:                                         ; preds = %18
  %load_i34 = load i16, i16* %i, align 2
  %14 = sext i16 %load_i34 to i32
  %tmpVar35 = mul i32 1, %14
  %tmpVar36 = add i32 %tmpVar35, 0
  %tmpVar37 = getelementptr inbounds [16 x float], [16 x float]* %buf2, i32 0, i32 %tmpVar36
  %load_i38 = load i16, i16* %i, align 2
  %15 = sext i16 %load_i38 to i32
  %tmpVar39 = sub i32 %15, 1
  %tmpVar40 = mul i32 1, %tmpVar39
  %tmpVar41 = add i32 %tmpVar40, 0
  %tmpVar42 = getelementptr inbounds [16 x float], [16 x float]* %buf2, i32 0, i32 %tmpVar41
  %load_tmpVar = load float, float* %tmpVar42, align 4
  store float %load_tmpVar, float* %tmpVar37, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar43 = add i16 %load_i, -1
  store i16 %tmpVar43, i16* %i, align 2
  br label %condition_check

continue21:                                       ; preds = %18
  %tmpVar44 = getelementptr inbounds [16 x float], [16 x float]* %buf2, i32 0, i32 0
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %tmpVar44, align 4
  %load_in45 = load float, float* %in, align 4
  store float %load_in45, float* %out, align 4
  %load_buf2 = load [16 x float], [16 x float]* %buf2, align 4
  store [16 x float] %load_buf2, [16 x float]* %buf, align 4
  store i16 0, i16* %start, align 2
  br label %condition_check46

16:                                               ; preds = %23
  %load_i28 = load i16, i16* %i, align 2
  %tmpVar29 = icmp sge i16 %load_i28, 1
  %17 = icmp ne i1 %tmpVar29, false
  br i1 %17, label %26, label %29

18:                                               ; preds = %29, %23
  %19 = phi i1 [ %24, %23 ], [ %30, %29 ]
  br i1 %19, label %for_body, label %continue21

20:                                               ; preds = %condition_check
  %load_i24 = load i16, i16* %i, align 2
  %load_M25 = load i16, i16* %M, align 2
  %21 = sext i16 %load_M25 to i32
  %tmpVar26 = sub i32 %21, 1
  %22 = trunc i32 %tmpVar26 to i16
  %tmpVar27 = icmp sge i16 %load_i24, %22
  br label %23

23:                                               ; preds = %20, %condition_check
  %24 = phi i1 [ %tmpVar23, %condition_check ], [ %tmpVar27, %20 ]
  %25 = icmp ne i1 %24, false
  br i1 %25, label %18, label %16

26:                                               ; preds = %16
  %load_i30 = load i16, i16* %i, align 2
  %load_M31 = load i16, i16* %M, align 2
  %27 = sext i16 %load_M31 to i32
  %tmpVar32 = sub i32 %27, 1
  %28 = trunc i32 %tmpVar32 to i16
  %tmpVar33 = icmp sle i16 %load_i30, %28
  br label %29

29:                                               ; preds = %26, %16
  %30 = phi i1 [ %tmpVar29, %16 ], [ %tmpVar33, %26 ]
  br label %18

condition_check46:                                ; preds = %increment48, %continue21
  %load_start = load i16, i16* %start, align 2
  %load_start50 = load i16, i16* %start, align 2
  %load_M51 = load i16, i16* %M, align 2
  %31 = sext i16 %load_M51 to i32
  %tmpVar52 = sub i32 %31, 2
  %32 = trunc i32 %tmpVar52 to i16
  %tmpVar53 = icmp sle i16 %load_start50, %32
  %33 = icmp ne i1 %tmpVar53, false
  br i1 %33, label %45, label %46

for_body47:                                       ; preds = %43
  %load_start62 = load i16, i16* %start, align 2
  %34 = sext i16 %load_start62 to i32
  %tmpVar63 = add i32 %34, 1
  %35 = trunc i32 %tmpVar63 to i16
  store i16 %35, i16* %i, align 2
  br label %condition_check64

increment48:                                      ; preds = %continue67
  %tmpVar117 = add i16 %load_start, 1
  store i16 %tmpVar117, i16* %start, align 2
  br label %condition_check46

continue49:                                       ; preds = %43
  %load_M118 = load i16, i16* %M, align 2
  %36 = sext i16 %load_M118 to i32
  %tmpVar119 = sub i32 %36, 1
  %load_d2 = load i16, i16* %d2, align 2
  %37 = sext i16 %load_d2 to i32
  %tmpVar120 = sub i32 %tmpVar119, %37
  %38 = trunc i32 %tmpVar120 to i16
  store i16 %38, i16* %stop, align 2
  %load_d2121 = load i16, i16* %d2, align 2
  store i16 %load_d2121, i16* %start, align 2
  %EVEN_instance = alloca %EVEN_interface, align 8
  br label %input124

39:                                               ; preds = %46
  %load_start56 = load i16, i16* %start, align 2
  %load_M57 = load i16, i16* %M, align 2
  %40 = sext i16 %load_M57 to i32
  %tmpVar58 = sub i32 %40, 2
  %41 = trunc i32 %tmpVar58 to i16
  %tmpVar59 = icmp sge i16 %load_start56, %41
  %42 = icmp ne i1 %tmpVar59, false
  br i1 %42, label %49, label %50

43:                                               ; preds = %50, %46
  %44 = phi i1 [ %47, %46 ], [ %51, %50 ]
  br i1 %44, label %for_body47, label %continue49

45:                                               ; preds = %condition_check46
  %load_start54 = load i16, i16* %start, align 2
  %tmpVar55 = icmp sge i16 %load_start54, 0
  br label %46

46:                                               ; preds = %45, %condition_check46
  %47 = phi i1 [ %tmpVar53, %condition_check46 ], [ %tmpVar55, %45 ]
  %48 = icmp ne i1 %47, false
  br i1 %48, label %43, label %39

49:                                               ; preds = %39
  %load_start60 = load i16, i16* %start, align 2
  %tmpVar61 = icmp sle i16 %load_start60, 0
  br label %50

50:                                               ; preds = %49, %39
  %51 = phi i1 [ %tmpVar59, %39 ], [ %tmpVar61, %49 ]
  br label %43

condition_check64:                                ; preds = %increment66, %for_body47
  %load_i68 = load i16, i16* %i, align 2
  %load_i69 = load i16, i16* %i, align 2
  %load_M70 = load i16, i16* %M, align 2
  %52 = sext i16 %load_M70 to i32
  %tmpVar71 = sub i32 %52, 1
  %53 = trunc i32 %tmpVar71 to i16
  %tmpVar72 = icmp sle i16 %load_i69, %53
  %54 = icmp ne i1 %tmpVar72, false
  br i1 %54, label %63, label %66

for_body65:                                       ; preds = %61
  %load_start87 = load i16, i16* %start, align 2
  %55 = sext i16 %load_start87 to i32
  %tmpVar88 = mul i32 1, %55
  %tmpVar89 = add i32 %tmpVar88, 0
  %tmpVar90 = getelementptr inbounds [16 x float], [16 x float]* %buf, i32 0, i32 %tmpVar89
  %load_tmpVar91 = load float, float* %tmpVar90, align 4
  %load_i92 = load i16, i16* %i, align 2
  %56 = sext i16 %load_i92 to i32
  %tmpVar93 = mul i32 1, %56
  %tmpVar94 = add i32 %tmpVar93, 0
  %tmpVar95 = getelementptr inbounds [16 x float], [16 x float]* %buf, i32 0, i32 %tmpVar94
  %load_tmpVar96 = load float, float* %tmpVar95, align 4
  %tmpVar97 = fcmp ogt float %load_tmpVar91, %load_tmpVar96
  br i1 %tmpVar97, label %condition_body86, label %continue85

increment66:                                      ; preds = %continue85
  %tmpVar116 = add i16 %load_i68, 1
  store i16 %tmpVar116, i16* %i, align 2
  br label %condition_check64

continue67:                                       ; preds = %61
  br label %increment48

57:                                               ; preds = %66
  %load_i77 = load i16, i16* %i, align 2
  %load_M78 = load i16, i16* %M, align 2
  %58 = sext i16 %load_M78 to i32
  %tmpVar79 = sub i32 %58, 1
  %59 = trunc i32 %tmpVar79 to i16
  %tmpVar80 = icmp sge i16 %load_i77, %59
  %60 = icmp ne i1 %tmpVar80, false
  br i1 %60, label %69, label %72

61:                                               ; preds = %72, %66
  %62 = phi i1 [ %67, %66 ], [ %73, %72 ]
  br i1 %62, label %for_body65, label %continue67

63:                                               ; preds = %condition_check64
  %load_i73 = load i16, i16* %i, align 2
  %load_start74 = load i16, i16* %start, align 2
  %64 = sext i16 %load_start74 to i32
  %tmpVar75 = add i32 %64, 1
  %65 = trunc i32 %tmpVar75 to i16
  %tmpVar76 = icmp sge i16 %load_i73, %65
  br label %66

66:                                               ; preds = %63, %condition_check64
  %67 = phi i1 [ %tmpVar72, %condition_check64 ], [ %tmpVar76, %63 ]
  %68 = icmp ne i1 %67, false
  br i1 %68, label %61, label %57

69:                                               ; preds = %57
  %load_i81 = load i16, i16* %i, align 2
  %load_start82 = load i16, i16* %start, align 2
  %70 = sext i16 %load_start82 to i32
  %tmpVar83 = add i32 %70, 1
  %71 = trunc i32 %tmpVar83 to i16
  %tmpVar84 = icmp sle i16 %load_i81, %71
  br label %72

72:                                               ; preds = %69, %57
  %73 = phi i1 [ %tmpVar80, %57 ], [ %tmpVar84, %69 ]
  br label %61

condition_body86:                                 ; preds = %for_body65
  %load_start98 = load i16, i16* %start, align 2
  %74 = sext i16 %load_start98 to i32
  %tmpVar99 = mul i32 1, %74
  %tmpVar100 = add i32 %tmpVar99, 0
  %tmpVar101 = getelementptr inbounds [16 x float], [16 x float]* %buf, i32 0, i32 %tmpVar100
  %load_tmpVar102 = load float, float* %tmpVar101, align 4
  store float %load_tmpVar102, float* %temp, align 4
  %load_start103 = load i16, i16* %start, align 2
  %75 = sext i16 %load_start103 to i32
  %tmpVar104 = mul i32 1, %75
  %tmpVar105 = add i32 %tmpVar104, 0
  %tmpVar106 = getelementptr inbounds [16 x float], [16 x float]* %buf, i32 0, i32 %tmpVar105
  %load_i107 = load i16, i16* %i, align 2
  %76 = sext i16 %load_i107 to i32
  %tmpVar108 = mul i32 1, %76
  %tmpVar109 = add i32 %tmpVar108, 0
  %tmpVar110 = getelementptr inbounds [16 x float], [16 x float]* %buf, i32 0, i32 %tmpVar109
  %load_tmpVar111 = load float, float* %tmpVar110, align 4
  store float %load_tmpVar111, float* %tmpVar106, align 4
  %load_i112 = load i16, i16* %i, align 2
  %77 = sext i16 %load_i112 to i32
  %tmpVar113 = mul i32 1, %77
  %tmpVar114 = add i32 %tmpVar113, 0
  %tmpVar115 = getelementptr inbounds [16 x float], [16 x float]* %buf, i32 0, i32 %tmpVar114
  %load_temp = load float, float* %temp, align 4
  store float %load_temp, float* %tmpVar115, align 4
  br label %continue85

continue85:                                       ; preds = %condition_body86, %for_body65
  br label %increment66

condition_body123:                                ; preds = %continue127
  %load_start131 = load i16, i16* %start, align 2
  %78 = sext i16 %load_start131 to i32
  %tmpVar132 = add i32 %78, 1
  %79 = trunc i32 %tmpVar132 to i16
  store i16 %79, i16* %start, align 2
  br label %continue122

continue122:                                      ; preds = %condition_body123, %continue127
  store float 0.000000e+00, float* %avg, align 4
  %load_start133 = load i16, i16* %start, align 2
  store i16 %load_start133, i16* %i, align 2
  br label %condition_check134

input124:                                         ; preds = %continue49
  %80 = getelementptr inbounds %EVEN_interface, %EVEN_interface* %EVEN_instance, i32 0, i32 0
  %load_disc128 = load i16, i16* %disc, align 2
  %81 = sext i16 %load_disc128 to i32
  store i32 %81, i32* %80, align 4
  br label %call125

call125:                                          ; preds = %input124
  %call129 = call i8 @EVEN(%EVEN_interface* %EVEN_instance)
  br label %output126

output126:                                        ; preds = %call125
  br label %continue127

continue127:                                      ; preds = %output126
  %tmpVar130 = xor i8 %call129, -1
  %82 = icmp ne i8 %tmpVar130, 0
  br i1 %82, label %condition_body123, label %continue122

condition_check134:                               ; preds = %increment136, %continue122
  %load_i138 = load i16, i16* %i, align 2
  %load_i139 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar140 = icmp sle i16 %load_i139, %load_stop
  %83 = icmp ne i1 %tmpVar140, false
  br i1 %83, label %89, label %90

for_body135:                                      ; preds = %87
  %load_avg = load float, float* %avg, align 4
  %load_i150 = load i16, i16* %i, align 2
  %84 = sext i16 %load_i150 to i32
  %tmpVar151 = mul i32 1, %84
  %tmpVar152 = add i32 %tmpVar151, 0
  %tmpVar153 = getelementptr inbounds [16 x float], [16 x float]* %buf, i32 0, i32 %tmpVar152
  %load_tmpVar154 = load float, float* %tmpVar153, align 4
  %tmpVar155 = fadd float %load_avg, %load_tmpVar154
  store float %tmpVar155, float* %avg, align 4
  br label %increment136

increment136:                                     ; preds = %for_body135
  %tmpVar156 = add i16 %load_i138, 1
  store i16 %tmpVar156, i16* %i, align 2
  br label %condition_check134

continue137:                                      ; preds = %87
  %load_avg157 = load float, float* %avg, align 4
  %INT_TO_REAL_instance = alloca %INT_TO_REAL_interface, align 8
  br label %input158

85:                                               ; preds = %90
  %load_i144 = load i16, i16* %i, align 2
  %load_stop145 = load i16, i16* %stop, align 2
  %tmpVar146 = icmp sge i16 %load_i144, %load_stop145
  %86 = icmp ne i1 %tmpVar146, false
  br i1 %86, label %93, label %94

87:                                               ; preds = %94, %90
  %88 = phi i1 [ %91, %90 ], [ %95, %94 ]
  br i1 %88, label %for_body135, label %continue137

89:                                               ; preds = %condition_check134
  %load_i141 = load i16, i16* %i, align 2
  %load_start142 = load i16, i16* %start, align 2
  %tmpVar143 = icmp sge i16 %load_i141, %load_start142
  br label %90

90:                                               ; preds = %89, %condition_check134
  %91 = phi i1 [ %tmpVar140, %condition_check134 ], [ %tmpVar143, %89 ]
  %92 = icmp ne i1 %91, false
  br i1 %92, label %87, label %85

93:                                               ; preds = %85
  %load_i147 = load i16, i16* %i, align 2
  %load_start148 = load i16, i16* %start, align 2
  %tmpVar149 = icmp sle i16 %load_i147, %load_start148
  br label %94

94:                                               ; preds = %93, %85
  %95 = phi i1 [ %tmpVar146, %85 ], [ %tmpVar149, %93 ]
  br label %87

input158:                                         ; preds = %continue137
  %96 = getelementptr inbounds %INT_TO_REAL_interface, %INT_TO_REAL_interface* %INT_TO_REAL_instance, i32 0, i32 0
  %load_stop162 = load i16, i16* %stop, align 2
  %97 = sext i16 %load_stop162 to i32
  %load_start163 = load i16, i16* %start, align 2
  %98 = sext i16 %load_start163 to i32
  %tmpVar164 = sub i32 %97, %98
  %tmpVar165 = add i32 %tmpVar164, 1
  %99 = trunc i32 %tmpVar165 to i16
  store i16 %99, i16* %96, align 2
  br label %call159

call159:                                          ; preds = %input158
  %call166 = call float @INT_TO_REAL(%INT_TO_REAL_interface* %INT_TO_REAL_instance)
  br label %output160

output160:                                        ; preds = %call159
  br label %continue161

continue161:                                      ; preds = %output160
  %tmpVar167 = fdiv float %load_avg157, %call166
  store float %tmpVar167, float* %avg, align 4
  %load_start168 = load i16, i16* %start, align 2
  %100 = sext i16 %load_start168 to i32
  %tmpVar169 = mul i32 1, %100
  %tmpVar170 = add i32 %tmpVar169, 0
  %tmpVar171 = getelementptr inbounds [16 x float], [16 x float]* %buf, i32 0, i32 %tmpVar170
  %load_tmpVar172 = load float, float* %tmpVar171, align 4
  store float %load_tmpVar172, float* %low, align 4
  %load_stop173 = load i16, i16* %stop, align 2
  %101 = sext i16 %load_stop173 to i32
  %tmpVar174 = mul i32 1, %101
  %tmpVar175 = add i32 %tmpVar174, 0
  %tmpVar176 = getelementptr inbounds [16 x float], [16 x float]* %buf, i32 0, i32 %tmpVar175
  %load_tmpVar177 = load float, float* %tmpVar176, align 4
  store float %load_tmpVar177, float* %high, align 4
  br label %continue12
}

define void @SH_T(%SH_T_interface* %0) {
entry:
  %IN = getelementptr inbounds %SH_T_interface, %SH_T_interface* %0, i32 0, i32 0
  %E = getelementptr inbounds %SH_T_interface, %SH_T_interface* %0, i32 0, i32 1
  %OUT = getelementptr inbounds %SH_T_interface, %SH_T_interface* %0, i32 0, i32 2
  %load_E = load i8, i8* %E, align 1
  %1 = icmp ne i8 %load_E, 0
  br i1 %1, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %load_in = load float, float* %IN, align 4
  store float %load_in, float* %OUT, align 4
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  ret void
}

define float @STAIR(%STAIR_interface* %0) {
entry:
  %X = getelementptr inbounds %STAIR_interface, %STAIR_interface* %0, i32 0, i32 0
  %D = getelementptr inbounds %STAIR_interface, %STAIR_interface* %0, i32 0, i32 1
  %STAIR = alloca float, align 4
  store float 0.000000e+00, float* %STAIR, align 4
  %load_D = load float, float* %D, align 4
  %tmpVar = fcmp ogt float %load_D, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %DINT_TO_REAL_instance = alloca %DINT_TO_REAL_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %load_X12 = load float, float* %X, align 4
  store float %load_X12, float* %STAIR, align 4
  br label %continue

continue:                                         ; preds = %else, %continue1
  %STAIR_ret = load float, float* %STAIR, align 4
  ret float %STAIR_ret

input:                                            ; preds = %condition_body
  %1 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance, i32 0, i32 0
  %REAL_TO_DINT_instance = alloca %REAL_TO_DINT_interface, align 8
  br label %input2

call:                                             ; preds = %continue5
  %call9 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %load_D10 = load float, float* %D, align 4
  %tmpVar11 = fmul float %call9, %load_D10
  store float %tmpVar11, float* %STAIR, align 4
  br label %continue

input2:                                           ; preds = %input
  %2 = getelementptr inbounds %REAL_TO_DINT_interface, %REAL_TO_DINT_interface* %REAL_TO_DINT_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  %load_D6 = load float, float* %D, align 4
  %tmpVar7 = fdiv float %load_X, %load_D6
  store float %tmpVar7, float* %2, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call8 = call i32 @REAL_TO_DINT(%REAL_TO_DINT_interface* %REAL_TO_DINT_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i32 %call8, i32* %1, align 4
  br label %call
}

define void @STAIR2(%STAIR2_interface* %0) {
entry:
  %X = getelementptr inbounds %STAIR2_interface, %STAIR2_interface* %0, i32 0, i32 0
  %D = getelementptr inbounds %STAIR2_interface, %STAIR2_interface* %0, i32 0, i32 1
  %Y = getelementptr inbounds %STAIR2_interface, %STAIR2_interface* %0, i32 0, i32 2
  %load_D = load float, float* %D, align 4
  %tmpVar = fcmp ogt float %load_D, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_X = load float, float* %X, align 4
  %load_Y = load float, float* %Y, align 4
  %load_D3 = load float, float* %D, align 4
  %tmpVar4 = fadd float %load_Y, %load_D3
  %tmpVar5 = fcmp oge float %load_X, %tmpVar4
  %1 = zext i1 %tmpVar5 to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %5, label %3

else:                                             ; preds = %entry
  %load_X18 = load float, float* %X, align 4
  store float %load_X18, float* %Y, align 4
  br label %continue

continue:                                         ; preds = %else, %continue1
  ret void

condition_body2:                                  ; preds = %5
  %FLOOR_instance = alloca %FLOOR_interface, align 8
  br label %input

continue1:                                        ; preds = %continue11, %5
  br label %continue

3:                                                ; preds = %condition_body
  %load_X6 = load float, float* %X, align 4
  %load_Y7 = load float, float* %Y, align 4
  %load_D8 = load float, float* %D, align 4
  %tmpVar9 = fsub float %load_Y7, %load_D8
  %tmpVar10 = fcmp ole float %load_X6, %tmpVar9
  %4 = zext i1 %tmpVar10 to i32
  br label %5

5:                                                ; preds = %3, %condition_body
  %6 = phi i32 [ %1, %condition_body ], [ %4, %3 ]
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %condition_body2, label %continue1

input:                                            ; preds = %condition_body2
  %8 = getelementptr inbounds %FLOOR_interface, %FLOOR_interface* %FLOOR_instance, i32 0, i32 0
  %load_X12 = load float, float* %X, align 4
  %load_D13 = load float, float* %D, align 4
  %tmpVar14 = fdiv float %load_X12, %load_D13
  store float %tmpVar14, float* %8, align 4
  br label %call

call:                                             ; preds = %input
  %call15 = call i16 @FLOOR(%FLOOR_interface* %FLOOR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue11

continue11:                                       ; preds = %output
  %9 = sitofp i16 %call15 to float
  %load_D16 = load float, float* %D, align 4
  %tmpVar17 = fmul float %9, %load_D16
  store float %tmpVar17, float* %Y, align 4
  br label %continue1
}

define void @TREND(%TREND_interface* %0) {
entry:
  %X = getelementptr inbounds %TREND_interface, %TREND_interface* %0, i32 0, i32 0
  %Q = getelementptr inbounds %TREND_interface, %TREND_interface* %0, i32 0, i32 1
  %TU = getelementptr inbounds %TREND_interface, %TREND_interface* %0, i32 0, i32 2
  %TD = getelementptr inbounds %TREND_interface, %TREND_interface* %0, i32 0, i32 3
  %D = getelementptr inbounds %TREND_interface, %TREND_interface* %0, i32 0, i32 4
  %last_X = getelementptr inbounds %TREND_interface, %TREND_interface* %0, i32 0, i32 5
  %load_X = load float, float* %X, align 4
  %load_last_X = load float, float* %last_X, align 4
  %tmpVar = fcmp ogt float %load_X, %load_last_X
  %1 = zext i1 %tmpVar to i8
  store i8 %1, i8* %TU, align 1
  %load_X1 = load float, float* %X, align 4
  %load_last_X2 = load float, float* %last_X, align 4
  %tmpVar3 = fcmp olt float %load_X1, %load_last_X2
  %2 = zext i1 %tmpVar3 to i8
  store i8 %2, i8* %TD, align 1
  %load_TU = load i8, i8* %TU, align 1
  %3 = zext i8 %load_TU to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %7, label %5

5:                                                ; preds = %entry
  %load_TD = load i8, i8* %TD, align 1
  %6 = zext i8 %load_TD to i32
  br label %7

7:                                                ; preds = %5, %entry
  %8 = phi i32 [ %3, %entry ], [ %6, %5 ]
  store i32 %8, i8* %Q, align 4
  %load_X4 = load float, float* %X, align 4
  %load_LAST_X = load float, float* %last_X, align 4
  %tmpVar5 = fsub float %load_X4, %load_LAST_X
  store float %tmpVar5, float* %D, align 4
  %load_X6 = load float, float* %X, align 4
  store float %load_X6, float* %last_X, align 4
  ret void
}

define void @TREND_DW(%TREND_DW_interface* %0) {
entry:
  %X = getelementptr inbounds %TREND_DW_interface, %TREND_DW_interface* %0, i32 0, i32 0
  %Q = getelementptr inbounds %TREND_DW_interface, %TREND_DW_interface* %0, i32 0, i32 1
  %TU = getelementptr inbounds %TREND_DW_interface, %TREND_DW_interface* %0, i32 0, i32 2
  %TD = getelementptr inbounds %TREND_DW_interface, %TREND_DW_interface* %0, i32 0, i32 3
  %D = getelementptr inbounds %TREND_DW_interface, %TREND_DW_interface* %0, i32 0, i32 4
  %last_X = getelementptr inbounds %TREND_DW_interface, %TREND_DW_interface* %0, i32 0, i32 5
  %load_X = load i32, i32* %X, align 4
  %load_last_X = load i32, i32* %last_X, align 4
  %tmpVar = icmp sgt i32 %load_X, %load_last_X
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 1, i8* %TU, align 1
  store i8 0, i8* %TD, align 1
  %load_X1 = load i32, i32* %X, align 4
  %load_last_X2 = load i32, i32* %last_X, align 4
  %tmpVar3 = sub i32 %load_X1, %load_last_X2
  store i32 %tmpVar3, i32* %D, align 4
  store i8 1, i8* %Q, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_X5 = load i32, i32* %X, align 4
  %load_last_X6 = load i32, i32* %last_X, align 4
  %tmpVar7 = icmp slt i32 %load_X5, %load_last_X6
  br i1 %tmpVar7, label %condition_body4, label %else

condition_body4:                                  ; preds = %branch
  store i8 1, i8* %TD, align 1
  store i8 0, i8* %TU, align 1
  %load_last_X8 = load i32, i32* %last_X, align 4
  %load_X9 = load i32, i32* %X, align 4
  %tmpVar10 = sub i32 %load_last_X8, %load_X9
  store i32 %tmpVar10, i32* %D, align 4
  store i8 0, i8* %Q, align 1
  br label %continue

else:                                             ; preds = %branch
  store i8 0, i8* %TU, align 1
  store i8 0, i8* %TD, align 1
  store i32 0, i32* %D, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body4, %condition_body
  %load_X11 = load i32, i32* %X, align 4
  store i32 %load_X11, i32* %last_X, align 4
  ret void
}

define float @WORD_TO_RANGE(%WORD_TO_RANGE_interface* %0) {
entry:
  %X = getelementptr inbounds %WORD_TO_RANGE_interface, %WORD_TO_RANGE_interface* %0, i32 0, i32 0
  %low = getelementptr inbounds %WORD_TO_RANGE_interface, %WORD_TO_RANGE_interface* %0, i32 0, i32 1
  %high = getelementptr inbounds %WORD_TO_RANGE_interface, %WORD_TO_RANGE_interface* %0, i32 0, i32 2
  %WORD_TO_RANGE = alloca float, align 4
  store float 0.000000e+00, float* %WORD_TO_RANGE, align 4
  %load_high = load float, float* %high, align 4
  %load_low = load float, float* %low, align 4
  %tmpVar = fsub float %load_high, %load_low
  %WORD_TO_REAL_instance = alloca %WORD_TO_REAL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %WORD_TO_REAL_interface, %WORD_TO_REAL_interface* %WORD_TO_REAL_instance, i32 0, i32 0
  %load_X = load i16, i16* %X, align 2
  store i16 %load_X, i16* %1, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call float @WORD_TO_REAL(%WORD_TO_REAL_interface* %WORD_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar2 = fmul float %tmpVar, %call1
  %tmpVar3 = fmul float %tmpVar2, 0x3EF0001000000000
  %load_low4 = load float, float* %low, align 4
  %tmpVar5 = fadd float %tmpVar3, %load_low4
  store float %tmpVar5, float* %WORD_TO_RANGE, align 4
  %WORD_TO_RANGE_ret = load float, float* %WORD_TO_RANGE, align 4
  ret float %WORD_TO_RANGE_ret
}

define i8 @LIST_ADD(%LIST_ADD_interface* %0) {
entry:
  %SEP = getelementptr inbounds %LIST_ADD_interface, %LIST_ADD_interface* %0, i32 0, i32 0
  %INS = getelementptr inbounds %LIST_ADD_interface, %LIST_ADD_interface* %0, i32 0, i32 1
  %LIST = getelementptr inbounds %LIST_ADD_interface, %LIST_ADD_interface* %0, i32 0, i32 2
  %sx = getelementptr inbounds %LIST_ADD_interface, %LIST_ADD_interface* %0, i32 0, i32 3
  %LIST_ADD = alloca i8, align 1
  %1 = bitcast [2 x i8]* %sx to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 2), i1 false)
  store i8 0, i8* %LIST_ADD, align 1
  %CHR_TO_STRING_instance = alloca %CHR_TO_STRING_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %CHR_TO_STRING_interface, %CHR_TO_STRING_interface* %CHR_TO_STRING_instance, i32 0, i32 0
  %load_SEP = load i8, i8* %SEP, align 1
  store i8 %load_SEP, i8* %2, align 1
  br label %call

call:                                             ; preds = %input
  %call1 = call [2 x i8] @CHR_TO_STRING(%CHR_TO_STRING_interface* %CHR_TO_STRING_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = alloca [2 x i8], align 1
  store [2 x i8] %call1, [2 x i8]* %3, align 1
  %4 = bitcast [2 x i8]* %sx to i8*
  %5 = bitcast [2 x i8]* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %4, i8* align 1 %5, i32 1, i1 false)
  %CONCAT_instance = alloca %CONCAT_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %6 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 0
  %7 = bitcast [1024 x i8]* %6 to i8*
  %8 = bitcast [2 x i8]* %sx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %7, i8* align 1 %8, i32 2, i1 false)
  %9 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 1
  %10 = bitcast [1024 x i8]* %9 to i8*
  %11 = bitcast [251 x i8]* %INS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %10, i8* align 1 %11, i32 251, i1 false)
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %12 = alloca [1024 x i8], align 1
  store [1024 x i8] %call6, [1024 x i8]* %12, align 1
  %13 = bitcast [251 x i8]* %INS to i8*
  %14 = bitcast [1024 x i8]* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %13, i8* align 1 %14, i32 250, i1 false)
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input8

condition_body:                                   ; preds = %continue17
  store i8 0, i8* %LIST_ADD, align 1
  br label %continue7

else:                                             ; preds = %continue17
  %deref20 = load [251 x i8]*, [251 x i8]** %LIST, align 8
  %CONCAT_instance21 = alloca %CONCAT_interface, align 8
  br label %input22

continue7:                                        ; preds = %continue25, %condition_body
  %LIST_ADD_ret = load i8, i8* %LIST_ADD, align 1
  ret i8 %LIST_ADD_ret

input8:                                           ; preds = %continue5
  %15 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %deref = load [251 x i8]*, [251 x i8]** %LIST, align 8
  %16 = bitcast [1024 x i8]* %15 to i8*
  %17 = bitcast [251 x i8]* %deref to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %16, i8* align 1 %17, i32 251, i1 false)
  br label %call9

call9:                                            ; preds = %input8
  %call12 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %18 = sext i16 %call12 to i32
  %LEN_instance13 = alloca %LEN_interface, align 8
  br label %input14

input14:                                          ; preds = %continue11
  %19 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance13, i32 0, i32 0
  %20 = bitcast [1024 x i8]* %19 to i8*
  %21 = bitcast [251 x i8]* %INS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 251, i1 false)
  br label %call15

call15:                                           ; preds = %input14
  %call18 = call i16 @LEN(%LEN_interface* %LEN_instance13)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %22 = sext i16 %call18 to i32
  %tmpVar = add i32 %18, %22
  %load_LIST_LENGTH = load i16, i16* @LIST_LENGTH, align 2
  %23 = sext i16 %load_LIST_LENGTH to i32
  %tmpVar19 = icmp sgt i32 %tmpVar, %23
  br i1 %tmpVar19, label %condition_body, label %else

input22:                                          ; preds = %else
  %24 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance21, i32 0, i32 0
  %deref26 = load [251 x i8]*, [251 x i8]** %LIST, align 8
  %25 = bitcast [1024 x i8]* %24 to i8*
  %26 = bitcast [251 x i8]* %deref26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %25, i8* align 1 %26, i32 251, i1 false)
  %27 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance21, i32 0, i32 1
  %28 = bitcast [1024 x i8]* %27 to i8*
  %29 = bitcast [251 x i8]* %INS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %28, i8* align 1 %29, i32 251, i1 false)
  br label %call23

call23:                                           ; preds = %input22
  %call27 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance21)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %30 = alloca [1024 x i8], align 1
  store [1024 x i8] %call27, [1024 x i8]* %30, align 1
  %31 = bitcast [251 x i8]* %deref20 to i8*
  %32 = bitcast [1024 x i8]* %30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %31, i8* align 1 %32, i32 250, i1 false)
  store i8 1, i8* %LIST_ADD, align 1
  br label %continue7
}

define i8 @LIST_CLEAN(%LIST_CLEAN_interface* %0) {
entry:
  %SEP = getelementptr inbounds %LIST_CLEAN_interface, %LIST_CLEAN_interface* %0, i32 0, i32 0
  %LIST = getelementptr inbounds %LIST_CLEAN_interface, %LIST_CLEAN_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %LIST_CLEAN_interface, %LIST_CLEAN_interface* %0, i32 0, i32 2
  %read = getelementptr inbounds %LIST_CLEAN_interface, %LIST_CLEAN_interface* %0, i32 0, i32 3
  %write = getelementptr inbounds %LIST_CLEAN_interface, %LIST_CLEAN_interface* %0, i32 0, i32 4
  %last = getelementptr inbounds %LIST_CLEAN_interface, %LIST_CLEAN_interface* %0, i32 0, i32 5
  %c = getelementptr inbounds %LIST_CLEAN_interface, %LIST_CLEAN_interface* %0, i32 0, i32 6
  %LIST_CLEAN = alloca i8, align 1
  store [250 x i8]* null, [250 x i8]** %pt, align 8
  store i16 1, i16* %read, align 2
  store i16 1, i16* %write, align 2
  store i8 0, i8* %last, align 1
  store i8 0, i8* %c, align 1
  store i8 0, i8* %LIST_CLEAN, align 1
  %deref = load [251 x i8]*, [251 x i8]** %LIST, align 8
  store [251 x i8]* %deref, [250 x i8]** %pt, align 8
  store i16 1, i16* %read, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %entry
  %load_read = load i16, i16* %read, align 2
  %load_read1 = load i16, i16* %read, align 2
  %load_LIST_LENGTH = load i16, i16* @LIST_LENGTH, align 2
  %tmpVar = icmp sle i16 %load_read1, %load_LIST_LENGTH
  %1 = icmp ne i1 %tmpVar, false
  br i1 %1, label %11, label %12

for_body:                                         ; preds = %9
  %deref9 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_read10 = load i16, i16* %read, align 2
  %2 = sub i16 %load_read10, 1
  %3 = sext i16 %2 to i32
  %tmpVar11 = mul i32 1, %3
  %tmpVar12 = add i32 %tmpVar11, 0
  %tmpVar13 = getelementptr inbounds [250 x i8], [250 x i8]* %deref9, i32 0, i32 %tmpVar12
  %load_tmpVar = load i8, i8* %tmpVar13, align 1
  store i8 %load_tmpVar, i8* %c, align 1
  %load_c = load i8, i8* %c, align 1
  %4 = zext i8 %load_c to i32
  %tmpVar15 = icmp eq i32 %4, 0
  br i1 %tmpVar15, label %condition_body, label %branch

increment:                                        ; preds = %continue14
  %tmpVar28 = add i16 %load_read, 1
  store i16 %tmpVar28, i16* %read, align 2
  br label %condition_check

continue:                                         ; preds = %condition_body, %9
  %load_last31 = load i8, i8* %last, align 1
  %5 = zext i8 %load_last31 to i32
  %load_SEP32 = load i8, i8* %SEP, align 1
  %6 = zext i8 %load_SEP32 to i32
  %tmpVar33 = icmp eq i32 %5, %6
  br i1 %tmpVar33, label %condition_body30, label %continue29

7:                                                ; preds = %12
  %load_read4 = load i16, i16* %read, align 2
  %load_LIST_LENGTH5 = load i16, i16* @LIST_LENGTH, align 2
  %tmpVar6 = icmp sge i16 %load_read4, %load_LIST_LENGTH5
  %8 = icmp ne i1 %tmpVar6, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue

11:                                               ; preds = %condition_check
  %load_read2 = load i16, i16* %read, align 2
  %tmpVar3 = icmp sge i16 %load_read2, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar3, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_read7 = load i16, i16* %read, align 2
  %tmpVar8 = icmp sle i16 %load_read7, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar6, %7 ], [ %tmpVar8, %15 ]
  br label %9

condition_body:                                   ; preds = %for_body
  br label %continue

buffer_block:                                     ; No predecessors!
  br label %continue14

branch:                                           ; preds = %for_body
  %load_c17 = load i8, i8* %c, align 1
  %18 = zext i8 %load_c17 to i32
  %load_SEP = load i8, i8* %SEP, align 1
  %19 = zext i8 %load_SEP to i32
  %tmpVar18 = icmp ne i32 %18, %19
  %20 = zext i1 %tmpVar18 to i32
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %30, label %26

condition_body16:                                 ; preds = %30
  %deref20 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_write = load i16, i16* %write, align 2
  %22 = sub i16 %load_write, 1
  %23 = sext i16 %22 to i32
  %tmpVar21 = mul i32 1, %23
  %tmpVar22 = add i32 %tmpVar21, 0
  %tmpVar23 = getelementptr inbounds [250 x i8], [250 x i8]* %deref20, i32 0, i32 %tmpVar22
  %load_c24 = load i8, i8* %c, align 1
  store i8 %load_c24, i8* %tmpVar23, align 1
  %load_write25 = load i16, i16* %write, align 2
  %24 = sext i16 %load_write25 to i32
  %tmpVar26 = add i32 %24, 1
  %25 = trunc i32 %tmpVar26 to i16
  store i16 %25, i16* %write, align 2
  br label %continue14

continue14:                                       ; preds = %condition_body16, %30, %buffer_block
  %load_c27 = load i8, i8* %c, align 1
  store i8 %load_c27, i8* %last, align 1
  br label %increment

26:                                               ; preds = %branch
  %load_sep = load i8, i8* %SEP, align 1
  %27 = zext i8 %load_sep to i32
  %load_last = load i8, i8* %last, align 1
  %28 = zext i8 %load_last to i32
  %tmpVar19 = icmp ne i32 %27, %28
  %29 = zext i1 %tmpVar19 to i32
  br label %30

30:                                               ; preds = %26, %branch
  %31 = phi i32 [ %20, %branch ], [ %29, %26 ]
  %32 = icmp ne i32 %31, 0
  br i1 %32, label %condition_body16, label %continue14

condition_body30:                                 ; preds = %continue
  %load_write34 = load i16, i16* %write, align 2
  %33 = sext i16 %load_write34 to i32
  %tmpVar35 = sub i32 %33, 1
  %34 = trunc i32 %tmpVar35 to i16
  store i16 %34, i16* %write, align 2
  br label %continue29

continue29:                                       ; preds = %condition_body30, %continue
  %load_write38 = load i16, i16* %write, align 2
  %35 = sext i16 %load_write38 to i32
  %load_STRING_LENGTH = load i16, i16* @STRING_LENGTH, align 2
  %36 = sext i16 %load_STRING_LENGTH to i32
  %tmpVar39 = icmp sle i32 %35, %36
  br i1 %tmpVar39, label %condition_body37, label %continue36

condition_body37:                                 ; preds = %continue29
  %deref40 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_write41 = load i16, i16* %write, align 2
  %37 = sub i16 %load_write41, 1
  %38 = sext i16 %37 to i32
  %tmpVar42 = mul i32 1, %38
  %tmpVar43 = add i32 %tmpVar42, 0
  %tmpVar44 = getelementptr inbounds [250 x i8], [250 x i8]* %deref40, i32 0, i32 %tmpVar43
  store i8 0, i8* %tmpVar44, align 1
  br label %continue36

continue36:                                       ; preds = %condition_body37, %continue29
  store i8 1, i8* %LIST_CLEAN, align 1
  %LIST_CLEAN_ret = load i8, i8* %LIST_CLEAN, align 1
  ret i8 %LIST_CLEAN_ret
}

define [251 x i8] @LIST_GET(%LIST_GET_interface* %0) {
entry:
  %SEP = getelementptr inbounds %LIST_GET_interface, %LIST_GET_interface* %0, i32 0, i32 0
  %POS = getelementptr inbounds %LIST_GET_interface, %LIST_GET_interface* %0, i32 0, i32 1
  %LIST = getelementptr inbounds %LIST_GET_interface, %LIST_GET_interface* %0, i32 0, i32 2
  %i = getelementptr inbounds %LIST_GET_interface, %LIST_GET_interface* %0, i32 0, i32 3
  %o = getelementptr inbounds %LIST_GET_interface, %LIST_GET_interface* %0, i32 0, i32 4
  %pt = getelementptr inbounds %LIST_GET_interface, %LIST_GET_interface* %0, i32 0, i32 5
  %po = getelementptr inbounds %LIST_GET_interface, %LIST_GET_interface* %0, i32 0, i32 6
  %cnt = getelementptr inbounds %LIST_GET_interface, %LIST_GET_interface* %0, i32 0, i32 7
  %c = getelementptr inbounds %LIST_GET_interface, %LIST_GET_interface* %0, i32 0, i32 8
  %LIST_GET = alloca [251 x i8], align 1
  store i16 1, i16* %i, align 2
  store i16 1, i16* %o, align 2
  store [250 x i8]* null, [250 x i8]** %pt, align 8
  store [250 x i8]* null, [250 x i8]** %po, align 8
  store i16 0, i16* %cnt, align 2
  store i8 0, i8* %c, align 1
  %1 = bitcast [251 x i8]* %LIST_GET to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %deref = load [251 x i8]*, [251 x i8]** %LIST, align 8
  store [251 x i8]* %deref, [250 x i8]** %pt, align 8
  store [251 x i8]* %LIST_GET, [250 x i8]** %po, align 8
  br label %while_body

condition_check:                                  ; preds = %continue7
  %load_i = load i16, i16* %i, align 2
  %2 = sext i16 %load_i to i32
  %load_LIST_LENGTH = load i16, i16* @LIST_LENGTH, align 2
  %3 = sext i16 %load_LIST_LENGTH to i32
  %tmpVar = icmp eq i32 %2, %3
  %4 = zext i1 %tmpVar to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %15, label %12

while_body:                                       ; preds = %entry, %15
  %deref2 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_i3 = load i16, i16* %i, align 2
  %6 = sub i16 %load_i3, 1
  %7 = sext i16 %6 to i32
  %tmpVar4 = mul i32 1, %7
  %tmpVar5 = add i32 %tmpVar4, 0
  %tmpVar6 = getelementptr inbounds [250 x i8], [250 x i8]* %deref2, i32 0, i32 %tmpVar5
  %load_tmpVar = load i8, i8* %tmpVar6, align 1
  store i8 %load_tmpVar, i8* %c, align 1
  %load_cnt = load i16, i16* %cnt, align 2
  %8 = sext i16 %load_cnt to i32
  %load_pos = load i16, i16* %POS, align 2
  %9 = sext i16 %load_pos to i32
  %tmpVar8 = icmp eq i32 %8, %9
  br i1 %tmpVar8, label %condition_body, label %branch

continue:                                         ; preds = %condition_body10, %15
  %deref28 = load [250 x i8]*, [250 x i8]** %po, align 8
  %load_o29 = load i16, i16* %o, align 2
  %10 = sub i16 %load_o29, 1
  %11 = sext i16 %10 to i32
  %tmpVar30 = mul i32 1, %11
  %tmpVar31 = add i32 %tmpVar30, 0
  %tmpVar32 = getelementptr inbounds [250 x i8], [250 x i8]* %deref28, i32 0, i32 %tmpVar31
  store i8 0, i8* %tmpVar32, align 1
  %LIST_GET_ret = load [251 x i8], [251 x i8]* %LIST_GET, align 1
  ret [251 x i8] %LIST_GET_ret

12:                                               ; preds = %condition_check
  %load_c = load i8, i8* %c, align 1
  %13 = zext i8 %load_c to i32
  %tmpVar1 = icmp eq i32 %13, 0
  %14 = zext i1 %tmpVar1 to i32
  br label %15

15:                                               ; preds = %12, %condition_check
  %16 = phi i32 [ %4, %condition_check ], [ %14, %12 ]
  br i32 %16, label %while_body, label %continue

condition_body:                                   ; preds = %while_body
  %load_c11 = load i8, i8* %c, align 1
  %17 = zext i8 %load_c11 to i32
  %load_SEP = load i8, i8* %SEP, align 1
  %18 = zext i8 %load_SEP to i32
  %tmpVar12 = icmp eq i32 %17, %18
  br i1 %tmpVar12, label %condition_body10, label %continue9

branch:                                           ; preds = %while_body
  %load_c21 = load i8, i8* %c, align 1
  %19 = zext i8 %load_c21 to i32
  %load_SEP22 = load i8, i8* %SEP, align 1
  %20 = zext i8 %load_SEP22 to i32
  %tmpVar23 = icmp eq i32 %19, %20
  br i1 %tmpVar23, label %condition_body20, label %continue7

condition_body20:                                 ; preds = %branch
  %load_cnt24 = load i16, i16* %cnt, align 2
  %21 = sext i16 %load_cnt24 to i32
  %tmpVar25 = add i32 %21, 1
  %22 = trunc i32 %tmpVar25 to i16
  store i16 %22, i16* %cnt, align 2
  br label %continue7

continue7:                                        ; preds = %condition_body20, %branch, %continue9
  %load_i26 = load i16, i16* %i, align 2
  %23 = sext i16 %load_i26 to i32
  %tmpVar27 = add i32 %23, 1
  %24 = trunc i32 %tmpVar27 to i16
  store i16 %24, i16* %i, align 2
  br label %condition_check

condition_body10:                                 ; preds = %condition_body
  br label %continue

buffer_block:                                     ; No predecessors!
  br label %continue9

continue9:                                        ; preds = %buffer_block, %condition_body
  %deref13 = load [250 x i8]*, [250 x i8]** %po, align 8
  %load_o = load i16, i16* %o, align 2
  %25 = sub i16 %load_o, 1
  %26 = sext i16 %25 to i32
  %tmpVar14 = mul i32 1, %26
  %tmpVar15 = add i32 %tmpVar14, 0
  %tmpVar16 = getelementptr inbounds [250 x i8], [250 x i8]* %deref13, i32 0, i32 %tmpVar15
  %load_c17 = load i8, i8* %c, align 1
  store i8 %load_c17, i8* %tmpVar16, align 1
  %load_o18 = load i16, i16* %o, align 2
  %27 = sext i16 %load_o18 to i32
  %tmpVar19 = add i32 %27, 1
  %28 = trunc i32 %tmpVar19 to i16
  store i16 %28, i16* %o, align 2
  br label %continue7
}

define i8 @LIST_INSERT(%LIST_INSERT_interface* %0) {
entry:
  %SEP = getelementptr inbounds %LIST_INSERT_interface, %LIST_INSERT_interface* %0, i32 0, i32 0
  %POS = getelementptr inbounds %LIST_INSERT_interface, %LIST_INSERT_interface* %0, i32 0, i32 1
  %INS = getelementptr inbounds %LIST_INSERT_interface, %LIST_INSERT_interface* %0, i32 0, i32 2
  %LIST = getelementptr inbounds %LIST_INSERT_interface, %LIST_INSERT_interface* %0, i32 0, i32 3
  %pt = getelementptr inbounds %LIST_INSERT_interface, %LIST_INSERT_interface* %0, i32 0, i32 4
  %read = getelementptr inbounds %LIST_INSERT_interface, %LIST_INSERT_interface* %0, i32 0, i32 5
  %cnt = getelementptr inbounds %LIST_INSERT_interface, %LIST_INSERT_interface* %0, i32 0, i32 6
  %sx = getelementptr inbounds %LIST_INSERT_interface, %LIST_INSERT_interface* %0, i32 0, i32 7
  %LIST_INSERT = alloca i8, align 1
  store [250 x i8]* null, [250 x i8]** %pt, align 8
  store i16 1, i16* %read, align 2
  store i16 1, i16* %cnt, align 2
  %1 = bitcast [2 x i8]* %sx to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 2), i1 false)
  store i8 0, i8* %LIST_INSERT, align 1
  %deref = load [251 x i8]*, [251 x i8]** %LIST, align 8
  store [251 x i8]* %deref, [250 x i8]** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

condition_body:                                   ; preds = %continue7
  store i8 0, i8* %LIST_INSERT, align 1
  br label %continue

else:                                             ; preds = %continue7
  store i8 1, i8* %LIST_INSERT, align 1
  br label %condition_check

continue:                                         ; preds = %continue12, %condition_body
  %LIST_INSERT_ret78 = load i8, i8* %LIST_INSERT, align 1
  ret i8 %LIST_INSERT_ret78

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %3 = bitcast [1024 x i8]* %2 to i8*
  %4 = bitcast [251 x i8]* %INS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %3, i8* align 1 %4, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call2 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %5 = sext i16 %call2 to i32
  %tmpVar = add i32 %5, 1
  %LEN_instance3 = alloca %LEN_interface, align 8
  br label %input4

input4:                                           ; preds = %continue1
  %6 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance3, i32 0, i32 0
  %deref8 = load [251 x i8]*, [251 x i8]** %LIST, align 8
  %7 = bitcast [1024 x i8]* %6 to i8*
  %8 = bitcast [251 x i8]* %deref8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %7, i8* align 1 %8, i32 251, i1 false)
  br label %call5

call5:                                            ; preds = %input4
  %call9 = call i16 @LEN(%LEN_interface* %LEN_instance3)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %9 = sext i16 %call9 to i32
  %tmpVar10 = add i32 %tmpVar, %9
  %load_LIST_LENGTH = load i16, i16* @LIST_LENGTH, align 2
  %10 = sext i16 %load_LIST_LENGTH to i32
  %tmpVar11 = icmp sgt i32 %tmpVar10, %10
  br i1 %tmpVar11, label %condition_body, label %else

condition_check:                                  ; preds = %else, %continue59
  %load_read = load i16, i16* %read, align 2
  %11 = sext i16 %load_read to i32
  %load_LIST_LENGTH13 = load i16, i16* @LIST_LENGTH, align 2
  %12 = sext i16 %load_LIST_LENGTH13 to i32
  %tmpVar14 = icmp slt i32 %11, %12
  br i1 %tmpVar14, label %while_body, label %continue12

while_body:                                       ; preds = %condition_check
  %load_cnt = load i16, i16* %cnt, align 2
  %13 = sext i16 %load_cnt to i32
  %load_POS = load i16, i16* %POS, align 2
  %14 = sext i16 %load_POS to i32
  %tmpVar17 = icmp sge i32 %13, %14
  br i1 %tmpVar17, label %condition_body16, label %continue15

continue12:                                       ; preds = %condition_check
  br label %continue

condition_body16:                                 ; preds = %while_body
  %CHR_TO_STRING_instance = alloca %CHR_TO_STRING_interface, align 8
  br label %input18

continue15:                                       ; preds = %buffer_block, %while_body
  %deref39 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_read40 = load i16, i16* %read, align 2
  %15 = sub i16 %load_read40, 1
  %16 = sext i16 %15 to i32
  %tmpVar41 = mul i32 1, %16
  %tmpVar42 = add i32 %tmpVar41, 0
  %tmpVar43 = getelementptr inbounds [250 x i8], [250 x i8]* %deref39, i32 0, i32 %tmpVar42
  %load_tmpVar = load i8, i8* %tmpVar43, align 1
  %17 = zext i8 %load_tmpVar to i32
  %tmpVar44 = icmp eq i32 %17, 0
  br i1 %tmpVar44, label %condition_body38, label %continue37

input18:                                          ; preds = %condition_body16
  %18 = getelementptr inbounds %CHR_TO_STRING_interface, %CHR_TO_STRING_interface* %CHR_TO_STRING_instance, i32 0, i32 0
  %load_SEP = load i8, i8* %SEP, align 1
  store i8 %load_SEP, i8* %18, align 1
  br label %call19

call19:                                           ; preds = %input18
  %call22 = call [2 x i8] @CHR_TO_STRING(%CHR_TO_STRING_interface* %CHR_TO_STRING_instance)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %19 = alloca [2 x i8], align 1
  store [2 x i8] %call22, [2 x i8]* %19, align 1
  %20 = bitcast [2 x i8]* %sx to i8*
  %21 = bitcast [2 x i8]* %19 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 1, i1 false)
  %CONCAT_instance = alloca %CONCAT_interface, align 8
  br label %input23

input23:                                          ; preds = %continue21
  %22 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 0
  %23 = bitcast [1024 x i8]* %22 to i8*
  %24 = bitcast [2 x i8]* %sx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %23, i8* align 1 %24, i32 2, i1 false)
  %25 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 1
  %26 = bitcast [1024 x i8]* %25 to i8*
  %27 = bitcast [251 x i8]* %INS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %26, i8* align 1 %27, i32 251, i1 false)
  br label %call24

call24:                                           ; preds = %input23
  %call27 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %28 = alloca [1024 x i8], align 1
  store [1024 x i8] %call27, [1024 x i8]* %28, align 1
  %29 = bitcast [251 x i8]* %INS to i8*
  %30 = bitcast [1024 x i8]* %28 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %29, i8* align 1 %30, i32 250, i1 false)
  %deref28 = load [251 x i8]*, [251 x i8]** %LIST, align 8
  %INSERT_instance = alloca %INSERT_interface, align 8
  br label %input29

input29:                                          ; preds = %continue26
  %31 = getelementptr inbounds %INSERT_interface, %INSERT_interface* %INSERT_instance, i32 0, i32 0
  %deref33 = load [251 x i8]*, [251 x i8]** %LIST, align 8
  %32 = bitcast [1024 x i8]* %31 to i8*
  %33 = bitcast [251 x i8]* %deref33 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %32, i8* align 1 %33, i32 251, i1 false)
  %34 = getelementptr inbounds %INSERT_interface, %INSERT_interface* %INSERT_instance, i32 0, i32 1
  %35 = bitcast [1024 x i8]* %34 to i8*
  %36 = bitcast [251 x i8]* %INS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %35, i8* align 1 %36, i32 251, i1 false)
  %37 = getelementptr inbounds %INSERT_interface, %INSERT_interface* %INSERT_instance, i32 0, i32 2
  %load_read34 = load i16, i16* %read, align 2
  %38 = sext i16 %load_read34 to i32
  %tmpVar35 = sub i32 %38, 1
  %39 = trunc i32 %tmpVar35 to i16
  store i16 %39, i16* %37, align 2
  br label %call30

call30:                                           ; preds = %input29
  %call36 = call [1024 x i8] @INSERT(%INSERT_interface* %INSERT_instance)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  %40 = alloca [1024 x i8], align 1
  store [1024 x i8] %call36, [1024 x i8]* %40, align 1
  %41 = bitcast [251 x i8]* %deref28 to i8*
  %42 = bitcast [1024 x i8]* %40 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %41, i8* align 1 %42, i32 250, i1 false)
  store i8 1, i8* %LIST_INSERT, align 1
  %LIST_INSERT_ret = load i8, i8* %LIST_INSERT, align 1
  ret i8 %LIST_INSERT_ret

buffer_block:                                     ; No predecessors!
  br label %continue15

condition_body38:                                 ; preds = %continue15
  %deref45 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_read46 = load i16, i16* %read, align 2
  %43 = sub i16 %load_read46, 1
  %44 = sext i16 %43 to i32
  %tmpVar47 = mul i32 1, %44
  %tmpVar48 = add i32 %tmpVar47, 0
  %tmpVar49 = getelementptr inbounds [250 x i8], [250 x i8]* %deref45, i32 0, i32 %tmpVar48
  %load_SEP50 = load i8, i8* %SEP, align 1
  store i8 %load_SEP50, i8* %tmpVar49, align 1
  %deref51 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_read52 = load i16, i16* %read, align 2
  %45 = sext i16 %load_read52 to i32
  %tmpVar53 = add i32 %45, 1
  %46 = sub i32 %tmpVar53, 1
  %tmpVar54 = mul i32 1, %46
  %tmpVar55 = add i32 %tmpVar54, 0
  %tmpVar56 = getelementptr inbounds [250 x i8], [250 x i8]* %deref51, i32 0, i32 %tmpVar55
  store i8 0, i8* %tmpVar56, align 1
  br label %continue37

continue37:                                       ; preds = %condition_body38, %continue15
  %load_read57 = load i16, i16* %read, align 2
  %47 = sext i16 %load_read57 to i32
  %tmpVar58 = add i32 %47, 1
  %48 = trunc i32 %tmpVar58 to i16
  store i16 %48, i16* %read, align 2
  %deref61 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_read62 = load i16, i16* %read, align 2
  %49 = sub i16 %load_read62, 1
  %50 = sext i16 %49 to i32
  %tmpVar63 = mul i32 1, %50
  %tmpVar64 = add i32 %tmpVar63, 0
  %tmpVar65 = getelementptr inbounds [250 x i8], [250 x i8]* %deref61, i32 0, i32 %tmpVar64
  %load_tmpVar66 = load i8, i8* %tmpVar65, align 1
  %51 = zext i8 %load_tmpVar66 to i32
  %load_SEP67 = load i8, i8* %SEP, align 1
  %52 = zext i8 %load_SEP67 to i32
  %tmpVar68 = icmp eq i32 %51, %52
  %53 = zext i1 %tmpVar68 to i32
  %54 = icmp ne i32 %53, 0
  br i1 %54, label %62, label %57

condition_body60:                                 ; preds = %62
  %load_cnt76 = load i16, i16* %cnt, align 2
  %55 = sext i16 %load_cnt76 to i32
  %tmpVar77 = add i32 %55, 1
  %56 = trunc i32 %tmpVar77 to i16
  store i16 %56, i16* %cnt, align 2
  br label %continue59

continue59:                                       ; preds = %condition_body60, %62
  br label %condition_check

57:                                               ; preds = %continue37
  %deref69 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_read70 = load i16, i16* %read, align 2
  %58 = sub i16 %load_read70, 1
  %59 = sext i16 %58 to i32
  %tmpVar71 = mul i32 1, %59
  %tmpVar72 = add i32 %tmpVar71, 0
  %tmpVar73 = getelementptr inbounds [250 x i8], [250 x i8]* %deref69, i32 0, i32 %tmpVar72
  %load_tmpVar74 = load i8, i8* %tmpVar73, align 1
  %60 = zext i8 %load_tmpVar74 to i32
  %tmpVar75 = icmp eq i32 %60, 0
  %61 = zext i1 %tmpVar75 to i32
  br label %62

62:                                               ; preds = %57, %continue37
  %63 = phi i32 [ %53, %continue37 ], [ %61, %57 ]
  %64 = icmp ne i32 %63, 0
  br i1 %64, label %condition_body60, label %continue59
}

define i16 @LIST_LEN(%LIST_LEN_interface* %0) {
entry:
  %SEP = getelementptr inbounds %LIST_LEN_interface, %LIST_LEN_interface* %0, i32 0, i32 0
  %LIST = getelementptr inbounds %LIST_LEN_interface, %LIST_LEN_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %LIST_LEN_interface, %LIST_LEN_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %LIST_LEN_interface, %LIST_LEN_interface* %0, i32 0, i32 3
  %c = getelementptr inbounds %LIST_LEN_interface, %LIST_LEN_interface* %0, i32 0, i32 4
  %LIST_LEN = alloca i16, align 2
  store [250 x i8]* null, [250 x i8]** %pt, align 8
  store i16 1, i16* %pos, align 2
  store i8 0, i8* %c, align 1
  store i16 0, i16* %LIST_LEN, align 2
  %deref = load [251 x i8]*, [251 x i8]** %LIST, align 8
  store [251 x i8]* %deref, [250 x i8]** %pt, align 8
  store i16 0, i16* %LIST_LEN, align 2
  br label %while_body

condition_check:                                  ; preds = %continue7
  %load_c = load i8, i8* %c, align 1
  %1 = zext i8 %load_c to i32
  %tmpVar = icmp eq i32 %1, 0
  %2 = zext i1 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %12, label %8

while_body:                                       ; preds = %entry, %12
  %deref2 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_pos3 = load i16, i16* %pos, align 2
  %4 = sub i16 %load_pos3, 1
  %5 = sext i16 %4 to i32
  %tmpVar4 = mul i32 1, %5
  %tmpVar5 = add i32 %tmpVar4, 0
  %tmpVar6 = getelementptr inbounds [250 x i8], [250 x i8]* %deref2, i32 0, i32 %tmpVar5
  %load_tmpVar = load i8, i8* %tmpVar6, align 1
  store i8 %load_tmpVar, i8* %c, align 1
  %load_c8 = load i8, i8* %c, align 1
  %6 = zext i8 %load_c8 to i32
  %load_SEP = load i8, i8* %SEP, align 1
  %7 = zext i8 %load_SEP to i32
  %tmpVar9 = icmp eq i32 %6, %7
  br i1 %tmpVar9, label %condition_body, label %continue7

continue:                                         ; preds = %12
  %LIST_LEN_ret = load i16, i16* %LIST_LEN, align 2
  ret i16 %LIST_LEN_ret

8:                                                ; preds = %condition_check
  %load_pos = load i16, i16* %pos, align 2
  %9 = sext i16 %load_pos to i32
  %load_LIST_LENGTH = load i16, i16* @LIST_LENGTH, align 2
  %10 = sext i16 %load_LIST_LENGTH to i32
  %tmpVar1 = icmp sgt i32 %9, %10
  %11 = zext i1 %tmpVar1 to i32
  br label %12

12:                                               ; preds = %8, %condition_check
  %13 = phi i32 [ %2, %condition_check ], [ %11, %8 ]
  br i32 %13, label %while_body, label %continue

condition_body:                                   ; preds = %while_body
  %load_LIST_LEN = load i16, i16* %LIST_LEN, align 2
  %14 = sext i16 %load_LIST_LEN to i32
  %tmpVar10 = add i32 %14, 1
  %15 = trunc i32 %tmpVar10 to i16
  store i16 %15, i16* %LIST_LEN, align 2
  br label %continue7

continue7:                                        ; preds = %condition_body, %while_body
  %load_pos11 = load i16, i16* %pos, align 2
  %16 = sext i16 %load_pos11 to i32
  %tmpVar12 = add i32 %16, 1
  %17 = trunc i32 %tmpVar12 to i16
  store i16 %17, i16* %pos, align 2
  br label %condition_check
}

define void @LIST_NEXT(%LIST_NEXT_interface* %0) {
entry:
  %SEP = getelementptr inbounds %LIST_NEXT_interface, %LIST_NEXT_interface* %0, i32 0, i32 0
  %RST = getelementptr inbounds %LIST_NEXT_interface, %LIST_NEXT_interface* %0, i32 0, i32 1
  %LIST = getelementptr inbounds %LIST_NEXT_interface, %LIST_NEXT_interface* %0, i32 0, i32 2
  %LEL = getelementptr inbounds %LIST_NEXT_interface, %LIST_NEXT_interface* %0, i32 0, i32 3
  %NUL = getelementptr inbounds %LIST_NEXT_interface, %LIST_NEXT_interface* %0, i32 0, i32 4
  %pos = getelementptr inbounds %LIST_NEXT_interface, %LIST_NEXT_interface* %0, i32 0, i32 5
  %pt = getelementptr inbounds %LIST_NEXT_interface, %LIST_NEXT_interface* %0, i32 0, i32 6
  %po = getelementptr inbounds %LIST_NEXT_interface, %LIST_NEXT_interface* %0, i32 0, i32 7
  %c = getelementptr inbounds %LIST_NEXT_interface, %LIST_NEXT_interface* %0, i32 0, i32 8
  %write = getelementptr inbounds %LIST_NEXT_interface, %LIST_NEXT_interface* %0, i32 0, i32 9
  %deref = load [251 x i8]*, [251 x i8]** %LIST, align 8
  store [251 x i8]* %deref, [250 x i8]** %pt, align 8
  store [251 x i8]* %LEL, [250 x i8]** %po, align 8
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  store i16 1, i16* %pos, align 2
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  %deref3 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_pos = load i16, i16* %pos, align 2
  %2 = sub i16 %load_pos, 1
  %3 = sext i16 %2 to i32
  %tmpVar = mul i32 1, %3
  %tmpVar4 = add i32 %tmpVar, 0
  %tmpVar5 = getelementptr inbounds [250 x i8], [250 x i8]* %deref3, i32 0, i32 %tmpVar4
  %load_tmpVar = load i8, i8* %tmpVar5, align 1
  %4 = zext i8 %load_tmpVar to i32
  %tmpVar6 = icmp eq i32 %4, 0
  %5 = zext i1 %tmpVar6 to i32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %14, label %10

condition_body2:                                  ; preds = %14
  %7 = bitcast [251 x i8]* %LEL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %7, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  store i8 1, i8* %NUL, align 1
  br label %continue1

else:                                             ; preds = %14
  store i8 0, i8* %NUL, align 1
  store i16 1, i16* %write, align 2
  %load_pos9 = load i16, i16* %pos, align 2
  %8 = sext i16 %load_pos9 to i32
  %tmpVar10 = add i32 %8, 1
  %9 = trunc i32 %tmpVar10 to i16
  store i16 %9, i16* %pos, align 2
  br label %condition_check

continue1:                                        ; preds = %continue11, %condition_body2
  ret void

10:                                               ; preds = %continue
  %load_pos7 = load i16, i16* %pos, align 2
  %11 = sext i16 %load_pos7 to i32
  %load_LIST_LENGTH = load i16, i16* @LIST_LENGTH, align 2
  %12 = sext i16 %load_LIST_LENGTH to i32
  %tmpVar8 = icmp eq i32 %11, %12
  %13 = zext i1 %tmpVar8 to i32
  br label %14

14:                                               ; preds = %10, %continue
  %15 = phi i32 [ %5, %continue ], [ %13, %10 ]
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %condition_body2, label %else

condition_check:                                  ; preds = %increment, %else
  %load_pos12 = load i16, i16* %pos, align 2
  %load_pos13 = load i16, i16* %pos, align 2
  %load_LIST_LENGTH14 = load i16, i16* @LIST_LENGTH, align 2
  %tmpVar15 = icmp sle i16 %load_pos13, %load_LIST_LENGTH14
  %17 = icmp ne i1 %tmpVar15, false
  br i1 %17, label %27, label %30

for_body:                                         ; preds = %25
  %deref27 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_pos28 = load i16, i16* %pos, align 2
  %18 = sub i16 %load_pos28, 1
  %19 = sext i16 %18 to i32
  %tmpVar29 = mul i32 1, %19
  %tmpVar30 = add i32 %tmpVar29, 0
  %tmpVar31 = getelementptr inbounds [250 x i8], [250 x i8]* %deref27, i32 0, i32 %tmpVar30
  %load_tmpVar32 = load i8, i8* %tmpVar31, align 1
  store i8 %load_tmpVar32, i8* %c, align 1
  %load_c = load i8, i8* %c, align 1
  %20 = zext i8 %load_c to i32
  %tmpVar36 = icmp eq i32 %20, 0
  %21 = zext i1 %tmpVar36 to i32
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %50, label %46

increment:                                        ; preds = %continue34
  %tmpVar56 = add i16 %load_pos12, 1
  store i16 %tmpVar56, i16* %pos, align 2
  br label %condition_check

continue11:                                       ; preds = %25
  br label %continue1

23:                                               ; preds = %30
  %load_pos20 = load i16, i16* %pos, align 2
  %load_LIST_LENGTH21 = load i16, i16* @LIST_LENGTH, align 2
  %tmpVar22 = icmp sge i16 %load_pos20, %load_LIST_LENGTH21
  %24 = icmp ne i1 %tmpVar22, false
  br i1 %24, label %33, label %36

25:                                               ; preds = %36, %30
  %26 = phi i1 [ %31, %30 ], [ %37, %36 ]
  br i1 %26, label %for_body, label %continue11

27:                                               ; preds = %condition_check
  %load_pos16 = load i16, i16* %pos, align 2
  %load_pos17 = load i16, i16* %pos, align 2
  %28 = sext i16 %load_pos17 to i32
  %tmpVar18 = add i32 %28, 1
  %29 = trunc i32 %tmpVar18 to i16
  %tmpVar19 = icmp sge i16 %load_pos16, %29
  br label %30

30:                                               ; preds = %27, %condition_check
  %31 = phi i1 [ %tmpVar15, %condition_check ], [ %tmpVar19, %27 ]
  %32 = icmp ne i1 %31, false
  br i1 %32, label %25, label %23

33:                                               ; preds = %23
  %load_pos23 = load i16, i16* %pos, align 2
  %load_pos24 = load i16, i16* %pos, align 2
  %34 = sext i16 %load_pos24 to i32
  %tmpVar25 = add i32 %34, 1
  %35 = trunc i32 %tmpVar25 to i16
  %tmpVar26 = icmp sle i16 %load_pos23, %35
  br label %36

36:                                               ; preds = %33, %23
  %37 = phi i1 [ %tmpVar22, %23 ], [ %tmpVar26, %33 ]
  br label %25

condition_body35:                                 ; preds = %50
  %deref39 = load [250 x i8]*, [250 x i8]** %po, align 8
  %load_write = load i16, i16* %write, align 2
  %38 = sub i16 %load_write, 1
  %39 = sext i16 %38 to i32
  %tmpVar40 = mul i32 1, %39
  %tmpVar41 = add i32 %tmpVar40, 0
  %tmpVar42 = getelementptr inbounds [250 x i8], [250 x i8]* %deref39, i32 0, i32 %tmpVar41
  store i8 0, i8* %tmpVar42, align 1
  ret void

buffer_block:                                     ; No predecessors!
  br label %continue34

else33:                                           ; preds = %50
  %deref43 = load [250 x i8]*, [250 x i8]** %po, align 8
  %load_write44 = load i16, i16* %write, align 2
  %40 = sub i16 %load_write44, 1
  %41 = sext i16 %40 to i32
  %tmpVar45 = mul i32 1, %41
  %tmpVar46 = add i32 %tmpVar45, 0
  %tmpVar47 = getelementptr inbounds [250 x i8], [250 x i8]* %deref43, i32 0, i32 %tmpVar46
  %deref48 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_pos49 = load i16, i16* %pos, align 2
  %42 = sub i16 %load_pos49, 1
  %43 = sext i16 %42 to i32
  %tmpVar50 = mul i32 1, %43
  %tmpVar51 = add i32 %tmpVar50, 0
  %tmpVar52 = getelementptr inbounds [250 x i8], [250 x i8]* %deref48, i32 0, i32 %tmpVar51
  %load_tmpVar53 = load i8, i8* %tmpVar52, align 1
  store i8 %load_tmpVar53, i8* %tmpVar47, align 1
  %load_write54 = load i16, i16* %write, align 2
  %44 = sext i16 %load_write54 to i32
  %tmpVar55 = add i32 %44, 1
  %45 = trunc i32 %tmpVar55 to i16
  store i16 %45, i16* %write, align 2
  br label %continue34

continue34:                                       ; preds = %else33, %buffer_block
  br label %increment

46:                                               ; preds = %for_body
  %load_c37 = load i8, i8* %c, align 1
  %47 = zext i8 %load_c37 to i32
  %load_SEP = load i8, i8* %SEP, align 1
  %48 = zext i8 %load_SEP to i32
  %tmpVar38 = icmp eq i32 %47, %48
  %49 = zext i1 %tmpVar38 to i32
  br label %50

50:                                               ; preds = %46, %for_body
  %51 = phi i32 [ %21, %for_body ], [ %49, %46 ]
  %52 = icmp ne i32 %51, 0
  br i1 %52, label %condition_body35, label %else33
}

define [251 x i8] @LIST_RETRIEVE(%LIST_RETRIEVE_interface* %0) {
entry:
  %SEP = getelementptr inbounds %LIST_RETRIEVE_interface, %LIST_RETRIEVE_interface* %0, i32 0, i32 0
  %POS = getelementptr inbounds %LIST_RETRIEVE_interface, %LIST_RETRIEVE_interface* %0, i32 0, i32 1
  %LIST = getelementptr inbounds %LIST_RETRIEVE_interface, %LIST_RETRIEVE_interface* %0, i32 0, i32 2
  %i = getelementptr inbounds %LIST_RETRIEVE_interface, %LIST_RETRIEVE_interface* %0, i32 0, i32 3
  %o = getelementptr inbounds %LIST_RETRIEVE_interface, %LIST_RETRIEVE_interface* %0, i32 0, i32 4
  %w = getelementptr inbounds %LIST_RETRIEVE_interface, %LIST_RETRIEVE_interface* %0, i32 0, i32 5
  %pt = getelementptr inbounds %LIST_RETRIEVE_interface, %LIST_RETRIEVE_interface* %0, i32 0, i32 6
  %po = getelementptr inbounds %LIST_RETRIEVE_interface, %LIST_RETRIEVE_interface* %0, i32 0, i32 7
  %cnt = getelementptr inbounds %LIST_RETRIEVE_interface, %LIST_RETRIEVE_interface* %0, i32 0, i32 8
  %c = getelementptr inbounds %LIST_RETRIEVE_interface, %LIST_RETRIEVE_interface* %0, i32 0, i32 9
  %LIST_RETRIEVE = alloca [251 x i8], align 1
  store i16 0, i16* %i, align 2
  store i16 1, i16* %o, align 2
  store i16 1, i16* %w, align 2
  store [250 x i8]* null, [250 x i8]** %pt, align 8
  store [250 x i8]* null, [250 x i8]** %po, align 8
  store i16 0, i16* %cnt, align 2
  store i8 0, i8* %c, align 1
  %1 = bitcast [251 x i8]* %LIST_RETRIEVE to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %deref = load [251 x i8]*, [251 x i8]** %LIST, align 8
  store [251 x i8]* %deref, [250 x i8]** %pt, align 8
  store [251 x i8]* %LIST_RETRIEVE, [250 x i8]** %po, align 8
  %load_pos = load i16, i16* %POS, align 2
  %2 = sext i16 %load_pos to i32
  %tmpVar = icmp sgt i32 %2, 0
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  store i16 1, i16* %i, align 2
  br label %condition_check

else:                                             ; preds = %entry
  %3 = bitcast [251 x i8]* %LIST_RETRIEVE to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %3, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  br label %continue

continue:                                         ; preds = %else, %continue1
  %LIST_RETRIEVE_ret79 = load [251 x i8], [251 x i8]* %LIST_RETRIEVE, align 1
  ret [251 x i8] %LIST_RETRIEVE_ret79

condition_check:                                  ; preds = %increment, %condition_body
  %load_i = load i16, i16* %i, align 2
  %load_i2 = load i16, i16* %i, align 2
  %load_LIST_LENGTH = load i16, i16* @LIST_LENGTH, align 2
  %tmpVar3 = icmp sle i16 %load_i2, %load_LIST_LENGTH
  %4 = icmp ne i1 %tmpVar3, false
  br i1 %4, label %12, label %13

for_body:                                         ; preds = %10
  %deref11 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_i12 = load i16, i16* %i, align 2
  %5 = sub i16 %load_i12, 1
  %6 = sext i16 %5 to i32
  %tmpVar13 = mul i32 1, %6
  %tmpVar14 = add i32 %tmpVar13, 0
  %tmpVar15 = getelementptr inbounds [250 x i8], [250 x i8]* %deref11, i32 0, i32 %tmpVar14
  %load_tmpVar = load i8, i8* %tmpVar15, align 1
  store i8 %load_tmpVar, i8* %c, align 1
  %load_c = load i8, i8* %c, align 1
  %7 = zext i8 %load_c to i32
  %tmpVar20 = icmp eq i32 %7, 0
  br i1 %tmpVar20, label %condition_body19, label %branch

increment:                                        ; preds = %continue72
  %tmpVar78 = add i16 %load_i, 1
  store i16 %tmpVar78, i16* %i, align 2
  br label %condition_check

continue1:                                        ; preds = %10
  br label %continue

8:                                                ; preds = %13
  %load_i6 = load i16, i16* %i, align 2
  %load_LIST_LENGTH7 = load i16, i16* @LIST_LENGTH, align 2
  %tmpVar8 = icmp sge i16 %load_i6, %load_LIST_LENGTH7
  %9 = icmp ne i1 %tmpVar8, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue1

12:                                               ; preds = %condition_check
  %load_i4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_i4, 1
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar3, %condition_check ], [ %tmpVar5, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_i9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sle i16 %load_i9, 1
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar8, %8 ], [ %tmpVar10, %16 ]
  br label %10

condition_body19:                                 ; preds = %for_body
  %deref21 = load [250 x i8]*, [250 x i8]** %po, align 8
  %load_o = load i16, i16* %o, align 2
  %19 = sub i16 %load_o, 1
  %20 = sext i16 %19 to i32
  %tmpVar22 = mul i32 1, %20
  %tmpVar23 = add i32 %tmpVar22, 0
  %tmpVar24 = getelementptr inbounds [250 x i8], [250 x i8]* %deref21, i32 0, i32 %tmpVar23
  store i8 0, i8* %tmpVar24, align 1
  %load_cnt = load i16, i16* %cnt, align 2
  %21 = sext i16 %load_cnt to i32
  %load_pos28 = load i16, i16* %POS, align 2
  %22 = sext i16 %load_pos28 to i32
  %tmpVar29 = icmp slt i32 %21, %22
  br i1 %tmpVar29, label %condition_body27, label %else25

branch:                                           ; preds = %for_body
  %load_cnt41 = load i16, i16* %cnt, align 2
  %23 = sext i16 %load_cnt41 to i32
  %load_pos42 = load i16, i16* %POS, align 2
  %24 = sext i16 %load_pos42 to i32
  %tmpVar43 = icmp eq i32 %23, %24
  %25 = zext i1 %tmpVar43 to i32
  %26 = icmp ne i32 %25, 0
  br i1 %26, label %45, label %49

condition_body40:                                 ; preds = %49
  %deref46 = load [250 x i8]*, [250 x i8]** %po, align 8
  %load_o47 = load i16, i16* %o, align 2
  %27 = sub i16 %load_o47, 1
  %28 = sext i16 %27 to i32
  %tmpVar48 = mul i32 1, %28
  %tmpVar49 = add i32 %tmpVar48, 0
  %tmpVar50 = getelementptr inbounds [250 x i8], [250 x i8]* %deref46, i32 0, i32 %tmpVar49
  %deref51 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_i52 = load i16, i16* %i, align 2
  %29 = sub i16 %load_i52, 1
  %30 = sext i16 %29 to i32
  %tmpVar53 = mul i32 1, %30
  %tmpVar54 = add i32 %tmpVar53, 0
  %tmpVar55 = getelementptr inbounds [250 x i8], [250 x i8]* %deref51, i32 0, i32 %tmpVar54
  %load_tmpVar56 = load i8, i8* %tmpVar55, align 1
  store i8 %load_tmpVar56, i8* %tmpVar50, align 1
  %load_o57 = load i16, i16* %o, align 2
  %31 = sext i16 %load_o57 to i32
  %tmpVar58 = add i32 %31, 1
  %32 = trunc i32 %tmpVar58 to i16
  store i16 %32, i16* %o, align 2
  br label %continue18

branch16:                                         ; preds = %49
  %load_cnt60 = load i16, i16* %cnt, align 2
  %33 = sext i16 %load_cnt60 to i32
  %load_pos61 = load i16, i16* %POS, align 2
  %34 = sext i16 %load_pos61 to i32
  %tmpVar62 = icmp sge i32 %33, %34
  br i1 %tmpVar62, label %condition_body59, label %else17

condition_body59:                                 ; preds = %branch16
  %deref63 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_w64 = load i16, i16* %w, align 2
  %35 = sub i16 %load_w64, 1
  %36 = sext i16 %35 to i32
  %tmpVar65 = mul i32 1, %36
  %tmpVar66 = add i32 %tmpVar65, 0
  %tmpVar67 = getelementptr inbounds [250 x i8], [250 x i8]* %deref63, i32 0, i32 %tmpVar66
  %load_c68 = load i8, i8* %c, align 1
  store i8 %load_c68, i8* %tmpVar67, align 1
  %load_w69 = load i16, i16* %w, align 2
  %37 = sext i16 %load_w69 to i32
  %tmpVar70 = add i32 %37, 1
  %38 = trunc i32 %tmpVar70 to i16
  store i16 %38, i16* %w, align 2
  br label %continue18

else17:                                           ; preds = %branch16
  %load_i71 = load i16, i16* %i, align 2
  store i16 %load_i71, i16* %w, align 2
  br label %continue18

continue18:                                       ; preds = %else17, %condition_body59, %condition_body40, %buffer_block
  %load_c74 = load i8, i8* %c, align 1
  %39 = zext i8 %load_c74 to i32
  %load_sep = load i8, i8* %SEP, align 1
  %40 = zext i8 %load_sep to i32
  %tmpVar75 = icmp eq i32 %39, %40
  br i1 %tmpVar75, label %condition_body73, label %continue72

condition_body27:                                 ; preds = %condition_body19
  %deref30 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_w = load i16, i16* %w, align 2
  %41 = sext i16 %load_w to i32
  %tmpVar31 = add i32 %41, 1
  %42 = sub i32 %tmpVar31, 1
  %tmpVar32 = mul i32 1, %42
  %tmpVar33 = add i32 %tmpVar32, 0
  %tmpVar34 = getelementptr inbounds [250 x i8], [250 x i8]* %deref30, i32 0, i32 %tmpVar33
  store i8 0, i8* %tmpVar34, align 1
  br label %continue26

else25:                                           ; preds = %condition_body19
  %deref35 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_w36 = load i16, i16* %w, align 2
  %43 = sub i16 %load_w36, 1
  %44 = sext i16 %43 to i32
  %tmpVar37 = mul i32 1, %44
  %tmpVar38 = add i32 %tmpVar37, 0
  %tmpVar39 = getelementptr inbounds [250 x i8], [250 x i8]* %deref35, i32 0, i32 %tmpVar38
  store i8 0, i8* %tmpVar39, align 1
  br label %continue26

continue26:                                       ; preds = %else25, %condition_body27
  %LIST_RETRIEVE_ret = load [251 x i8], [251 x i8]* %LIST_RETRIEVE, align 1
  ret [251 x i8] %LIST_RETRIEVE_ret

buffer_block:                                     ; No predecessors!
  br label %continue18

45:                                               ; preds = %branch
  %load_c44 = load i8, i8* %c, align 1
  %46 = zext i8 %load_c44 to i32
  %load_SEP = load i8, i8* %SEP, align 1
  %47 = zext i8 %load_SEP to i32
  %tmpVar45 = icmp ne i32 %46, %47
  %48 = zext i1 %tmpVar45 to i32
  br label %49

49:                                               ; preds = %45, %branch
  %50 = phi i32 [ %25, %branch ], [ %48, %45 ]
  %51 = icmp ne i32 %50, 0
  br i1 %51, label %condition_body40, label %branch16

condition_body73:                                 ; preds = %continue18
  %load_cnt76 = load i16, i16* %cnt, align 2
  %52 = sext i16 %load_cnt76 to i32
  %tmpVar77 = add i32 %52, 1
  %53 = trunc i32 %tmpVar77 to i16
  store i16 %53, i16* %cnt, align 2
  br label %continue72

continue72:                                       ; preds = %condition_body73, %continue18
  br label %increment
}

define [251 x i8] @LIST_RETRIEVE_LAST(%LIST_RETRIEVE_LAST_interface* %0) {
entry:
  %SEP = getelementptr inbounds %LIST_RETRIEVE_LAST_interface, %LIST_RETRIEVE_LAST_interface* %0, i32 0, i32 0
  %LIST = getelementptr inbounds %LIST_RETRIEVE_LAST_interface, %LIST_RETRIEVE_LAST_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %LIST_RETRIEVE_LAST_interface, %LIST_RETRIEVE_LAST_interface* %0, i32 0, i32 2
  %last = getelementptr inbounds %LIST_RETRIEVE_LAST_interface, %LIST_RETRIEVE_LAST_interface* %0, i32 0, i32 3
  %pt = getelementptr inbounds %LIST_RETRIEVE_LAST_interface, %LIST_RETRIEVE_LAST_interface* %0, i32 0, i32 4
  %c = getelementptr inbounds %LIST_RETRIEVE_LAST_interface, %LIST_RETRIEVE_LAST_interface* %0, i32 0, i32 5
  %LIST_RETRIEVE_LAST = alloca [251 x i8], align 1
  store i16 0, i16* %i, align 2
  store i16 1, i16* %last, align 2
  store [250 x i8]* null, [250 x i8]** %pt, align 8
  store i8 0, i8* %c, align 1
  %1 = bitcast [251 x i8]* %LIST_RETRIEVE_LAST to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %deref = load [251 x i8]*, [251 x i8]** %LIST, align 8
  store [251 x i8]* %deref, [250 x i8]** %pt, align 8
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %entry
  %load_i = load i16, i16* %i, align 2
  %load_i1 = load i16, i16* %i, align 2
  %load_LIST_LENGTH = load i16, i16* @LIST_LENGTH, align 2
  %tmpVar = icmp sle i16 %load_i1, %load_LIST_LENGTH
  %2 = icmp ne i1 %tmpVar, false
  br i1 %2, label %12, label %13

for_body:                                         ; preds = %10
  %deref9 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_i10 = load i16, i16* %i, align 2
  %3 = sub i16 %load_i10, 1
  %4 = sext i16 %3 to i32
  %tmpVar11 = mul i32 1, %4
  %tmpVar12 = add i32 %tmpVar11, 0
  %tmpVar13 = getelementptr inbounds [250 x i8], [250 x i8]* %deref9, i32 0, i32 %tmpVar12
  %load_tmpVar = load i8, i8* %tmpVar13, align 1
  store i8 %load_tmpVar, i8* %c, align 1
  %load_c = load i8, i8* %c, align 1
  %5 = zext i8 %load_c to i32
  %tmpVar15 = icmp eq i32 %5, 0
  br i1 %tmpVar15, label %condition_body, label %branch

increment:                                        ; preds = %continue14
  %tmpVar19 = add i16 %load_i, 1
  store i16 %tmpVar19, i16* %i, align 2
  br label %condition_check

continue:                                         ; preds = %condition_body, %10
  %deref20 = load [250 x i8]*, [250 x i8]** %pt, align 8
  %load_last = load i16, i16* %last, align 2
  %6 = sub i16 %load_last, 1
  %7 = sext i16 %6 to i32
  %tmpVar21 = mul i32 1, %7
  %tmpVar22 = add i32 %tmpVar21, 0
  %tmpVar23 = getelementptr inbounds [250 x i8], [250 x i8]* %deref20, i32 0, i32 %tmpVar22
  store i8 0, i8* %tmpVar23, align 1
  %LIST_RETRIEVE_LAST_ret = load [251 x i8], [251 x i8]* %LIST_RETRIEVE_LAST, align 1
  ret [251 x i8] %LIST_RETRIEVE_LAST_ret

8:                                                ; preds = %13
  %load_i4 = load i16, i16* %i, align 2
  %load_LIST_LENGTH5 = load i16, i16* @LIST_LENGTH, align 2
  %tmpVar6 = icmp sge i16 %load_i4, %load_LIST_LENGTH5
  %9 = icmp ne i1 %tmpVar6, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue

12:                                               ; preds = %condition_check
  %load_i2 = load i16, i16* %i, align 2
  %tmpVar3 = icmp sge i16 %load_i2, 1
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar3, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_i7 = load i16, i16* %i, align 2
  %tmpVar8 = icmp sle i16 %load_i7, 1
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar6, %8 ], [ %tmpVar8, %16 ]
  br label %10

condition_body:                                   ; preds = %for_body
  br label %continue

buffer_block:                                     ; No predecessors!
  br label %continue14

branch:                                           ; preds = %for_body
  %load_C = load i8, i8* %c, align 1
  %19 = zext i8 %load_C to i32
  %load_SEP = load i8, i8* %SEP, align 1
  %20 = zext i8 %load_SEP to i32
  %tmpVar17 = icmp eq i32 %19, %20
  br i1 %tmpVar17, label %condition_body16, label %continue14

condition_body16:                                 ; preds = %branch
  %load_i18 = load i16, i16* %i, align 2
  store i16 %load_i18, i16* %last, align 2
  br label %continue14

continue14:                                       ; preds = %condition_body16, %branch, %buffer_block
  br label %increment
}

define void @COUNT_BR(%COUNT_BR_interface* %0) {
entry:
  %SET = getelementptr inbounds %COUNT_BR_interface, %COUNT_BR_interface* %0, i32 0, i32 0
  %IN = getelementptr inbounds %COUNT_BR_interface, %COUNT_BR_interface* %0, i32 0, i32 1
  %UP = getelementptr inbounds %COUNT_BR_interface, %COUNT_BR_interface* %0, i32 0, i32 2
  %DN = getelementptr inbounds %COUNT_BR_interface, %COUNT_BR_interface* %0, i32 0, i32 3
  %STEP = getelementptr inbounds %COUNT_BR_interface, %COUNT_BR_interface* %0, i32 0, i32 4
  %MX = getelementptr inbounds %COUNT_BR_interface, %COUNT_BR_interface* %0, i32 0, i32 5
  %RST = getelementptr inbounds %COUNT_BR_interface, %COUNT_BR_interface* %0, i32 0, i32 6
  %CNT = getelementptr inbounds %COUNT_BR_interface, %COUNT_BR_interface* %0, i32 0, i32 7
  %last_up = getelementptr inbounds %COUNT_BR_interface, %COUNT_BR_interface* %0, i32 0, i32 8
  %last_dn = getelementptr inbounds %COUNT_BR_interface, %COUNT_BR_interface* %0, i32 0, i32 9
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %CNT, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_set = load i8, i8* %SET, align 1
  %2 = icmp ne i8 %load_set, 0
  br i1 %2, label %condition_body3, label %branch1

condition_body3:                                  ; preds = %branch
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input

branch1:                                          ; preds = %branch
  %load_up = load i8, i8* %UP, align 1
  %3 = zext i8 %load_up to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %13, label %15

condition_body6:                                  ; preds = %15
  %INT_TO_BYTE_instance = alloca %INT_TO_BYTE_interface, align 8
  br label %input7

branch2:                                          ; preds = %15
  %load_dn = load i8, i8* %DN, align 1
  %5 = zext i8 %load_dn to i32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %25, label %27

condition_body18:                                 ; preds = %27
  %INT_TO_BYTE_instance20 = alloca %INT_TO_BYTE_interface, align 8
  br label %input21

continue:                                         ; preds = %continue24, %27, %continue10, %continue4, %condition_body
  %load_up36 = load i8, i8* %UP, align 1
  store i8 %load_up36, i8* %last_up, align 1
  %load_dn37 = load i8, i8* %DN, align 1
  store i8 %load_dn37, i8* %last_dn, align 1
  ret void

input:                                            ; preds = %condition_body3
  %7 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %7, align 4
  %8 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_in = load i8, i8* %IN, align 1
  %9 = zext i8 %load_in to i64
  store i64 %9, i64* %8, align 4
  %10 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_mx = load i8, i8* %MX, align 1
  %11 = zext i8 %load_mx to i64
  store i64 %11, i64* %10, align 4
  br label %call

call:                                             ; preds = %input
  %call5 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue4

continue4:                                        ; preds = %output
  %12 = trunc i64 %call5 to i8
  store i8 %12, i8* %CNT, align 1
  br label %continue

13:                                               ; preds = %branch1
  %load_last_up = load i8, i8* %last_up, align 1
  %tmpVar = xor i8 %load_last_up, -1
  %14 = zext i8 %tmpVar to i32
  br label %15

15:                                               ; preds = %13, %branch1
  %16 = phi i32 [ %3, %branch1 ], [ %14, %13 ]
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %condition_body6, label %branch2

input7:                                           ; preds = %condition_body6
  %18 = getelementptr inbounds %INT_TO_BYTE_interface, %INT_TO_BYTE_interface* %INT_TO_BYTE_instance, i32 0, i32 0
  %INC_instance = alloca %INC_interface, align 8
  br label %input11

call8:                                            ; preds = %continue14
  %call17 = call i8 @INT_TO_BYTE(%INT_TO_BYTE_interface* %INT_TO_BYTE_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  store i8 %call17, i8* %CNT, align 1
  br label %continue

input11:                                          ; preds = %input7
  %19 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance, i32 0, i32 0
  %load_cnt = load i8, i8* %CNT, align 1
  %20 = zext i8 %load_cnt to i16
  store i16 %20, i16* %19, align 2
  %21 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance, i32 0, i32 1
  %load_step = load i8, i8* %STEP, align 1
  %22 = zext i8 %load_step to i16
  store i16 %22, i16* %21, align 2
  %23 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance, i32 0, i32 2
  %load_mx15 = load i8, i8* %MX, align 1
  %24 = zext i8 %load_mx15 to i16
  store i16 %24, i16* %23, align 2
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call i16 @INC(%INC_interface* %INC_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  store i16 %call16, i16* %18, align 2
  br label %call8

25:                                               ; preds = %branch2
  %load_last_dn = load i8, i8* %last_dn, align 1
  %tmpVar19 = xor i8 %load_last_dn, -1
  %26 = zext i8 %tmpVar19 to i32
  br label %27

27:                                               ; preds = %25, %branch2
  %28 = phi i32 [ %5, %branch2 ], [ %26, %25 ]
  %29 = icmp ne i32 %28, 0
  br i1 %29, label %condition_body18, label %continue

input21:                                          ; preds = %condition_body18
  %30 = getelementptr inbounds %INT_TO_BYTE_interface, %INT_TO_BYTE_interface* %INT_TO_BYTE_instance20, i32 0, i32 0
  %INC_instance25 = alloca %INC_interface, align 8
  br label %input26

call22:                                           ; preds = %continue29
  %call35 = call i8 @INT_TO_BYTE(%INT_TO_BYTE_interface* %INT_TO_BYTE_instance20)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  store i8 %call35, i8* %CNT, align 1
  br label %continue

input26:                                          ; preds = %input21
  %31 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance25, i32 0, i32 0
  %load_cnt30 = load i8, i8* %CNT, align 1
  %32 = zext i8 %load_cnt30 to i16
  store i16 %32, i16* %31, align 2
  %33 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance25, i32 0, i32 1
  %load_step31 = load i8, i8* %STEP, align 1
  %tmpVar32 = sub i8 0, %load_step31
  %34 = sext i8 %tmpVar32 to i16
  store i16 %34, i16* %33, align 2
  %35 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance25, i32 0, i32 2
  %load_mx33 = load i8, i8* %MX, align 1
  %36 = zext i8 %load_mx33 to i16
  store i16 %36, i16* %35, align 2
  br label %call27

call27:                                           ; preds = %input26
  %call34 = call i16 @INC(%INC_interface* %INC_instance25)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  store i16 %call34, i16* %30, align 2
  br label %call22
}

define void @COUNT_DR(%COUNT_DR_interface* %0) {
entry:
  %SET = getelementptr inbounds %COUNT_DR_interface, %COUNT_DR_interface* %0, i32 0, i32 0
  %IN = getelementptr inbounds %COUNT_DR_interface, %COUNT_DR_interface* %0, i32 0, i32 1
  %UP = getelementptr inbounds %COUNT_DR_interface, %COUNT_DR_interface* %0, i32 0, i32 2
  %DN = getelementptr inbounds %COUNT_DR_interface, %COUNT_DR_interface* %0, i32 0, i32 3
  %STEP = getelementptr inbounds %COUNT_DR_interface, %COUNT_DR_interface* %0, i32 0, i32 4
  %MX = getelementptr inbounds %COUNT_DR_interface, %COUNT_DR_interface* %0, i32 0, i32 5
  %RST = getelementptr inbounds %COUNT_DR_interface, %COUNT_DR_interface* %0, i32 0, i32 6
  %CNT = getelementptr inbounds %COUNT_DR_interface, %COUNT_DR_interface* %0, i32 0, i32 7
  %last_up = getelementptr inbounds %COUNT_DR_interface, %COUNT_DR_interface* %0, i32 0, i32 8
  %last_dn = getelementptr inbounds %COUNT_DR_interface, %COUNT_DR_interface* %0, i32 0, i32 9
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i32 0, i32* %CNT, align 4
  br label %continue

branch:                                           ; preds = %entry
  %load_set = load i8, i8* %SET, align 1
  %2 = icmp ne i8 %load_set, 0
  br i1 %2, label %condition_body3, label %branch1

condition_body3:                                  ; preds = %branch
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input

branch1:                                          ; preds = %branch
  %load_up = load i8, i8* %UP, align 1
  %3 = zext i8 %load_up to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %13, label %15

condition_body6:                                  ; preds = %15
  %load_STEP = load i32, i32* %STEP, align 4
  %load_MX = load i32, i32* %MX, align 4
  %load_CNT = load i32, i32* %CNT, align 4
  %tmpVar9 = sub i32 %load_MX, %load_CNT
  %tmpVar10 = icmp sgt i32 %load_STEP, %tmpVar9
  br i1 %tmpVar10, label %condition_body8, label %else

branch2:                                          ; preds = %15
  %load_dn = load i8, i8* %DN, align 1
  %5 = zext i8 %load_dn to i32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %18, label %20

condition_body20:                                 ; preds = %20
  %load_STEP25 = load i32, i32* %STEP, align 4
  %load_CNT26 = load i32, i32* %CNT, align 4
  %tmpVar27 = icmp sgt i32 %load_STEP25, %load_CNT26
  br i1 %tmpVar27, label %condition_body24, label %else22

continue:                                         ; preds = %continue23, %20, %continue7, %continue4, %condition_body
  %load_up37 = load i8, i8* %UP, align 1
  store i8 %load_up37, i8* %last_up, align 1
  %load_dn38 = load i8, i8* %DN, align 1
  store i8 %load_dn38, i8* %last_dn, align 1
  ret void

input:                                            ; preds = %condition_body3
  %7 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %7, align 4
  %8 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_in = load i32, i32* %IN, align 4
  %9 = zext i32 %load_in to i64
  store i64 %9, i64* %8, align 4
  %10 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_mx = load i32, i32* %MX, align 4
  %11 = zext i32 %load_mx to i64
  store i64 %11, i64* %10, align 4
  br label %call

call:                                             ; preds = %input
  %call5 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue4

continue4:                                        ; preds = %output
  %12 = trunc i64 %call5 to i32
  store i32 %12, i32* %CNT, align 4
  br label %continue

13:                                               ; preds = %branch1
  %load_last_up = load i8, i8* %last_up, align 1
  %tmpVar = xor i8 %load_last_up, -1
  %14 = zext i8 %tmpVar to i32
  br label %15

15:                                               ; preds = %13, %branch1
  %16 = phi i32 [ %3, %branch1 ], [ %14, %13 ]
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %condition_body6, label %branch2

condition_body8:                                  ; preds = %condition_body6
  %load_CNT11 = load i32, i32* %CNT, align 4
  %load_MX12 = load i32, i32* %MX, align 4
  %tmpVar13 = sub i32 %load_CNT11, %load_MX12
  %load_STEP14 = load i32, i32* %STEP, align 4
  %tmpVar15 = add i32 %tmpVar13, %load_STEP14
  %tmpVar16 = sub i32 %tmpVar15, 1
  store i32 %tmpVar16, i32* %CNT, align 4
  br label %continue7

else:                                             ; preds = %condition_body6
  %load_CNT17 = load i32, i32* %CNT, align 4
  %load_STEP18 = load i32, i32* %STEP, align 4
  %tmpVar19 = add i32 %load_CNT17, %load_STEP18
  store i32 %tmpVar19, i32* %CNT, align 4
  br label %continue7

continue7:                                        ; preds = %else, %condition_body8
  br label %continue

18:                                               ; preds = %branch2
  %load_last_dn = load i8, i8* %last_dn, align 1
  %tmpVar21 = xor i8 %load_last_dn, -1
  %19 = zext i8 %tmpVar21 to i32
  br label %20

20:                                               ; preds = %18, %branch2
  %21 = phi i32 [ %5, %branch2 ], [ %19, %18 ]
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %condition_body20, label %continue

condition_body24:                                 ; preds = %condition_body20
  %load_CNT28 = load i32, i32* %CNT, align 4
  %load_STEP29 = load i32, i32* %STEP, align 4
  %tmpVar30 = sub i32 %load_CNT28, %load_STEP29
  %load_MX31 = load i32, i32* %MX, align 4
  %tmpVar32 = add i32 %tmpVar30, %load_MX31
  %tmpVar33 = add i32 %tmpVar32, 1
  store i32 %tmpVar33, i32* %CNT, align 4
  br label %continue23

else22:                                           ; preds = %condition_body20
  %load_CNT34 = load i32, i32* %CNT, align 4
  %load_STEP35 = load i32, i32* %STEP, align 4
  %tmpVar36 = sub i32 %load_CNT34, %load_STEP35
  store i32 %tmpVar36, i32* %CNT, align 4
  br label %continue23

continue23:                                       ; preds = %else22, %condition_body24
  br label %continue
}

define void @FF_D2E(%FF_D2E_interface* %0) {
entry:
  %D0 = getelementptr inbounds %FF_D2E_interface, %FF_D2E_interface* %0, i32 0, i32 0
  %D1 = getelementptr inbounds %FF_D2E_interface, %FF_D2E_interface* %0, i32 0, i32 1
  %CLK = getelementptr inbounds %FF_D2E_interface, %FF_D2E_interface* %0, i32 0, i32 2
  %RST = getelementptr inbounds %FF_D2E_interface, %FF_D2E_interface* %0, i32 0, i32 3
  %Q0 = getelementptr inbounds %FF_D2E_interface, %FF_D2E_interface* %0, i32 0, i32 4
  %Q1 = getelementptr inbounds %FF_D2E_interface, %FF_D2E_interface* %0, i32 0, i32 5
  %edge = getelementptr inbounds %FF_D2E_interface, %FF_D2E_interface* %0, i32 0, i32 6
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_clk = load i8, i8* %CLK, align 1
  %2 = zext i8 %load_clk to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %4, label %6

condition_body1:                                  ; preds = %6
  %load_D0 = load i8, i8* %D0, align 1
  store i8 %load_D0, i8* %Q0, align 1
  %load_D1 = load i8, i8* %D1, align 1
  store i8 %load_D1, i8* %Q1, align 1
  br label %continue

continue:                                         ; preds = %condition_body1, %6, %condition_body
  %load_CLK = load i8, i8* %CLK, align 1
  store i8 %load_CLK, i8* %edge, align 1
  ret void

4:                                                ; preds = %branch
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar = xor i8 %load_edge, -1
  %5 = zext i8 %tmpVar to i32
  br label %6

6:                                                ; preds = %4, %branch
  %7 = phi i32 [ %2, %branch ], [ %5, %4 ]
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %condition_body1, label %continue
}

define void @FF_D4E(%FF_D4E_interface* %0) {
entry:
  %D0 = getelementptr inbounds %FF_D4E_interface, %FF_D4E_interface* %0, i32 0, i32 0
  %D1 = getelementptr inbounds %FF_D4E_interface, %FF_D4E_interface* %0, i32 0, i32 1
  %D2 = getelementptr inbounds %FF_D4E_interface, %FF_D4E_interface* %0, i32 0, i32 2
  %D3 = getelementptr inbounds %FF_D4E_interface, %FF_D4E_interface* %0, i32 0, i32 3
  %CLK = getelementptr inbounds %FF_D4E_interface, %FF_D4E_interface* %0, i32 0, i32 4
  %RST = getelementptr inbounds %FF_D4E_interface, %FF_D4E_interface* %0, i32 0, i32 5
  %Q0 = getelementptr inbounds %FF_D4E_interface, %FF_D4E_interface* %0, i32 0, i32 6
  %Q1 = getelementptr inbounds %FF_D4E_interface, %FF_D4E_interface* %0, i32 0, i32 7
  %Q2 = getelementptr inbounds %FF_D4E_interface, %FF_D4E_interface* %0, i32 0, i32 8
  %Q3 = getelementptr inbounds %FF_D4E_interface, %FF_D4E_interface* %0, i32 0, i32 9
  %edge = getelementptr inbounds %FF_D4E_interface, %FF_D4E_interface* %0, i32 0, i32 10
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_clk = load i8, i8* %CLK, align 1
  %2 = zext i8 %load_clk to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %4, label %6

condition_body1:                                  ; preds = %6
  %load_D0 = load i8, i8* %D0, align 1
  store i8 %load_D0, i8* %Q0, align 1
  %load_D1 = load i8, i8* %D1, align 1
  store i8 %load_D1, i8* %Q1, align 1
  %load_D2 = load i8, i8* %D2, align 1
  store i8 %load_D2, i8* %Q2, align 1
  %load_D3 = load i8, i8* %D3, align 1
  store i8 %load_D3, i8* %Q3, align 1
  br label %continue

continue:                                         ; preds = %condition_body1, %6, %condition_body
  %load_CLK = load i8, i8* %CLK, align 1
  store i8 %load_CLK, i8* %edge, align 1
  ret void

4:                                                ; preds = %branch
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar = xor i8 %load_edge, -1
  %5 = zext i8 %tmpVar to i32
  br label %6

6:                                                ; preds = %4, %branch
  %7 = phi i32 [ %2, %branch ], [ %5, %4 ]
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %condition_body1, label %continue
}

define void @FF_DRE(%FF_DRE_interface* %0) {
entry:
  %SET = getelementptr inbounds %FF_DRE_interface, %FF_DRE_interface* %0, i32 0, i32 0
  %D = getelementptr inbounds %FF_DRE_interface, %FF_DRE_interface* %0, i32 0, i32 1
  %CLK = getelementptr inbounds %FF_DRE_interface, %FF_DRE_interface* %0, i32 0, i32 2
  %RST = getelementptr inbounds %FF_DRE_interface, %FF_DRE_interface* %0, i32 0, i32 3
  %Q = getelementptr inbounds %FF_DRE_interface, %FF_DRE_interface* %0, i32 0, i32 4
  %edge = getelementptr inbounds %FF_DRE_interface, %FF_DRE_interface* %0, i32 0, i32 5
  %load_rst = load i8, i8* %RST, align 1
  %1 = zext i8 %load_rst to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %7, label %5

condition_body:                                   ; preds = %7
  %load_rst1 = load i8, i8* %RST, align 1
  %tmpVar = xor i8 %load_rst1, -1
  store i8 %tmpVar, i8* %Q, align 1
  br label %continue

branch:                                           ; preds = %7
  %load_clk = load i8, i8* %CLK, align 1
  %3 = zext i8 %load_clk to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %10, label %12

condition_body2:                                  ; preds = %12
  %load_D = load i8, i8* %D, align 1
  store i8 %load_D, i8* %Q, align 1
  br label %continue

continue:                                         ; preds = %condition_body2, %12, %condition_body
  %load_CLK = load i8, i8* %CLK, align 1
  store i8 %load_CLK, i8* %edge, align 1
  ret void

5:                                                ; preds = %entry
  %load_set = load i8, i8* %SET, align 1
  %6 = zext i8 %load_set to i32
  br label %7

7:                                                ; preds = %5, %entry
  %8 = phi i32 [ %1, %entry ], [ %6, %5 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body, label %branch

10:                                               ; preds = %branch
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar3 = xor i8 %load_edge, -1
  %11 = zext i8 %tmpVar3 to i32
  br label %12

12:                                               ; preds = %10, %branch
  %13 = phi i32 [ %3, %branch ], [ %11, %10 ]
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %condition_body2, label %continue
}

define void @FF_JKE(%FF_JKE_interface* %0) {
entry:
  %SET = getelementptr inbounds %FF_JKE_interface, %FF_JKE_interface* %0, i32 0, i32 0
  %J = getelementptr inbounds %FF_JKE_interface, %FF_JKE_interface* %0, i32 0, i32 1
  %CLK = getelementptr inbounds %FF_JKE_interface, %FF_JKE_interface* %0, i32 0, i32 2
  %K = getelementptr inbounds %FF_JKE_interface, %FF_JKE_interface* %0, i32 0, i32 3
  %RST = getelementptr inbounds %FF_JKE_interface, %FF_JKE_interface* %0, i32 0, i32 4
  %Q = getelementptr inbounds %FF_JKE_interface, %FF_JKE_interface* %0, i32 0, i32 5
  %edge = getelementptr inbounds %FF_JKE_interface, %FF_JKE_interface* %0, i32 0, i32 6
  %load_rst = load i8, i8* %RST, align 1
  %1 = zext i8 %load_rst to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %10, label %8

condition_body:                                   ; preds = %10
  %load_rst1 = load i8, i8* %RST, align 1
  %tmpVar = xor i8 %load_rst1, -1
  store i8 %tmpVar, i8* %Q, align 1
  br label %continue

branch:                                           ; preds = %10
  %load_clk = load i8, i8* %CLK, align 1
  %3 = zext i8 %load_clk to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %13, label %15

condition_body2:                                  ; preds = %15
  %load_J = load i8, i8* %J, align 1
  %5 = zext i8 %load_J to i32
  %load_K = load i8, i8* %K, align 1
  %6 = zext i8 %load_K to i32
  %tmpVar6 = xor i32 %5, %6
  %7 = icmp ne i32 %tmpVar6, 0
  br i1 %7, label %condition_body5, label %else

continue:                                         ; preds = %continue4, %15, %condition_body
  %load_CLK = load i8, i8* %CLK, align 1
  store i8 %load_CLK, i8* %edge, align 1
  ret void

8:                                                ; preds = %entry
  %load_set = load i8, i8* %SET, align 1
  %9 = zext i8 %load_set to i32
  br label %10

10:                                               ; preds = %8, %entry
  %11 = phi i32 [ %1, %entry ], [ %9, %8 ]
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %condition_body, label %branch

13:                                               ; preds = %branch
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar3 = xor i8 %load_edge, -1
  %14 = zext i8 %tmpVar3 to i32
  br label %15

15:                                               ; preds = %13, %branch
  %16 = phi i32 [ %3, %branch ], [ %14, %13 ]
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %condition_body2, label %continue

condition_body5:                                  ; preds = %condition_body2
  %load_J7 = load i8, i8* %J, align 1
  store i8 %load_J7, i8* %Q, align 1
  br label %continue4

else:                                             ; preds = %condition_body2
  %load_K8 = load i8, i8* %K, align 1
  %18 = zext i8 %load_K8 to i32
  %load_Q = load i8, i8* %Q, align 1
  %19 = zext i8 %load_Q to i32
  %tmpVar9 = xor i32 %18, %19
  store i32 %tmpVar9, i8* %Q, align 4
  br label %continue4

continue4:                                        ; preds = %else, %condition_body5
  br label %continue
}

define void @FF_RSE(%FF_RSE_interface* %0) {
entry:
  %CS = getelementptr inbounds %FF_RSE_interface, %FF_RSE_interface* %0, i32 0, i32 0
  %CR = getelementptr inbounds %FF_RSE_interface, %FF_RSE_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %FF_RSE_interface, %FF_RSE_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %FF_RSE_interface, %FF_RSE_interface* %0, i32 0, i32 3
  %es = getelementptr inbounds %FF_RSE_interface, %FF_RSE_interface* %0, i32 0, i32 4
  %er = getelementptr inbounds %FF_RSE_interface, %FF_RSE_interface* %0, i32 0, i32 5
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_CR = load i8, i8* %CR, align 1
  %2 = zext i8 %load_CR to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %6, label %8

condition_body2:                                  ; preds = %8
  store i8 0, i8* %Q, align 1
  br label %continue

branch1:                                          ; preds = %8
  %load_CS = load i8, i8* %CS, align 1
  %4 = zext i8 %load_CS to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %11, label %13

condition_body3:                                  ; preds = %13
  store i8 1, i8* %Q, align 1
  br label %continue

continue:                                         ; preds = %condition_body3, %13, %condition_body2, %condition_body
  %load_CS5 = load i8, i8* %CS, align 1
  store i8 %load_CS5, i8* %es, align 1
  %load_CR6 = load i8, i8* %CR, align 1
  store i8 %load_CR6, i8* %er, align 1
  ret void

6:                                                ; preds = %branch
  %load_er = load i8, i8* %er, align 1
  %tmpVar = xor i8 %load_er, -1
  %7 = zext i8 %tmpVar to i32
  br label %8

8:                                                ; preds = %6, %branch
  %9 = phi i32 [ %2, %branch ], [ %7, %6 ]
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %condition_body2, label %branch1

11:                                               ; preds = %branch1
  %load_es = load i8, i8* %es, align 1
  %tmpVar4 = xor i8 %load_es, -1
  %12 = zext i8 %tmpVar4 to i32
  br label %13

13:                                               ; preds = %11, %branch1
  %14 = phi i32 [ %4, %branch1 ], [ %12, %11 ]
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %condition_body3, label %continue
}

define void @SELECT_8(%SELECT_8_interface* %0) {
entry:
  %E = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 0
  %SET = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 1
  %IN = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 2
  %UP = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 3
  %DN = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 4
  %RST = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 5
  %Q0 = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 6
  %Q1 = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 7
  %Q2 = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 8
  %Q3 = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 9
  %Q4 = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 10
  %Q5 = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 11
  %Q6 = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 12
  %Q7 = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 13
  %STATE = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 14
  %last_up = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 15
  %last_dn = getelementptr inbounds %SELECT_8_interface, %SELECT_8_interface* %0, i32 0, i32 16
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i16 0, i16* %STATE, align 2
  br label %continue

branch:                                           ; preds = %entry
  %load_set = load i8, i8* %SET, align 1
  %2 = icmp ne i8 %load_set, 0
  br i1 %2, label %condition_body3, label %branch1

condition_body3:                                  ; preds = %branch
  %load_IN = load i8, i8* %IN, align 1
  %3 = zext i8 %load_IN to i16
  store i16 %3, i16* %STATE, align 2
  br label %continue

branch1:                                          ; preds = %branch
  %load_up = load i8, i8* %UP, align 1
  %4 = zext i8 %load_up to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %9, label %11

condition_body4:                                  ; preds = %11
  %INC_instance = alloca %INC_interface, align 8
  br label %input

branch2:                                          ; preds = %11
  %load_dn = load i8, i8* %DN, align 1
  %6 = zext i8 %load_dn to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %17, label %19

condition_body7:                                  ; preds = %19
  %INC_instance9 = alloca %INC_interface, align 8
  br label %input10

continue:                                         ; preds = %continue13, %19, %continue5, %condition_body3, %condition_body
  %load_UP = load i8, i8* %UP, align 1
  store i8 %load_UP, i8* %last_up, align 1
  %load_DN = load i8, i8* %DN, align 1
  store i8 %load_DN, i8* %last_dn, align 1
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i8 0, i8* %Q4, align 1
  store i8 0, i8* %Q5, align 1
  store i8 0, i8* %Q6, align 1
  store i8 0, i8* %Q7, align 1
  %load_E = load i8, i8* %E, align 1
  %8 = icmp ne i8 %load_E, 0
  br i1 %8, label %condition_body17, label %continue16

9:                                                ; preds = %branch1
  %load_last_up = load i8, i8* %last_up, align 1
  %tmpVar = xor i8 %load_last_up, -1
  %10 = zext i8 %tmpVar to i32
  br label %11

11:                                               ; preds = %9, %branch1
  %12 = phi i32 [ %4, %branch1 ], [ %10, %9 ]
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %condition_body4, label %branch2

input:                                            ; preds = %condition_body4
  %14 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance, i32 0, i32 0
  %load_state = load i16, i16* %STATE, align 2
  store i16 %load_state, i16* %14, align 2
  %15 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance, i32 0, i32 1
  store i16 1, i16* %15, align 2
  %16 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance, i32 0, i32 2
  store i16 7, i16* %16, align 2
  br label %call

call:                                             ; preds = %input
  %call6 = call i16 @INC(%INC_interface* %INC_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue5

continue5:                                        ; preds = %output
  store i16 %call6, i16* %STATE, align 2
  br label %continue

17:                                               ; preds = %branch2
  %load_last_dn = load i8, i8* %last_dn, align 1
  %tmpVar8 = xor i8 %load_last_dn, -1
  %18 = zext i8 %tmpVar8 to i32
  br label %19

19:                                               ; preds = %17, %branch2
  %20 = phi i32 [ %6, %branch2 ], [ %18, %17 ]
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %condition_body7, label %continue

input10:                                          ; preds = %condition_body7
  %22 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance9, i32 0, i32 0
  %load_state14 = load i16, i16* %STATE, align 2
  store i16 %load_state14, i16* %22, align 2
  %23 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance9, i32 0, i32 1
  store i16 -1, i16* %23, align 2
  %24 = getelementptr inbounds %INC_interface, %INC_interface* %INC_instance9, i32 0, i32 2
  store i16 7, i16* %24, align 2
  br label %call11

call11:                                           ; preds = %input10
  %call15 = call i16 @INC(%INC_interface* %INC_instance9)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  store i16 %call15, i16* %STATE, align 2
  br label %continue

condition_body17:                                 ; preds = %continue
  %load_state19 = load i16, i16* %STATE, align 2
  switch i16 %load_state19, label %else [
    i16 0, label %case
    i16 1, label %case20
    i16 2, label %case21
    i16 3, label %case22
    i16 4, label %case23
    i16 5, label %case24
    i16 6, label %case25
    i16 7, label %case26
  ]

continue16:                                       ; preds = %continue18, %continue
  ret void

case:                                             ; preds = %condition_body17
  store i8 1, i8* %Q0, align 1
  br label %continue18

case20:                                           ; preds = %condition_body17
  store i8 1, i8* %Q1, align 1
  br label %continue18

case21:                                           ; preds = %condition_body17
  store i8 1, i8* %Q2, align 1
  br label %continue18

case22:                                           ; preds = %condition_body17
  store i8 1, i8* %Q3, align 1
  br label %continue18

case23:                                           ; preds = %condition_body17
  store i8 1, i8* %Q4, align 1
  br label %continue18

case24:                                           ; preds = %condition_body17
  store i8 1, i8* %Q5, align 1
  br label %continue18

case25:                                           ; preds = %condition_body17
  store i8 1, i8* %Q6, align 1
  br label %continue18

case26:                                           ; preds = %condition_body17
  store i8 1, i8* %Q7, align 1
  br label %continue18

else:                                             ; preds = %condition_body17
  br label %continue18

continue18:                                       ; preds = %else, %case26, %case25, %case24, %case23, %case22, %case21, %case20, %case
  br label %continue16
}

define void @SHR_4E(%SHR_4E_interface* %0) {
entry:
  %SET = getelementptr inbounds %SHR_4E_interface, %SHR_4E_interface* %0, i32 0, i32 0
  %D0 = getelementptr inbounds %SHR_4E_interface, %SHR_4E_interface* %0, i32 0, i32 1
  %CLK = getelementptr inbounds %SHR_4E_interface, %SHR_4E_interface* %0, i32 0, i32 2
  %RST = getelementptr inbounds %SHR_4E_interface, %SHR_4E_interface* %0, i32 0, i32 3
  %Q0 = getelementptr inbounds %SHR_4E_interface, %SHR_4E_interface* %0, i32 0, i32 4
  %Q1 = getelementptr inbounds %SHR_4E_interface, %SHR_4E_interface* %0, i32 0, i32 5
  %Q2 = getelementptr inbounds %SHR_4E_interface, %SHR_4E_interface* %0, i32 0, i32 6
  %Q3 = getelementptr inbounds %SHR_4E_interface, %SHR_4E_interface* %0, i32 0, i32 7
  %trig = getelementptr inbounds %SHR_4E_interface, %SHR_4E_interface* %0, i32 0, i32 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %R_TRIG_interface, %R_TRIG_interface* %trig, i32 0, i32 0
  %load_clk = load i8, i8* %CLK, align 1
  store i8 %load_clk, i8* %1, align 1
  br label %call

call:                                             ; preds = %input
  call void @R_TRIG(%R_TRIG_interface* %trig)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_set = load i8, i8* %SET, align 1
  %2 = zext i8 %load_set to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %7, label %5

condition_body:                                   ; preds = %7
  %load_rst2 = load i8, i8* %RST, align 1
  %tmpVar = xor i8 %load_rst2, -1
  store i8 %tmpVar, i8* %Q0, align 1
  %load_Q0 = load i8, i8* %Q0, align 1
  store i8 %load_Q0, i8* %Q1, align 1
  %load_Q03 = load i8, i8* %Q0, align 1
  store i8 %load_Q03, i8* %Q2, align 1
  %load_Q04 = load i8, i8* %Q0, align 1
  store i8 %load_Q04, i8* %Q3, align 1
  br label %continue1

branch:                                           ; preds = %7
  %Q = getelementptr inbounds %R_TRIG_interface, %R_TRIG_interface* %trig, i32 0, i32 1
  %load_ = load i8, i8* %Q, align 1
  %4 = icmp ne i8 %load_, 0
  br i1 %4, label %condition_body5, label %continue1

condition_body5:                                  ; preds = %branch
  %load_Q2 = load i8, i8* %Q2, align 1
  store i8 %load_Q2, i8* %Q3, align 1
  %load_Q1 = load i8, i8* %Q1, align 1
  store i8 %load_Q1, i8* %Q2, align 1
  %load_Q06 = load i8, i8* %Q0, align 1
  store i8 %load_Q06, i8* %Q1, align 1
  %load_D0 = load i8, i8* %D0, align 1
  store i8 %load_D0, i8* %Q0, align 1
  br label %continue1

continue1:                                        ; preds = %condition_body5, %branch, %condition_body
  ret void

5:                                                ; preds = %continue
  %load_rst = load i8, i8* %RST, align 1
  %6 = zext i8 %load_rst to i32
  br label %7

7:                                                ; preds = %5, %continue
  %8 = phi i32 [ %2, %continue ], [ %6, %5 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body, label %branch
}

define void @SHR_4UDE(%SHR_4UDE_interface* %0) {
entry:
  %SET = getelementptr inbounds %SHR_4UDE_interface, %SHR_4UDE_interface* %0, i32 0, i32 0
  %D0 = getelementptr inbounds %SHR_4UDE_interface, %SHR_4UDE_interface* %0, i32 0, i32 1
  %D3 = getelementptr inbounds %SHR_4UDE_interface, %SHR_4UDE_interface* %0, i32 0, i32 2
  %CLK = getelementptr inbounds %SHR_4UDE_interface, %SHR_4UDE_interface* %0, i32 0, i32 3
  %DN = getelementptr inbounds %SHR_4UDE_interface, %SHR_4UDE_interface* %0, i32 0, i32 4
  %RST = getelementptr inbounds %SHR_4UDE_interface, %SHR_4UDE_interface* %0, i32 0, i32 5
  %Q0 = getelementptr inbounds %SHR_4UDE_interface, %SHR_4UDE_interface* %0, i32 0, i32 6
  %Q1 = getelementptr inbounds %SHR_4UDE_interface, %SHR_4UDE_interface* %0, i32 0, i32 7
  %Q2 = getelementptr inbounds %SHR_4UDE_interface, %SHR_4UDE_interface* %0, i32 0, i32 8
  %Q3 = getelementptr inbounds %SHR_4UDE_interface, %SHR_4UDE_interface* %0, i32 0, i32 9
  %trig = getelementptr inbounds %SHR_4UDE_interface, %SHR_4UDE_interface* %0, i32 0, i32 10
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %R_TRIG_interface, %R_TRIG_interface* %trig, i32 0, i32 0
  %load_clk = load i8, i8* %CLK, align 1
  store i8 %load_clk, i8* %1, align 1
  br label %call

call:                                             ; preds = %input
  call void @R_TRIG(%R_TRIG_interface* %trig)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_set = load i8, i8* %SET, align 1
  %2 = zext i8 %load_set to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %8, label %6

condition_body:                                   ; preds = %8
  %load_RST = load i8, i8* %RST, align 1
  %tmpVar = xor i8 %load_RST, -1
  store i8 %tmpVar, i8* %Q0, align 1
  %load_Q0 = load i8, i8* %Q0, align 1
  store i8 %load_Q0, i8* %Q1, align 1
  %load_Q02 = load i8, i8* %Q0, align 1
  store i8 %load_Q02, i8* %Q2, align 1
  %load_Q03 = load i8, i8* %Q0, align 1
  store i8 %load_Q03, i8* %Q3, align 1
  br label %continue1

branch:                                           ; preds = %8
  %Q = getelementptr inbounds %R_TRIG_interface, %R_TRIG_interface* %trig, i32 0, i32 1
  %load_ = load i8, i8* %Q, align 1
  %4 = icmp ne i8 %load_, 0
  br i1 %4, label %condition_body4, label %continue1

condition_body4:                                  ; preds = %branch
  %load_dn = load i8, i8* %DN, align 1
  %5 = icmp ne i8 %load_dn, 0
  br i1 %5, label %condition_body6, label %else

continue1:                                        ; preds = %continue5, %branch, %condition_body
  ret void

6:                                                ; preds = %continue
  %load_rst = load i8, i8* %RST, align 1
  %7 = zext i8 %load_rst to i32
  br label %8

8:                                                ; preds = %6, %continue
  %9 = phi i32 [ %2, %continue ], [ %7, %6 ]
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %condition_body, label %branch

condition_body6:                                  ; preds = %condition_body4
  %load_Q1 = load i8, i8* %Q1, align 1
  store i8 %load_Q1, i8* %Q0, align 1
  %load_Q2 = load i8, i8* %Q2, align 1
  store i8 %load_Q2, i8* %Q1, align 1
  %load_Q3 = load i8, i8* %Q3, align 1
  store i8 %load_Q3, i8* %Q2, align 1
  %load_D3 = load i8, i8* %D3, align 1
  store i8 %load_D3, i8* %Q3, align 1
  br label %continue5

else:                                             ; preds = %condition_body4
  %load_Q27 = load i8, i8* %Q2, align 1
  store i8 %load_Q27, i8* %Q3, align 1
  %load_Q18 = load i8, i8* %Q1, align 1
  store i8 %load_Q18, i8* %Q2, align 1
  %load_Q09 = load i8, i8* %Q0, align 1
  store i8 %load_Q09, i8* %Q1, align 1
  %load_D0 = load i8, i8* %D0, align 1
  store i8 %load_D0, i8* %Q0, align 1
  br label %continue5

continue5:                                        ; preds = %else, %condition_body6
  br label %continue1
}

define void @SHR_8PLE(%SHR_8PLE_interface* %0) {
entry:
  %Din = getelementptr inbounds %SHR_8PLE_interface, %SHR_8PLE_interface* %0, i32 0, i32 0
  %Dload = getelementptr inbounds %SHR_8PLE_interface, %SHR_8PLE_interface* %0, i32 0, i32 1
  %CLK = getelementptr inbounds %SHR_8PLE_interface, %SHR_8PLE_interface* %0, i32 0, i32 2
  %UP = getelementptr inbounds %SHR_8PLE_interface, %SHR_8PLE_interface* %0, i32 0, i32 3
  %load = getelementptr inbounds %SHR_8PLE_interface, %SHR_8PLE_interface* %0, i32 0, i32 4
  %RST = getelementptr inbounds %SHR_8PLE_interface, %SHR_8PLE_interface* %0, i32 0, i32 5
  %DOut = getelementptr inbounds %SHR_8PLE_interface, %SHR_8PLE_interface* %0, i32 0, i32 6
  %edge = getelementptr inbounds %SHR_8PLE_interface, %SHR_8PLE_interface* %0, i32 0, i32 7
  %register = getelementptr inbounds %SHR_8PLE_interface, %SHR_8PLE_interface* %0, i32 0, i32 8
  %load_CLK = load i8, i8* %CLK, align 1
  %1 = zext i8 %load_CLK to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %10, label %12

condition_body:                                   ; preds = %7
  store i8 0, i8* %edge, align 1
  %load_UP = load i8, i8* %UP, align 1
  %3 = icmp ne i8 %load_UP, 0
  br i1 %3, label %condition_body2, label %else

continue:                                         ; preds = %continue18, %7
  %load_clk = load i8, i8* %CLK, align 1
  %tmpVar29 = xor i8 %load_clk, -1
  %4 = icmp ne i8 %tmpVar29, 0
  br i1 %4, label %condition_body28, label %continue27

5:                                                ; preds = %12
  %load_rst = load i8, i8* %RST, align 1
  %tmpVar = xor i8 %load_rst, -1
  %6 = zext i8 %tmpVar to i32
  br label %7

7:                                                ; preds = %5, %12
  %8 = phi i32 [ %13, %12 ], [ %6, %5 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body, label %continue

10:                                               ; preds = %entry
  %load_edge = load i8, i8* %edge, align 1
  %11 = zext i8 %load_edge to i32
  br label %12

12:                                               ; preds = %10, %entry
  %13 = phi i32 [ %1, %entry ], [ %11, %10 ]
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %5, label %7

condition_body2:                                  ; preds = %condition_body
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

else:                                             ; preds = %condition_body
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input6

continue1:                                        ; preds = %continue9, %continue3
  %load_load = load i8, i8* %load, align 1
  %15 = icmp ne i8 %load_load, 0
  br i1 %15, label %condition_body19, label %continue18

input:                                            ; preds = %condition_body2
  %16 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_register = load i8, i8* %register, align 1
  %17 = zext i8 %load_register to i64
  store i64 %17, i64* %16, align 4
  %18 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 1, i16* %18, align 2
  br label %call

call:                                             ; preds = %input
  %call4 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  %19 = trunc i64 %call4 to i8
  store i8 %19, i8* %register, align 1
  %20 = load i8, i8* %register, align 1
  %erase = and i8 %20, -2
  %load_Din = load i8, i8* %Din, align 1
  %value = shl i8 %load_Din, 0
  %or = or i8 %erase, %value
  store i8 %or, i8* %register, align 1
  %load_register5 = load i8, i8* %register, align 1
  %shift = lshr i8 %load_register5, 7
  store i8 %shift, i8* %DOut, align 1
  br label %continue1

input6:                                           ; preds = %else
  %21 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_register10 = load i8, i8* %register, align 1
  %22 = zext i8 %load_register10 to i64
  store i64 %22, i64* %21, align 4
  %23 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 1, i16* %23, align 2
  br label %call7

call7:                                            ; preds = %input6
  %call11 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %24 = trunc i64 %call11 to i8
  store i8 %24, i8* %register, align 1
  %25 = load i8, i8* %register, align 1
  %erase12 = and i8 %25, 127
  %load_Din13 = load i8, i8* %Din, align 1
  %value14 = shl i8 %load_Din13, 7
  %or15 = or i8 %erase12, %value14
  store i8 %or15, i8* %register, align 1
  %load_register16 = load i8, i8* %register, align 1
  %shift17 = lshr i8 %load_register16, 0
  store i8 %shift17, i8* %DOut, align 1
  br label %continue1

condition_body19:                                 ; preds = %continue1
  %load_Dload = load i8, i8* %Dload, align 1
  store i8 %load_Dload, i8* %register, align 1
  %load_up = load i8, i8* %UP, align 1
  %26 = icmp ne i8 %load_up, 0
  br i1 %26, label %condition_body22, label %else20

continue18:                                       ; preds = %continue21, %continue1
  br label %continue

condition_body22:                                 ; preds = %condition_body19
  %load_register23 = load i8, i8* %register, align 1
  %shift24 = lshr i8 %load_register23, 7
  store i8 %shift24, i8* %DOut, align 1
  br label %continue21

else20:                                           ; preds = %condition_body19
  %load_register25 = load i8, i8* %register, align 1
  %shift26 = lshr i8 %load_register25, 0
  store i8 %shift26, i8* %DOut, align 1
  br label %continue21

continue21:                                       ; preds = %else20, %condition_body22
  br label %continue18

condition_body28:                                 ; preds = %continue
  store i8 1, i8* %edge, align 1
  br label %continue27

continue27:                                       ; preds = %condition_body28, %continue
  %load_rst32 = load i8, i8* %RST, align 1
  %27 = icmp ne i8 %load_rst32, 0
  br i1 %27, label %condition_body31, label %continue30

condition_body31:                                 ; preds = %continue27
  store i8 0, i8* %register, align 1
  store i8 0, i8* %DOut, align 1
  br label %continue30

continue30:                                       ; preds = %condition_body31, %continue27
  ret void
}

define void @SHR_8UDE(%SHR_8UDE_interface* %0) {
entry:
  %SET = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 0
  %D0 = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 1
  %D7 = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 2
  %CLK = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 3
  %DN = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 4
  %RST = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 5
  %Q0 = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 6
  %Q1 = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 7
  %Q2 = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 8
  %Q3 = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 9
  %Q4 = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 10
  %Q5 = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 11
  %Q6 = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 12
  %Q7 = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 13
  %trig = getelementptr inbounds %SHR_8UDE_interface, %SHR_8UDE_interface* %0, i32 0, i32 14
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %R_TRIG_interface, %R_TRIG_interface* %trig, i32 0, i32 0
  %load_clk = load i8, i8* %CLK, align 1
  store i8 %load_clk, i8* %1, align 1
  br label %call

call:                                             ; preds = %input
  call void @R_TRIG(%R_TRIG_interface* %trig)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_set = load i8, i8* %SET, align 1
  %2 = zext i8 %load_set to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %8, label %6

condition_body:                                   ; preds = %8
  %load_RST = load i8, i8* %RST, align 1
  %tmpVar = xor i8 %load_RST, -1
  store i8 %tmpVar, i8* %Q0, align 1
  %load_Q0 = load i8, i8* %Q0, align 1
  store i8 %load_Q0, i8* %Q1, align 1
  %load_Q02 = load i8, i8* %Q0, align 1
  store i8 %load_Q02, i8* %Q2, align 1
  %load_Q03 = load i8, i8* %Q0, align 1
  store i8 %load_Q03, i8* %Q3, align 1
  %load_Q04 = load i8, i8* %Q0, align 1
  store i8 %load_Q04, i8* %Q4, align 1
  %load_Q05 = load i8, i8* %Q0, align 1
  store i8 %load_Q05, i8* %Q5, align 1
  %load_Q06 = load i8, i8* %Q0, align 1
  store i8 %load_Q06, i8* %Q6, align 1
  %load_Q07 = load i8, i8* %Q0, align 1
  store i8 %load_Q07, i8* %Q7, align 1
  br label %continue1

branch:                                           ; preds = %8
  %Q = getelementptr inbounds %R_TRIG_interface, %R_TRIG_interface* %trig, i32 0, i32 1
  %load_ = load i8, i8* %Q, align 1
  %4 = icmp ne i8 %load_, 0
  br i1 %4, label %condition_body8, label %continue1

condition_body8:                                  ; preds = %branch
  %load_dn = load i8, i8* %DN, align 1
  %5 = icmp ne i8 %load_dn, 0
  br i1 %5, label %condition_body10, label %else

continue1:                                        ; preds = %continue9, %branch, %condition_body
  ret void

6:                                                ; preds = %continue
  %load_rst = load i8, i8* %RST, align 1
  %7 = zext i8 %load_rst to i32
  br label %8

8:                                                ; preds = %6, %continue
  %9 = phi i32 [ %2, %continue ], [ %7, %6 ]
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %condition_body, label %branch

condition_body10:                                 ; preds = %condition_body8
  %load_Q1 = load i8, i8* %Q1, align 1
  store i8 %load_Q1, i8* %Q0, align 1
  %load_Q2 = load i8, i8* %Q2, align 1
  store i8 %load_Q2, i8* %Q1, align 1
  %load_Q3 = load i8, i8* %Q3, align 1
  store i8 %load_Q3, i8* %Q2, align 1
  %load_Q4 = load i8, i8* %Q4, align 1
  store i8 %load_Q4, i8* %Q3, align 1
  %load_Q5 = load i8, i8* %Q5, align 1
  store i8 %load_Q5, i8* %Q4, align 1
  %load_Q6 = load i8, i8* %Q6, align 1
  store i8 %load_Q6, i8* %Q5, align 1
  %load_Q7 = load i8, i8* %Q7, align 1
  store i8 %load_Q7, i8* %Q6, align 1
  %load_D7 = load i8, i8* %D7, align 1
  store i8 %load_D7, i8* %Q7, align 1
  br label %continue9

else:                                             ; preds = %condition_body8
  %load_Q611 = load i8, i8* %Q6, align 1
  store i8 %load_Q611, i8* %Q7, align 1
  %load_Q512 = load i8, i8* %Q5, align 1
  store i8 %load_Q512, i8* %Q6, align 1
  %load_Q413 = load i8, i8* %Q4, align 1
  store i8 %load_Q413, i8* %Q5, align 1
  %load_Q314 = load i8, i8* %Q3, align 1
  store i8 %load_Q314, i8* %Q4, align 1
  %load_Q215 = load i8, i8* %Q2, align 1
  store i8 %load_Q215, i8* %Q3, align 1
  %load_Q116 = load i8, i8* %Q1, align 1
  store i8 %load_Q116, i8* %Q2, align 1
  %load_Q017 = load i8, i8* %Q0, align 1
  store i8 %load_Q017, i8* %Q1, align 1
  %load_D0 = load i8, i8* %D0, align 1
  store i8 %load_D0, i8* %Q0, align 1
  br label %continue9

continue9:                                        ; preds = %else, %condition_body10
  br label %continue1
}

define void @TOGGLE(%TOGGLE_interface* %0) {
entry:
  %CLK = getelementptr inbounds %TOGGLE_interface, %TOGGLE_interface* %0, i32 0, i32 0
  %rst = getelementptr inbounds %TOGGLE_interface, %TOGGLE_interface* %0, i32 0, i32 1
  %Q = getelementptr inbounds %TOGGLE_interface, %TOGGLE_interface* %0, i32 0, i32 2
  %edge = getelementptr inbounds %TOGGLE_interface, %TOGGLE_interface* %0, i32 0, i32 3
  %load_rst = load i8, i8* %rst, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_clk = load i8, i8* %CLK, align 1
  %2 = zext i8 %load_clk to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %4, label %6

condition_body1:                                  ; preds = %6
  %load_Q = load i8, i8* %Q, align 1
  %tmpVar2 = xor i8 %load_Q, -1
  store i8 %tmpVar2, i8* %Q, align 1
  br label %continue

continue:                                         ; preds = %condition_body1, %6, %condition_body
  %load_clk3 = load i8, i8* %CLK, align 1
  store i8 %load_clk3, i8* %edge, align 1
  ret void

4:                                                ; preds = %branch
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar = xor i8 %load_edge, -1
  %5 = zext i8 %tmpVar to i32
  br label %6

6:                                                ; preds = %4, %branch
  %7 = phi i32 [ %2, %branch ], [ %5, %4 ]
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %condition_body1, label %continue
}

define void @LTCH(%LTCH_interface* %0) {
entry:
  %D = getelementptr inbounds %LTCH_interface, %LTCH_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %LTCH_interface, %LTCH_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %LTCH_interface, %LTCH_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %LTCH_interface, %LTCH_interface* %0, i32 0, i32 3
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_L = load i8, i8* %L, align 1
  %2 = icmp ne i8 %load_L, 0
  br i1 %2, label %condition_body1, label %continue

condition_body1:                                  ; preds = %branch
  %load_D = load i8, i8* %D, align 1
  store i8 %load_D, i8* %Q, align 1
  br label %continue

continue:                                         ; preds = %condition_body1, %branch, %condition_body
  ret void
}

define void @LTCH_4(%LTCH_4_interface* %0) {
entry:
  %D0 = getelementptr inbounds %LTCH_4_interface, %LTCH_4_interface* %0, i32 0, i32 0
  %D1 = getelementptr inbounds %LTCH_4_interface, %LTCH_4_interface* %0, i32 0, i32 1
  %D2 = getelementptr inbounds %LTCH_4_interface, %LTCH_4_interface* %0, i32 0, i32 2
  %D3 = getelementptr inbounds %LTCH_4_interface, %LTCH_4_interface* %0, i32 0, i32 3
  %L = getelementptr inbounds %LTCH_4_interface, %LTCH_4_interface* %0, i32 0, i32 4
  %RST = getelementptr inbounds %LTCH_4_interface, %LTCH_4_interface* %0, i32 0, i32 5
  %Q0 = getelementptr inbounds %LTCH_4_interface, %LTCH_4_interface* %0, i32 0, i32 6
  %Q1 = getelementptr inbounds %LTCH_4_interface, %LTCH_4_interface* %0, i32 0, i32 7
  %Q2 = getelementptr inbounds %LTCH_4_interface, %LTCH_4_interface* %0, i32 0, i32 8
  %Q3 = getelementptr inbounds %LTCH_4_interface, %LTCH_4_interface* %0, i32 0, i32 9
  %load_rst = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_L = load i8, i8* %L, align 1
  %2 = icmp ne i8 %load_L, 0
  br i1 %2, label %condition_body1, label %continue

condition_body1:                                  ; preds = %branch
  %load_D0 = load i8, i8* %D0, align 1
  store i8 %load_D0, i8* %Q0, align 1
  %load_D1 = load i8, i8* %D1, align 1
  store i8 %load_D1, i8* %Q1, align 1
  %load_D2 = load i8, i8* %D2, align 1
  store i8 %load_D2, i8* %Q2, align 1
  %load_D3 = load i8, i8* %D3, align 1
  store i8 %load_D3, i8* %Q3, align 1
  br label %continue

continue:                                         ; preds = %condition_body1, %branch, %condition_body
  ret void
}

define void @STORE_8(%STORE_8_interface* %0) {
entry:
  %Set = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 0
  %D0 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 1
  %D1 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 2
  %D2 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 3
  %D3 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 4
  %D4 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 5
  %D5 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 6
  %D6 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 7
  %D7 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 8
  %Clr = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 9
  %Rst = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 10
  %Q0 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 11
  %Q1 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 12
  %Q2 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 13
  %Q3 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 14
  %Q4 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 15
  %Q5 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 16
  %Q6 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 17
  %Q7 = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 18
  %edge = getelementptr inbounds %STORE_8_interface, %STORE_8_interface* %0, i32 0, i32 19
  %load_rst = load i8, i8* %Rst, align 1
  %1 = zext i8 %load_rst to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %6, label %4

condition_body:                                   ; preds = %6
  %load_rst1 = load i8, i8* %Rst, align 1
  %tmpVar = xor i8 %load_rst1, -1
  store i8 %tmpVar, i8* %Q0, align 1
  %load_q0 = load i8, i8* %Q0, align 1
  store i8 %load_q0, i8* %Q1, align 1
  %load_q02 = load i8, i8* %Q0, align 1
  store i8 %load_q02, i8* %Q2, align 1
  %load_q03 = load i8, i8* %Q0, align 1
  store i8 %load_q03, i8* %Q3, align 1
  %load_q04 = load i8, i8* %Q0, align 1
  store i8 %load_q04, i8* %Q4, align 1
  %load_q05 = load i8, i8* %Q0, align 1
  store i8 %load_q05, i8* %Q5, align 1
  %load_q06 = load i8, i8* %Q0, align 1
  store i8 %load_q06, i8* %Q6, align 1
  %load_q07 = load i8, i8* %Q0, align 1
  store i8 %load_q07, i8* %Q7, align 1
  br label %continue

else:                                             ; preds = %6
  %load_D0 = load i8, i8* %D0, align 1
  %3 = icmp ne i8 %load_D0, 0
  br i1 %3, label %condition_body9, label %continue8

continue:                                         ; preds = %continue24, %condition_body
  ret void

4:                                                ; preds = %entry
  %load_set = load i8, i8* %Set, align 1
  %5 = zext i8 %load_set to i32
  br label %6

6:                                                ; preds = %4, %entry
  %7 = phi i32 [ %1, %entry ], [ %5, %4 ]
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %condition_body, label %else

condition_body9:                                  ; preds = %else
  store i8 1, i8* %Q0, align 1
  br label %continue8

continue8:                                        ; preds = %condition_body9, %else
  %load_D1 = load i8, i8* %D1, align 1
  %9 = icmp ne i8 %load_D1, 0
  br i1 %9, label %condition_body11, label %continue10

condition_body11:                                 ; preds = %continue8
  store i8 1, i8* %Q1, align 1
  br label %continue10

continue10:                                       ; preds = %condition_body11, %continue8
  %load_D2 = load i8, i8* %D2, align 1
  %10 = icmp ne i8 %load_D2, 0
  br i1 %10, label %condition_body13, label %continue12

condition_body13:                                 ; preds = %continue10
  store i8 1, i8* %Q2, align 1
  br label %continue12

continue12:                                       ; preds = %condition_body13, %continue10
  %load_D3 = load i8, i8* %D3, align 1
  %11 = icmp ne i8 %load_D3, 0
  br i1 %11, label %condition_body15, label %continue14

condition_body15:                                 ; preds = %continue12
  store i8 1, i8* %Q3, align 1
  br label %continue14

continue14:                                       ; preds = %condition_body15, %continue12
  %load_D4 = load i8, i8* %D4, align 1
  %12 = icmp ne i8 %load_D4, 0
  br i1 %12, label %condition_body17, label %continue16

condition_body17:                                 ; preds = %continue14
  store i8 1, i8* %Q4, align 1
  br label %continue16

continue16:                                       ; preds = %condition_body17, %continue14
  %load_D5 = load i8, i8* %D5, align 1
  %13 = icmp ne i8 %load_D5, 0
  br i1 %13, label %condition_body19, label %continue18

condition_body19:                                 ; preds = %continue16
  store i8 1, i8* %Q5, align 1
  br label %continue18

continue18:                                       ; preds = %condition_body19, %continue16
  %load_D6 = load i8, i8* %D6, align 1
  %14 = icmp ne i8 %load_D6, 0
  br i1 %14, label %condition_body21, label %continue20

condition_body21:                                 ; preds = %continue18
  store i8 1, i8* %Q6, align 1
  br label %continue20

continue20:                                       ; preds = %condition_body21, %continue18
  %load_D7 = load i8, i8* %D7, align 1
  %15 = icmp ne i8 %load_D7, 0
  br i1 %15, label %condition_body23, label %continue22

condition_body23:                                 ; preds = %continue20
  store i8 1, i8* %Q7, align 1
  br label %continue22

continue22:                                       ; preds = %condition_body23, %continue20
  %load_clr = load i8, i8* %Clr, align 1
  %16 = zext i8 %load_clr to i32
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %19, label %21

condition_body25:                                 ; preds = %21
  %load_q035 = load i8, i8* %Q0, align 1
  %18 = icmp ne i8 %load_q035, 0
  br i1 %18, label %condition_body34, label %branch

continue24:                                       ; preds = %continue33, %21
  %load_clr42 = load i8, i8* %Clr, align 1
  store i8 %load_clr42, i8* %edge, align 1
  br label %continue

19:                                               ; preds = %continue22
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar26 = xor i8 %load_edge, -1
  %20 = zext i8 %tmpVar26 to i32
  br label %21

21:                                               ; preds = %19, %continue22
  %22 = phi i32 [ %16, %continue22 ], [ %20, %19 ]
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %condition_body25, label %continue24

condition_body34:                                 ; preds = %condition_body25
  store i8 0, i8* %Q0, align 1
  br label %continue33

branch:                                           ; preds = %condition_body25
  %load_q1 = load i8, i8* %Q1, align 1
  %24 = icmp ne i8 %load_q1, 0
  br i1 %24, label %condition_body36, label %branch27

condition_body36:                                 ; preds = %branch
  store i8 0, i8* %Q1, align 1
  br label %continue33

branch27:                                         ; preds = %branch
  %load_q2 = load i8, i8* %Q2, align 1
  %25 = icmp ne i8 %load_q2, 0
  br i1 %25, label %condition_body37, label %branch28

condition_body37:                                 ; preds = %branch27
  store i8 0, i8* %Q2, align 1
  br label %continue33

branch28:                                         ; preds = %branch27
  %load_q3 = load i8, i8* %Q3, align 1
  %26 = icmp ne i8 %load_q3, 0
  br i1 %26, label %condition_body38, label %branch29

condition_body38:                                 ; preds = %branch28
  store i8 0, i8* %Q3, align 1
  br label %continue33

branch29:                                         ; preds = %branch28
  %load_q4 = load i8, i8* %Q4, align 1
  %27 = icmp ne i8 %load_q4, 0
  br i1 %27, label %condition_body39, label %branch30

condition_body39:                                 ; preds = %branch29
  store i8 0, i8* %Q4, align 1
  br label %continue33

branch30:                                         ; preds = %branch29
  %load_q5 = load i8, i8* %Q5, align 1
  %28 = icmp ne i8 %load_q5, 0
  br i1 %28, label %condition_body40, label %branch31

condition_body40:                                 ; preds = %branch30
  store i8 0, i8* %Q5, align 1
  br label %continue33

branch31:                                         ; preds = %branch30
  %load_q6 = load i8, i8* %Q6, align 1
  %29 = icmp ne i8 %load_q6, 0
  br i1 %29, label %condition_body41, label %else32

condition_body41:                                 ; preds = %branch31
  store i8 0, i8* %Q6, align 1
  br label %continue33

else32:                                           ; preds = %branch31
  store i8 0, i8* %Q7, align 1
  br label %continue33

continue33:                                       ; preds = %else32, %condition_body41, %condition_body40, %condition_body39, %condition_body38, %condition_body37, %condition_body36, %condition_body34
  br label %continue24
}

define i16 @BCDC_TO_INT(%BCDC_TO_INT_interface* %0) {
entry:
  %IN = getelementptr inbounds %BCDC_TO_INT_interface, %BCDC_TO_INT_interface* %0, i32 0, i32 0
  %BCDC_TO_INT = alloca i16, align 2
  store i16 0, i16* %BCDC_TO_INT, align 2
  %load_in = load i8, i8* %IN, align 1
  %1 = zext i8 %load_in to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %3, label %4

3:                                                ; preds = %entry
  br label %4

4:                                                ; preds = %3, %entry
  %5 = phi i32 [ %1, %entry ], [ 15, %3 ]
  %6 = zext i32 %5 to i64
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %4
  %7 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in1 = load i8, i8* %IN, align 1
  %8 = zext i8 %load_in1 to i64
  store i64 %8, i64* %7, align 4
  %9 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 4, i16* %9, align 2
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = mul i64 %call2, 10
  %tmpVar3 = add i64 %6, %tmpVar
  %10 = trunc i64 %tmpVar3 to i16
  store i16 %10, i16* %BCDC_TO_INT, align 2
  %BCDC_TO_INT_ret = load i16, i16* %BCDC_TO_INT, align 2
  ret i16 %BCDC_TO_INT_ret
}

define i16 @BIT_COUNT(%BIT_COUNT_interface* %0) {
entry:
  %IN = getelementptr inbounds %BIT_COUNT_interface, %BIT_COUNT_interface* %0, i32 0, i32 0
  %BIT_COUNT = alloca i16, align 2
  store i16 0, i16* %BIT_COUNT, align 2
  br label %condition_check

condition_check:                                  ; preds = %entry, %continue4
  %load_in = load i32, i32* %IN, align 4
  %tmpVar = icmp sgt i32 %load_in, 0
  br i1 %tmpVar, label %while_body, label %continue

while_body:                                       ; preds = %condition_check
  %load_in2 = load i32, i32* %IN, align 4
  %shift = lshr i32 %load_in2, 0
  %1 = trunc i32 %shift to i8
  %2 = icmp ne i8 %1, 0
  br i1 %2, label %condition_body, label %continue1

continue:                                         ; preds = %condition_check
  %BIT_COUNT_ret = load i16, i16* %BIT_COUNT, align 2
  ret i16 %BIT_COUNT_ret

condition_body:                                   ; preds = %while_body
  %load_Bit_Count = load i16, i16* %BIT_COUNT, align 2
  %3 = sext i16 %load_Bit_Count to i32
  %tmpVar3 = add i32 %3, 1
  %4 = trunc i32 %tmpVar3 to i16
  store i16 %4, i16* %BIT_COUNT, align 2
  br label %continue1

continue1:                                        ; preds = %condition_body, %while_body
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %continue1
  %5 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in5 = load i32, i32* %IN, align 4
  %6 = zext i32 %load_in5 to i64
  store i64 %6, i64* %5, align 4
  %7 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 1, i16* %7, align 2
  br label %call

call:                                             ; preds = %input
  %call6 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue4

continue4:                                        ; preds = %output
  %8 = trunc i64 %call6 to i32
  store i32 %8, i32* %IN, align 4
  br label %condition_check
}

define i8 @BIT_LOAD_B(%BIT_LOAD_B_interface* %0) {
entry:
  %IN = getelementptr inbounds %BIT_LOAD_B_interface, %BIT_LOAD_B_interface* %0, i32 0, i32 0
  %VAL = getelementptr inbounds %BIT_LOAD_B_interface, %BIT_LOAD_B_interface* %0, i32 0, i32 1
  %POS = getelementptr inbounds %BIT_LOAD_B_interface, %BIT_LOAD_B_interface* %0, i32 0, i32 2
  %dat = getelementptr inbounds %BIT_LOAD_B_interface, %BIT_LOAD_B_interface* %0, i32 0, i32 3
  %BIT_LOAD_B = alloca i8, align 1
  store i8 1, i8* %dat, align 1
  store i8 0, i8* %BIT_LOAD_B, align 1
  %load_VAL = load i8, i8* %VAL, align 1
  %1 = icmp ne i8 %load_VAL, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_in = load i8, i8* %IN, align 1
  %2 = zext i8 %load_in to i64
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %7, label %6

else:                                             ; preds = %entry
  %load_in3 = load i8, i8* %IN, align 1
  %4 = zext i8 %load_in3 to i64
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %12, label %13

continue:                                         ; preds = %13, %7
  %BIT_LOAD_B_ret = load i8, i8* %BIT_LOAD_B, align 1
  ret i8 %BIT_LOAD_B_ret

6:                                                ; preds = %condition_body
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

7:                                                ; preds = %continue1, %condition_body
  %8 = phi i64 [ %2, %condition_body ], [ %call2, %continue1 ]
  store i64 %8, i8* %BIT_LOAD_B, align 4
  br label %continue

input:                                            ; preds = %6
  %9 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_dat = load i8, i8* %dat, align 1
  %10 = zext i8 %load_dat to i64
  store i64 %10, i64* %9, align 4
  %11 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_pos = load i16, i16* %POS, align 2
  store i16 %load_pos, i16* %11, align 2
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  br label %7

12:                                               ; preds = %else
  %SHL_instance4 = alloca %SHL_interface, align 8
  br label %input5

13:                                               ; preds = %continue8, %else
  %14 = phi i64 [ %4, %else ], [ %tmpVar, %continue8 ]
  store i64 %14, i8* %BIT_LOAD_B, align 4
  br label %continue

input5:                                           ; preds = %12
  %15 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance4, i32 0, i32 0
  %load_dat9 = load i8, i8* %dat, align 1
  %16 = zext i8 %load_dat9 to i64
  store i64 %16, i64* %15, align 4
  %17 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance4, i32 0, i32 1
  %load_pos10 = load i16, i16* %POS, align 2
  store i16 %load_pos10, i16* %17, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call11 = call i64 @SHL(%SHL_interface* %SHL_instance4)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %tmpVar = xor i64 %call11, -1
  br label %13
}

define i8 @BIT_LOAD_B2(%BIT_LOAD_B2_interface* %0) {
entry:
  %I = getelementptr inbounds %BIT_LOAD_B2_interface, %BIT_LOAD_B2_interface* %0, i32 0, i32 0
  %D = getelementptr inbounds %BIT_LOAD_B2_interface, %BIT_LOAD_B2_interface* %0, i32 0, i32 1
  %P = getelementptr inbounds %BIT_LOAD_B2_interface, %BIT_LOAD_B2_interface* %0, i32 0, i32 2
  %N = getelementptr inbounds %BIT_LOAD_B2_interface, %BIT_LOAD_B2_interface* %0, i32 0, i32 3
  %BIT_LOAD_B2 = alloca i8, align 1
  store i8 0, i8* %BIT_LOAD_B2, align 1
  %load_D = load i8, i8* %D, align 1
  %1 = icmp ne i8 %load_D, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %ROL_instance = alloca %ROL_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %ROL_instance14 = alloca %ROL_interface, align 8
  br label %input15

continue:                                         ; preds = %continue18, %continue1
  %BIT_LOAD_B2_ret = load i8, i8* %BIT_LOAD_B2, align 1
  ret i8 %BIT_LOAD_B2_ret

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 0
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input2

call:                                             ; preds = %5
  %call13 = call i64 @ROL(%ROL_interface* %ROL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %3 = trunc i64 %call13 to i8
  store i8 %3, i8* %BIT_LOAD_B2, align 1
  br label %continue

4:                                                ; preds = %continue5
  %ROR_instance = alloca %ROR_interface, align 8
  br label %input7

5:                                                ; preds = %continue10, %continue5
  %6 = phi i64 [ %call6, %continue5 ], [ %call11, %continue10 ]
  store i64 %6, i64* %2, align 4
  %7 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 1
  %load_P12 = load i16, i16* %P, align 2
  store i16 %load_P12, i16* %7, align 2
  br label %call

input2:                                           ; preds = %input
  %8 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  store i64 255, i64* %8, align 4
  %9 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %10 = sext i16 %load_N to i32
  %tmpVar = sub i32 8, %10
  %11 = trunc i32 %tmpVar to i16
  store i16 %11, i16* %9, align 2
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %12 = icmp ne i64 %call6, 0
  br i1 %12, label %5, label %4

input7:                                           ; preds = %4
  %13 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance, i32 0, i32 0
  %load_i = load i8, i8* %I, align 1
  %14 = zext i8 %load_i to i64
  store i64 %14, i64* %13, align 4
  %15 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance, i32 0, i32 1
  %load_P = load i16, i16* %P, align 2
  store i16 %load_P, i16* %15, align 2
  br label %call8

call8:                                            ; preds = %input7
  %call11 = call i64 @ROR(%ROR_interface* %ROR_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  br label %5

input15:                                          ; preds = %else
  %16 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance14, i32 0, i32 0
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input19

call16:                                           ; preds = %19
  %call33 = call i64 @ROL(%ROL_interface* %ROL_instance14)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %17 = trunc i64 %call33 to i8
  store i8 %17, i8* %BIT_LOAD_B2, align 1
  br label %continue

18:                                               ; preds = %continue22
  %ROR_instance25 = alloca %ROR_interface, align 8
  br label %input26

19:                                               ; preds = %continue29, %continue22
  %20 = phi i64 [ %call24, %continue22 ], [ %call31, %continue29 ]
  store i64 %20, i64* %16, align 4
  %21 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance14, i32 0, i32 1
  %load_P32 = load i16, i16* %P, align 2
  store i16 %load_P32, i16* %21, align 2
  br label %call16

input19:                                          ; preds = %input15
  %22 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  store i64 255, i64* %22, align 4
  %23 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_N23 = load i16, i16* %N, align 2
  store i16 %load_N23, i16* %23, align 2
  br label %call20

call20:                                           ; preds = %input19
  %call24 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  %24 = icmp ne i64 %call24, 0
  br i1 %24, label %18, label %19

input26:                                          ; preds = %18
  %25 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance25, i32 0, i32 0
  %load_I = load i8, i8* %I, align 1
  %26 = zext i8 %load_I to i64
  store i64 %26, i64* %25, align 4
  %27 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance25, i32 0, i32 1
  %load_P30 = load i16, i16* %P, align 2
  store i16 %load_P30, i16* %27, align 2
  br label %call27

call27:                                           ; preds = %input26
  %call31 = call i64 @ROR(%ROR_interface* %ROR_instance25)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  br label %19
}

define i32 @BIT_LOAD_DW(%BIT_LOAD_DW_interface* %0) {
entry:
  %IN = getelementptr inbounds %BIT_LOAD_DW_interface, %BIT_LOAD_DW_interface* %0, i32 0, i32 0
  %VAL = getelementptr inbounds %BIT_LOAD_DW_interface, %BIT_LOAD_DW_interface* %0, i32 0, i32 1
  %POS = getelementptr inbounds %BIT_LOAD_DW_interface, %BIT_LOAD_DW_interface* %0, i32 0, i32 2
  %dat = getelementptr inbounds %BIT_LOAD_DW_interface, %BIT_LOAD_DW_interface* %0, i32 0, i32 3
  %BIT_LOAD_DW = alloca i32, align 4
  store i32 1, i32* %dat, align 4
  store i32 0, i32* %BIT_LOAD_DW, align 4
  %load_val = load i8, i8* %VAL, align 1
  %1 = icmp ne i8 %load_val, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_in = load i32, i32* %IN, align 4
  %2 = zext i32 %load_in to i64
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %7, label %6

else:                                             ; preds = %entry
  %load_in3 = load i32, i32* %IN, align 4
  %4 = zext i32 %load_in3 to i64
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %12, label %13

continue:                                         ; preds = %13, %7
  %BIT_LOAD_DW_ret = load i32, i32* %BIT_LOAD_DW, align 4
  ret i32 %BIT_LOAD_DW_ret

6:                                                ; preds = %condition_body
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

7:                                                ; preds = %continue1, %condition_body
  %8 = phi i64 [ %2, %condition_body ], [ %call2, %continue1 ]
  store i64 %8, i32* %BIT_LOAD_DW, align 4
  br label %continue

input:                                            ; preds = %6
  %9 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_dat = load i32, i32* %dat, align 4
  %10 = zext i32 %load_dat to i64
  store i64 %10, i64* %9, align 4
  %11 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_pos = load i16, i16* %POS, align 2
  store i16 %load_pos, i16* %11, align 2
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  br label %7

12:                                               ; preds = %else
  %SHL_instance4 = alloca %SHL_interface, align 8
  br label %input5

13:                                               ; preds = %continue8, %else
  %14 = phi i64 [ %4, %else ], [ %tmpVar, %continue8 ]
  store i64 %14, i32* %BIT_LOAD_DW, align 4
  br label %continue

input5:                                           ; preds = %12
  %15 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance4, i32 0, i32 0
  %load_dat9 = load i32, i32* %dat, align 4
  %16 = zext i32 %load_dat9 to i64
  store i64 %16, i64* %15, align 4
  %17 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance4, i32 0, i32 1
  %load_pos10 = load i16, i16* %POS, align 2
  store i16 %load_pos10, i16* %17, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call11 = call i64 @SHL(%SHL_interface* %SHL_instance4)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %tmpVar = xor i64 %call11, -1
  br label %13
}

define i32 @BIT_LOAD_DW2(%BIT_LOAD_DW2_interface* %0) {
entry:
  %I = getelementptr inbounds %BIT_LOAD_DW2_interface, %BIT_LOAD_DW2_interface* %0, i32 0, i32 0
  %D = getelementptr inbounds %BIT_LOAD_DW2_interface, %BIT_LOAD_DW2_interface* %0, i32 0, i32 1
  %P = getelementptr inbounds %BIT_LOAD_DW2_interface, %BIT_LOAD_DW2_interface* %0, i32 0, i32 2
  %N = getelementptr inbounds %BIT_LOAD_DW2_interface, %BIT_LOAD_DW2_interface* %0, i32 0, i32 3
  %BIT_LOAD_DW2 = alloca i32, align 4
  store i32 0, i32* %BIT_LOAD_DW2, align 4
  %load_D = load i8, i8* %D, align 1
  %1 = icmp ne i8 %load_D, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %ROL_instance = alloca %ROL_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %ROL_instance14 = alloca %ROL_interface, align 8
  br label %input15

continue:                                         ; preds = %continue18, %continue1
  %BIT_LOAD_DW2_ret = load i32, i32* %BIT_LOAD_DW2, align 4
  ret i32 %BIT_LOAD_DW2_ret

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 0
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input2

call:                                             ; preds = %5
  %call13 = call i64 @ROL(%ROL_interface* %ROL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %3 = trunc i64 %call13 to i32
  store i32 %3, i32* %BIT_LOAD_DW2, align 4
  br label %continue

4:                                                ; preds = %continue5
  %ROR_instance = alloca %ROR_interface, align 8
  br label %input7

5:                                                ; preds = %continue10, %continue5
  %6 = phi i64 [ %call6, %continue5 ], [ %call11, %continue10 ]
  store i64 %6, i64* %2, align 4
  %7 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 1
  %load_P12 = load i16, i16* %P, align 2
  store i16 %load_P12, i16* %7, align 2
  br label %call

input2:                                           ; preds = %input
  %8 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  store i64 4294967295, i64* %8, align 4
  %9 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %10 = sext i16 %load_N to i32
  %tmpVar = sub i32 32, %10
  %11 = trunc i32 %tmpVar to i16
  store i16 %11, i16* %9, align 2
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %12 = icmp ne i64 %call6, 0
  br i1 %12, label %5, label %4

input7:                                           ; preds = %4
  %13 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance, i32 0, i32 0
  %load_i = load i32, i32* %I, align 4
  %14 = zext i32 %load_i to i64
  store i64 %14, i64* %13, align 4
  %15 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance, i32 0, i32 1
  %load_P = load i16, i16* %P, align 2
  store i16 %load_P, i16* %15, align 2
  br label %call8

call8:                                            ; preds = %input7
  %call11 = call i64 @ROR(%ROR_interface* %ROR_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  br label %5

input15:                                          ; preds = %else
  %16 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance14, i32 0, i32 0
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input19

call16:                                           ; preds = %19
  %call33 = call i64 @ROL(%ROL_interface* %ROL_instance14)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %17 = trunc i64 %call33 to i32
  store i32 %17, i32* %BIT_LOAD_DW2, align 4
  br label %continue

18:                                               ; preds = %continue22
  %ROR_instance25 = alloca %ROR_interface, align 8
  br label %input26

19:                                               ; preds = %continue29, %continue22
  %20 = phi i64 [ %call24, %continue22 ], [ %call31, %continue29 ]
  store i64 %20, i64* %16, align 4
  %21 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance14, i32 0, i32 1
  %load_P32 = load i16, i16* %P, align 2
  store i16 %load_P32, i16* %21, align 2
  br label %call16

input19:                                          ; preds = %input15
  %22 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  store i64 4294967295, i64* %22, align 4
  %23 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_N23 = load i16, i16* %N, align 2
  store i16 %load_N23, i16* %23, align 2
  br label %call20

call20:                                           ; preds = %input19
  %call24 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  %24 = icmp ne i64 %call24, 0
  br i1 %24, label %18, label %19

input26:                                          ; preds = %18
  %25 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance25, i32 0, i32 0
  %load_I = load i32, i32* %I, align 4
  %26 = zext i32 %load_I to i64
  store i64 %26, i64* %25, align 4
  %27 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance25, i32 0, i32 1
  %load_P30 = load i16, i16* %P, align 2
  store i16 %load_P30, i16* %27, align 2
  br label %call27

call27:                                           ; preds = %input26
  %call31 = call i64 @ROR(%ROR_interface* %ROR_instance25)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  br label %19
}

define i16 @BIT_LOAD_W(%BIT_LOAD_W_interface* %0) {
entry:
  %IN = getelementptr inbounds %BIT_LOAD_W_interface, %BIT_LOAD_W_interface* %0, i32 0, i32 0
  %VAL = getelementptr inbounds %BIT_LOAD_W_interface, %BIT_LOAD_W_interface* %0, i32 0, i32 1
  %POS = getelementptr inbounds %BIT_LOAD_W_interface, %BIT_LOAD_W_interface* %0, i32 0, i32 2
  %dat = getelementptr inbounds %BIT_LOAD_W_interface, %BIT_LOAD_W_interface* %0, i32 0, i32 3
  %BIT_LOAD_W = alloca i16, align 2
  store i16 1, i16* %dat, align 2
  store i16 0, i16* %BIT_LOAD_W, align 2
  %load_val = load i8, i8* %VAL, align 1
  %1 = icmp ne i8 %load_val, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_in = load i16, i16* %IN, align 2
  %2 = zext i16 %load_in to i64
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %7, label %6

else:                                             ; preds = %entry
  %load_in3 = load i16, i16* %IN, align 2
  %4 = zext i16 %load_in3 to i64
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %12, label %13

continue:                                         ; preds = %13, %7
  %BIT_LOAD_W_ret = load i16, i16* %BIT_LOAD_W, align 2
  ret i16 %BIT_LOAD_W_ret

6:                                                ; preds = %condition_body
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

7:                                                ; preds = %continue1, %condition_body
  %8 = phi i64 [ %2, %condition_body ], [ %call2, %continue1 ]
  store i64 %8, i16* %BIT_LOAD_W, align 4
  br label %continue

input:                                            ; preds = %6
  %9 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_dat = load i16, i16* %dat, align 2
  %10 = zext i16 %load_dat to i64
  store i64 %10, i64* %9, align 4
  %11 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_pos = load i16, i16* %POS, align 2
  store i16 %load_pos, i16* %11, align 2
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  br label %7

12:                                               ; preds = %else
  %SHL_instance4 = alloca %SHL_interface, align 8
  br label %input5

13:                                               ; preds = %continue8, %else
  %14 = phi i64 [ %4, %else ], [ %tmpVar, %continue8 ]
  store i64 %14, i16* %BIT_LOAD_W, align 4
  br label %continue

input5:                                           ; preds = %12
  %15 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance4, i32 0, i32 0
  %load_dat9 = load i16, i16* %dat, align 2
  %16 = zext i16 %load_dat9 to i64
  store i64 %16, i64* %15, align 4
  %17 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance4, i32 0, i32 1
  %load_pos10 = load i16, i16* %POS, align 2
  store i16 %load_pos10, i16* %17, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call11 = call i64 @SHL(%SHL_interface* %SHL_instance4)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %tmpVar = xor i64 %call11, -1
  br label %13
}

define i16 @BIT_LOAD_W2(%BIT_LOAD_W2_interface* %0) {
entry:
  %I = getelementptr inbounds %BIT_LOAD_W2_interface, %BIT_LOAD_W2_interface* %0, i32 0, i32 0
  %D = getelementptr inbounds %BIT_LOAD_W2_interface, %BIT_LOAD_W2_interface* %0, i32 0, i32 1
  %P = getelementptr inbounds %BIT_LOAD_W2_interface, %BIT_LOAD_W2_interface* %0, i32 0, i32 2
  %N = getelementptr inbounds %BIT_LOAD_W2_interface, %BIT_LOAD_W2_interface* %0, i32 0, i32 3
  %BIT_LOAD_W2 = alloca i16, align 2
  store i16 0, i16* %BIT_LOAD_W2, align 2
  %load_D = load i8, i8* %D, align 1
  %1 = icmp ne i8 %load_D, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %ROL_instance = alloca %ROL_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %ROL_instance14 = alloca %ROL_interface, align 8
  br label %input15

continue:                                         ; preds = %continue18, %continue1
  %BIT_LOAD_W2_ret = load i16, i16* %BIT_LOAD_W2, align 2
  ret i16 %BIT_LOAD_W2_ret

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 0
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input2

call:                                             ; preds = %5
  %call13 = call i64 @ROL(%ROL_interface* %ROL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %3 = trunc i64 %call13 to i16
  store i16 %3, i16* %BIT_LOAD_W2, align 2
  br label %continue

4:                                                ; preds = %continue5
  %ROR_instance = alloca %ROR_interface, align 8
  br label %input7

5:                                                ; preds = %continue10, %continue5
  %6 = phi i64 [ %call6, %continue5 ], [ %call11, %continue10 ]
  store i64 %6, i64* %2, align 4
  %7 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 1
  %load_P12 = load i16, i16* %P, align 2
  store i16 %load_P12, i16* %7, align 2
  br label %call

input2:                                           ; preds = %input
  %8 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  store i64 65535, i64* %8, align 4
  %9 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %10 = sext i16 %load_N to i32
  %tmpVar = sub i32 16, %10
  %11 = trunc i32 %tmpVar to i16
  store i16 %11, i16* %9, align 2
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %12 = icmp ne i64 %call6, 0
  br i1 %12, label %5, label %4

input7:                                           ; preds = %4
  %13 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance, i32 0, i32 0
  %load_i = load i16, i16* %I, align 2
  %14 = zext i16 %load_i to i64
  store i64 %14, i64* %13, align 4
  %15 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance, i32 0, i32 1
  %load_P = load i16, i16* %P, align 2
  store i16 %load_P, i16* %15, align 2
  br label %call8

call8:                                            ; preds = %input7
  %call11 = call i64 @ROR(%ROR_interface* %ROR_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  br label %5

input15:                                          ; preds = %else
  %16 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance14, i32 0, i32 0
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input19

call16:                                           ; preds = %19
  %call33 = call i64 @ROL(%ROL_interface* %ROL_instance14)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %17 = trunc i64 %call33 to i16
  store i16 %17, i16* %BIT_LOAD_W2, align 2
  br label %continue

18:                                               ; preds = %continue22
  %ROR_instance25 = alloca %ROR_interface, align 8
  br label %input26

19:                                               ; preds = %continue29, %continue22
  %20 = phi i64 [ %call24, %continue22 ], [ %call31, %continue29 ]
  store i64 %20, i64* %16, align 4
  %21 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance14, i32 0, i32 1
  %load_P32 = load i16, i16* %P, align 2
  store i16 %load_P32, i16* %21, align 2
  br label %call16

input19:                                          ; preds = %input15
  %22 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  store i64 65535, i64* %22, align 4
  %23 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_N23 = load i16, i16* %N, align 2
  store i16 %load_N23, i16* %23, align 2
  br label %call20

call20:                                           ; preds = %input19
  %call24 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  %24 = icmp ne i64 %call24, 0
  br i1 %24, label %18, label %19

input26:                                          ; preds = %18
  %25 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance25, i32 0, i32 0
  %load_I = load i16, i16* %I, align 2
  %26 = zext i16 %load_I to i64
  store i64 %26, i64* %25, align 4
  %27 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance25, i32 0, i32 1
  %load_P30 = load i16, i16* %P, align 2
  store i16 %load_P30, i16* %27, align 2
  br label %call27

call27:                                           ; preds = %input26
  %call31 = call i64 @ROR(%ROR_interface* %ROR_instance25)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  br label %19
}

define i8 @BIT_OF_DWORD(%BIT_OF_DWORD_interface* %0) {
entry:
  %in = getelementptr inbounds %BIT_OF_DWORD_interface, %BIT_OF_DWORD_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %BIT_OF_DWORD_interface, %BIT_OF_DWORD_interface* %0, i32 0, i32 1
  %BIT_OF_DWORD = alloca i8, align 1
  store i8 0, i8* %BIT_OF_DWORD, align 1
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

1:                                                ; preds = %continue
  br label %2

2:                                                ; preds = %1, %continue
  %3 = phi i64 [ %call1, %continue ], [ 1, %1 ]
  %tmpVar = icmp sgt i64 %3, i32 0
  %4 = zext i1 %tmpVar to i8
  store i8 %4, i8* %BIT_OF_DWORD, align 1
  %BIT_OF_DWORD_ret = load i8, i8* %BIT_OF_DWORD, align 1
  ret i8 %BIT_OF_DWORD_ret

input:                                            ; preds = %entry
  %5 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in = load i32, i32* %in, align 4
  %6 = zext i32 %load_in to i64
  store i64 %6, i64* %5, align 4
  %7 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  store i16 %load_N, i16* %7, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %8 = icmp ne i64 %call1, 0
  br i1 %8, label %1, label %2
}

define i8 @BIT_TOGGLE_B(%BIT_TOGGLE_B_interface* %0) {
entry:
  %IN = getelementptr inbounds %BIT_TOGGLE_B_interface, %BIT_TOGGLE_B_interface* %0, i32 0, i32 0
  %POS = getelementptr inbounds %BIT_TOGGLE_B_interface, %BIT_TOGGLE_B_interface* %0, i32 0, i32 1
  %BIT_TOGGLE_B = alloca i8, align 1
  store i8 0, i8* %BIT_TOGGLE_B, align 1
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  store i64 1, i64* %1, align 4
  %2 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_POS = load i16, i16* %POS, align 2
  store i16 %load_POS, i16* %2, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_IN = load i8, i8* %IN, align 1
  %3 = zext i8 %load_IN to i64
  %tmpVar = xor i64 %call1, %3
  store i64 %tmpVar, i8* %BIT_TOGGLE_B, align 4
  %BIT_TOGGLE_B_ret = load i8, i8* %BIT_TOGGLE_B, align 1
  ret i8 %BIT_TOGGLE_B_ret
}

define i32 @BIT_TOGGLE_DW(%BIT_TOGGLE_DW_interface* %0) {
entry:
  %IN = getelementptr inbounds %BIT_TOGGLE_DW_interface, %BIT_TOGGLE_DW_interface* %0, i32 0, i32 0
  %POS = getelementptr inbounds %BIT_TOGGLE_DW_interface, %BIT_TOGGLE_DW_interface* %0, i32 0, i32 1
  %BIT_TOGGLE_DW = alloca i32, align 4
  store i32 0, i32* %BIT_TOGGLE_DW, align 4
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  store i64 1, i64* %1, align 4
  %2 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_POS = load i16, i16* %POS, align 2
  store i16 %load_POS, i16* %2, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_IN = load i32, i32* %IN, align 4
  %3 = zext i32 %load_IN to i64
  %tmpVar = xor i64 %call1, %3
  store i64 %tmpVar, i32* %BIT_TOGGLE_DW, align 4
  %BIT_TOGGLE_DW_ret = load i32, i32* %BIT_TOGGLE_DW, align 4
  ret i32 %BIT_TOGGLE_DW_ret
}

define i16 @BIT_TOGGLE_W(%BIT_TOGGLE_W_interface* %0) {
entry:
  %IN = getelementptr inbounds %BIT_TOGGLE_W_interface, %BIT_TOGGLE_W_interface* %0, i32 0, i32 0
  %POS = getelementptr inbounds %BIT_TOGGLE_W_interface, %BIT_TOGGLE_W_interface* %0, i32 0, i32 1
  %BIT_TOGGLE_W = alloca i16, align 2
  store i16 0, i16* %BIT_TOGGLE_W, align 2
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  store i64 1, i64* %1, align 4
  %2 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_POS = load i16, i16* %POS, align 2
  store i16 %load_POS, i16* %2, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_IN = load i16, i16* %IN, align 2
  %3 = zext i16 %load_IN to i64
  %tmpVar = xor i64 %call1, %3
  store i64 %tmpVar, i16* %BIT_TOGGLE_W, align 4
  %BIT_TOGGLE_W_ret = load i16, i16* %BIT_TOGGLE_W, align 2
  ret i16 %BIT_TOGGLE_W_ret
}

define i8 @BYTE_OF_BIT(%BYTE_OF_BIT_interface* %0) {
entry:
  %B0 = getelementptr inbounds %BYTE_OF_BIT_interface, %BYTE_OF_BIT_interface* %0, i32 0, i32 0
  %B1 = getelementptr inbounds %BYTE_OF_BIT_interface, %BYTE_OF_BIT_interface* %0, i32 0, i32 1
  %B2 = getelementptr inbounds %BYTE_OF_BIT_interface, %BYTE_OF_BIT_interface* %0, i32 0, i32 2
  %B3 = getelementptr inbounds %BYTE_OF_BIT_interface, %BYTE_OF_BIT_interface* %0, i32 0, i32 3
  %B4 = getelementptr inbounds %BYTE_OF_BIT_interface, %BYTE_OF_BIT_interface* %0, i32 0, i32 4
  %B5 = getelementptr inbounds %BYTE_OF_BIT_interface, %BYTE_OF_BIT_interface* %0, i32 0, i32 5
  %B6 = getelementptr inbounds %BYTE_OF_BIT_interface, %BYTE_OF_BIT_interface* %0, i32 0, i32 6
  %B7 = getelementptr inbounds %BYTE_OF_BIT_interface, %BYTE_OF_BIT_interface* %0, i32 0, i32 7
  %BYTE_OF_BIT = alloca i8, align 1
  store i8 0, i8* %BYTE_OF_BIT, align 1
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

1:                                                ; preds = %continue
  %BOOL_TO_BYTE_instance79 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input80

2:                                                ; preds = %continue83, %continue
  %3 = phi i64 [ %call78, %continue ], [ %58, %continue83 ]
  store i64 %3, i8* %BYTE_OF_BIT, align 4
  %BYTE_OF_BIT_ret = load i8, i8* %BYTE_OF_BIT, align 1
  ret i8 %BYTE_OF_BIT_ret

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %SHL_instance1 = alloca %SHL_interface, align 8
  br label %input2

call:                                             ; preds = %7
  %call78 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = icmp ne i64 %call78, 0
  br i1 %5, label %2, label %1

6:                                                ; preds = %continue5
  %BOOL_TO_BYTE_instance72 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input73

7:                                                ; preds = %continue76, %continue5
  %8 = phi i64 [ %call71, %continue5 ], [ %56, %continue76 ]
  store i64 %8, i64* %4, align 4
  %9 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 1, i16* %9, align 2
  br label %call

input2:                                           ; preds = %input
  %10 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance1, i32 0, i32 0
  %SHL_instance6 = alloca %SHL_interface, align 8
  br label %input7

call3:                                            ; preds = %13
  %call71 = call i64 @SHL(%SHL_interface* %SHL_instance1)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %11 = icmp ne i64 %call71, 0
  br i1 %11, label %7, label %6

12:                                               ; preds = %continue10
  %BOOL_TO_BYTE_instance65 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input66

13:                                               ; preds = %continue69, %continue10
  %14 = phi i64 [ %call64, %continue10 ], [ %54, %continue69 ]
  store i64 %14, i64* %10, align 4
  %15 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance1, i32 0, i32 1
  store i16 1, i16* %15, align 2
  br label %call3

input7:                                           ; preds = %input2
  %16 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance6, i32 0, i32 0
  %SHL_instance11 = alloca %SHL_interface, align 8
  br label %input12

call8:                                            ; preds = %19
  %call64 = call i64 @SHL(%SHL_interface* %SHL_instance6)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %17 = icmp ne i64 %call64, 0
  br i1 %17, label %13, label %12

18:                                               ; preds = %continue15
  %BOOL_TO_BYTE_instance58 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input59

19:                                               ; preds = %continue62, %continue15
  %20 = phi i64 [ %call57, %continue15 ], [ %52, %continue62 ]
  store i64 %20, i64* %16, align 4
  %21 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance6, i32 0, i32 1
  store i16 1, i16* %21, align 2
  br label %call8

input12:                                          ; preds = %input7
  %22 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance11, i32 0, i32 0
  %SHL_instance16 = alloca %SHL_interface, align 8
  br label %input17

call13:                                           ; preds = %25
  %call57 = call i64 @SHL(%SHL_interface* %SHL_instance11)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %23 = icmp ne i64 %call57, 0
  br i1 %23, label %19, label %18

24:                                               ; preds = %continue20
  %BOOL_TO_BYTE_instance51 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input52

25:                                               ; preds = %continue55, %continue20
  %26 = phi i64 [ %call50, %continue20 ], [ %50, %continue55 ]
  store i64 %26, i64* %22, align 4
  %27 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance11, i32 0, i32 1
  store i16 1, i16* %27, align 2
  br label %call13

input17:                                          ; preds = %input12
  %28 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance16, i32 0, i32 0
  %SHL_instance21 = alloca %SHL_interface, align 8
  br label %input22

call18:                                           ; preds = %31
  %call50 = call i64 @SHL(%SHL_interface* %SHL_instance16)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %29 = icmp ne i64 %call50, 0
  br i1 %29, label %25, label %24

30:                                               ; preds = %continue25
  %BOOL_TO_BYTE_instance44 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input45

31:                                               ; preds = %continue48, %continue25
  %32 = phi i64 [ %call43, %continue25 ], [ %48, %continue48 ]
  store i64 %32, i64* %28, align 4
  %33 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance16, i32 0, i32 1
  store i16 1, i16* %33, align 2
  br label %call18

input22:                                          ; preds = %input17
  %34 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance21, i32 0, i32 0
  %SHL_instance26 = alloca %SHL_interface, align 8
  br label %input27

call23:                                           ; preds = %37
  %call43 = call i64 @SHL(%SHL_interface* %SHL_instance21)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %35 = icmp ne i64 %call43, 0
  br i1 %35, label %31, label %30

36:                                               ; preds = %continue30
  %BOOL_TO_BYTE_instance37 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input38

37:                                               ; preds = %continue41, %continue30
  %38 = phi i64 [ %call36, %continue30 ], [ %46, %continue41 ]
  store i64 %38, i64* %34, align 4
  %39 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance21, i32 0, i32 1
  store i16 1, i16* %39, align 2
  br label %call23

input27:                                          ; preds = %input22
  %40 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance26, i32 0, i32 0
  %BOOL_TO_BYTE_instance = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input31

call28:                                           ; preds = %continue34
  %call36 = call i64 @SHL(%SHL_interface* %SHL_instance26)
  br label %output29

output29:                                         ; preds = %call28
  br label %continue30

continue30:                                       ; preds = %output29
  %41 = icmp ne i64 %call36, 0
  br i1 %41, label %37, label %36

input31:                                          ; preds = %input27
  %42 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance, i32 0, i32 0
  %load_B7 = load i8, i8* %B7, align 1
  store i8 %load_B7, i8* %42, align 1
  br label %call32

call32:                                           ; preds = %input31
  %call35 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  %43 = zext i8 %call35 to i64
  store i64 %43, i64* %40, align 4
  %44 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance26, i32 0, i32 1
  store i16 1, i16* %44, align 2
  br label %call28

input38:                                          ; preds = %36
  %45 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance37, i32 0, i32 0
  %load_B6 = load i8, i8* %B6, align 1
  store i8 %load_B6, i8* %45, align 1
  br label %call39

call39:                                           ; preds = %input38
  %call42 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance37)
  br label %output40

output40:                                         ; preds = %call39
  br label %continue41

continue41:                                       ; preds = %output40
  %46 = zext i8 %call42 to i64
  br label %37

input45:                                          ; preds = %30
  %47 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance44, i32 0, i32 0
  %load_B5 = load i8, i8* %B5, align 1
  store i8 %load_B5, i8* %47, align 1
  br label %call46

call46:                                           ; preds = %input45
  %call49 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance44)
  br label %output47

output47:                                         ; preds = %call46
  br label %continue48

continue48:                                       ; preds = %output47
  %48 = zext i8 %call49 to i64
  br label %31

input52:                                          ; preds = %24
  %49 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance51, i32 0, i32 0
  %load_B4 = load i8, i8* %B4, align 1
  store i8 %load_B4, i8* %49, align 1
  br label %call53

call53:                                           ; preds = %input52
  %call56 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance51)
  br label %output54

output54:                                         ; preds = %call53
  br label %continue55

continue55:                                       ; preds = %output54
  %50 = zext i8 %call56 to i64
  br label %25

input59:                                          ; preds = %18
  %51 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance58, i32 0, i32 0
  %load_B3 = load i8, i8* %B3, align 1
  store i8 %load_B3, i8* %51, align 1
  br label %call60

call60:                                           ; preds = %input59
  %call63 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance58)
  br label %output61

output61:                                         ; preds = %call60
  br label %continue62

continue62:                                       ; preds = %output61
  %52 = zext i8 %call63 to i64
  br label %19

input66:                                          ; preds = %12
  %53 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance65, i32 0, i32 0
  %load_B2 = load i8, i8* %B2, align 1
  store i8 %load_B2, i8* %53, align 1
  br label %call67

call67:                                           ; preds = %input66
  %call70 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance65)
  br label %output68

output68:                                         ; preds = %call67
  br label %continue69

continue69:                                       ; preds = %output68
  %54 = zext i8 %call70 to i64
  br label %13

input73:                                          ; preds = %6
  %55 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance72, i32 0, i32 0
  %load_B1 = load i8, i8* %B1, align 1
  store i8 %load_B1, i8* %55, align 1
  br label %call74

call74:                                           ; preds = %input73
  %call77 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance72)
  br label %output75

output75:                                         ; preds = %call74
  br label %continue76

continue76:                                       ; preds = %output75
  %56 = zext i8 %call77 to i64
  br label %7

input80:                                          ; preds = %1
  %57 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance79, i32 0, i32 0
  %load_B0 = load i8, i8* %B0, align 1
  store i8 %load_B0, i8* %57, align 1
  br label %call81

call81:                                           ; preds = %input80
  %call84 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance79)
  br label %output82

output82:                                         ; preds = %call81
  br label %continue83

continue83:                                       ; preds = %output82
  %58 = zext i8 %call84 to i64
  br label %2
}

define i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %0) {
entry:
  %in = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %0, i32 0, i32 1
  %BYTE_OF_DWORD = alloca i8, align 1
  store i8 0, i8* %BYTE_OF_DWORD, align 1
  %DWORD_TO_BYTE_instance = alloca %DWORD_TO_BYTE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_BYTE_interface, %DWORD_TO_BYTE_interface* %DWORD_TO_BYTE_instance, i32 0, i32 0
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call11 = call i8 @DWORD_TO_BYTE(%DWORD_TO_BYTE_interface* %DWORD_TO_BYTE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i8 %call11, i8* %BYTE_OF_DWORD, align 1
  %BYTE_OF_DWORD_ret = load i8, i8* %BYTE_OF_DWORD, align 1
  ret i8 %BYTE_OF_DWORD_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in = load i32, i32* %in, align 4
  %3 = zext i32 %load_in to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  %call10 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %5 = trunc i64 %call10 to i32
  store i32 %5, i32* %1, align 4
  br label %call

input5:                                           ; preds = %input1
  %6 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_n = load i8, i8* %N, align 1
  %7 = zext i8 %load_n to i64
  store i64 %7, i64* %6, align 4
  %8 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 3, i16* %8, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %9 = trunc i64 %call9 to i16
  store i16 %9, i16* %4, align 2
  br label %call2
}

define void @BYTE_TO_BITS(%BYTE_TO_BITS_interface* %0) {
entry:
  %IN = getelementptr inbounds %BYTE_TO_BITS_interface, %BYTE_TO_BITS_interface* %0, i32 0, i32 0
  %B0 = getelementptr inbounds %BYTE_TO_BITS_interface, %BYTE_TO_BITS_interface* %0, i32 0, i32 1
  %B1 = getelementptr inbounds %BYTE_TO_BITS_interface, %BYTE_TO_BITS_interface* %0, i32 0, i32 2
  %B2 = getelementptr inbounds %BYTE_TO_BITS_interface, %BYTE_TO_BITS_interface* %0, i32 0, i32 3
  %B3 = getelementptr inbounds %BYTE_TO_BITS_interface, %BYTE_TO_BITS_interface* %0, i32 0, i32 4
  %B4 = getelementptr inbounds %BYTE_TO_BITS_interface, %BYTE_TO_BITS_interface* %0, i32 0, i32 5
  %B5 = getelementptr inbounds %BYTE_TO_BITS_interface, %BYTE_TO_BITS_interface* %0, i32 0, i32 6
  %B6 = getelementptr inbounds %BYTE_TO_BITS_interface, %BYTE_TO_BITS_interface* %0, i32 0, i32 7
  %B7 = getelementptr inbounds %BYTE_TO_BITS_interface, %BYTE_TO_BITS_interface* %0, i32 0, i32 8
  %load_IN = load i8, i8* %IN, align 1
  %shift = lshr i8 %load_IN, 0
  store i8 %shift, i8* %B0, align 1
  %load_IN1 = load i8, i8* %IN, align 1
  %shift2 = lshr i8 %load_IN1, 1
  store i8 %shift2, i8* %B1, align 1
  %load_IN3 = load i8, i8* %IN, align 1
  %shift4 = lshr i8 %load_IN3, 2
  store i8 %shift4, i8* %B2, align 1
  %load_IN5 = load i8, i8* %IN, align 1
  %shift6 = lshr i8 %load_IN5, 3
  store i8 %shift6, i8* %B3, align 1
  %load_IN7 = load i8, i8* %IN, align 1
  %shift8 = lshr i8 %load_IN7, 4
  store i8 %shift8, i8* %B4, align 1
  %load_IN9 = load i8, i8* %IN, align 1
  %shift10 = lshr i8 %load_IN9, 5
  store i8 %shift10, i8* %B5, align 1
  %load_IN11 = load i8, i8* %IN, align 1
  %shift12 = lshr i8 %load_IN11, 6
  store i8 %shift12, i8* %B6, align 1
  %load_IN13 = load i8, i8* %IN, align 1
  %shift14 = lshr i8 %load_IN13, 7
  store i8 %shift14, i8* %B7, align 1
  ret void
}

define i8 @BYTE_TO_GRAY(%BYTE_TO_GRAY_interface* %0) {
entry:
  %IN = getelementptr inbounds %BYTE_TO_GRAY_interface, %BYTE_TO_GRAY_interface* %0, i32 0, i32 0
  %BYTE_TO_GRAY = alloca i8, align 1
  store i8 0, i8* %BYTE_TO_GRAY, align 1
  %load_IN = load i8, i8* %IN, align 1
  %1 = zext i8 %load_IN to i64
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_IN1 = load i8, i8* %IN, align 1
  %3 = zext i8 %load_IN1 to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 1, i16* %4, align 2
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = xor i64 %1, %call2
  store i64 %tmpVar, i8* %BYTE_TO_GRAY, align 4
  %BYTE_TO_GRAY_ret = load i8, i8* %BYTE_TO_GRAY, align 1
  ret i8 %BYTE_TO_GRAY_ret
}

define i8 @CHECK_PARITY(%CHECK_PARITY_interface* %0) {
entry:
  %in = getelementptr inbounds %CHECK_PARITY_interface, %CHECK_PARITY_interface* %0, i32 0, i32 0
  %p = getelementptr inbounds %CHECK_PARITY_interface, %CHECK_PARITY_interface* %0, i32 0, i32 1
  %CHECK_PARITY = alloca i8, align 1
  store i8 0, i8* %CHECK_PARITY, align 1
  %load_p = load i8, i8* %p, align 1
  %tmpVar = xor i8 %load_p, -1
  store i8 %tmpVar, i8* %CHECK_PARITY, align 1
  br label %condition_check

condition_check:                                  ; preds = %entry, %continue13
  %load_in = load i32, i32* %in, align 4
  %tmpVar1 = icmp sgt i32 %load_in, 0
  br i1 %tmpVar1, label %while_body, label %continue

while_body:                                       ; preds = %condition_check
  %load_CHECK_PARITY = load i8, i8* %CHECK_PARITY, align 1
  %1 = zext i8 %load_CHECK_PARITY to i32
  %load_in2 = load i32, i32* %in, align 4
  %shift = lshr i32 %load_in2, 0
  %2 = trunc i32 %shift to i8
  %3 = zext i8 %2 to i32
  %tmpVar3 = xor i32 %1, %3
  %load_in4 = load i32, i32* %in, align 4
  %shift5 = lshr i32 %load_in4, 1
  %4 = trunc i32 %shift5 to i8
  %5 = zext i8 %4 to i32
  %tmpVar6 = xor i32 %tmpVar3, %5
  %load_in7 = load i32, i32* %in, align 4
  %shift8 = lshr i32 %load_in7, 2
  %6 = trunc i32 %shift8 to i8
  %7 = zext i8 %6 to i32
  %tmpVar9 = xor i32 %tmpVar6, %7
  %load_in10 = load i32, i32* %in, align 4
  %shift11 = lshr i32 %load_in10, 3
  %8 = trunc i32 %shift11 to i8
  %9 = zext i8 %8 to i32
  %tmpVar12 = xor i32 %tmpVar9, %9
  store i32 %tmpVar12, i8* %CHECK_PARITY, align 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

continue:                                         ; preds = %condition_check
  %CHECK_PARITY_ret = load i8, i8* %CHECK_PARITY, align 1
  ret i8 %CHECK_PARITY_ret

input:                                            ; preds = %while_body
  %10 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in14 = load i32, i32* %in, align 4
  %11 = zext i32 %load_in14 to i64
  store i64 %11, i64* %10, align 4
  %12 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 4, i16* %12, align 2
  br label %call

call:                                             ; preds = %input
  %call15 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue13

continue13:                                       ; preds = %output
  %13 = trunc i64 %call15 to i32
  store i32 %13, i32* %in, align 4
  br label %condition_check
}

define i8 @CHK_REAL(%CHK_REAL_interface* %0) {
entry:
  %X = getelementptr inbounds %CHK_REAL_interface, %CHK_REAL_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %CHK_REAL_interface, %CHK_REAL_interface* %0, i32 0, i32 1
  %tmp = getelementptr inbounds %CHK_REAL_interface, %CHK_REAL_interface* %0, i32 0, i32 2
  %CHK_REAL = alloca i8, align 1
  store i32* null, i32** %pt, align 8
  store i32 0, i32* %tmp, align 4
  store i8 0, i8* %CHK_REAL, align 1
  store float* %X, i32** %pt, align 8
  %ROL_instance = alloca %ROL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 0
  %deref = load i32*, i32** %pt, align 8
  %load_tmpVar = load i32, i32* %deref, align 4
  %2 = zext i32 %load_tmpVar to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 1
  store i16 1, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @ROL(%ROL_interface* %ROL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = trunc i64 %call1 to i32
  store i32 %4, i32* %tmp, align 4
  %load_tmp = load i32, i32* %tmp, align 4
  %5 = zext i32 %load_tmp to i64
  %tmpVar = icmp slt i64 %5, 4278190080
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %continue
  store i8 0, i8* %CHK_REAL, align 1
  br label %continue3

branch:                                           ; preds = %continue
  %load_tmp5 = load i32, i32* %tmp, align 4
  %6 = zext i32 %load_tmp5 to i64
  %tmpVar6 = icmp eq i64 %6, 4278190080
  br i1 %tmpVar6, label %condition_body4, label %branch2

condition_body4:                                  ; preds = %branch
  store i8 32, i8* %CHK_REAL, align 1
  br label %continue3

branch2:                                          ; preds = %branch
  %load_tmp8 = load i32, i32* %tmp, align 4
  %7 = zext i32 %load_tmp8 to i64
  %tmpVar9 = icmp eq i64 %7, 4278190081
  br i1 %tmpVar9, label %condition_body7, label %else

condition_body7:                                  ; preds = %branch2
  store i8 64, i8* %CHK_REAL, align 1
  br label %continue3

else:                                             ; preds = %branch2
  store i8 -128, i8* %CHK_REAL, align 1
  br label %continue3

continue3:                                        ; preds = %else, %condition_body7, %condition_body4, %condition_body
  %CHK_REAL_ret = load i8, i8* %CHK_REAL, align 1
  ret i8 %CHK_REAL_ret
}

define void @DEC_2(%DEC_2_interface* %0) {
entry:
  %D = getelementptr inbounds %DEC_2_interface, %DEC_2_interface* %0, i32 0, i32 0
  %A = getelementptr inbounds %DEC_2_interface, %DEC_2_interface* %0, i32 0, i32 1
  %Q0 = getelementptr inbounds %DEC_2_interface, %DEC_2_interface* %0, i32 0, i32 2
  %Q1 = getelementptr inbounds %DEC_2_interface, %DEC_2_interface* %0, i32 0, i32 3
  %load_D = load i8, i8* %D, align 1
  %1 = zext i8 %load_D to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %3, label %5

3:                                                ; preds = %entry
  %load_A = load i8, i8* %A, align 1
  %tmpVar = xor i8 %load_A, -1
  %4 = zext i8 %tmpVar to i32
  br label %5

5:                                                ; preds = %3, %entry
  %6 = phi i32 [ %1, %entry ], [ %4, %3 ]
  store i32 %6, i8* %Q0, align 4
  %load_D1 = load i8, i8* %D, align 1
  %7 = zext i8 %load_D1 to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %9, label %11

9:                                                ; preds = %5
  %load_A2 = load i8, i8* %A, align 1
  %10 = zext i8 %load_A2 to i32
  br label %11

11:                                               ; preds = %9, %5
  %12 = phi i32 [ %7, %5 ], [ %10, %9 ]
  store i32 %12, i8* %Q1, align 4
  ret void
}

define void @DEC_4(%DEC_4_interface* %0) {
entry:
  %D = getelementptr inbounds %DEC_4_interface, %DEC_4_interface* %0, i32 0, i32 0
  %A0 = getelementptr inbounds %DEC_4_interface, %DEC_4_interface* %0, i32 0, i32 1
  %A1 = getelementptr inbounds %DEC_4_interface, %DEC_4_interface* %0, i32 0, i32 2
  %Q0 = getelementptr inbounds %DEC_4_interface, %DEC_4_interface* %0, i32 0, i32 3
  %Q1 = getelementptr inbounds %DEC_4_interface, %DEC_4_interface* %0, i32 0, i32 4
  %Q2 = getelementptr inbounds %DEC_4_interface, %DEC_4_interface* %0, i32 0, i32 5
  %Q3 = getelementptr inbounds %DEC_4_interface, %DEC_4_interface* %0, i32 0, i32 6
  %load_D = load i8, i8* %D, align 1
  %1 = zext i8 %load_D to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %9, label %11

3:                                                ; preds = %11
  %load_A1 = load i8, i8* %A1, align 1
  %tmpVar1 = xor i8 %load_A1, -1
  %4 = zext i8 %tmpVar1 to i32
  br label %5

5:                                                ; preds = %3, %11
  %6 = phi i32 [ %12, %11 ], [ %4, %3 ]
  store i32 %6, i8* %Q0, align 4
  %load_D2 = load i8, i8* %D, align 1
  %7 = zext i8 %load_D2 to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %20, label %22

9:                                                ; preds = %entry
  %load_A0 = load i8, i8* %A0, align 1
  %tmpVar = xor i8 %load_A0, -1
  %10 = zext i8 %tmpVar to i32
  br label %11

11:                                               ; preds = %9, %entry
  %12 = phi i32 [ %1, %entry ], [ %10, %9 ]
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %3, label %5

14:                                               ; preds = %22
  %load_A14 = load i8, i8* %A1, align 1
  %tmpVar5 = xor i8 %load_A14, -1
  %15 = zext i8 %tmpVar5 to i32
  br label %16

16:                                               ; preds = %14, %22
  %17 = phi i32 [ %23, %22 ], [ %15, %14 ]
  store i32 %17, i8* %Q1, align 4
  %load_D6 = load i8, i8* %D, align 1
  %18 = zext i8 %load_D6 to i32
  %19 = icmp ne i32 %18, 0
  br i1 %19, label %31, label %33

20:                                               ; preds = %5
  %load_A03 = load i8, i8* %A0, align 1
  %21 = zext i8 %load_A03 to i32
  br label %22

22:                                               ; preds = %20, %5
  %23 = phi i32 [ %7, %5 ], [ %21, %20 ]
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %14, label %16

25:                                               ; preds = %33
  %load_A19 = load i8, i8* %A1, align 1
  %26 = zext i8 %load_A19 to i32
  br label %27

27:                                               ; preds = %25, %33
  %28 = phi i32 [ %34, %33 ], [ %26, %25 ]
  store i32 %28, i8* %Q2, align 4
  %load_D10 = load i8, i8* %D, align 1
  %29 = zext i8 %load_D10 to i32
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %40, label %42

31:                                               ; preds = %16
  %load_A07 = load i8, i8* %A0, align 1
  %tmpVar8 = xor i8 %load_A07, -1
  %32 = zext i8 %tmpVar8 to i32
  br label %33

33:                                               ; preds = %31, %16
  %34 = phi i32 [ %18, %16 ], [ %32, %31 ]
  %35 = icmp ne i32 %34, 0
  br i1 %35, label %25, label %27

36:                                               ; preds = %42
  %load_A112 = load i8, i8* %A1, align 1
  %37 = zext i8 %load_A112 to i32
  br label %38

38:                                               ; preds = %36, %42
  %39 = phi i32 [ %43, %42 ], [ %37, %36 ]
  store i32 %39, i8* %Q3, align 4
  ret void

40:                                               ; preds = %27
  %load_A011 = load i8, i8* %A0, align 1
  %41 = zext i8 %load_A011 to i32
  br label %42

42:                                               ; preds = %40, %27
  %43 = phi i32 [ %29, %27 ], [ %41, %40 ]
  %44 = icmp ne i32 %43, 0
  br i1 %44, label %36, label %38
}

define void @DEC_8(%DEC_8_interface* %0) {
entry:
  %D = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 0
  %A0 = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 1
  %A1 = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 2
  %A2 = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 3
  %Q0 = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 4
  %Q1 = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 5
  %Q2 = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 6
  %Q3 = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 7
  %Q4 = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 8
  %Q5 = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 9
  %Q6 = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 10
  %Q7 = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 11
  %X = getelementptr inbounds %DEC_8_interface, %DEC_8_interface* %0, i32 0, i32 12
  %1 = load i16, i16* %X, align 2
  %erase = and i16 %1, -2
  %load_A0 = load i8, i8* %A0, align 1
  %2 = zext i8 %load_A0 to i16
  %value = shl i16 %2, 0
  %or = or i16 %erase, %value
  store i16 %or, i16* %X, align 2
  %3 = load i16, i16* %X, align 2
  %erase1 = and i16 %3, -3
  %load_A1 = load i8, i8* %A1, align 1
  %4 = zext i8 %load_A1 to i16
  %value2 = shl i16 %4, 1
  %or3 = or i16 %erase1, %value2
  store i16 %or3, i16* %X, align 2
  %5 = load i16, i16* %X, align 2
  %erase4 = and i16 %5, -5
  %load_A2 = load i8, i8* %A2, align 1
  %6 = zext i8 %load_A2 to i16
  %value5 = shl i16 %6, 2
  %or6 = or i16 %erase4, %value5
  store i16 %or6, i16* %X, align 2
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i8 0, i8* %Q4, align 1
  store i8 0, i8* %Q5, align 1
  store i8 0, i8* %Q6, align 1
  store i8 0, i8* %Q7, align 1
  %load_X = load i16, i16* %X, align 2
  switch i16 %load_X, label %else [
    i16 0, label %case
    i16 1, label %case7
    i16 2, label %case9
    i16 3, label %case11
    i16 4, label %case13
    i16 5, label %case15
    i16 6, label %case17
    i16 7, label %case19
  ]

case:                                             ; preds = %entry
  %load_D = load i8, i8* %D, align 1
  store i8 %load_D, i8* %Q0, align 1
  br label %continue

case7:                                            ; preds = %entry
  %load_D8 = load i8, i8* %D, align 1
  store i8 %load_D8, i8* %Q1, align 1
  br label %continue

case9:                                            ; preds = %entry
  %load_D10 = load i8, i8* %D, align 1
  store i8 %load_D10, i8* %Q2, align 1
  br label %continue

case11:                                           ; preds = %entry
  %load_D12 = load i8, i8* %D, align 1
  store i8 %load_D12, i8* %Q3, align 1
  br label %continue

case13:                                           ; preds = %entry
  %load_D14 = load i8, i8* %D, align 1
  store i8 %load_D14, i8* %Q4, align 1
  br label %continue

case15:                                           ; preds = %entry
  %load_D16 = load i8, i8* %D, align 1
  store i8 %load_D16, i8* %Q5, align 1
  br label %continue

case17:                                           ; preds = %entry
  %load_D18 = load i8, i8* %D, align 1
  store i8 %load_D18, i8* %Q6, align 1
  br label %continue

case19:                                           ; preds = %entry
  %load_D20 = load i8, i8* %D, align 1
  store i8 %load_D20, i8* %Q7, align 1
  br label %continue

else:                                             ; preds = %entry
  br label %continue

continue:                                         ; preds = %else, %case19, %case17, %case15, %case13, %case11, %case9, %case7, %case
  ret void
}

define float @DW_TO_REAL(%DW_TO_REAL_interface* %0) {
entry:
  %X = getelementptr inbounds %DW_TO_REAL_interface, %DW_TO_REAL_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %DW_TO_REAL_interface, %DW_TO_REAL_interface* %0, i32 0, i32 1
  %DW_TO_REAL = alloca float, align 4
  store float* null, float** %pt, align 8
  store float 0.000000e+00, float* %DW_TO_REAL, align 4
  store i32* %X, float** %pt, align 8
  %deref = load float*, float** %pt, align 8
  %load_tmpVar = load float, float* %deref, align 4
  store float %load_tmpVar, float* %DW_TO_REAL, align 4
  %DW_TO_REAL_ret = load float, float* %DW_TO_REAL, align 4
  ret float %DW_TO_REAL_ret
}

define i32 @DWORD_OF_BYTE(%DWORD_OF_BYTE_interface* %0) {
entry:
  %B3 = getelementptr inbounds %DWORD_OF_BYTE_interface, %DWORD_OF_BYTE_interface* %0, i32 0, i32 0
  %B2 = getelementptr inbounds %DWORD_OF_BYTE_interface, %DWORD_OF_BYTE_interface* %0, i32 0, i32 1
  %B1 = getelementptr inbounds %DWORD_OF_BYTE_interface, %DWORD_OF_BYTE_interface* %0, i32 0, i32 2
  %B0 = getelementptr inbounds %DWORD_OF_BYTE_interface, %DWORD_OF_BYTE_interface* %0, i32 0, i32 3
  %DWORD_OF_BYTE = alloca i32, align 4
  store i32 0, i32* %DWORD_OF_BYTE, align 4
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

1:                                                ; preds = %continue
  %BYTE_TO_DWORD_instance31 = alloca %BYTE_TO_DWORD_interface, align 8
  br label %input32

2:                                                ; preds = %continue35, %continue
  %3 = phi i64 [ %call30, %continue ], [ %26, %continue35 ]
  store i64 %3, i32* %DWORD_OF_BYTE, align 4
  %DWORD_OF_BYTE_ret = load i32, i32* %DWORD_OF_BYTE, align 4
  ret i32 %DWORD_OF_BYTE_ret

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %SHL_instance1 = alloca %SHL_interface, align 8
  br label %input2

call:                                             ; preds = %7
  %call30 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = icmp ne i64 %call30, 0
  br i1 %5, label %2, label %1

6:                                                ; preds = %continue5
  %BYTE_TO_DWORD_instance24 = alloca %BYTE_TO_DWORD_interface, align 8
  br label %input25

7:                                                ; preds = %continue28, %continue5
  %8 = phi i64 [ %call23, %continue5 ], [ %24, %continue28 ]
  store i64 %8, i64* %4, align 4
  %9 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 8, i16* %9, align 2
  br label %call

input2:                                           ; preds = %input
  %10 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance1, i32 0, i32 0
  %SHL_instance6 = alloca %SHL_interface, align 8
  br label %input7

call3:                                            ; preds = %13
  %call23 = call i64 @SHL(%SHL_interface* %SHL_instance1)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %11 = icmp ne i64 %call23, 0
  br i1 %11, label %7, label %6

12:                                               ; preds = %continue10
  %BYTE_TO_DWORD_instance17 = alloca %BYTE_TO_DWORD_interface, align 8
  br label %input18

13:                                               ; preds = %continue21, %continue10
  %14 = phi i64 [ %call16, %continue10 ], [ %22, %continue21 ]
  store i64 %14, i64* %10, align 4
  %15 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance1, i32 0, i32 1
  store i16 8, i16* %15, align 2
  br label %call3

input7:                                           ; preds = %input2
  %16 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance6, i32 0, i32 0
  %BYTE_TO_DWORD_instance = alloca %BYTE_TO_DWORD_interface, align 8
  br label %input11

call8:                                            ; preds = %continue14
  %call16 = call i64 @SHL(%SHL_interface* %SHL_instance6)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %17 = icmp ne i64 %call16, 0
  br i1 %17, label %13, label %12

input11:                                          ; preds = %input7
  %18 = getelementptr inbounds %BYTE_TO_DWORD_interface, %BYTE_TO_DWORD_interface* %BYTE_TO_DWORD_instance, i32 0, i32 0
  %load_B3 = load i8, i8* %B3, align 1
  store i8 %load_B3, i8* %18, align 1
  br label %call12

call12:                                           ; preds = %input11
  %call15 = call i32 @BYTE_TO_DWORD(%BYTE_TO_DWORD_interface* %BYTE_TO_DWORD_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %19 = zext i32 %call15 to i64
  store i64 %19, i64* %16, align 4
  %20 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance6, i32 0, i32 1
  store i16 8, i16* %20, align 2
  br label %call8

input18:                                          ; preds = %12
  %21 = getelementptr inbounds %BYTE_TO_DWORD_interface, %BYTE_TO_DWORD_interface* %BYTE_TO_DWORD_instance17, i32 0, i32 0
  %load_B2 = load i8, i8* %B2, align 1
  store i8 %load_B2, i8* %21, align 1
  br label %call19

call19:                                           ; preds = %input18
  %call22 = call i32 @BYTE_TO_DWORD(%BYTE_TO_DWORD_interface* %BYTE_TO_DWORD_instance17)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %22 = zext i32 %call22 to i64
  br label %13

input25:                                          ; preds = %6
  %23 = getelementptr inbounds %BYTE_TO_DWORD_interface, %BYTE_TO_DWORD_interface* %BYTE_TO_DWORD_instance24, i32 0, i32 0
  %load_B1 = load i8, i8* %B1, align 1
  store i8 %load_B1, i8* %23, align 1
  br label %call26

call26:                                           ; preds = %input25
  %call29 = call i32 @BYTE_TO_DWORD(%BYTE_TO_DWORD_interface* %BYTE_TO_DWORD_instance24)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  %24 = zext i32 %call29 to i64
  br label %7

input32:                                          ; preds = %1
  %25 = getelementptr inbounds %BYTE_TO_DWORD_interface, %BYTE_TO_DWORD_interface* %BYTE_TO_DWORD_instance31, i32 0, i32 0
  %load_B0 = load i8, i8* %B0, align 1
  store i8 %load_B0, i8* %25, align 1
  br label %call33

call33:                                           ; preds = %input32
  %call36 = call i32 @BYTE_TO_DWORD(%BYTE_TO_DWORD_interface* %BYTE_TO_DWORD_instance31)
  br label %output34

output34:                                         ; preds = %call33
  br label %continue35

continue35:                                       ; preds = %output34
  %26 = zext i32 %call36 to i64
  br label %2
}

define i32 @DWORD_OF_WORD(%DWORD_OF_WORD_interface* %0) {
entry:
  %W1 = getelementptr inbounds %DWORD_OF_WORD_interface, %DWORD_OF_WORD_interface* %0, i32 0, i32 0
  %W0 = getelementptr inbounds %DWORD_OF_WORD_interface, %DWORD_OF_WORD_interface* %0, i32 0, i32 1
  %DWORD_OF_WORD = alloca i32, align 4
  store i32 0, i32* %DWORD_OF_WORD, align 4
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

1:                                                ; preds = %continue
  %WORD_TO_DWORD_instance7 = alloca %WORD_TO_DWORD_interface, align 8
  br label %input8

2:                                                ; preds = %continue11, %continue
  %3 = phi i64 [ %call6, %continue ], [ %10, %continue11 ]
  store i64 %3, i32* %DWORD_OF_WORD, align 4
  %DWORD_OF_WORD_ret = load i32, i32* %DWORD_OF_WORD, align 4
  ret i32 %DWORD_OF_WORD_ret

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %WORD_TO_DWORD_instance = alloca %WORD_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = icmp ne i64 %call6, 0
  br i1 %5, label %2, label %1

input1:                                           ; preds = %input
  %6 = getelementptr inbounds %WORD_TO_DWORD_interface, %WORD_TO_DWORD_interface* %WORD_TO_DWORD_instance, i32 0, i32 0
  %load_W1 = load i16, i16* %W1, align 2
  store i16 %load_W1, i16* %6, align 2
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @WORD_TO_DWORD(%WORD_TO_DWORD_interface* %WORD_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %7 = zext i32 %call5 to i64
  store i64 %7, i64* %4, align 4
  %8 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 16, i16* %8, align 2
  br label %call

input8:                                           ; preds = %1
  %9 = getelementptr inbounds %WORD_TO_DWORD_interface, %WORD_TO_DWORD_interface* %WORD_TO_DWORD_instance7, i32 0, i32 0
  %load_W0 = load i16, i16* %W0, align 2
  store i16 %load_W0, i16* %9, align 2
  br label %call9

call9:                                            ; preds = %input8
  %call12 = call i32 @WORD_TO_DWORD(%WORD_TO_DWORD_interface* %WORD_TO_DWORD_instance7)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %10 = zext i32 %call12 to i64
  br label %2
}

define i8 @GRAY_TO_BYTE(%GRAY_TO_BYTE_interface* %0) {
entry:
  %IN = getelementptr inbounds %GRAY_TO_BYTE_interface, %GRAY_TO_BYTE_interface* %0, i32 0, i32 0
  %GRAY_TO_BYTE = alloca i8, align 1
  store i8 0, i8* %GRAY_TO_BYTE, align 1
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_IN = load i8, i8* %IN, align 1
  %2 = zext i8 %load_IN to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 4, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_IN2 = load i8, i8* %IN, align 1
  %4 = zext i8 %load_IN2 to i64
  %tmpVar = xor i64 %call1, %4
  store i64 %tmpVar, i8* %GRAY_TO_BYTE, align 4
  %SHR_instance3 = alloca %SHR_interface, align 8
  br label %input4

input4:                                           ; preds = %continue
  %5 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance3, i32 0, i32 0
  %load_GRAY_TO_BYTE = load i8, i8* %GRAY_TO_BYTE, align 1
  %6 = zext i8 %load_GRAY_TO_BYTE to i64
  store i64 %6, i64* %5, align 4
  %7 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance3, i32 0, i32 1
  store i16 2, i16* %7, align 2
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call i64 @SHR(%SHR_interface* %SHR_instance3)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %load_GRAY_TO_BYTE9 = load i8, i8* %GRAY_TO_BYTE, align 1
  %8 = zext i8 %load_GRAY_TO_BYTE9 to i64
  %tmpVar10 = xor i64 %call8, %8
  store i64 %tmpVar10, i8* %GRAY_TO_BYTE, align 4
  %SHR_instance11 = alloca %SHR_interface, align 8
  br label %input12

input12:                                          ; preds = %continue7
  %9 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance11, i32 0, i32 0
  %load_GRAY_TO_BYTE16 = load i8, i8* %GRAY_TO_BYTE, align 1
  %10 = zext i8 %load_GRAY_TO_BYTE16 to i64
  store i64 %10, i64* %9, align 4
  %11 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance11, i32 0, i32 1
  store i16 1, i16* %11, align 2
  br label %call13

call13:                                           ; preds = %input12
  %call17 = call i64 @SHR(%SHR_interface* %SHR_instance11)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %load_GRAY_TO_BYTE18 = load i8, i8* %GRAY_TO_BYTE, align 1
  %12 = zext i8 %load_GRAY_TO_BYTE18 to i64
  %tmpVar19 = xor i64 %call17, %12
  store i64 %tmpVar19, i8* %GRAY_TO_BYTE, align 4
  %GRAY_TO_BYTE_ret = load i8, i8* %GRAY_TO_BYTE, align 1
  ret i8 %GRAY_TO_BYTE_ret
}

define i8 @INT_TO_BCDC(%INT_TO_BCDC_interface* %0) {
entry:
  %IN = getelementptr inbounds %INT_TO_BCDC_interface, %INT_TO_BCDC_interface* %0, i32 0, i32 0
  %INT_TO_BCDC = alloca i8, align 1
  store i8 0, i8* %INT_TO_BCDC, align 1
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

1:                                                ; preds = %continue
  %INT_TO_BYTE_instance7 = alloca %INT_TO_BYTE_interface, align 8
  br label %input8

2:                                                ; preds = %continue11, %continue
  %3 = phi i64 [ %call6, %continue ], [ %14, %continue11 ]
  store i64 %3, i8* %INT_TO_BCDC, align 4
  %INT_TO_BCDC_ret = load i8, i8* %INT_TO_BCDC, align 1
  ret i8 %INT_TO_BCDC_ret

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %INT_TO_BYTE_instance = alloca %INT_TO_BYTE_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = icmp ne i64 %call6, 0
  br i1 %5, label %2, label %1

input1:                                           ; preds = %input
  %6 = getelementptr inbounds %INT_TO_BYTE_interface, %INT_TO_BYTE_interface* %INT_TO_BYTE_instance, i32 0, i32 0
  %load_IN = load i16, i16* %IN, align 2
  %7 = sext i16 %load_IN to i32
  %tmpVar = sdiv i32 %7, 10
  %8 = trunc i32 %tmpVar to i16
  store i16 %8, i16* %6, align 2
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i8 @INT_TO_BYTE(%INT_TO_BYTE_interface* %INT_TO_BYTE_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %9 = zext i8 %call5 to i64
  store i64 %9, i64* %4, align 4
  %10 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 4, i16* %10, align 2
  br label %call

input8:                                           ; preds = %1
  %11 = getelementptr inbounds %INT_TO_BYTE_interface, %INT_TO_BYTE_interface* %INT_TO_BYTE_instance7, i32 0, i32 0
  %load_in = load i16, i16* %IN, align 2
  %12 = sext i16 %load_in to i32
  %tmpVar12 = srem i32 %12, 10
  %13 = trunc i32 %tmpVar12 to i16
  store i16 %13, i16* %11, align 2
  br label %call9

call9:                                            ; preds = %input8
  %call13 = call i8 @INT_TO_BYTE(%INT_TO_BYTE_interface* %INT_TO_BYTE_instance7)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %14 = zext i8 %call13 to i64
  br label %2
}

define i8 @MUX_2(%MUX_2_interface* %0) {
entry:
  %D0 = getelementptr inbounds %MUX_2_interface, %MUX_2_interface* %0, i32 0, i32 0
  %D1 = getelementptr inbounds %MUX_2_interface, %MUX_2_interface* %0, i32 0, i32 1
  %A0 = getelementptr inbounds %MUX_2_interface, %MUX_2_interface* %0, i32 0, i32 2
  %MUX_2 = alloca i8, align 1
  store i8 0, i8* %MUX_2, align 1
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_A0 = load i8, i8* %A0, align 1
  store i8 %load_A0, i8* %1, align 1
  %2 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_D0 = load i8, i8* %D0, align 1
  %3 = zext i8 %load_D0 to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_D1 = load i8, i8* %D1, align 1
  %5 = zext i8 %load_D1 to i64
  store i64 %5, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %6 = trunc i64 %call1 to i8
  store i8 %6, i8* %MUX_2, align 1
  %MUX_2_ret = load i8, i8* %MUX_2, align 1
  ret i8 %MUX_2_ret
}

define i8 @MUX_4(%MUX_4_interface* %0) {
entry:
  %D0 = getelementptr inbounds %MUX_4_interface, %MUX_4_interface* %0, i32 0, i32 0
  %D1 = getelementptr inbounds %MUX_4_interface, %MUX_4_interface* %0, i32 0, i32 1
  %D2 = getelementptr inbounds %MUX_4_interface, %MUX_4_interface* %0, i32 0, i32 2
  %D3 = getelementptr inbounds %MUX_4_interface, %MUX_4_interface* %0, i32 0, i32 3
  %A0 = getelementptr inbounds %MUX_4_interface, %MUX_4_interface* %0, i32 0, i32 4
  %A1 = getelementptr inbounds %MUX_4_interface, %MUX_4_interface* %0, i32 0, i32 5
  %MUX_4 = alloca i8, align 1
  store i8 0, i8* %MUX_4, align 1
  %load_A1 = load i8, i8* %A1, align 1
  %1 = icmp ne i8 %load_A1, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %SEL_instance3 = alloca %SEL_interface, align 8
  br label %input4

continue:                                         ; preds = %continue7, %continue1
  %MUX_4_ret = load i8, i8* %MUX_4, align 1
  ret i8 %MUX_4_ret

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_A0 = load i8, i8* %A0, align 1
  store i8 %load_A0, i8* %2, align 1
  %3 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_D2 = load i8, i8* %D2, align 1
  %4 = zext i8 %load_D2 to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_D3 = load i8, i8* %D3, align 1
  %6 = zext i8 %load_D3 to i64
  store i64 %6, i64* %5, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %7 = trunc i64 %call2 to i8
  store i8 %7, i8* %MUX_4, align 1
  br label %continue

input4:                                           ; preds = %else
  %8 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance3, i32 0, i32 0
  %load_A08 = load i8, i8* %A0, align 1
  store i8 %load_A08, i8* %8, align 1
  %9 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance3, i32 0, i32 1
  %load_D0 = load i8, i8* %D0, align 1
  %10 = zext i8 %load_D0 to i64
  store i64 %10, i64* %9, align 4
  %11 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance3, i32 0, i32 2
  %load_D1 = load i8, i8* %D1, align 1
  %12 = zext i8 %load_D1 to i64
  store i64 %12, i64* %11, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call9 = call i64 @SEL(%SEL_interface* %SEL_instance3)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %13 = trunc i64 %call9 to i8
  store i8 %13, i8* %MUX_4, align 1
  br label %continue
}

define i8 @PARITY(%PARITY_interface* %0) {
entry:
  %in = getelementptr inbounds %PARITY_interface, %PARITY_interface* %0, i32 0, i32 0
  %PARITY = alloca i8, align 1
  store i8 0, i8* %PARITY, align 1
  br label %condition_check

condition_check:                                  ; preds = %entry, %continue12
  %load_in = load i32, i32* %in, align 4
  %tmpVar = icmp sgt i32 %load_in, 0
  br i1 %tmpVar, label %while_body, label %continue

while_body:                                       ; preds = %condition_check
  %load_PARITY = load i8, i8* %PARITY, align 1
  %1 = zext i8 %load_PARITY to i32
  %load_in1 = load i32, i32* %in, align 4
  %shift = lshr i32 %load_in1, 0
  %2 = trunc i32 %shift to i8
  %3 = zext i8 %2 to i32
  %tmpVar2 = xor i32 %1, %3
  %load_in3 = load i32, i32* %in, align 4
  %shift4 = lshr i32 %load_in3, 1
  %4 = trunc i32 %shift4 to i8
  %5 = zext i8 %4 to i32
  %tmpVar5 = xor i32 %tmpVar2, %5
  %load_in6 = load i32, i32* %in, align 4
  %shift7 = lshr i32 %load_in6, 2
  %6 = trunc i32 %shift7 to i8
  %7 = zext i8 %6 to i32
  %tmpVar8 = xor i32 %tmpVar5, %7
  %load_in9 = load i32, i32* %in, align 4
  %shift10 = lshr i32 %load_in9, 3
  %8 = trunc i32 %shift10 to i8
  %9 = zext i8 %8 to i32
  %tmpVar11 = xor i32 %tmpVar8, %9
  store i32 %tmpVar11, i8* %PARITY, align 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

continue:                                         ; preds = %condition_check
  %PARITY_ret = load i8, i8* %PARITY, align 1
  ret i8 %PARITY_ret

input:                                            ; preds = %while_body
  %10 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in13 = load i32, i32* %in, align 4
  %11 = zext i32 %load_in13 to i64
  store i64 %11, i64* %10, align 4
  %12 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 4, i16* %12, align 2
  br label %call

call:                                             ; preds = %input
  %call14 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue12

continue12:                                       ; preds = %output
  %13 = trunc i64 %call14 to i32
  store i32 %13, i32* %in, align 4
  br label %condition_check
}

define i32 @REAL_TO_DW(%REAL_TO_DW_interface* %0) {
entry:
  %X = getelementptr inbounds %REAL_TO_DW_interface, %REAL_TO_DW_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %REAL_TO_DW_interface, %REAL_TO_DW_interface* %0, i32 0, i32 1
  %REAL_TO_DW = alloca i32, align 4
  store i32* null, i32** %pt, align 8
  store i32 0, i32* %REAL_TO_DW, align 4
  store float* %X, i32** %pt, align 8
  %deref = load i32*, i32** %pt, align 8
  %load_tmpVar = load i32, i32* %deref, align 4
  store i32 %load_tmpVar, i32* %REAL_TO_DW, align 4
  %REAL_TO_DW_ret = load i32, i32* %REAL_TO_DW, align 4
  ret i32 %REAL_TO_DW_ret
}

define i32 @REFLECT(%REFLECT_interface* %0) {
entry:
  %D = getelementptr inbounds %REFLECT_interface, %REFLECT_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %REFLECT_interface, %REFLECT_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %REFLECT_interface, %REFLECT_interface* %0, i32 0, i32 2
  %REFLECT = alloca i32, align 4
  store i16 0, i16* %i, align 2
  store i32 0, i32* %REFLECT, align 4
  store i32 0, i32* %REFLECT, align 4
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %entry
  %load_i = load i16, i16* %i, align 2
  %load_i1 = load i16, i16* %i, align 2
  %load_L = load i16, i16* %L, align 2
  %tmpVar = icmp sle i16 %load_i1, %load_L
  %1 = icmp ne i1 %tmpVar, false
  br i1 %1, label %8, label %9

for_body:                                         ; preds = %6
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

increment:                                        ; preds = %continue19
  %tmpVar22 = add i16 %load_i, 1
  store i16 %tmpVar22, i16* %i, align 2
  br label %condition_check

continue:                                         ; preds = %6
  %load_REFLECT23 = load i32, i32* %REFLECT, align 4
  %2 = zext i32 %load_REFLECT23 to i64
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %30, label %29

4:                                                ; preds = %9
  %load_i4 = load i16, i16* %i, align 2
  %load_L5 = load i16, i16* %L, align 2
  %tmpVar6 = icmp sge i16 %load_i4, %load_L5
  %5 = icmp ne i1 %tmpVar6, false
  br i1 %5, label %12, label %13

6:                                                ; preds = %13, %9
  %7 = phi i1 [ %10, %9 ], [ %14, %13 ]
  br i1 %7, label %for_body, label %continue

8:                                                ; preds = %condition_check
  %load_i2 = load i16, i16* %i, align 2
  %tmpVar3 = icmp sge i16 %load_i2, 1
  br label %9

9:                                                ; preds = %8, %condition_check
  %10 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar3, %8 ]
  %11 = icmp ne i1 %10, false
  br i1 %11, label %6, label %4

12:                                               ; preds = %4
  %load_i7 = load i16, i16* %i, align 2
  %tmpVar8 = icmp sle i16 %load_i7, 1
  br label %13

13:                                               ; preds = %12, %4
  %14 = phi i1 [ %tmpVar6, %4 ], [ %tmpVar8, %12 ]
  br label %6

15:                                               ; preds = %continue9
  %BOOL_TO_DWORD_instance = alloca %BOOL_TO_DWORD_interface, align 8
  br label %input11

16:                                               ; preds = %continue14, %continue9
  %17 = phi i64 [ %call10, %continue9 ], [ %24, %continue14 ]
  store i64 %17, i32* %REFLECT, align 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input16

input:                                            ; preds = %for_body
  %18 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_REFLECT = load i32, i32* %REFLECT, align 4
  %19 = zext i32 %load_REFLECT to i64
  store i64 %19, i64* %18, align 4
  %20 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 1, i16* %20, align 2
  br label %call

call:                                             ; preds = %input
  %call10 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue9

continue9:                                        ; preds = %output
  %21 = icmp ne i64 %call10, 0
  br i1 %21, label %16, label %15

input11:                                          ; preds = %15
  %22 = getelementptr inbounds %BOOL_TO_DWORD_interface, %BOOL_TO_DWORD_interface* %BOOL_TO_DWORD_instance, i32 0, i32 0
  %load_D = load i32, i32* %D, align 4
  %shift = lshr i32 %load_D, 0
  %23 = trunc i32 %shift to i8
  store i8 %23, i8* %22, align 1
  br label %call12

call12:                                           ; preds = %input11
  %call15 = call i32 @BOOL_TO_DWORD(%BOOL_TO_DWORD_interface* %BOOL_TO_DWORD_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %24 = zext i32 %call15 to i64
  br label %16

input16:                                          ; preds = %16
  %25 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_D20 = load i32, i32* %D, align 4
  %26 = zext i32 %load_D20 to i64
  store i64 %26, i64* %25, align 4
  %27 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 1, i16* %27, align 2
  br label %call17

call17:                                           ; preds = %input16
  %call21 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %28 = trunc i64 %call21 to i32
  store i32 %28, i32* %D, align 4
  br label %increment

29:                                               ; preds = %continue
  %SHL_instance24 = alloca %SHL_interface, align 8
  br label %input25

30:                                               ; preds = %continue28, %continue
  %31 = phi i64 [ %2, %continue ], [ %call31, %continue28 ]
  store i64 %31, i32* %REFLECT, align 4
  %REFLECT_ret = load i32, i32* %REFLECT, align 4
  ret i32 %REFLECT_ret

input25:                                          ; preds = %29
  %32 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance24, i32 0, i32 0
  %load_D29 = load i32, i32* %D, align 4
  %33 = zext i32 %load_D29 to i64
  store i64 %33, i64* %32, align 4
  %34 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance24, i32 0, i32 1
  %load_L30 = load i16, i16* %L, align 2
  store i16 %load_L30, i16* %34, align 2
  br label %call26

call26:                                           ; preds = %input25
  %call31 = call i64 @SHL(%SHL_interface* %SHL_instance24)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  br label %30
}

define i8 @REVERSE(%REVERSE_interface* %0) {
entry:
  %IN = getelementptr inbounds %REVERSE_interface, %REVERSE_interface* %0, i32 0, i32 0
  %REVERSE = alloca i8, align 1
  store i8 0, i8* %REVERSE, align 1
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

1:                                                ; preds = %5
  %SHR_instance27 = alloca %SHR_interface, align 8
  br label %input28

2:                                                ; preds = %49, %5
  %3 = phi i32 [ %6, %5 ], [ %50, %49 ]
  store i32 %3, i8* %REVERSE, align 4
  %REVERSE_ret = load i8, i8* %REVERSE, align 1
  ret i8 %REVERSE_ret

4:                                                ; preds = %9
  %SHL_instance20 = alloca %SHL_interface, align 8
  br label %input21

5:                                                ; preds = %42, %9
  %6 = phi i32 [ %10, %9 ], [ %43, %42 ]
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %2, label %1

8:                                                ; preds = %13
  %ROL_instance = alloca %ROL_interface, align 8
  br label %input14

9:                                                ; preds = %35, %13
  %10 = phi i32 [ %14, %13 ], [ %36, %35 ]
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %5, label %4

12:                                               ; preds = %17
  %ROR_instance = alloca %ROR_interface, align 8
  br label %input8

13:                                               ; preds = %28, %17
  %14 = phi i32 [ %18, %17 ], [ %29, %28 ]
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %9, label %8

16:                                               ; preds = %continue
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input2

17:                                               ; preds = %continue5, %continue
  %18 = phi i64 [ %call1, %continue ], [ %call7, %continue5 ]
  %19 = icmp ne i64 %18, i32 0
  br i1 %19, label %13, label %12

input:                                            ; preds = %entry
  %20 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_in = load i8, i8* %IN, align 1
  %21 = zext i8 %load_in to i64
  store i64 %21, i64* %20, align 4
  %22 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 7, i16* %22, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %23 = icmp ne i64 %call1, 0
  br i1 %23, label %17, label %16

input2:                                           ; preds = %16
  %24 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in6 = load i8, i8* %IN, align 1
  %25 = zext i8 %load_in6 to i64
  store i64 %25, i64* %24, align 4
  %26 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 7, i16* %26, align 2
  br label %call3

call3:                                            ; preds = %input2
  %call7 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  br label %17

27:                                               ; preds = %continue11
  br label %28

28:                                               ; preds = %27, %continue11
  %29 = phi i64 [ %call13, %continue11 ], [ 68, %27 ]
  br label %13

input8:                                           ; preds = %12
  %30 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance, i32 0, i32 0
  %load_in12 = load i8, i8* %IN, align 1
  %31 = zext i8 %load_in12 to i64
  store i64 %31, i64* %30, align 4
  %32 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance, i32 0, i32 1
  store i16 3, i16* %32, align 2
  br label %call9

call9:                                            ; preds = %input8
  %call13 = call i64 @ROR(%ROR_interface* %ROR_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %33 = icmp ne i64 %call13, 0
  br i1 %33, label %27, label %28

34:                                               ; preds = %continue17
  br label %35

35:                                               ; preds = %34, %continue17
  %36 = phi i64 [ %call19, %continue17 ], [ 34, %34 ]
  br label %9

input14:                                          ; preds = %8
  %37 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 0
  %load_in18 = load i8, i8* %IN, align 1
  %38 = zext i8 %load_in18 to i64
  store i64 %38, i64* %37, align 4
  %39 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 1
  store i16 3, i16* %39, align 2
  br label %call15

call15:                                           ; preds = %input14
  %call19 = call i64 @ROL(%ROL_interface* %ROL_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %40 = icmp ne i64 %call19, 0
  br i1 %40, label %34, label %35

41:                                               ; preds = %continue24
  br label %42

42:                                               ; preds = %41, %continue24
  %43 = phi i64 [ %call26, %continue24 ], [ 16, %41 ]
  br label %5

input21:                                          ; preds = %4
  %44 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance20, i32 0, i32 0
  %load_in25 = load i8, i8* %IN, align 1
  %45 = zext i8 %load_in25 to i64
  store i64 %45, i64* %44, align 4
  %46 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance20, i32 0, i32 1
  store i16 1, i16* %46, align 2
  br label %call22

call22:                                           ; preds = %input21
  %call26 = call i64 @SHL(%SHL_interface* %SHL_instance20)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %47 = icmp ne i64 %call26, 0
  br i1 %47, label %41, label %42

48:                                               ; preds = %continue31
  br label %49

49:                                               ; preds = %48, %continue31
  %50 = phi i64 [ %call33, %continue31 ], [ 8, %48 ]
  br label %2

input28:                                          ; preds = %1
  %51 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance27, i32 0, i32 0
  %load_in32 = load i8, i8* %IN, align 1
  %52 = zext i8 %load_in32 to i64
  store i64 %52, i64* %51, align 4
  %53 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance27, i32 0, i32 1
  store i16 1, i16* %53, align 2
  br label %call29

call29:                                           ; preds = %input28
  %call33 = call i64 @SHR(%SHR_interface* %SHR_instance27)
  br label %output30

output30:                                         ; preds = %call29
  br label %continue31

continue31:                                       ; preds = %output30
  %54 = icmp ne i64 %call33, 0
  br i1 %54, label %48, label %49
}

define i32 @SHL1(%SHL1_interface* %0) {
entry:
  %IN = getelementptr inbounds %SHL1_interface, %SHL1_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %SHL1_interface, %SHL1_interface* %0, i32 0, i32 1
  %temp = getelementptr inbounds %SHL1_interface, %SHL1_interface* %0, i32 0, i32 2
  %SHL1 = alloca i32, align 4
  store i32 -1, i32* %temp, align 4
  store i32 0, i32* %SHL1, align 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

1:                                                ; preds = %continue
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input2

2:                                                ; preds = %continue5, %continue
  %3 = phi i64 [ %call1, %continue ], [ %call7, %continue5 ]
  store i64 %3, i32* %SHL1, align 4
  %SHL1_ret = load i32, i32* %SHL1, align 4
  ret i32 %SHL1_ret

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_temp = load i32, i32* %temp, align 4
  %5 = zext i32 %load_temp to i64
  store i64 %5, i64* %4, align 4
  %6 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %7 = sext i16 %load_N to i32
  %tmpVar = sub i32 32, %7
  %8 = trunc i32 %tmpVar to i16
  store i16 %8, i16* %6, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %9 = icmp ne i64 %call1, 0
  br i1 %9, label %2, label %1

input2:                                           ; preds = %1
  %10 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_IN = load i32, i32* %IN, align 4
  %11 = zext i32 %load_IN to i64
  store i64 %11, i64* %10, align 4
  %12 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_N6 = load i16, i16* %N, align 2
  store i16 %load_N6, i16* %12, align 2
  br label %call3

call3:                                            ; preds = %input2
  %call7 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  br label %2
}

define i32 @SHR1(%SHR1_interface* %0) {
entry:
  %IN = getelementptr inbounds %SHR1_interface, %SHR1_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %SHR1_interface, %SHR1_interface* %0, i32 0, i32 1
  %temp = getelementptr inbounds %SHR1_interface, %SHR1_interface* %0, i32 0, i32 2
  %SHR1 = alloca i32, align 4
  store i32 -1, i32* %temp, align 4
  store i32 0, i32* %SHR1, align 4
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

1:                                                ; preds = %continue
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input2

2:                                                ; preds = %continue5, %continue
  %3 = phi i64 [ %call1, %continue ], [ %call7, %continue5 ]
  store i64 %3, i32* %SHR1, align 4
  %SHR1_ret = load i32, i32* %SHR1, align 4
  ret i32 %SHR1_ret

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_temp = load i32, i32* %temp, align 4
  %5 = zext i32 %load_temp to i64
  store i64 %5, i64* %4, align 4
  %6 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %7 = sext i16 %load_N to i32
  %tmpVar = sub i32 32, %7
  %8 = trunc i32 %tmpVar to i16
  store i16 %8, i16* %6, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %9 = icmp ne i64 %call1, 0
  br i1 %9, label %2, label %1

input2:                                           ; preds = %1
  %10 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_IN = load i32, i32* %IN, align 4
  %11 = zext i32 %load_IN to i64
  store i64 %11, i64* %10, align 4
  %12 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %load_N6 = load i16, i16* %N, align 2
  store i16 %load_N6, i16* %12, align 2
  br label %call3

call3:                                            ; preds = %input2
  %call7 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  br label %2
}

define i16 @SWAP_BYTE(%SWAP_BYTE_interface* %0) {
entry:
  %IN = getelementptr inbounds %SWAP_BYTE_interface, %SWAP_BYTE_interface* %0, i32 0, i32 0
  %SWAP_BYTE = alloca i16, align 2
  store i16 0, i16* %SWAP_BYTE, align 2
  %ROL_instance = alloca %ROL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 0
  %load_in = load i16, i16* %IN, align 2
  %2 = zext i16 %load_in to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 1
  store i16 8, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @ROL(%ROL_interface* %ROL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = trunc i64 %call1 to i16
  store i16 %4, i16* %SWAP_BYTE, align 2
  %SWAP_BYTE_ret = load i16, i16* %SWAP_BYTE, align 2
  ret i16 %SWAP_BYTE_ret
}

define i32 @SWAP_BYTE2(%SWAP_BYTE2_interface* %0) {
entry:
  %IN = getelementptr inbounds %SWAP_BYTE2_interface, %SWAP_BYTE2_interface* %0, i32 0, i32 0
  %SWAP_BYTE2 = alloca i32, align 4
  store i32 0, i32* %SWAP_BYTE2, align 4
  %ROR_instance = alloca %ROR_interface, align 8
  br label %input

1:                                                ; preds = %5
  %ROL_instance = alloca %ROL_interface, align 8
  br label %input2

2:                                                ; preds = %13, %5
  %3 = phi i32 [ %6, %5 ], [ %14, %13 ]
  store i32 %3, i32* %SWAP_BYTE2, align 4
  %SWAP_BYTE2_ret = load i32, i32* %SWAP_BYTE2, align 4
  ret i32 %SWAP_BYTE2_ret

4:                                                ; preds = %continue
  br label %5

5:                                                ; preds = %4, %continue
  %6 = phi i64 [ %call1, %continue ], [ 4278255360, %4 ]
  %7 = icmp ne i64 %6, i32 0
  br i1 %7, label %2, label %1

input:                                            ; preds = %entry
  %8 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance, i32 0, i32 0
  %load_in = load i32, i32* %IN, align 4
  %9 = zext i32 %load_in to i64
  store i64 %9, i64* %8, align 4
  %10 = getelementptr inbounds %ROR_interface, %ROR_interface* %ROR_instance, i32 0, i32 1
  store i16 8, i16* %10, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @ROR(%ROR_interface* %ROR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %11 = icmp ne i64 %call1, 0
  br i1 %11, label %4, label %5

12:                                               ; preds = %continue5
  br label %13

13:                                               ; preds = %12, %continue5
  %14 = phi i64 [ %call7, %continue5 ], [ 16711935, %12 ]
  br label %2

input2:                                           ; preds = %1
  %15 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 0
  %load_in6 = load i32, i32* %IN, align 4
  %16 = zext i32 %load_in6 to i64
  store i64 %16, i64* %15, align 4
  %17 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 1
  store i16 8, i16* %17, align 2
  br label %call3

call3:                                            ; preds = %input2
  %call7 = call i64 @ROL(%ROL_interface* %ROL_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %18 = icmp ne i64 %call7, 0
  br i1 %18, label %12, label %13
}

define i16 @WORD_OF_BYTE(%WORD_OF_BYTE_interface* %0) {
entry:
  %B1 = getelementptr inbounds %WORD_OF_BYTE_interface, %WORD_OF_BYTE_interface* %0, i32 0, i32 0
  %B0 = getelementptr inbounds %WORD_OF_BYTE_interface, %WORD_OF_BYTE_interface* %0, i32 0, i32 1
  %WORD_OF_BYTE = alloca i16, align 2
  store i16 0, i16* %WORD_OF_BYTE, align 2
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

1:                                                ; preds = %continue
  %BYTE_TO_WORD_instance7 = alloca %BYTE_TO_WORD_interface, align 8
  br label %input8

2:                                                ; preds = %continue11, %continue
  %3 = phi i64 [ %call6, %continue ], [ %10, %continue11 ]
  store i64 %3, i16* %WORD_OF_BYTE, align 4
  %WORD_OF_BYTE_ret = load i16, i16* %WORD_OF_BYTE, align 2
  ret i16 %WORD_OF_BYTE_ret

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %BYTE_TO_WORD_instance = alloca %BYTE_TO_WORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = icmp ne i64 %call6, 0
  br i1 %5, label %2, label %1

input1:                                           ; preds = %input
  %6 = getelementptr inbounds %BYTE_TO_WORD_interface, %BYTE_TO_WORD_interface* %BYTE_TO_WORD_instance, i32 0, i32 0
  %load_B1 = load i8, i8* %B1, align 1
  store i8 %load_B1, i8* %6, align 1
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i16 @BYTE_TO_WORD(%BYTE_TO_WORD_interface* %BYTE_TO_WORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %7 = zext i16 %call5 to i64
  store i64 %7, i64* %4, align 4
  %8 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 8, i16* %8, align 2
  br label %call

input8:                                           ; preds = %1
  %9 = getelementptr inbounds %BYTE_TO_WORD_interface, %BYTE_TO_WORD_interface* %BYTE_TO_WORD_instance7, i32 0, i32 0
  %load_B0 = load i8, i8* %B0, align 1
  store i8 %load_B0, i8* %9, align 1
  br label %call9

call9:                                            ; preds = %input8
  %call12 = call i16 @BYTE_TO_WORD(%BYTE_TO_WORD_interface* %BYTE_TO_WORD_instance7)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %10 = zext i16 %call12 to i64
  br label %2
}

define i16 @WORD_OF_DWORD(%WORD_OF_DWORD_interface* %0) {
entry:
  %in = getelementptr inbounds %WORD_OF_DWORD_interface, %WORD_OF_DWORD_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %WORD_OF_DWORD_interface, %WORD_OF_DWORD_interface* %0, i32 0, i32 1
  %WORD_OF_DWORD = alloca i16, align 2
  store i16 0, i16* %WORD_OF_DWORD, align 2
  %DWORD_TO_WORD_instance = alloca %DWORD_TO_WORD_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_WORD_interface, %DWORD_TO_WORD_interface* %DWORD_TO_WORD_instance, i32 0, i32 0
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call11 = call i16 @DWORD_TO_WORD(%DWORD_TO_WORD_interface* %DWORD_TO_WORD_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call11, i16* %WORD_OF_DWORD, align 2
  %WORD_OF_DWORD_ret = load i16, i16* %WORD_OF_DWORD, align 2
  ret i16 %WORD_OF_DWORD_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in = load i32, i32* %in, align 4
  %3 = zext i32 %load_in to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  %call10 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %5 = trunc i64 %call10 to i32
  store i32 %5, i32* %1, align 4
  br label %call

input5:                                           ; preds = %input1
  %6 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_n = load i8, i8* %N, align 1
  %7 = zext i8 %load_n to i64
  store i64 %7, i64* %6, align 4
  %8 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 4, i16* %8, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %9 = trunc i64 %call9 to i16
  store i16 %9, i16* %4, align 2
  br label %call2
}

define void @A_TRIG(%A_TRIG_interface* %0) {
entry:
  %IN = getelementptr inbounds %A_TRIG_interface, %A_TRIG_interface* %0, i32 0, i32 0
  %RES = getelementptr inbounds %A_TRIG_interface, %A_TRIG_interface* %0, i32 0, i32 1
  %Q = getelementptr inbounds %A_TRIG_interface, %A_TRIG_interface* %0, i32 0, i32 2
  %D = getelementptr inbounds %A_TRIG_interface, %A_TRIG_interface* %0, i32 0, i32 3
  %last_in = getelementptr inbounds %A_TRIG_interface, %A_TRIG_interface* %0, i32 0, i32 4
  %load_IN = load float, float* %IN, align 4
  %load_LAST_IN = load float, float* %last_in, align 4
  %tmpVar = fsub float %load_IN, %load_LAST_IN
  store float %tmpVar, float* %D, align 4
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_D = load float, float* %D, align 4
  %2 = fptoui float %load_D to i64
  store i64 %2, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = uitofp i64 %call1 to double
  %load_res = load float, float* %RES, align 4
  %4 = fpext float %load_res to double
  %tmpVar2 = fcmp ogt double %3, %4
  %5 = zext i1 %tmpVar2 to i8
  store i8 %5, i8* %Q, align 1
  %load_Q = load i8, i8* %Q, align 1
  %6 = icmp ne i8 %load_Q, 0
  br i1 %6, label %condition_body, label %continue3

condition_body:                                   ; preds = %continue
  %load_IN4 = load float, float* %IN, align 4
  store float %load_IN4, float* %last_in, align 4
  br label %continue3

continue3:                                        ; preds = %condition_body, %continue
  %load_IN5 = load float, float* %IN, align 4
  %load_LAST_IN6 = load float, float* %last_in, align 4
  %tmpVar7 = fsub float %load_IN5, %load_LAST_IN6
  store float %tmpVar7, float* %D, align 4
  ret void
}

define void @B_TRIG(%B_TRIG_interface* %0) {
entry:
  %CLK = getelementptr inbounds %B_TRIG_interface, %B_TRIG_interface* %0, i32 0, i32 0
  %Q = getelementptr inbounds %B_TRIG_interface, %B_TRIG_interface* %0, i32 0, i32 1
  %edge = getelementptr inbounds %B_TRIG_interface, %B_TRIG_interface* %0, i32 0, i32 2
  %load_clk = load i8, i8* %CLK, align 1
  %1 = zext i8 %load_clk to i32
  %load_edge = load i8, i8* %edge, align 1
  %2 = zext i8 %load_edge to i32
  %tmpVar = xor i32 %1, %2
  store i32 %tmpVar, i8* %Q, align 4
  %load_CLK = load i8, i8* %CLK, align 1
  store i8 %load_CLK, i8* %edge, align 1
  ret void
}

define void @CLICK_CNT(%CLICK_CNT_interface* %0) {
entry:
  %IN = getelementptr inbounds %CLICK_CNT_interface, %CLICK_CNT_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %CLICK_CNT_interface, %CLICK_CNT_interface* %0, i32 0, i32 1
  %TC = getelementptr inbounds %CLICK_CNT_interface, %CLICK_CNT_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %CLICK_CNT_interface, %CLICK_CNT_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %CLICK_CNT_interface, %CLICK_CNT_interface* %0, i32 0, i32 4
  %edge = getelementptr inbounds %CLICK_CNT_interface, %CLICK_CNT_interface* %0, i32 0, i32 5
  %cnt = getelementptr inbounds %CLICK_CNT_interface, %CLICK_CNT_interface* %0, i32 0, i32 6
  store i8 0, i8* %Q, align 1
  %load_in = load i8, i8* %IN, align 1
  %1 = zext i8 %load_in to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %16, label %18

condition_body:                                   ; preds = %13
  store i16 0, i16* %cnt, align 2
  br label %continue

branch:                                           ; preds = %13
  %Q4 = getelementptr inbounds %TP_interface, %TP_interface* %tx, i32 0, i32 2
  %load_5 = load i8, i8* %Q4, align 1
  %3 = zext i8 %load_5 to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %26, label %28

condition_body3:                                  ; preds = %23
  %load_cnt = load i16, i16* %cnt, align 2
  %5 = sext i16 %load_cnt to i32
  %tmpVar8 = add i32 %5, 1
  %6 = trunc i32 %tmpVar8 to i16
  store i16 %6, i16* %cnt, align 2
  br label %continue

branch1:                                          ; preds = %23
  %Q10 = getelementptr inbounds %TP_interface, %TP_interface* %tx, i32 0, i32 2
  %load_11 = load i8, i8* %Q10, align 1
  %tmpVar12 = xor i8 %load_11, -1
  %7 = icmp ne i8 %tmpVar12, 0
  br i1 %7, label %condition_body9, label %continue

condition_body9:                                  ; preds = %branch1
  %load_cnt13 = load i16, i16* %cnt, align 2
  %8 = sext i16 %load_cnt13 to i32
  %load_N = load i16, i16* %N, align 2
  %9 = sext i16 %load_N to i32
  %tmpVar14 = icmp eq i32 %8, %9
  %10 = zext i1 %tmpVar14 to i8
  store i8 %10, i8* %Q, align 1
  store i16 -1, i16* %cnt, align 2
  br label %continue

continue:                                         ; preds = %condition_body9, %branch1, %condition_body3, %condition_body
  %load_IN15 = load i8, i8* %IN, align 1
  store i8 %load_IN15, i8* %edge, align 1
  br label %input

11:                                               ; preds = %18
  %q = getelementptr inbounds %TP_interface, %TP_interface* %tx, i32 0, i32 2
  %load_ = load i8, i8* %q, align 1
  %tmpVar2 = xor i8 %load_, -1
  %12 = zext i8 %tmpVar2 to i32
  br label %13

13:                                               ; preds = %11, %18
  %14 = phi i32 [ %19, %18 ], [ %12, %11 ]
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %condition_body, label %branch

16:                                               ; preds = %entry
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar = xor i8 %load_edge, -1
  %17 = zext i8 %tmpVar to i32
  br label %18

18:                                               ; preds = %16, %entry
  %19 = phi i32 [ %1, %entry ], [ %17, %16 ]
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %11, label %13

21:                                               ; preds = %28
  %load_edge7 = load i8, i8* %edge, align 1
  %22 = zext i8 %load_edge7 to i32
  br label %23

23:                                               ; preds = %21, %28
  %24 = phi i32 [ %29, %28 ], [ %22, %21 ]
  %25 = icmp ne i32 %24, 0
  br i1 %25, label %condition_body3, label %branch1

26:                                               ; preds = %branch
  %load_IN = load i8, i8* %IN, align 1
  %tmpVar6 = xor i8 %load_IN, -1
  %27 = zext i8 %tmpVar6 to i32
  br label %28

28:                                               ; preds = %26, %branch
  %29 = phi i32 [ %3, %branch ], [ %27, %26 ]
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %21, label %23

input:                                            ; preds = %continue
  %31 = getelementptr inbounds %TP_interface, %TP_interface* %tx, i32 0, i32 0
  %load_IN17 = load i8, i8* %IN, align 1
  store i8 %load_IN17, i8* %31, align 1
  %32 = getelementptr inbounds %TP_interface, %TP_interface* %tx, i32 0, i32 1
  %load_TC = load i64, i64* %TC, align 4
  store i64 %load_TC, i64* %32, align 4
  br label %call

call:                                             ; preds = %input
  call void @TP(%TP_interface* %tx)
  br label %output

output:                                           ; preds = %call
  br label %continue16

continue16:                                       ; preds = %output
  ret void
}

define void @CLICK_DEC(%CLICK_DEC_interface* %0) {
entry:
  %IN = getelementptr inbounds %CLICK_DEC_interface, %CLICK_DEC_interface* %0, i32 0, i32 0
  %TC = getelementptr inbounds %CLICK_DEC_interface, %CLICK_DEC_interface* %0, i32 0, i32 1
  %Q0 = getelementptr inbounds %CLICK_DEC_interface, %CLICK_DEC_interface* %0, i32 0, i32 2
  %Q1 = getelementptr inbounds %CLICK_DEC_interface, %CLICK_DEC_interface* %0, i32 0, i32 3
  %Q2 = getelementptr inbounds %CLICK_DEC_interface, %CLICK_DEC_interface* %0, i32 0, i32 4
  %Q3 = getelementptr inbounds %CLICK_DEC_interface, %CLICK_DEC_interface* %0, i32 0, i32 5
  %tx = getelementptr inbounds %CLICK_DEC_interface, %CLICK_DEC_interface* %0, i32 0, i32 6
  %edge = getelementptr inbounds %CLICK_DEC_interface, %CLICK_DEC_interface* %0, i32 0, i32 7
  %cnt = getelementptr inbounds %CLICK_DEC_interface, %CLICK_DEC_interface* %0, i32 0, i32 8
  %load_in = load i8, i8* %IN, align 1
  %1 = zext i8 %load_in to i32
  %tmpVar = icmp eq i32 %1, 0
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  %load_in4 = load i8, i8* %IN, align 1
  %2 = zext i8 %load_in4 to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %14, label %16

condition_body3:                                  ; preds = %11
  store i16 0, i16* %cnt, align 2
  br label %continue2

branch:                                           ; preds = %11
  %Q = getelementptr inbounds %TP_interface, %TP_interface* %tx, i32 0, i32 2
  %load_8 = load i8, i8* %Q, align 1
  %4 = zext i8 %load_8 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %24, label %26

condition_body7:                                  ; preds = %21
  %load_cnt = load i16, i16* %cnt, align 2
  %6 = sext i16 %load_cnt to i32
  %tmpVar11 = add i32 %6, 1
  %7 = trunc i32 %tmpVar11 to i16
  store i16 %7, i16* %cnt, align 2
  br label %continue2

branch1:                                          ; preds = %21
  %Q13 = getelementptr inbounds %TP_interface, %TP_interface* %tx, i32 0, i32 2
  %load_14 = load i8, i8* %Q13, align 1
  %tmpVar15 = xor i8 %load_14, -1
  %8 = icmp ne i8 %tmpVar15, 0
  br i1 %8, label %condition_body12, label %continue2

condition_body12:                                 ; preds = %branch1
  %load_cnt17 = load i16, i16* %cnt, align 2
  switch i16 %load_cnt17, label %else [
    i16 0, label %case
    i16 1, label %case18
    i16 2, label %case19
    i16 3, label %case20
  ]

continue2:                                        ; preds = %continue16, %branch1, %condition_body7, %condition_body3
  %load_IN21 = load i8, i8* %IN, align 1
  store i8 %load_IN21, i8* %edge, align 1
  br label %input

9:                                                ; preds = %16
  %q = getelementptr inbounds %TP_interface, %TP_interface* %tx, i32 0, i32 2
  %load_ = load i8, i8* %q, align 1
  %tmpVar6 = xor i8 %load_, -1
  %10 = zext i8 %tmpVar6 to i32
  br label %11

11:                                               ; preds = %9, %16
  %12 = phi i32 [ %17, %16 ], [ %10, %9 ]
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %condition_body3, label %branch

14:                                               ; preds = %continue
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar5 = xor i8 %load_edge, -1
  %15 = zext i8 %tmpVar5 to i32
  br label %16

16:                                               ; preds = %14, %continue
  %17 = phi i32 [ %2, %continue ], [ %15, %14 ]
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %9, label %11

19:                                               ; preds = %26
  %load_edge10 = load i8, i8* %edge, align 1
  %20 = zext i8 %load_edge10 to i32
  br label %21

21:                                               ; preds = %19, %26
  %22 = phi i32 [ %27, %26 ], [ %20, %19 ]
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %condition_body7, label %branch1

24:                                               ; preds = %branch
  %load_IN = load i8, i8* %IN, align 1
  %tmpVar9 = xor i8 %load_IN, -1
  %25 = zext i8 %tmpVar9 to i32
  br label %26

26:                                               ; preds = %24, %branch
  %27 = phi i32 [ %4, %branch ], [ %25, %24 ]
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %19, label %21

case:                                             ; preds = %condition_body12
  store i8 1, i8* %Q0, align 1
  br label %continue16

case18:                                           ; preds = %condition_body12
  store i8 1, i8* %Q1, align 1
  br label %continue16

case19:                                           ; preds = %condition_body12
  store i8 1, i8* %Q2, align 1
  br label %continue16

case20:                                           ; preds = %condition_body12
  store i8 1, i8* %Q3, align 1
  br label %continue16

else:                                             ; preds = %condition_body12
  br label %continue16

continue16:                                       ; preds = %else, %case20, %case19, %case18, %case
  store i16 -1, i16* %cnt, align 2
  br label %continue2

input:                                            ; preds = %continue2
  %29 = getelementptr inbounds %TP_interface, %TP_interface* %tx, i32 0, i32 0
  %load_IN23 = load i8, i8* %IN, align 1
  store i8 %load_IN23, i8* %29, align 1
  %30 = getelementptr inbounds %TP_interface, %TP_interface* %tx, i32 0, i32 1
  %load_TC = load i64, i64* %TC, align 4
  store i64 %load_TC, i64* %30, align 4
  br label %call

call:                                             ; preds = %input
  call void @TP(%TP_interface* %tx)
  br label %output

output:                                           ; preds = %call
  br label %continue22

continue22:                                       ; preds = %output
  ret void
}

define void @CLK_DIV(%CLK_DIV_interface* %0) {
entry:
  %clk = getelementptr inbounds %CLK_DIV_interface, %CLK_DIV_interface* %0, i32 0, i32 0
  %rst = getelementptr inbounds %CLK_DIV_interface, %CLK_DIV_interface* %0, i32 0, i32 1
  %Q0 = getelementptr inbounds %CLK_DIV_interface, %CLK_DIV_interface* %0, i32 0, i32 2
  %Q1 = getelementptr inbounds %CLK_DIV_interface, %CLK_DIV_interface* %0, i32 0, i32 3
  %Q2 = getelementptr inbounds %CLK_DIV_interface, %CLK_DIV_interface* %0, i32 0, i32 4
  %Q3 = getelementptr inbounds %CLK_DIV_interface, %CLK_DIV_interface* %0, i32 0, i32 5
  %Q4 = getelementptr inbounds %CLK_DIV_interface, %CLK_DIV_interface* %0, i32 0, i32 6
  %Q5 = getelementptr inbounds %CLK_DIV_interface, %CLK_DIV_interface* %0, i32 0, i32 7
  %Q6 = getelementptr inbounds %CLK_DIV_interface, %CLK_DIV_interface* %0, i32 0, i32 8
  %Q7 = getelementptr inbounds %CLK_DIV_interface, %CLK_DIV_interface* %0, i32 0, i32 9
  %cnt = getelementptr inbounds %CLK_DIV_interface, %CLK_DIV_interface* %0, i32 0, i32 10
  %load_rst = load i8, i8* %rst, align 1
  %1 = icmp ne i8 %load_rst, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i8 0, i8* %cnt, align 1
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i8 0, i8* %Q4, align 1
  store i8 0, i8* %Q5, align 1
  store i8 0, i8* %Q6, align 1
  store i8 0, i8* %Q7, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_clk = load i8, i8* %clk, align 1
  %2 = icmp ne i8 %load_clk, 0
  br i1 %2, label %condition_body1, label %continue

condition_body1:                                  ; preds = %branch
  %load_cnt = load i8, i8* %cnt, align 1
  %3 = zext i8 %load_cnt to i32
  %tmpVar = add i32 %3, 1
  %4 = trunc i32 %tmpVar to i8
  store i8 %4, i8* %cnt, align 1
  %load_cnt2 = load i8, i8* %cnt, align 1
  %shift = lshr i8 %load_cnt2, 0
  store i8 %shift, i8* %Q0, align 1
  %load_cnt3 = load i8, i8* %cnt, align 1
  %shift4 = lshr i8 %load_cnt3, 1
  store i8 %shift4, i8* %Q1, align 1
  %load_cnt5 = load i8, i8* %cnt, align 1
  %shift6 = lshr i8 %load_cnt5, 2
  store i8 %shift6, i8* %Q2, align 1
  %load_cnt7 = load i8, i8* %cnt, align 1
  %shift8 = lshr i8 %load_cnt7, 3
  store i8 %shift8, i8* %Q3, align 1
  %load_cnt9 = load i8, i8* %cnt, align 1
  %shift10 = lshr i8 %load_cnt9, 4
  store i8 %shift10, i8* %Q4, align 1
  %load_cnt11 = load i8, i8* %cnt, align 1
  %shift12 = lshr i8 %load_cnt11, 5
  store i8 %shift12, i8* %Q5, align 1
  %load_cnt13 = load i8, i8* %cnt, align 1
  %shift14 = lshr i8 %load_cnt13, 6
  store i8 %shift14, i8* %Q6, align 1
  %load_cnt15 = load i8, i8* %cnt, align 1
  %shift16 = lshr i8 %load_cnt15, 7
  store i8 %shift16, i8* %Q7, align 1
  br label %continue

continue:                                         ; preds = %condition_body1, %branch, %condition_body
  ret void
}

define void @CLK_N(%CLK_N_interface* %0) {
entry:
  %N = getelementptr inbounds %CLK_N_interface, %CLK_N_interface* %0, i32 0, i32 0
  %Q = getelementptr inbounds %CLK_N_interface, %CLK_N_interface* %0, i32 0, i32 1
  %edge = getelementptr inbounds %CLK_N_interface, %CLK_N_interface* %0, i32 0, i32 2
  %stime = getelementptr inbounds %CLK_N_interface, %CLK_N_interface* %0, i32 0, i32 3
  %clk = getelementptr inbounds %CLK_N_interface, %CLK_N_interface* %0, i32 0, i32 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %2 = trunc i64 %call6 to i32
  store i32 %2, i32* %stime, align 4
  %load_stime = load i32, i32* %stime, align 4
  %shift = lshr i32 %load_stime, 0
  %3 = trunc i32 %shift to i8
  store i8 %3, i8* %clk, align 1
  %load_clk = load i8, i8* %clk, align 1
  %4 = zext i8 %load_clk to i32
  %load_edge = load i8, i8* %edge, align 1
  %5 = zext i8 %load_edge to i32
  %tmpVar = xor i32 %4, %5
  store i32 %tmpVar, i8* %Q, align 4
  %load_CLK = load i8, i8* %clk, align 1
  store i8 %load_CLK, i8* %edge, align 1
  ret void

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %6 = zext i32 %call5 to i64
  store i64 %6, i64* %1, align 4
  %7 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  store i16 %load_N, i16* %7, align 2
  br label %call
}

define void @CLK_PRG(%CLK_PRG_interface* %0) {
entry:
  %PT = getelementptr inbounds %CLK_PRG_interface, %CLK_PRG_interface* %0, i32 0, i32 0
  %Q = getelementptr inbounds %CLK_PRG_interface, %CLK_PRG_interface* %0, i32 0, i32 1
  %init = getelementptr inbounds %CLK_PRG_interface, %CLK_PRG_interface* %0, i32 0, i32 2
  %last = getelementptr inbounds %CLK_PRG_interface, %CLK_PRG_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %CLK_PRG_interface, %CLK_PRG_interface* %0, i32 0, i32 4
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar, 0
  br i1 %2, label %condition_body, label %continue7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  %load_pt = load i64, i64* %PT, align 4
  %tmpVar8 = sub i64 %load_tx, %load_pt
  store i64 %tmpVar8, i64* %last, align 4
  br label %continue7

continue7:                                        ; preds = %condition_body, %continue
  %load_tx9 = load i64, i64* %tx, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar10 = sub i64 %load_tx9, %load_last
  %load_pt11 = load i64, i64* %PT, align 4
  %tmpVar12 = icmp sge i64 %tmpVar10, %load_pt11
  %3 = zext i1 %tmpVar12 to i8
  store i8 %3, i8* %Q, align 1
  %load_Q = load i8, i8* %Q, align 1
  %4 = icmp ne i8 %load_Q, 0
  br i1 %4, label %condition_body14, label %continue13

condition_body14:                                 ; preds = %continue7
  %load_tx15 = load i64, i64* %tx, align 4
  store i64 %load_tx15, i64* %last, align 4
  br label %continue13

continue13:                                       ; preds = %condition_body14, %continue7
  ret void
}

define void @CLK_PULSE(%CLK_PULSE_interface* %0) {
entry:
  %PT = getelementptr inbounds %CLK_PULSE_interface, %CLK_PULSE_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %CLK_PULSE_interface, %CLK_PULSE_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %CLK_PULSE_interface, %CLK_PULSE_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %CLK_PULSE_interface, %CLK_PULSE_interface* %0, i32 0, i32 3
  %CNT = getelementptr inbounds %CLK_PULSE_interface, %CLK_PULSE_interface* %0, i32 0, i32 4
  %RUN = getelementptr inbounds %CLK_PULSE_interface, %CLK_PULSE_interface* %0, i32 0, i32 5
  %tx = getelementptr inbounds %CLK_PULSE_interface, %CLK_PULSE_interface* %0, i32 0, i32 6
  %tn = getelementptr inbounds %CLK_PULSE_interface, %CLK_PULSE_interface* %0, i32 0, i32 7
  %init = getelementptr inbounds %CLK_PULSE_interface, %CLK_PULSE_interface* %0, i32 0, i32 8
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  store i8 0, i8* %Q, align 1
  %load_CNT = load i16, i16* %CNT, align 2
  %1 = sext i16 %load_CNT to i32
  %load_N = load i16, i16* %N, align 2
  %2 = sext i16 %load_N to i32
  %tmpVar = icmp slt i32 %1, %2
  %3 = zext i1 %tmpVar to i8
  store i8 %3, i8* %RUN, align 1
  %load_init = load i8, i8* %init, align 1
  %tmpVar3 = xor i8 %load_init, -1
  %4 = zext i8 %tmpVar3 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %14, label %12

condition_body:                                   ; preds = %14
  store i8 1, i8* %init, align 1
  store i16 0, i16* %CNT, align 2
  %load_tx = load i32, i32* %tx, align 4
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input4

branch:                                           ; preds = %14
  %load_cnt = load i16, i16* %CNT, align 2
  %6 = sext i16 %load_cnt to i32
  %load_N11 = load i16, i16* %N, align 2
  %7 = sext i16 %load_N11 to i32
  %tmpVar12 = icmp slt i32 %6, %7
  %8 = zext i1 %tmpVar12 to i32
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %25, label %22

condition_body10:                                 ; preds = %19
  %load_CNT25 = load i16, i16* %CNT, align 2
  %10 = sext i16 %load_CNT25 to i32
  %tmpVar26 = add i32 %10, 1
  %11 = trunc i32 %tmpVar26 to i16
  store i16 %11, i16* %CNT, align 2
  store i8 1, i8* %Q, align 1
  %load_tn27 = load i32, i32* %tn, align 4
  %TIME_TO_DWORD_instance28 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input29

continue2:                                        ; preds = %continue32, %19, %continue7
  ret void

12:                                               ; preds = %continue
  %load_RST = load i8, i8* %RST, align 1
  %13 = zext i8 %load_RST to i32
  br label %14

14:                                               ; preds = %12, %continue
  %15 = phi i32 [ %4, %continue ], [ %13, %12 ]
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %condition_body, label %branch

input4:                                           ; preds = %condition_body
  %17 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_PT = load i64, i64* %PT, align 4
  store i64 %load_PT, i64* %17, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %tmpVar9 = sub i32 %load_tx, %call8
  store i32 %tmpVar9, i32* %tn, align 4
  store i8 0, i8* %RUN, align 1
  br label %continue2

18:                                               ; preds = %25
  %load_tx15 = load i32, i32* %tx, align 4
  %load_tn = load i32, i32* %tn, align 4
  %tmpVar16 = sub i32 %load_tx15, %load_tn
  %TIME_TO_DWORD_instance17 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input18

19:                                               ; preds = %continue21, %25
  %20 = phi i32 [ %26, %25 ], [ %29, %continue21 ]
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %condition_body10, label %continue2

22:                                               ; preds = %branch
  %load_N13 = load i16, i16* %N, align 2
  %23 = sext i16 %load_N13 to i32
  %tmpVar14 = icmp eq i32 %23, 0
  %24 = zext i1 %tmpVar14 to i32
  br label %25

25:                                               ; preds = %22, %branch
  %26 = phi i32 [ %8, %branch ], [ %24, %22 ]
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %18, label %19

input18:                                          ; preds = %18
  %28 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance17, i32 0, i32 0
  %load_PT22 = load i64, i64* %PT, align 4
  store i64 %load_PT22, i64* %28, align 4
  br label %call19

call19:                                           ; preds = %input18
  %call23 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance17)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %tmpVar24 = icmp sge i32 %tmpVar16, %call23
  %29 = zext i1 %tmpVar24 to i32
  br label %19

input29:                                          ; preds = %condition_body10
  %30 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance28, i32 0, i32 0
  %load_PT33 = load i64, i64* %PT, align 4
  store i64 %load_PT33, i64* %30, align 4
  br label %call30

call30:                                           ; preds = %input29
  %call34 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance28)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  %tmpVar35 = add i32 %load_tn27, %call34
  store i32 %tmpVar35, i32* %tn, align 4
  br label %continue2
}

define void @CYCLE_4(%CYCLE_4_interface* %0) {
entry:
  %E = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 0
  %T0 = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 1
  %T1 = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 2
  %T2 = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 3
  %T3 = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 4
  %S0 = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 5
  %SX = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 6
  %SL = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 7
  %STATE = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 8
  %tx = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 9
  %last = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 10
  %init = getelementptr inbounds %CYCLE_4_interface, %CYCLE_4_interface* %0, i32 0, i32 11
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar, 0
  br i1 %2, label %condition_body, label %continue7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  br label %continue7

continue7:                                        ; preds = %condition_body, %continue
  %load_E = load i8, i8* %E, align 1
  %3 = icmp ne i8 %load_E, 0
  br i1 %3, label %condition_body9, label %else

condition_body9:                                  ; preds = %continue7
  %load_SL = load i8, i8* %SL, align 1
  %4 = icmp ne i8 %load_SL, 0
  br i1 %4, label %condition_body12, label %else10

else:                                             ; preds = %continue7
  store i16 0, i16* %STATE, align 2
  %load_tx53 = load i64, i64* %tx, align 4
  store i64 %load_tx53, i64* %last, align 4
  br label %continue8

continue8:                                        ; preds = %else, %continue11
  ret void

condition_body12:                                 ; preds = %condition_body9
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input13

else10:                                           ; preds = %condition_body9
  %load_state = load i16, i16* %STATE, align 2
  switch i16 %load_state, label %else20 [
    i16 0, label %case
    i16 1, label %case27
    i16 2, label %case35
    i16 3, label %case43
  ]

continue11:                                       ; preds = %continue19, %continue16
  br label %continue8

input13:                                          ; preds = %condition_body12
  %5 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %5, align 4
  %6 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_SX = load i16, i16* %SX, align 2
  %7 = sext i16 %load_SX to i64
  store i64 %7, i64* %6, align 4
  %8 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 3, i64* %8, align 4
  br label %call14

call14:                                           ; preds = %input13
  %call17 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %9 = trunc i64 %call17 to i16
  store i16 %9, i16* %STATE, align 2
  %load_tx18 = load i64, i64* %tx, align 4
  store i64 %load_tx18, i64* %last, align 4
  store i8 0, i8* %SL, align 1
  br label %continue11

case:                                             ; preds = %else10
  %load_tx23 = load i64, i64* %tx, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar24 = sub i64 %load_tx23, %load_last
  %load_T0 = load i64, i64* %T0, align 4
  %tmpVar25 = icmp sge i64 %tmpVar24, %load_T0
  br i1 %tmpVar25, label %condition_body22, label %continue21

case27:                                           ; preds = %else10
  %load_tx30 = load i64, i64* %tx, align 4
  %load_last31 = load i64, i64* %last, align 4
  %tmpVar32 = sub i64 %load_tx30, %load_last31
  %load_T1 = load i64, i64* %T1, align 4
  %tmpVar33 = icmp sge i64 %tmpVar32, %load_T1
  br i1 %tmpVar33, label %condition_body29, label %continue28

case35:                                           ; preds = %else10
  %load_tx38 = load i64, i64* %tx, align 4
  %load_last39 = load i64, i64* %last, align 4
  %tmpVar40 = sub i64 %load_tx38, %load_last39
  %load_T2 = load i64, i64* %T2, align 4
  %tmpVar41 = icmp sge i64 %tmpVar40, %load_T2
  br i1 %tmpVar41, label %condition_body37, label %continue36

case43:                                           ; preds = %else10
  %load_tx46 = load i64, i64* %tx, align 4
  %load_last47 = load i64, i64* %last, align 4
  %tmpVar48 = sub i64 %load_tx46, %load_last47
  %load_T3 = load i64, i64* %T3, align 4
  %tmpVar49 = icmp sge i64 %tmpVar48, %load_T3
  br i1 %tmpVar49, label %condition_body45, label %continue44

else20:                                           ; preds = %else10
  br label %continue19

continue19:                                       ; preds = %else20, %continue44, %continue36, %continue28, %continue21
  br label %continue11

condition_body22:                                 ; preds = %case
  store i16 1, i16* %STATE, align 2
  %load_tx26 = load i64, i64* %tx, align 4
  store i64 %load_tx26, i64* %last, align 4
  br label %continue21

continue21:                                       ; preds = %condition_body22, %case
  br label %continue19

condition_body29:                                 ; preds = %case27
  store i16 2, i16* %STATE, align 2
  %load_tx34 = load i64, i64* %tx, align 4
  store i64 %load_tx34, i64* %last, align 4
  br label %continue28

continue28:                                       ; preds = %condition_body29, %case27
  br label %continue19

condition_body37:                                 ; preds = %case35
  store i16 3, i16* %STATE, align 2
  %load_tx42 = load i64, i64* %tx, align 4
  store i64 %load_tx42, i64* %last, align 4
  br label %continue36

continue36:                                       ; preds = %condition_body37, %case35
  br label %continue19

condition_body45:                                 ; preds = %case43
  %load_S0 = load i8, i8* %S0, align 1
  %10 = icmp ne i8 %load_S0, 0
  br i1 %10, label %condition_body51, label %continue50

continue44:                                       ; preds = %continue50, %case43
  br label %continue19

condition_body51:                                 ; preds = %condition_body45
  store i16 0, i16* %STATE, align 2
  br label %continue50

continue50:                                       ; preds = %condition_body51, %condition_body45
  %load_tx52 = load i64, i64* %tx, align 4
  store i64 %load_tx52, i64* %last, align 4
  br label %continue44
}

define void @D_TRIG(%D_TRIG_interface* %0) {
entry:
  %in = getelementptr inbounds %D_TRIG_interface, %D_TRIG_interface* %0, i32 0, i32 0
  %Q = getelementptr inbounds %D_TRIG_interface, %D_TRIG_interface* %0, i32 0, i32 1
  %X = getelementptr inbounds %D_TRIG_interface, %D_TRIG_interface* %0, i32 0, i32 2
  %last_in = getelementptr inbounds %D_TRIG_interface, %D_TRIG_interface* %0, i32 0, i32 3
  %load_in = load i32, i32* %in, align 4
  %load_last_in = load i32, i32* %last_in, align 4
  %tmpVar = icmp ne i32 %load_in, %load_last_in
  %1 = zext i1 %tmpVar to i8
  store i8 %1, i8* %Q, align 1
  %load_in1 = load i32, i32* %in, align 4
  %load_last_in2 = load i32, i32* %last_in, align 4
  %tmpVar3 = sub i32 %load_in1, %load_last_in2
  store i32 %tmpVar3, i32* %X, align 4
  %load_in4 = load i32, i32* %in, align 4
  store i32 %load_in4, i32* %last_in, align 4
  ret void
}

define void @GEN_BIT(%GEN_BIT_interface* %0) {
entry:
  %in0 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 0
  %in1 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 1
  %in2 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 2
  %in3 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 3
  %clk = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 4
  %steps = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 5
  %rep = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 6
  %rst = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 7
  %Q0 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 8
  %Q1 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 9
  %Q2 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 10
  %Q3 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 11
  %cnt = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 12
  %run = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 13
  %r0 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 14
  %r1 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 15
  %r2 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 16
  %r3 = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 17
  %rx = getelementptr inbounds %GEN_BIT_interface, %GEN_BIT_interface* %0, i32 0, i32 18
  %load_clk = load i8, i8* %clk, align 1
  %1 = zext i8 %load_clk to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %7, label %9

condition_body:                                   ; preds = %9
  %load_rep = load i16, i16* %rep, align 2
  %3 = sext i16 %load_rep to i32
  %tmpVar1 = icmp eq i32 %3, 0
  %4 = zext i1 %tmpVar1 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %16, label %12

else:                                             ; preds = %9
  %load_rst65 = load i8, i8* %rst, align 1
  %6 = icmp ne i8 %load_rst65, 0
  br i1 %6, label %condition_body64, label %continue63

continue:                                         ; preds = %continue63, %continue4
  ret void

7:                                                ; preds = %entry
  %load_rst = load i8, i8* %rst, align 1
  %tmpVar = xor i8 %load_rst, -1
  %8 = zext i8 %tmpVar to i32
  br label %9

9:                                                ; preds = %7, %entry
  %10 = phi i32 [ %1, %entry ], [ %8, %7 ]
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %condition_body, label %else

12:                                               ; preds = %condition_body
  %load_rx = load i16, i16* %rx, align 2
  %13 = sext i16 %load_rx to i32
  %load_rep2 = load i16, i16* %rep, align 2
  %14 = sext i16 %load_rep2 to i32
  %tmpVar3 = icmp sle i32 %13, %14
  %15 = zext i1 %tmpVar3 to i32
  br label %16

16:                                               ; preds = %12, %condition_body
  %17 = phi i32 [ %4, %condition_body ], [ %15, %12 ]
  store i32 %17, i8* %run, align 4
  %load_run = load i8, i8* %run, align 1
  %18 = icmp ne i8 %load_run, 0
  br i1 %18, label %condition_body5, label %continue4

condition_body5:                                  ; preds = %16
  %load_cnt = load i16, i16* %cnt, align 2
  %19 = sext i16 %load_cnt to i32
  %load_steps = load i16, i16* %steps, align 2
  %20 = sext i16 %load_steps to i32
  %tmpVar8 = icmp eq i32 %19, %20
  br i1 %tmpVar8, label %condition_body7, label %continue6

continue4:                                        ; preds = %continue56, %16
  br label %continue

condition_body7:                                  ; preds = %condition_body5
  store i16 0, i16* %cnt, align 2
  br label %continue6

continue6:                                        ; preds = %condition_body7, %condition_body5
  %load_cnt11 = load i16, i16* %cnt, align 2
  %21 = sext i16 %load_cnt11 to i32
  %tmpVar12 = icmp eq i32 %21, 0
  br i1 %tmpVar12, label %condition_body10, label %continue9

condition_body10:                                 ; preds = %continue6
  %load_in0 = load i32, i32* %in0, align 4
  store i32 %load_in0, i32* %r0, align 4
  %load_in1 = load i32, i32* %in1, align 4
  store i32 %load_in1, i32* %r1, align 4
  %load_in2 = load i32, i32* %in2, align 4
  store i32 %load_in2, i32* %r2, align 4
  %load_in3 = load i32, i32* %in3, align 4
  store i32 %load_in3, i32* %r3, align 4
  br label %continue9

continue9:                                        ; preds = %condition_body10, %continue6
  %load_cnt15 = load i16, i16* %cnt, align 2
  %22 = sext i16 %load_cnt15 to i32
  %load_steps16 = load i16, i16* %steps, align 2
  %23 = sext i16 %load_steps16 to i32
  %tmpVar17 = icmp slt i32 %22, %23
  br i1 %tmpVar17, label %condition_body14, label %continue13

condition_body14:                                 ; preds = %continue9
  %load_r0 = load i32, i32* %r0, align 4
  %shift = lshr i32 %load_r0, 0
  %24 = trunc i32 %shift to i8
  store i8 %24, i8* %Q0, align 1
  %load_r1 = load i32, i32* %r1, align 4
  %shift18 = lshr i32 %load_r1, 0
  %25 = trunc i32 %shift18 to i8
  store i8 %25, i8* %Q1, align 1
  %load_r2 = load i32, i32* %r2, align 4
  %shift19 = lshr i32 %load_r2, 0
  %26 = trunc i32 %shift19 to i8
  store i8 %26, i8* %Q2, align 1
  %load_r3 = load i32, i32* %r3, align 4
  %shift20 = lshr i32 %load_r3, 0
  %27 = trunc i32 %shift20 to i8
  store i8 %27, i8* %Q3, align 1
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

continue13:                                       ; preds = %continue42, %continue9
  %load_cnt45 = load i16, i16* %cnt, align 2
  %28 = sext i16 %load_cnt45 to i32
  %tmpVar46 = add i32 %28, 1
  %29 = trunc i32 %tmpVar46 to i16
  store i16 %29, i16* %cnt, align 2
  %load_cnt49 = load i16, i16* %cnt, align 2
  %30 = sext i16 %load_cnt49 to i32
  %load_steps50 = load i16, i16* %steps, align 2
  %31 = sext i16 %load_steps50 to i32
  %tmpVar51 = icmp eq i32 %30, %31
  %32 = zext i1 %tmpVar51 to i32
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %56, label %59

input:                                            ; preds = %condition_body14
  %34 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_r022 = load i32, i32* %r0, align 4
  %35 = zext i32 %load_r022 to i64
  store i64 %35, i64* %34, align 4
  %36 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 1, i16* %36, align 2
  br label %call

call:                                             ; preds = %input
  %call23 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue21

continue21:                                       ; preds = %output
  %37 = trunc i64 %call23 to i32
  store i32 %37, i32* %r0, align 4
  %SHR_instance24 = alloca %SHR_interface, align 8
  br label %input25

input25:                                          ; preds = %continue21
  %38 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance24, i32 0, i32 0
  %load_r129 = load i32, i32* %r1, align 4
  %39 = zext i32 %load_r129 to i64
  store i64 %39, i64* %38, align 4
  %40 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance24, i32 0, i32 1
  store i16 1, i16* %40, align 2
  br label %call26

call26:                                           ; preds = %input25
  %call30 = call i64 @SHR(%SHR_interface* %SHR_instance24)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  %41 = trunc i64 %call30 to i32
  store i32 %41, i32* %r1, align 4
  %SHR_instance31 = alloca %SHR_interface, align 8
  br label %input32

input32:                                          ; preds = %continue28
  %42 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance31, i32 0, i32 0
  %load_r236 = load i32, i32* %r2, align 4
  %43 = zext i32 %load_r236 to i64
  store i64 %43, i64* %42, align 4
  %44 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance31, i32 0, i32 1
  store i16 1, i16* %44, align 2
  br label %call33

call33:                                           ; preds = %input32
  %call37 = call i64 @SHR(%SHR_interface* %SHR_instance31)
  br label %output34

output34:                                         ; preds = %call33
  br label %continue35

continue35:                                       ; preds = %output34
  %45 = trunc i64 %call37 to i32
  store i32 %45, i32* %r2, align 4
  %SHR_instance38 = alloca %SHR_interface, align 8
  br label %input39

input39:                                          ; preds = %continue35
  %46 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance38, i32 0, i32 0
  %load_r343 = load i32, i32* %r3, align 4
  %47 = zext i32 %load_r343 to i64
  store i64 %47, i64* %46, align 4
  %48 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance38, i32 0, i32 1
  store i16 1, i16* %48, align 2
  br label %call40

call40:                                           ; preds = %input39
  %call44 = call i64 @SHR(%SHR_interface* %SHR_instance38)
  br label %output41

output41:                                         ; preds = %call40
  br label %continue42

continue42:                                       ; preds = %output41
  %49 = trunc i64 %call44 to i32
  store i32 %49, i32* %r3, align 4
  br label %continue13

condition_body48:                                 ; preds = %59
  %load_rx54 = load i16, i16* %rx, align 2
  %50 = sext i16 %load_rx54 to i32
  %tmpVar55 = add i32 %50, 1
  %51 = trunc i32 %tmpVar55 to i16
  store i16 %51, i16* %rx, align 2
  br label %continue47

continue47:                                       ; preds = %condition_body48, %59
  %load_rx58 = load i16, i16* %rx, align 2
  %52 = sext i16 %load_rx58 to i32
  %load_rep59 = load i16, i16* %rep, align 2
  %53 = sext i16 %load_rep59 to i32
  %tmpVar60 = icmp sgt i32 %52, %53
  %54 = zext i1 %tmpVar60 to i32
  %55 = icmp ne i32 %54, 0
  br i1 %55, label %62, label %65

56:                                               ; preds = %continue13
  %load_rep52 = load i16, i16* %rep, align 2
  %57 = sext i16 %load_rep52 to i32
  %tmpVar53 = icmp ne i32 %57, 0
  %58 = zext i1 %tmpVar53 to i32
  br label %59

59:                                               ; preds = %56, %continue13
  %60 = phi i32 [ %32, %continue13 ], [ %58, %56 ]
  %61 = icmp ne i32 %60, 0
  br i1 %61, label %condition_body48, label %continue47

condition_body57:                                 ; preds = %65
  store i8 0, i8* %run, align 1
  br label %continue56

continue56:                                       ; preds = %condition_body57, %65
  br label %continue4

62:                                               ; preds = %continue47
  %load_rep61 = load i16, i16* %rep, align 2
  %63 = sext i16 %load_rep61 to i32
  %tmpVar62 = icmp ne i32 %63, 0
  %64 = zext i1 %tmpVar62 to i32
  br label %65

65:                                               ; preds = %62, %continue47
  %66 = phi i32 [ %54, %continue47 ], [ %64, %62 ]
  %67 = icmp ne i32 %66, 0
  br i1 %67, label %condition_body57, label %continue56

condition_body64:                                 ; preds = %else
  store i8 0, i8* %run, align 1
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i32 0, i32* %r0, align 4
  store i32 0, i32* %r1, align 4
  store i32 0, i32* %r2, align 4
  store i32 0, i32* %r3, align 4
  store i16 0, i16* %cnt, align 2
  store i16 1, i16* %rx, align 2
  br label %continue63

continue63:                                       ; preds = %condition_body64, %else
  br label %continue
}

define void @GEN_SQ(%GEN_SQ_interface* %0) {
entry:
  %PT = getelementptr inbounds %GEN_SQ_interface, %GEN_SQ_interface* %0, i32 0, i32 0
  %Q = getelementptr inbounds %GEN_SQ_interface, %GEN_SQ_interface* %0, i32 0, i32 1
  %tn = getelementptr inbounds %GEN_SQ_interface, %GEN_SQ_interface* %0, i32 0, i32 2
  %tx = getelementptr inbounds %GEN_SQ_interface, %GEN_SQ_interface* %0, i32 0, i32 3
  %init = getelementptr inbounds %GEN_SQ_interface, %GEN_SQ_interface* %0, i32 0, i32 4
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %1 = icmp ne i8 %tmpVar, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  %load_tx = load i32, i32* %tx, align 4
  store i32 %load_tx, i32* %tn, align 4
  store i8 1, i8* %Q, align 1
  br label %continue2

branch:                                           ; preds = %continue
  %load_tx4 = load i32, i32* %tx, align 4
  %load_tn = load i32, i32* %tn, align 4
  %tmpVar5 = sub i32 %load_tx4, %load_tn
  %2 = sext i32 %tmpVar5 to i64
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input6

condition_body3:                                  ; preds = %continue9
  %load_Q = load i8, i8* %Q, align 1
  %tmpVar17 = xor i8 %load_Q, -1
  store i8 %tmpVar17, i8* %Q, align 1
  %load_tn18 = load i32, i32* %tn, align 4
  %3 = zext i32 %load_tn18 to i64
  %SHR_instance19 = alloca %SHR_interface, align 8
  br label %input20

continue2:                                        ; preds = %continue23, %continue9, %condition_body
  ret void

input6:                                           ; preds = %branch
  %4 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input10

call7:                                            ; preds = %continue13
  %call15 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %tmpVar16 = icmp sge i64 %2, %call15
  br i1 %tmpVar16, label %condition_body3, label %continue2

input10:                                          ; preds = %input6
  %5 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_PT = load i64, i64* %PT, align 4
  store i64 %load_PT, i64* %5, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call14 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %6 = zext i32 %call14 to i64
  store i64 %6, i64* %4, align 4
  %7 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 1, i16* %7, align 2
  br label %call7

input20:                                          ; preds = %condition_body3
  %8 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance19, i32 0, i32 0
  %TIME_TO_DWORD_instance24 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input25

call21:                                           ; preds = %continue28
  %call30 = call i64 @SHR(%SHR_interface* %SHR_instance19)
  br label %output22

output22:                                         ; preds = %call21
  br label %continue23

continue23:                                       ; preds = %output22
  %tmpVar31 = add i64 %3, %call30
  %9 = trunc i64 %tmpVar31 to i32
  store i32 %9, i32* %tn, align 4
  br label %continue2

input25:                                          ; preds = %input20
  %10 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance24, i32 0, i32 0
  %load_pt = load i64, i64* %PT, align 4
  store i64 %load_pt, i64* %10, align 4
  br label %call26

call26:                                           ; preds = %input25
  %call29 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance24)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  %11 = zext i32 %call29 to i64
  store i64 %11, i64* %8, align 4
  %12 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance19, i32 0, i32 1
  store i16 1, i16* %12, align 2
  br label %call21
}

define void @SCHEDULER(%SCHEDULER_interface* %0) {
entry:
  %E0 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 0
  %E1 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 1
  %E2 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 2
  %E3 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 3
  %T0 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 4
  %T1 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 5
  %T2 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 6
  %T3 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 7
  %Q0 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 8
  %Q1 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 9
  %Q2 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 10
  %Q3 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 11
  %init = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 12
  %s0 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 13
  %s1 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 14
  %s2 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 15
  %s3 = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 16
  %tx = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 17
  %c = getelementptr inbounds %SCHEDULER_interface, %SCHEDULER_interface* %0, i32 0, i32 18
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar, 0
  br i1 %2, label %condition_body, label %continue7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  %load_T0 = load i64, i64* %T0, align 4
  %tmpVar8 = sub i64 %load_tx, %load_T0
  store i64 %tmpVar8, i64* %s0, align 4
  %load_tx9 = load i64, i64* %tx, align 4
  %load_T1 = load i64, i64* %T1, align 4
  %tmpVar10 = sub i64 %load_tx9, %load_T1
  store i64 %tmpVar10, i64* %s1, align 4
  %load_tx11 = load i64, i64* %tx, align 4
  %load_T2 = load i64, i64* %T2, align 4
  %tmpVar12 = sub i64 %load_tx11, %load_T2
  store i64 %tmpVar12, i64* %s2, align 4
  %load_tx13 = load i64, i64* %tx, align 4
  %load_T3 = load i64, i64* %T3, align 4
  %tmpVar14 = sub i64 %load_tx13, %load_T3
  store i64 %tmpVar14, i64* %s3, align 4
  br label %continue7

continue7:                                        ; preds = %condition_body, %continue
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  %load_c = load i16, i16* %c, align 2
  switch i16 %load_c, label %else [
    i16 0, label %case
    i16 1, label %case23
    i16 2, label %case31
    i16 3, label %case39
  ]

case:                                             ; preds = %continue7
  %load_tx18 = load i64, i64* %tx, align 4
  %load_s0 = load i64, i64* %s0, align 4
  %tmpVar19 = sub i64 %load_tx18, %load_s0
  %load_T020 = load i64, i64* %T0, align 4
  %tmpVar21 = icmp sge i64 %tmpVar19, %load_T020
  br i1 %tmpVar21, label %condition_body17, label %continue16

case23:                                           ; preds = %continue7
  %load_tx26 = load i64, i64* %tx, align 4
  %load_s1 = load i64, i64* %s1, align 4
  %tmpVar27 = sub i64 %load_tx26, %load_s1
  %load_T128 = load i64, i64* %T1, align 4
  %tmpVar29 = icmp sge i64 %tmpVar27, %load_T128
  br i1 %tmpVar29, label %condition_body25, label %continue24

case31:                                           ; preds = %continue7
  %load_tx34 = load i64, i64* %tx, align 4
  %load_s2 = load i64, i64* %s2, align 4
  %tmpVar35 = sub i64 %load_tx34, %load_s2
  %load_T236 = load i64, i64* %T2, align 4
  %tmpVar37 = icmp sge i64 %tmpVar35, %load_T236
  br i1 %tmpVar37, label %condition_body33, label %continue32

case39:                                           ; preds = %continue7
  %load_tx42 = load i64, i64* %tx, align 4
  %load_s3 = load i64, i64* %s3, align 4
  %tmpVar43 = sub i64 %load_tx42, %load_s3
  %load_T344 = load i64, i64* %T3, align 4
  %tmpVar45 = icmp sge i64 %tmpVar43, %load_T344
  br i1 %tmpVar45, label %condition_body41, label %continue40

else:                                             ; preds = %continue7
  br label %continue15

continue15:                                       ; preds = %else, %continue40, %continue32, %continue24, %continue16
  ret void

condition_body17:                                 ; preds = %case
  %load_E0 = load i8, i8* %E0, align 1
  store i8 %load_E0, i8* %Q0, align 1
  %load_tx22 = load i64, i64* %tx, align 4
  store i64 %load_tx22, i64* %s0, align 4
  br label %continue16

continue16:                                       ; preds = %condition_body17, %case
  store i16 1, i16* %c, align 2
  br label %continue15

condition_body25:                                 ; preds = %case23
  %load_E1 = load i8, i8* %E1, align 1
  store i8 %load_E1, i8* %Q1, align 1
  %load_tx30 = load i64, i64* %tx, align 4
  store i64 %load_tx30, i64* %s1, align 4
  br label %continue24

continue24:                                       ; preds = %condition_body25, %case23
  store i16 2, i16* %c, align 2
  br label %continue15

condition_body33:                                 ; preds = %case31
  %load_E2 = load i8, i8* %E2, align 1
  store i8 %load_E2, i8* %Q2, align 1
  %load_tx38 = load i64, i64* %tx, align 4
  store i64 %load_tx38, i64* %s2, align 4
  br label %continue32

continue32:                                       ; preds = %condition_body33, %case31
  store i16 3, i16* %c, align 2
  br label %continue15

condition_body41:                                 ; preds = %case39
  %load_E3 = load i8, i8* %E3, align 1
  store i8 %load_E3, i8* %Q3, align 1
  %load_tx46 = load i64, i64* %tx, align 4
  store i64 %load_tx46, i64* %s3, align 4
  br label %continue40

continue40:                                       ; preds = %condition_body41, %case39
  store i16 0, i16* %c, align 2
  br label %continue15
}

define void @SCHEDULER_2(%SCHEDULER_2_interface* %0) {
entry:
  %E0 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 0
  %E1 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 1
  %E2 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 2
  %E3 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 3
  %C0 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 4
  %C1 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 5
  %C2 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 6
  %C3 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 7
  %O0 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 8
  %O1 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 9
  %O2 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 10
  %O3 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 11
  %Q0 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 12
  %Q1 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 13
  %Q2 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 14
  %Q3 = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 15
  %sx = getelementptr inbounds %SCHEDULER_2_interface, %SCHEDULER_2_interface* %0, i32 0, i32 16
  %load_E0 = load i8, i8* %E0, align 1
  %1 = zext i8 %load_E0 to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %3, label %8

3:                                                ; preds = %entry
  %load_sx = load i16, i16* %sx, align 2
  %4 = zext i16 %load_sx to i32
  %load_C0 = load i16, i16* %C0, align 2
  %5 = zext i16 %load_C0 to i32
  %tmpVar = srem i32 %4, %5
  %load_O0 = load i16, i16* %O0, align 2
  %6 = zext i16 %load_O0 to i32
  %tmpVar1 = sub i32 %tmpVar, %6
  %tmpVar2 = icmp eq i32 %tmpVar1, 0
  %7 = zext i1 %tmpVar2 to i32
  br label %8

8:                                                ; preds = %3, %entry
  %9 = phi i32 [ %1, %entry ], [ %7, %3 ]
  store i32 %9, i8* %Q0, align 4
  %load_E1 = load i8, i8* %E1, align 1
  %10 = zext i8 %load_E1 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %12, label %17

12:                                               ; preds = %8
  %load_sx3 = load i16, i16* %sx, align 2
  %13 = zext i16 %load_sx3 to i32
  %load_C1 = load i16, i16* %C1, align 2
  %14 = zext i16 %load_C1 to i32
  %tmpVar4 = srem i32 %13, %14
  %load_O1 = load i16, i16* %O1, align 2
  %15 = zext i16 %load_O1 to i32
  %tmpVar5 = sub i32 %tmpVar4, %15
  %tmpVar6 = icmp eq i32 %tmpVar5, 0
  %16 = zext i1 %tmpVar6 to i32
  br label %17

17:                                               ; preds = %12, %8
  %18 = phi i32 [ %10, %8 ], [ %16, %12 ]
  store i32 %18, i8* %Q1, align 4
  %load_E2 = load i8, i8* %E2, align 1
  %19 = zext i8 %load_E2 to i32
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %21, label %26

21:                                               ; preds = %17
  %load_sx7 = load i16, i16* %sx, align 2
  %22 = zext i16 %load_sx7 to i32
  %load_C2 = load i16, i16* %C2, align 2
  %23 = zext i16 %load_C2 to i32
  %tmpVar8 = srem i32 %22, %23
  %load_O2 = load i16, i16* %O2, align 2
  %24 = zext i16 %load_O2 to i32
  %tmpVar9 = sub i32 %tmpVar8, %24
  %tmpVar10 = icmp eq i32 %tmpVar9, 0
  %25 = zext i1 %tmpVar10 to i32
  br label %26

26:                                               ; preds = %21, %17
  %27 = phi i32 [ %19, %17 ], [ %25, %21 ]
  store i32 %27, i8* %Q2, align 4
  %load_E3 = load i8, i8* %E3, align 1
  %28 = zext i8 %load_E3 to i32
  %29 = icmp ne i32 %28, 0
  br i1 %29, label %30, label %35

30:                                               ; preds = %26
  %load_sx11 = load i16, i16* %sx, align 2
  %31 = zext i16 %load_sx11 to i32
  %load_C3 = load i16, i16* %C3, align 2
  %32 = zext i16 %load_C3 to i32
  %tmpVar12 = srem i32 %31, %32
  %load_O3 = load i16, i16* %O3, align 2
  %33 = zext i16 %load_O3 to i32
  %tmpVar13 = sub i32 %tmpVar12, %33
  %tmpVar14 = icmp eq i32 %tmpVar13, 0
  %34 = zext i1 %tmpVar14 to i32
  br label %35

35:                                               ; preds = %30, %26
  %36 = phi i32 [ %28, %26 ], [ %34, %30 ]
  store i32 %36, i8* %Q3, align 4
  %load_sx15 = load i16, i16* %sx, align 2
  %37 = zext i16 %load_sx15 to i32
  %tmpVar16 = add i32 %37, 1
  %38 = trunc i32 %tmpVar16 to i16
  store i16 %38, i16* %sx, align 2
  ret void
}

define void @SEQUENCE_4(%SEQUENCE_4_interface* %0) {
entry:
  %in0 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 0
  %in1 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 1
  %in2 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 2
  %in3 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 3
  %start = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 4
  %rst = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 5
  %wait0 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 6
  %delay0 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 7
  %wait1 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 8
  %delay1 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 9
  %wait2 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 10
  %delay2 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 11
  %wait3 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 12
  %delay3 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 13
  %stop_on_error = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 14
  %Q0 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 15
  %Q1 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 16
  %Q2 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 17
  %Q3 = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 18
  %QX = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 19
  %run = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 20
  %step = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 21
  %status = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 22
  %last = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 23
  %edge = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 24
  %tx = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 25
  %init = getelementptr inbounds %SEQUENCE_4_interface, %SEQUENCE_4_interface* %0, i32 0, i32 26
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar, 0
  br i1 %2, label %condition_body, label %continue7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  store i8 1, i8* %init, align 1
  store i8 110, i8* %status, align 1
  br label %continue7

continue7:                                        ; preds = %condition_body, %continue
  %load_rst = load i8, i8* %rst, align 1
  %3 = icmp ne i8 %load_rst, 0
  br i1 %3, label %condition_body9, label %branch

condition_body9:                                  ; preds = %continue7
  store i16 -1, i16* %step, align 2
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i8 110, i8* %status, align 1
  store i8 0, i8* %run, align 1
  br label %continue8

branch:                                           ; preds = %continue7
  %load_start = load i8, i8* %start, align 1
  %4 = zext i8 %load_start to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %9, label %11

condition_body10:                                 ; preds = %11
  store i16 0, i16* %step, align 2
  %load_tx12 = load i64, i64* %tx, align 4
  store i64 %load_tx12, i64* %last, align 4
  store i8 111, i8* %status, align 1
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i8 1, i8* %run, align 1
  br label %continue8

continue8:                                        ; preds = %condition_body10, %11, %condition_body9
  %load_start13 = load i8, i8* %start, align 1
  store i8 %load_start13, i8* %edge, align 1
  %load_status = load i8, i8* %status, align 1
  %6 = zext i8 %load_status to i32
  %tmpVar16 = icmp sgt i32 %6, 0
  %7 = zext i1 %tmpVar16 to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %21, label %24

9:                                                ; preds = %branch
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar11 = xor i8 %load_edge, -1
  %10 = zext i8 %tmpVar11 to i32
  br label %11

11:                                               ; preds = %9, %branch
  %12 = phi i32 [ %4, %branch ], [ %10, %9 ]
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %condition_body10, label %continue8

condition_body15:                                 ; preds = %18
  ret void

buffer_block:                                     ; No predecessors!
  br label %continue14

continue14:                                       ; preds = %buffer_block, %18
  %load_run = load i8, i8* %run, align 1
  %14 = zext i8 %load_run to i32
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %31, label %34

16:                                               ; preds = %24
  %load_stop_on_error = load i8, i8* %stop_on_error, align 1
  %17 = zext i8 %load_stop_on_error to i32
  br label %18

18:                                               ; preds = %16, %24
  %19 = phi i32 [ %25, %24 ], [ %17, %16 ]
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %condition_body15, label %continue14

21:                                               ; preds = %continue8
  %load_status17 = load i8, i8* %status, align 1
  %22 = zext i8 %load_status17 to i32
  %tmpVar18 = icmp slt i32 %22, 100
  %23 = zext i1 %tmpVar18 to i32
  br label %24

24:                                               ; preds = %21, %continue8
  %25 = phi i32 [ %7, %continue8 ], [ %23, %21 ]
  %26 = icmp ne i32 %25, 0
  br i1 %26, label %16, label %18

condition_body20:                                 ; preds = %34
  %load_q0 = load i8, i8* %Q0, align 1
  %tmpVar26 = xor i8 %load_q0, -1
  %27 = zext i8 %tmpVar26 to i32
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %46, label %48

continue19:                                       ; preds = %continue24, %34
  %load_run48 = load i8, i8* %run, align 1
  %29 = zext i8 %load_run48 to i32
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %65, label %68

31:                                               ; preds = %continue14
  %load_step = load i16, i16* %step, align 2
  %32 = sext i16 %load_step to i32
  %tmpVar21 = icmp eq i32 %32, 0
  %33 = zext i1 %tmpVar21 to i32
  br label %34

34:                                               ; preds = %31, %continue14
  %35 = phi i32 [ %14, %continue14 ], [ %33, %31 ]
  %36 = icmp ne i32 %35, 0
  br i1 %36, label %condition_body20, label %continue19

condition_body25:                                 ; preds = %43
  store i8 1, i8* %Q0, align 1
  %load_tx30 = load i64, i64* %tx, align 4
  store i64 %load_tx30, i64* %last, align 4
  br label %continue24

branch22:                                         ; preds = %43
  %load_q032 = load i8, i8* %Q0, align 1
  %tmpVar33 = xor i8 %load_q032, -1
  %37 = zext i8 %tmpVar33 to i32
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %51, label %53

condition_body31:                                 ; preds = %53
  store i8 1, i8* %status, align 1
  store i8 0, i8* %run, align 1
  br label %continue24

branch23:                                         ; preds = %53
  %load_q040 = load i8, i8* %Q0, align 1
  %39 = zext i8 %load_q040 to i32
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %56, label %58

condition_body39:                                 ; preds = %58
  store i16 1, i16* %step, align 2
  %load_tx45 = load i64, i64* %tx, align 4
  store i64 %load_tx45, i64* %last, align 4
  br label %continue24

continue24:                                       ; preds = %condition_body39, %58, %condition_body31, %condition_body25
  br label %continue19

41:                                               ; preds = %48
  %load_tx27 = load i64, i64* %tx, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar28 = sub i64 %load_tx27, %load_last
  %load_wait0 = load i64, i64* %wait0, align 4
  %tmpVar29 = icmp sle i64 %tmpVar28, %load_wait0
  %42 = zext i1 %tmpVar29 to i32
  br label %43

43:                                               ; preds = %41, %48
  %44 = phi i32 [ %49, %48 ], [ %42, %41 ]
  %45 = icmp ne i32 %44, 0
  br i1 %45, label %condition_body25, label %branch22

46:                                               ; preds = %condition_body20
  %load_in0 = load i8, i8* %in0, align 1
  %47 = zext i8 %load_in0 to i32
  br label %48

48:                                               ; preds = %46, %condition_body20
  %49 = phi i32 [ %27, %condition_body20 ], [ %47, %46 ]
  %50 = icmp ne i32 %49, 0
  br i1 %50, label %41, label %43

51:                                               ; preds = %branch22
  %load_tx34 = load i64, i64* %tx, align 4
  %load_last35 = load i64, i64* %last, align 4
  %tmpVar36 = sub i64 %load_tx34, %load_last35
  %load_wait037 = load i64, i64* %wait0, align 4
  %tmpVar38 = icmp sgt i64 %tmpVar36, %load_wait037
  %52 = zext i1 %tmpVar38 to i32
  br label %53

53:                                               ; preds = %51, %branch22
  %54 = phi i32 [ %37, %branch22 ], [ %52, %51 ]
  %55 = icmp ne i32 %54, 0
  br i1 %55, label %condition_body31, label %branch23

56:                                               ; preds = %branch23
  %load_tx41 = load i64, i64* %tx, align 4
  %load_last42 = load i64, i64* %last, align 4
  %tmpVar43 = sub i64 %load_tx41, %load_last42
  %load_delay0 = load i64, i64* %delay0, align 4
  %tmpVar44 = icmp sge i64 %tmpVar43, %load_delay0
  %57 = zext i1 %tmpVar44 to i32
  br label %58

58:                                               ; preds = %56, %branch23
  %59 = phi i32 [ %39, %branch23 ], [ %57, %56 ]
  %60 = icmp ne i32 %59, 0
  br i1 %60, label %condition_body39, label %continue24

condition_body47:                                 ; preds = %68
  %load_q1 = load i8, i8* %Q1, align 1
  %tmpVar55 = xor i8 %load_q1, -1
  %61 = zext i8 %tmpVar55 to i32
  %62 = icmp ne i32 %61, 0
  br i1 %62, label %80, label %82

continue46:                                       ; preds = %continue53, %68
  %load_run77 = load i8, i8* %run, align 1
  %63 = zext i8 %load_run77 to i32
  %64 = icmp ne i32 %63, 0
  br i1 %64, label %99, label %102

65:                                               ; preds = %continue19
  %load_step49 = load i16, i16* %step, align 2
  %66 = sext i16 %load_step49 to i32
  %tmpVar50 = icmp eq i32 %66, 1
  %67 = zext i1 %tmpVar50 to i32
  br label %68

68:                                               ; preds = %65, %continue19
  %69 = phi i32 [ %29, %continue19 ], [ %67, %65 ]
  %70 = icmp ne i32 %69, 0
  br i1 %70, label %condition_body47, label %continue46

condition_body54:                                 ; preds = %77
  store i8 0, i8* %Q0, align 1
  store i8 1, i8* %Q1, align 1
  %load_tx60 = load i64, i64* %tx, align 4
  store i64 %load_tx60, i64* %last, align 4
  br label %continue53

branch51:                                         ; preds = %77
  %load_q162 = load i8, i8* %Q1, align 1
  %tmpVar63 = xor i8 %load_q162, -1
  %71 = zext i8 %tmpVar63 to i32
  %72 = icmp ne i32 %71, 0
  br i1 %72, label %85, label %87

condition_body61:                                 ; preds = %87
  store i8 2, i8* %status, align 1
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %run, align 1
  br label %continue53

branch52:                                         ; preds = %87
  %load_q169 = load i8, i8* %Q1, align 1
  %73 = zext i8 %load_q169 to i32
  %74 = icmp ne i32 %73, 0
  br i1 %74, label %90, label %92

condition_body68:                                 ; preds = %92
  store i16 2, i16* %step, align 2
  %load_tx74 = load i64, i64* %tx, align 4
  store i64 %load_tx74, i64* %last, align 4
  br label %continue53

continue53:                                       ; preds = %condition_body68, %92, %condition_body61, %condition_body54
  br label %continue46

75:                                               ; preds = %82
  %load_tx56 = load i64, i64* %tx, align 4
  %load_last57 = load i64, i64* %last, align 4
  %tmpVar58 = sub i64 %load_tx56, %load_last57
  %load_wait1 = load i64, i64* %wait1, align 4
  %tmpVar59 = icmp sle i64 %tmpVar58, %load_wait1
  %76 = zext i1 %tmpVar59 to i32
  br label %77

77:                                               ; preds = %75, %82
  %78 = phi i32 [ %83, %82 ], [ %76, %75 ]
  %79 = icmp ne i32 %78, 0
  br i1 %79, label %condition_body54, label %branch51

80:                                               ; preds = %condition_body47
  %load_in1 = load i8, i8* %in1, align 1
  %81 = zext i8 %load_in1 to i32
  br label %82

82:                                               ; preds = %80, %condition_body47
  %83 = phi i32 [ %61, %condition_body47 ], [ %81, %80 ]
  %84 = icmp ne i32 %83, 0
  br i1 %84, label %75, label %77

85:                                               ; preds = %branch51
  %load_Tx = load i64, i64* %tx, align 4
  %load_last64 = load i64, i64* %last, align 4
  %tmpVar65 = sub i64 %load_Tx, %load_last64
  %load_wait166 = load i64, i64* %wait1, align 4
  %tmpVar67 = icmp sgt i64 %tmpVar65, %load_wait166
  %86 = zext i1 %tmpVar67 to i32
  br label %87

87:                                               ; preds = %85, %branch51
  %88 = phi i32 [ %71, %branch51 ], [ %86, %85 ]
  %89 = icmp ne i32 %88, 0
  br i1 %89, label %condition_body61, label %branch52

90:                                               ; preds = %branch52
  %load_tx70 = load i64, i64* %tx, align 4
  %load_last71 = load i64, i64* %last, align 4
  %tmpVar72 = sub i64 %load_tx70, %load_last71
  %load_delay1 = load i64, i64* %delay1, align 4
  %tmpVar73 = icmp sge i64 %tmpVar72, %load_delay1
  %91 = zext i1 %tmpVar73 to i32
  br label %92

92:                                               ; preds = %90, %branch52
  %93 = phi i32 [ %73, %branch52 ], [ %91, %90 ]
  %94 = icmp ne i32 %93, 0
  br i1 %94, label %condition_body68, label %continue53

condition_body76:                                 ; preds = %102
  %load_q2 = load i8, i8* %Q2, align 1
  %tmpVar84 = xor i8 %load_q2, -1
  %95 = zext i8 %tmpVar84 to i32
  %96 = icmp ne i32 %95, 0
  br i1 %96, label %114, label %116

continue75:                                       ; preds = %continue82, %102
  %load_run107 = load i8, i8* %run, align 1
  %97 = zext i8 %load_run107 to i32
  %98 = icmp ne i32 %97, 0
  br i1 %98, label %133, label %136

99:                                               ; preds = %continue46
  %load_step78 = load i16, i16* %step, align 2
  %100 = sext i16 %load_step78 to i32
  %tmpVar79 = icmp eq i32 %100, 2
  %101 = zext i1 %tmpVar79 to i32
  br label %102

102:                                              ; preds = %99, %continue46
  %103 = phi i32 [ %63, %continue46 ], [ %101, %99 ]
  %104 = icmp ne i32 %103, 0
  br i1 %104, label %condition_body76, label %continue75

condition_body83:                                 ; preds = %111
  store i8 0, i8* %Q1, align 1
  store i8 1, i8* %Q2, align 1
  %load_tx89 = load i64, i64* %tx, align 4
  store i64 %load_tx89, i64* %last, align 4
  br label %continue82

branch80:                                         ; preds = %111
  %load_q291 = load i8, i8* %Q2, align 1
  %tmpVar92 = xor i8 %load_q291, -1
  %105 = zext i8 %tmpVar92 to i32
  %106 = icmp ne i32 %105, 0
  br i1 %106, label %119, label %121

condition_body90:                                 ; preds = %121
  store i8 3, i8* %status, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %run, align 1
  br label %continue82

branch81:                                         ; preds = %121
  %load_q299 = load i8, i8* %Q2, align 1
  %107 = zext i8 %load_q299 to i32
  %108 = icmp ne i32 %107, 0
  br i1 %108, label %124, label %126

condition_body98:                                 ; preds = %126
  store i16 3, i16* %step, align 2
  %load_tx104 = load i64, i64* %tx, align 4
  store i64 %load_tx104, i64* %last, align 4
  br label %continue82

continue82:                                       ; preds = %condition_body98, %126, %condition_body90, %condition_body83
  br label %continue75

109:                                              ; preds = %116
  %load_tx85 = load i64, i64* %tx, align 4
  %load_last86 = load i64, i64* %last, align 4
  %tmpVar87 = sub i64 %load_tx85, %load_last86
  %load_wait2 = load i64, i64* %wait2, align 4
  %tmpVar88 = icmp sle i64 %tmpVar87, %load_wait2
  %110 = zext i1 %tmpVar88 to i32
  br label %111

111:                                              ; preds = %109, %116
  %112 = phi i32 [ %117, %116 ], [ %110, %109 ]
  %113 = icmp ne i32 %112, 0
  br i1 %113, label %condition_body83, label %branch80

114:                                              ; preds = %condition_body76
  %load_in2 = load i8, i8* %in2, align 1
  %115 = zext i8 %load_in2 to i32
  br label %116

116:                                              ; preds = %114, %condition_body76
  %117 = phi i32 [ %95, %condition_body76 ], [ %115, %114 ]
  %118 = icmp ne i32 %117, 0
  br i1 %118, label %109, label %111

119:                                              ; preds = %branch80
  %load_Tx93 = load i64, i64* %tx, align 4
  %load_last94 = load i64, i64* %last, align 4
  %tmpVar95 = sub i64 %load_Tx93, %load_last94
  %load_wait296 = load i64, i64* %wait2, align 4
  %tmpVar97 = icmp sgt i64 %tmpVar95, %load_wait296
  %120 = zext i1 %tmpVar97 to i32
  br label %121

121:                                              ; preds = %119, %branch80
  %122 = phi i32 [ %105, %branch80 ], [ %120, %119 ]
  %123 = icmp ne i32 %122, 0
  br i1 %123, label %condition_body90, label %branch81

124:                                              ; preds = %branch81
  %load_tx100 = load i64, i64* %tx, align 4
  %load_last101 = load i64, i64* %last, align 4
  %tmpVar102 = sub i64 %load_tx100, %load_last101
  %load_delay2 = load i64, i64* %delay2, align 4
  %tmpVar103 = icmp sge i64 %tmpVar102, %load_delay2
  %125 = zext i1 %tmpVar103 to i32
  br label %126

126:                                              ; preds = %124, %branch81
  %127 = phi i32 [ %107, %branch81 ], [ %125, %124 ]
  %128 = icmp ne i32 %127, 0
  br i1 %128, label %condition_body98, label %continue82

condition_body106:                                ; preds = %136
  %load_q3 = load i8, i8* %Q3, align 1
  %tmpVar114 = xor i8 %load_q3, -1
  %129 = zext i8 %tmpVar114 to i32
  %130 = icmp ne i32 %129, 0
  br i1 %130, label %148, label %150

continue105:                                      ; preds = %continue112, %136
  %load_q0134 = load i8, i8* %Q0, align 1
  %131 = zext i8 %load_q0134 to i32
  %132 = icmp ne i32 %131, 0
  br i1 %132, label %174, label %172

133:                                              ; preds = %continue75
  %load_step108 = load i16, i16* %step, align 2
  %134 = sext i16 %load_step108 to i32
  %tmpVar109 = icmp eq i32 %134, 3
  %135 = zext i1 %tmpVar109 to i32
  br label %136

136:                                              ; preds = %133, %continue75
  %137 = phi i32 [ %97, %continue75 ], [ %135, %133 ]
  %138 = icmp ne i32 %137, 0
  br i1 %138, label %condition_body106, label %continue105

condition_body113:                                ; preds = %145
  store i8 0, i8* %Q2, align 1
  store i8 1, i8* %Q3, align 1
  %load_tx119 = load i64, i64* %tx, align 4
  store i64 %load_tx119, i64* %last, align 4
  br label %continue112

branch110:                                        ; preds = %145
  %load_q3121 = load i8, i8* %Q3, align 1
  %tmpVar122 = xor i8 %load_q3121, -1
  %139 = zext i8 %tmpVar122 to i32
  %140 = icmp ne i32 %139, 0
  br i1 %140, label %153, label %155

condition_body120:                                ; preds = %155
  store i8 4, i8* %status, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %run, align 1
  br label %continue112

branch111:                                        ; preds = %155
  %load_q3129 = load i8, i8* %Q3, align 1
  %141 = zext i8 %load_q3129 to i32
  %142 = icmp ne i32 %141, 0
  br i1 %142, label %158, label %160

condition_body128:                                ; preds = %160
  store i16 -1, i16* %step, align 2
  store i8 0, i8* %Q3, align 1
  store i8 0, i8* %run, align 1
  store i8 110, i8* %status, align 1
  br label %continue112

continue112:                                      ; preds = %condition_body128, %160, %condition_body120, %condition_body113
  br label %continue105

143:                                              ; preds = %150
  %load_tx115 = load i64, i64* %tx, align 4
  %load_last116 = load i64, i64* %last, align 4
  %tmpVar117 = sub i64 %load_tx115, %load_last116
  %load_wait3 = load i64, i64* %wait3, align 4
  %tmpVar118 = icmp sle i64 %tmpVar117, %load_wait3
  %144 = zext i1 %tmpVar118 to i32
  br label %145

145:                                              ; preds = %143, %150
  %146 = phi i32 [ %151, %150 ], [ %144, %143 ]
  %147 = icmp ne i32 %146, 0
  br i1 %147, label %condition_body113, label %branch110

148:                                              ; preds = %condition_body106
  %load_in3 = load i8, i8* %in3, align 1
  %149 = zext i8 %load_in3 to i32
  br label %150

150:                                              ; preds = %148, %condition_body106
  %151 = phi i32 [ %129, %condition_body106 ], [ %149, %148 ]
  %152 = icmp ne i32 %151, 0
  br i1 %152, label %143, label %145

153:                                              ; preds = %branch110
  %load_Tx123 = load i64, i64* %tx, align 4
  %load_last124 = load i64, i64* %last, align 4
  %tmpVar125 = sub i64 %load_Tx123, %load_last124
  %load_wait3126 = load i64, i64* %wait3, align 4
  %tmpVar127 = icmp sgt i64 %tmpVar125, %load_wait3126
  %154 = zext i1 %tmpVar127 to i32
  br label %155

155:                                              ; preds = %153, %branch110
  %156 = phi i32 [ %139, %branch110 ], [ %154, %153 ]
  %157 = icmp ne i32 %156, 0
  br i1 %157, label %condition_body120, label %branch111

158:                                              ; preds = %branch111
  %load_tx130 = load i64, i64* %tx, align 4
  %load_last131 = load i64, i64* %last, align 4
  %tmpVar132 = sub i64 %load_tx130, %load_last131
  %load_delay3 = load i64, i64* %delay3, align 4
  %tmpVar133 = icmp sge i64 %tmpVar132, %load_delay3
  %159 = zext i1 %tmpVar133 to i32
  br label %160

160:                                              ; preds = %158, %branch111
  %161 = phi i32 [ %141, %branch111 ], [ %159, %158 ]
  %162 = icmp ne i32 %161, 0
  br i1 %162, label %condition_body128, label %continue112

163:                                              ; preds = %169
  %load_q3137 = load i8, i8* %Q3, align 1
  %164 = zext i8 %load_q3137 to i32
  br label %165

165:                                              ; preds = %163, %169
  %166 = phi i32 [ %170, %169 ], [ %164, %163 ]
  store i32 %166, i8* %QX, align 4
  ret void

167:                                              ; preds = %174
  %load_q2136 = load i8, i8* %Q2, align 1
  %168 = zext i8 %load_q2136 to i32
  br label %169

169:                                              ; preds = %167, %174
  %170 = phi i32 [ %175, %174 ], [ %168, %167 ]
  %171 = icmp ne i32 %170, 0
  br i1 %171, label %165, label %163

172:                                              ; preds = %continue105
  %load_q1135 = load i8, i8* %Q1, align 1
  %173 = zext i8 %load_q1135 to i32
  br label %174

174:                                              ; preds = %172, %continue105
  %175 = phi i32 [ %131, %continue105 ], [ %173, %172 ]
  %176 = icmp ne i32 %175, 0
  br i1 %176, label %169, label %167
}

define void @SEQUENCE_64(%SEQUENCE_64_interface* %0) {
entry:
  %START = getelementptr inbounds %SEQUENCE_64_interface, %SEQUENCE_64_interface* %0, i32 0, i32 0
  %SMAX = getelementptr inbounds %SEQUENCE_64_interface, %SEQUENCE_64_interface* %0, i32 0, i32 1
  %PROG = getelementptr inbounds %SEQUENCE_64_interface, %SEQUENCE_64_interface* %0, i32 0, i32 2
  %RST = getelementptr inbounds %SEQUENCE_64_interface, %SEQUENCE_64_interface* %0, i32 0, i32 3
  %STATE = getelementptr inbounds %SEQUENCE_64_interface, %SEQUENCE_64_interface* %0, i32 0, i32 4
  %TRIG = getelementptr inbounds %SEQUENCE_64_interface, %SEQUENCE_64_interface* %0, i32 0, i32 5
  %tx = getelementptr inbounds %SEQUENCE_64_interface, %SEQUENCE_64_interface* %0, i32 0, i32 6
  %edge = getelementptr inbounds %SEQUENCE_64_interface, %SEQUENCE_64_interface* %0, i32 0, i32 7
  %last = getelementptr inbounds %SEQUENCE_64_interface, %SEQUENCE_64_interface* %0, i32 0, i32 8
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  store i8 0, i8* %TRIG, align 1
  %load_RST = load i8, i8* %RST, align 1
  %2 = icmp ne i8 %load_RST, 0
  br i1 %2, label %condition_body, label %branch

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  store i16 -1, i16* %STATE, align 2
  br label %continue8

branch:                                           ; preds = %continue
  %load_START = load i8, i8* %START, align 1
  %3 = zext i8 %load_START to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %7, label %9

condition_body9:                                  ; preds = %9
  store i16 0, i16* %STATE, align 2
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  store i8 1, i8* %TRIG, align 1
  br label %continue8

branch7:                                          ; preds = %9
  %load_STATE = load i16, i16* %STATE, align 2
  %5 = sext i16 %load_STATE to i32
  %tmpVar11 = icmp sge i32 %5, 0
  br i1 %tmpVar11, label %condition_body10, label %continue8

condition_body10:                                 ; preds = %branch7
  %load_tx14 = load i64, i64* %tx, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar15 = sub i64 %load_tx14, %load_last
  %load_STATE16 = load i16, i16* %STATE, align 2
  %6 = sext i16 %load_STATE16 to i32
  %tmpVar17 = mul i32 1, %6
  %tmpVar18 = add i32 %tmpVar17, 0
  %tmpVar19 = getelementptr inbounds [64 x i64], [64 x i64]* %PROG, i32 0, i32 %tmpVar18
  %load_tmpVar = load i64, i64* %tmpVar19, align 4
  %tmpVar20 = icmp sge i64 %tmpVar15, %load_tmpVar
  br i1 %tmpVar20, label %condition_body13, label %continue12

continue8:                                        ; preds = %continue12, %branch7, %condition_body9, %condition_body
  %load_START28 = load i8, i8* %START, align 1
  store i8 %load_START28, i8* %edge, align 1
  ret void

7:                                                ; preds = %branch
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar = xor i8 %load_edge, -1
  %8 = zext i8 %tmpVar to i32
  br label %9

9:                                                ; preds = %7, %branch
  %10 = phi i32 [ %3, %branch ], [ %8, %7 ]
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %condition_body9, label %branch7

condition_body13:                                 ; preds = %condition_body10
  %INC2_instance = alloca %INC2_interface, align 8
  br label %input21

continue12:                                       ; preds = %continue24, %condition_body10
  br label %continue8

input21:                                          ; preds = %condition_body13
  %12 = getelementptr inbounds %INC2_interface, %INC2_interface* %INC2_instance, i32 0, i32 0
  %load_STATE25 = load i16, i16* %STATE, align 2
  store i16 %load_STATE25, i16* %12, align 2
  %13 = getelementptr inbounds %INC2_interface, %INC2_interface* %INC2_instance, i32 0, i32 1
  store i16 1, i16* %13, align 2
  %14 = getelementptr inbounds %INC2_interface, %INC2_interface* %INC2_instance, i32 0, i32 2
  store i16 -1, i16* %14, align 2
  %15 = getelementptr inbounds %INC2_interface, %INC2_interface* %INC2_instance, i32 0, i32 3
  %load_SMAX = load i16, i16* %SMAX, align 2
  store i16 %load_SMAX, i16* %15, align 2
  br label %call22

call22:                                           ; preds = %input21
  %call26 = call i16 @INC2(%INC2_interface* %INC2_instance)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  store i16 %call26, i16* %STATE, align 2
  %load_tx27 = load i64, i64* %tx, align 4
  store i64 %load_tx27, i64* %last, align 4
  store i8 1, i8* %TRIG, align 1
  br label %continue12
}

define void @SEQUENCE_8(%SEQUENCE_8_interface* %0) {
entry:
  %in0 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 0
  %in1 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 1
  %in2 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 2
  %in3 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 3
  %in4 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 4
  %in5 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 5
  %in6 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 6
  %in7 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 7
  %start = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 8
  %rst = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 9
  %wait0 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 10
  %delay0 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 11
  %wait1 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 12
  %delay1 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 13
  %wait2 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 14
  %delay2 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 15
  %wait3 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 16
  %delay3 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 17
  %wait4 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 18
  %delay4 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 19
  %wait5 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 20
  %delay5 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 21
  %wait6 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 22
  %delay6 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 23
  %wait7 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 24
  %delay7 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 25
  %stop_on_error = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 26
  %Q0 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 27
  %Q1 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 28
  %Q2 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 29
  %Q3 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 30
  %Q4 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 31
  %Q5 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 32
  %Q6 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 33
  %Q7 = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 34
  %QX = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 35
  %run = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 36
  %step = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 37
  %status = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 38
  %last = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 39
  %edge = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 40
  %tx = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 41
  %init = getelementptr inbounds %SEQUENCE_8_interface, %SEQUENCE_8_interface* %0, i32 0, i32 42
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar, 0
  br i1 %2, label %condition_body, label %continue7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  store i8 1, i8* %init, align 1
  store i8 110, i8* %status, align 1
  br label %continue7

continue7:                                        ; preds = %condition_body, %continue
  %load_rst = load i8, i8* %rst, align 1
  %3 = icmp ne i8 %load_rst, 0
  br i1 %3, label %condition_body9, label %branch

condition_body9:                                  ; preds = %continue7
  store i16 -1, i16* %step, align 2
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i8 0, i8* %Q4, align 1
  store i8 0, i8* %Q5, align 1
  store i8 0, i8* %Q6, align 1
  store i8 0, i8* %Q7, align 1
  store i8 110, i8* %status, align 1
  store i8 0, i8* %run, align 1
  br label %continue8

branch:                                           ; preds = %continue7
  %load_start = load i8, i8* %start, align 1
  %4 = zext i8 %load_start to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %9, label %11

condition_body10:                                 ; preds = %11
  store i16 0, i16* %step, align 2
  %load_tx12 = load i64, i64* %tx, align 4
  store i64 %load_tx12, i64* %last, align 4
  store i8 111, i8* %status, align 1
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %Q3, align 1
  store i8 0, i8* %Q4, align 1
  store i8 0, i8* %Q5, align 1
  store i8 0, i8* %Q6, align 1
  store i8 0, i8* %Q7, align 1
  store i8 1, i8* %run, align 1
  br label %continue8

continue8:                                        ; preds = %condition_body10, %11, %condition_body9
  %load_start13 = load i8, i8* %start, align 1
  store i8 %load_start13, i8* %edge, align 1
  %load_status = load i8, i8* %status, align 1
  %6 = zext i8 %load_status to i32
  %tmpVar16 = icmp sgt i32 %6, 0
  %7 = zext i1 %tmpVar16 to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %21, label %24

9:                                                ; preds = %branch
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar11 = xor i8 %load_edge, -1
  %10 = zext i8 %tmpVar11 to i32
  br label %11

11:                                               ; preds = %9, %branch
  %12 = phi i32 [ %4, %branch ], [ %10, %9 ]
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %condition_body10, label %continue8

condition_body15:                                 ; preds = %18
  ret void

buffer_block:                                     ; No predecessors!
  br label %continue14

continue14:                                       ; preds = %buffer_block, %18
  %load_run = load i8, i8* %run, align 1
  %14 = zext i8 %load_run to i32
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %31, label %34

16:                                               ; preds = %24
  %load_stop_on_error = load i8, i8* %stop_on_error, align 1
  %17 = zext i8 %load_stop_on_error to i32
  br label %18

18:                                               ; preds = %16, %24
  %19 = phi i32 [ %25, %24 ], [ %17, %16 ]
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %condition_body15, label %continue14

21:                                               ; preds = %continue8
  %load_status17 = load i8, i8* %status, align 1
  %22 = zext i8 %load_status17 to i32
  %tmpVar18 = icmp slt i32 %22, 100
  %23 = zext i1 %tmpVar18 to i32
  br label %24

24:                                               ; preds = %21, %continue8
  %25 = phi i32 [ %7, %continue8 ], [ %23, %21 ]
  %26 = icmp ne i32 %25, 0
  br i1 %26, label %16, label %18

condition_body20:                                 ; preds = %34
  %load_q0 = load i8, i8* %Q0, align 1
  %tmpVar26 = xor i8 %load_q0, -1
  %27 = zext i8 %tmpVar26 to i32
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %46, label %48

continue19:                                       ; preds = %continue24, %34
  %load_run48 = load i8, i8* %run, align 1
  %29 = zext i8 %load_run48 to i32
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %65, label %68

31:                                               ; preds = %continue14
  %load_step = load i16, i16* %step, align 2
  %32 = sext i16 %load_step to i32
  %tmpVar21 = icmp eq i32 %32, 0
  %33 = zext i1 %tmpVar21 to i32
  br label %34

34:                                               ; preds = %31, %continue14
  %35 = phi i32 [ %14, %continue14 ], [ %33, %31 ]
  %36 = icmp ne i32 %35, 0
  br i1 %36, label %condition_body20, label %continue19

condition_body25:                                 ; preds = %43
  store i8 1, i8* %Q0, align 1
  %load_tx30 = load i64, i64* %tx, align 4
  store i64 %load_tx30, i64* %last, align 4
  br label %continue24

branch22:                                         ; preds = %43
  %load_q032 = load i8, i8* %Q0, align 1
  %tmpVar33 = xor i8 %load_q032, -1
  %37 = zext i8 %tmpVar33 to i32
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %51, label %53

condition_body31:                                 ; preds = %53
  store i8 1, i8* %status, align 1
  store i8 0, i8* %run, align 1
  br label %continue24

branch23:                                         ; preds = %53
  %load_q040 = load i8, i8* %Q0, align 1
  %39 = zext i8 %load_q040 to i32
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %56, label %58

condition_body39:                                 ; preds = %58
  store i16 1, i16* %step, align 2
  %load_tx45 = load i64, i64* %tx, align 4
  store i64 %load_tx45, i64* %last, align 4
  br label %continue24

continue24:                                       ; preds = %condition_body39, %58, %condition_body31, %condition_body25
  br label %continue19

41:                                               ; preds = %48
  %load_tx27 = load i64, i64* %tx, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar28 = sub i64 %load_tx27, %load_last
  %load_wait0 = load i64, i64* %wait0, align 4
  %tmpVar29 = icmp sle i64 %tmpVar28, %load_wait0
  %42 = zext i1 %tmpVar29 to i32
  br label %43

43:                                               ; preds = %41, %48
  %44 = phi i32 [ %49, %48 ], [ %42, %41 ]
  %45 = icmp ne i32 %44, 0
  br i1 %45, label %condition_body25, label %branch22

46:                                               ; preds = %condition_body20
  %load_in0 = load i8, i8* %in0, align 1
  %47 = zext i8 %load_in0 to i32
  br label %48

48:                                               ; preds = %46, %condition_body20
  %49 = phi i32 [ %27, %condition_body20 ], [ %47, %46 ]
  %50 = icmp ne i32 %49, 0
  br i1 %50, label %41, label %43

51:                                               ; preds = %branch22
  %load_tx34 = load i64, i64* %tx, align 4
  %load_last35 = load i64, i64* %last, align 4
  %tmpVar36 = sub i64 %load_tx34, %load_last35
  %load_wait037 = load i64, i64* %wait0, align 4
  %tmpVar38 = icmp sgt i64 %tmpVar36, %load_wait037
  %52 = zext i1 %tmpVar38 to i32
  br label %53

53:                                               ; preds = %51, %branch22
  %54 = phi i32 [ %37, %branch22 ], [ %52, %51 ]
  %55 = icmp ne i32 %54, 0
  br i1 %55, label %condition_body31, label %branch23

56:                                               ; preds = %branch23
  %load_tx41 = load i64, i64* %tx, align 4
  %load_last42 = load i64, i64* %last, align 4
  %tmpVar43 = sub i64 %load_tx41, %load_last42
  %load_delay0 = load i64, i64* %delay0, align 4
  %tmpVar44 = icmp sge i64 %tmpVar43, %load_delay0
  %57 = zext i1 %tmpVar44 to i32
  br label %58

58:                                               ; preds = %56, %branch23
  %59 = phi i32 [ %39, %branch23 ], [ %57, %56 ]
  %60 = icmp ne i32 %59, 0
  br i1 %60, label %condition_body39, label %continue24

condition_body47:                                 ; preds = %68
  %load_q1 = load i8, i8* %Q1, align 1
  %tmpVar55 = xor i8 %load_q1, -1
  %61 = zext i8 %tmpVar55 to i32
  %62 = icmp ne i32 %61, 0
  br i1 %62, label %80, label %82

continue46:                                       ; preds = %continue53, %68
  %load_run77 = load i8, i8* %run, align 1
  %63 = zext i8 %load_run77 to i32
  %64 = icmp ne i32 %63, 0
  br i1 %64, label %99, label %102

65:                                               ; preds = %continue19
  %load_step49 = load i16, i16* %step, align 2
  %66 = sext i16 %load_step49 to i32
  %tmpVar50 = icmp eq i32 %66, 1
  %67 = zext i1 %tmpVar50 to i32
  br label %68

68:                                               ; preds = %65, %continue19
  %69 = phi i32 [ %29, %continue19 ], [ %67, %65 ]
  %70 = icmp ne i32 %69, 0
  br i1 %70, label %condition_body47, label %continue46

condition_body54:                                 ; preds = %77
  store i8 0, i8* %Q0, align 1
  store i8 1, i8* %Q1, align 1
  %load_tx60 = load i64, i64* %tx, align 4
  store i64 %load_tx60, i64* %last, align 4
  br label %continue53

branch51:                                         ; preds = %77
  %load_q162 = load i8, i8* %Q1, align 1
  %tmpVar63 = xor i8 %load_q162, -1
  %71 = zext i8 %tmpVar63 to i32
  %72 = icmp ne i32 %71, 0
  br i1 %72, label %85, label %87

condition_body61:                                 ; preds = %87
  store i8 2, i8* %status, align 1
  store i8 0, i8* %Q0, align 1
  store i8 0, i8* %run, align 1
  br label %continue53

branch52:                                         ; preds = %87
  %load_q169 = load i8, i8* %Q1, align 1
  %73 = zext i8 %load_q169 to i32
  %74 = icmp ne i32 %73, 0
  br i1 %74, label %90, label %92

condition_body68:                                 ; preds = %92
  store i16 2, i16* %step, align 2
  %load_tx74 = load i64, i64* %tx, align 4
  store i64 %load_tx74, i64* %last, align 4
  br label %continue53

continue53:                                       ; preds = %condition_body68, %92, %condition_body61, %condition_body54
  br label %continue46

75:                                               ; preds = %82
  %load_tx56 = load i64, i64* %tx, align 4
  %load_last57 = load i64, i64* %last, align 4
  %tmpVar58 = sub i64 %load_tx56, %load_last57
  %load_wait1 = load i64, i64* %wait1, align 4
  %tmpVar59 = icmp sle i64 %tmpVar58, %load_wait1
  %76 = zext i1 %tmpVar59 to i32
  br label %77

77:                                               ; preds = %75, %82
  %78 = phi i32 [ %83, %82 ], [ %76, %75 ]
  %79 = icmp ne i32 %78, 0
  br i1 %79, label %condition_body54, label %branch51

80:                                               ; preds = %condition_body47
  %load_in1 = load i8, i8* %in1, align 1
  %81 = zext i8 %load_in1 to i32
  br label %82

82:                                               ; preds = %80, %condition_body47
  %83 = phi i32 [ %61, %condition_body47 ], [ %81, %80 ]
  %84 = icmp ne i32 %83, 0
  br i1 %84, label %75, label %77

85:                                               ; preds = %branch51
  %load_Tx = load i64, i64* %tx, align 4
  %load_last64 = load i64, i64* %last, align 4
  %tmpVar65 = sub i64 %load_Tx, %load_last64
  %load_wait166 = load i64, i64* %wait1, align 4
  %tmpVar67 = icmp sgt i64 %tmpVar65, %load_wait166
  %86 = zext i1 %tmpVar67 to i32
  br label %87

87:                                               ; preds = %85, %branch51
  %88 = phi i32 [ %71, %branch51 ], [ %86, %85 ]
  %89 = icmp ne i32 %88, 0
  br i1 %89, label %condition_body61, label %branch52

90:                                               ; preds = %branch52
  %load_tx70 = load i64, i64* %tx, align 4
  %load_last71 = load i64, i64* %last, align 4
  %tmpVar72 = sub i64 %load_tx70, %load_last71
  %load_delay1 = load i64, i64* %delay1, align 4
  %tmpVar73 = icmp sge i64 %tmpVar72, %load_delay1
  %91 = zext i1 %tmpVar73 to i32
  br label %92

92:                                               ; preds = %90, %branch52
  %93 = phi i32 [ %73, %branch52 ], [ %91, %90 ]
  %94 = icmp ne i32 %93, 0
  br i1 %94, label %condition_body68, label %continue53

condition_body76:                                 ; preds = %102
  %load_q2 = load i8, i8* %Q2, align 1
  %tmpVar84 = xor i8 %load_q2, -1
  %95 = zext i8 %tmpVar84 to i32
  %96 = icmp ne i32 %95, 0
  br i1 %96, label %114, label %116

continue75:                                       ; preds = %continue82, %102
  %load_run107 = load i8, i8* %run, align 1
  %97 = zext i8 %load_run107 to i32
  %98 = icmp ne i32 %97, 0
  br i1 %98, label %133, label %136

99:                                               ; preds = %continue46
  %load_step78 = load i16, i16* %step, align 2
  %100 = sext i16 %load_step78 to i32
  %tmpVar79 = icmp eq i32 %100, 2
  %101 = zext i1 %tmpVar79 to i32
  br label %102

102:                                              ; preds = %99, %continue46
  %103 = phi i32 [ %63, %continue46 ], [ %101, %99 ]
  %104 = icmp ne i32 %103, 0
  br i1 %104, label %condition_body76, label %continue75

condition_body83:                                 ; preds = %111
  store i8 0, i8* %Q1, align 1
  store i8 1, i8* %Q2, align 1
  %load_tx89 = load i64, i64* %tx, align 4
  store i64 %load_tx89, i64* %last, align 4
  br label %continue82

branch80:                                         ; preds = %111
  %load_q291 = load i8, i8* %Q2, align 1
  %tmpVar92 = xor i8 %load_q291, -1
  %105 = zext i8 %tmpVar92 to i32
  %106 = icmp ne i32 %105, 0
  br i1 %106, label %119, label %121

condition_body90:                                 ; preds = %121
  store i8 3, i8* %status, align 1
  store i8 0, i8* %Q1, align 1
  store i8 0, i8* %run, align 1
  br label %continue82

branch81:                                         ; preds = %121
  %load_q299 = load i8, i8* %Q2, align 1
  %107 = zext i8 %load_q299 to i32
  %108 = icmp ne i32 %107, 0
  br i1 %108, label %124, label %126

condition_body98:                                 ; preds = %126
  store i16 3, i16* %step, align 2
  %load_tx104 = load i64, i64* %tx, align 4
  store i64 %load_tx104, i64* %last, align 4
  br label %continue82

continue82:                                       ; preds = %condition_body98, %126, %condition_body90, %condition_body83
  br label %continue75

109:                                              ; preds = %116
  %load_tx85 = load i64, i64* %tx, align 4
  %load_last86 = load i64, i64* %last, align 4
  %tmpVar87 = sub i64 %load_tx85, %load_last86
  %load_wait2 = load i64, i64* %wait2, align 4
  %tmpVar88 = icmp sle i64 %tmpVar87, %load_wait2
  %110 = zext i1 %tmpVar88 to i32
  br label %111

111:                                              ; preds = %109, %116
  %112 = phi i32 [ %117, %116 ], [ %110, %109 ]
  %113 = icmp ne i32 %112, 0
  br i1 %113, label %condition_body83, label %branch80

114:                                              ; preds = %condition_body76
  %load_in2 = load i8, i8* %in2, align 1
  %115 = zext i8 %load_in2 to i32
  br label %116

116:                                              ; preds = %114, %condition_body76
  %117 = phi i32 [ %95, %condition_body76 ], [ %115, %114 ]
  %118 = icmp ne i32 %117, 0
  br i1 %118, label %109, label %111

119:                                              ; preds = %branch80
  %load_Tx93 = load i64, i64* %tx, align 4
  %load_last94 = load i64, i64* %last, align 4
  %tmpVar95 = sub i64 %load_Tx93, %load_last94
  %load_wait296 = load i64, i64* %wait2, align 4
  %tmpVar97 = icmp sgt i64 %tmpVar95, %load_wait296
  %120 = zext i1 %tmpVar97 to i32
  br label %121

121:                                              ; preds = %119, %branch80
  %122 = phi i32 [ %105, %branch80 ], [ %120, %119 ]
  %123 = icmp ne i32 %122, 0
  br i1 %123, label %condition_body90, label %branch81

124:                                              ; preds = %branch81
  %load_tx100 = load i64, i64* %tx, align 4
  %load_last101 = load i64, i64* %last, align 4
  %tmpVar102 = sub i64 %load_tx100, %load_last101
  %load_delay2 = load i64, i64* %delay2, align 4
  %tmpVar103 = icmp sge i64 %tmpVar102, %load_delay2
  %125 = zext i1 %tmpVar103 to i32
  br label %126

126:                                              ; preds = %124, %branch81
  %127 = phi i32 [ %107, %branch81 ], [ %125, %124 ]
  %128 = icmp ne i32 %127, 0
  br i1 %128, label %condition_body98, label %continue82

condition_body106:                                ; preds = %136
  %load_q3 = load i8, i8* %Q3, align 1
  %tmpVar114 = xor i8 %load_q3, -1
  %129 = zext i8 %tmpVar114 to i32
  %130 = icmp ne i32 %129, 0
  br i1 %130, label %148, label %150

continue105:                                      ; preds = %continue112, %136
  %load_run137 = load i8, i8* %run, align 1
  %131 = zext i8 %load_run137 to i32
  %132 = icmp ne i32 %131, 0
  br i1 %132, label %167, label %170

133:                                              ; preds = %continue75
  %load_step108 = load i16, i16* %step, align 2
  %134 = sext i16 %load_step108 to i32
  %tmpVar109 = icmp eq i32 %134, 3
  %135 = zext i1 %tmpVar109 to i32
  br label %136

136:                                              ; preds = %133, %continue75
  %137 = phi i32 [ %97, %continue75 ], [ %135, %133 ]
  %138 = icmp ne i32 %137, 0
  br i1 %138, label %condition_body106, label %continue105

condition_body113:                                ; preds = %145
  store i8 0, i8* %Q2, align 1
  store i8 1, i8* %Q3, align 1
  %load_tx119 = load i64, i64* %tx, align 4
  store i64 %load_tx119, i64* %last, align 4
  br label %continue112

branch110:                                        ; preds = %145
  %load_q3121 = load i8, i8* %Q3, align 1
  %tmpVar122 = xor i8 %load_q3121, -1
  %139 = zext i8 %tmpVar122 to i32
  %140 = icmp ne i32 %139, 0
  br i1 %140, label %153, label %155

condition_body120:                                ; preds = %155
  store i8 4, i8* %status, align 1
  store i8 0, i8* %Q2, align 1
  store i8 0, i8* %run, align 1
  br label %continue112

branch111:                                        ; preds = %155
  %load_q3129 = load i8, i8* %Q3, align 1
  %141 = zext i8 %load_q3129 to i32
  %142 = icmp ne i32 %141, 0
  br i1 %142, label %158, label %160

condition_body128:                                ; preds = %160
  store i16 4, i16* %step, align 2
  %load_tx134 = load i64, i64* %tx, align 4
  store i64 %load_tx134, i64* %last, align 4
  br label %continue112

continue112:                                      ; preds = %condition_body128, %160, %condition_body120, %condition_body113
  br label %continue105

143:                                              ; preds = %150
  %load_tx115 = load i64, i64* %tx, align 4
  %load_last116 = load i64, i64* %last, align 4
  %tmpVar117 = sub i64 %load_tx115, %load_last116
  %load_wait3 = load i64, i64* %wait3, align 4
  %tmpVar118 = icmp sle i64 %tmpVar117, %load_wait3
  %144 = zext i1 %tmpVar118 to i32
  br label %145

145:                                              ; preds = %143, %150
  %146 = phi i32 [ %151, %150 ], [ %144, %143 ]
  %147 = icmp ne i32 %146, 0
  br i1 %147, label %condition_body113, label %branch110

148:                                              ; preds = %condition_body106
  %load_in3 = load i8, i8* %in3, align 1
  %149 = zext i8 %load_in3 to i32
  br label %150

150:                                              ; preds = %148, %condition_body106
  %151 = phi i32 [ %129, %condition_body106 ], [ %149, %148 ]
  %152 = icmp ne i32 %151, 0
  br i1 %152, label %143, label %145

153:                                              ; preds = %branch110
  %load_Tx123 = load i64, i64* %tx, align 4
  %load_last124 = load i64, i64* %last, align 4
  %tmpVar125 = sub i64 %load_Tx123, %load_last124
  %load_wait3126 = load i64, i64* %wait3, align 4
  %tmpVar127 = icmp sgt i64 %tmpVar125, %load_wait3126
  %154 = zext i1 %tmpVar127 to i32
  br label %155

155:                                              ; preds = %153, %branch110
  %156 = phi i32 [ %139, %branch110 ], [ %154, %153 ]
  %157 = icmp ne i32 %156, 0
  br i1 %157, label %condition_body120, label %branch111

158:                                              ; preds = %branch111
  %load_tx130 = load i64, i64* %tx, align 4
  %load_last131 = load i64, i64* %last, align 4
  %tmpVar132 = sub i64 %load_tx130, %load_last131
  %load_delay3 = load i64, i64* %delay3, align 4
  %tmpVar133 = icmp sge i64 %tmpVar132, %load_delay3
  %159 = zext i1 %tmpVar133 to i32
  br label %160

160:                                              ; preds = %158, %branch111
  %161 = phi i32 [ %141, %branch111 ], [ %159, %158 ]
  %162 = icmp ne i32 %161, 0
  br i1 %162, label %condition_body128, label %continue112

condition_body136:                                ; preds = %170
  %load_q4 = load i8, i8* %Q4, align 1
  %tmpVar144 = xor i8 %load_q4, -1
  %163 = zext i8 %tmpVar144 to i32
  %164 = icmp ne i32 %163, 0
  br i1 %164, label %182, label %184

continue135:                                      ; preds = %continue142, %170
  %load_run167 = load i8, i8* %run, align 1
  %165 = zext i8 %load_run167 to i32
  %166 = icmp ne i32 %165, 0
  br i1 %166, label %201, label %204

167:                                              ; preds = %continue105
  %load_step138 = load i16, i16* %step, align 2
  %168 = sext i16 %load_step138 to i32
  %tmpVar139 = icmp eq i32 %168, 4
  %169 = zext i1 %tmpVar139 to i32
  br label %170

170:                                              ; preds = %167, %continue105
  %171 = phi i32 [ %131, %continue105 ], [ %169, %167 ]
  %172 = icmp ne i32 %171, 0
  br i1 %172, label %condition_body136, label %continue135

condition_body143:                                ; preds = %179
  store i8 0, i8* %Q3, align 1
  store i8 1, i8* %Q4, align 1
  %load_tx149 = load i64, i64* %tx, align 4
  store i64 %load_tx149, i64* %last, align 4
  br label %continue142

branch140:                                        ; preds = %179
  %load_q4151 = load i8, i8* %Q4, align 1
  %tmpVar152 = xor i8 %load_q4151, -1
  %173 = zext i8 %tmpVar152 to i32
  %174 = icmp ne i32 %173, 0
  br i1 %174, label %187, label %189

condition_body150:                                ; preds = %189
  store i8 5, i8* %status, align 1
  store i8 0, i8* %Q3, align 1
  store i8 0, i8* %run, align 1
  br label %continue142

branch141:                                        ; preds = %189
  %load_q4159 = load i8, i8* %Q4, align 1
  %175 = zext i8 %load_q4159 to i32
  %176 = icmp ne i32 %175, 0
  br i1 %176, label %192, label %194

condition_body158:                                ; preds = %194
  store i16 5, i16* %step, align 2
  %load_tx164 = load i64, i64* %tx, align 4
  store i64 %load_tx164, i64* %last, align 4
  br label %continue142

continue142:                                      ; preds = %condition_body158, %194, %condition_body150, %condition_body143
  br label %continue135

177:                                              ; preds = %184
  %load_tx145 = load i64, i64* %tx, align 4
  %load_last146 = load i64, i64* %last, align 4
  %tmpVar147 = sub i64 %load_tx145, %load_last146
  %load_wait4 = load i64, i64* %wait4, align 4
  %tmpVar148 = icmp sle i64 %tmpVar147, %load_wait4
  %178 = zext i1 %tmpVar148 to i32
  br label %179

179:                                              ; preds = %177, %184
  %180 = phi i32 [ %185, %184 ], [ %178, %177 ]
  %181 = icmp ne i32 %180, 0
  br i1 %181, label %condition_body143, label %branch140

182:                                              ; preds = %condition_body136
  %load_in4 = load i8, i8* %in4, align 1
  %183 = zext i8 %load_in4 to i32
  br label %184

184:                                              ; preds = %182, %condition_body136
  %185 = phi i32 [ %163, %condition_body136 ], [ %183, %182 ]
  %186 = icmp ne i32 %185, 0
  br i1 %186, label %177, label %179

187:                                              ; preds = %branch140
  %load_Tx153 = load i64, i64* %tx, align 4
  %load_last154 = load i64, i64* %last, align 4
  %tmpVar155 = sub i64 %load_Tx153, %load_last154
  %load_wait4156 = load i64, i64* %wait4, align 4
  %tmpVar157 = icmp sgt i64 %tmpVar155, %load_wait4156
  %188 = zext i1 %tmpVar157 to i32
  br label %189

189:                                              ; preds = %187, %branch140
  %190 = phi i32 [ %173, %branch140 ], [ %188, %187 ]
  %191 = icmp ne i32 %190, 0
  br i1 %191, label %condition_body150, label %branch141

192:                                              ; preds = %branch141
  %load_tx160 = load i64, i64* %tx, align 4
  %load_last161 = load i64, i64* %last, align 4
  %tmpVar162 = sub i64 %load_tx160, %load_last161
  %load_delay4 = load i64, i64* %delay4, align 4
  %tmpVar163 = icmp sge i64 %tmpVar162, %load_delay4
  %193 = zext i1 %tmpVar163 to i32
  br label %194

194:                                              ; preds = %192, %branch141
  %195 = phi i32 [ %175, %branch141 ], [ %193, %192 ]
  %196 = icmp ne i32 %195, 0
  br i1 %196, label %condition_body158, label %continue142

condition_body166:                                ; preds = %204
  %load_q5 = load i8, i8* %Q5, align 1
  %tmpVar174 = xor i8 %load_q5, -1
  %197 = zext i8 %tmpVar174 to i32
  %198 = icmp ne i32 %197, 0
  br i1 %198, label %216, label %218

continue165:                                      ; preds = %continue172, %204
  %load_run197 = load i8, i8* %run, align 1
  %199 = zext i8 %load_run197 to i32
  %200 = icmp ne i32 %199, 0
  br i1 %200, label %235, label %238

201:                                              ; preds = %continue135
  %load_step168 = load i16, i16* %step, align 2
  %202 = sext i16 %load_step168 to i32
  %tmpVar169 = icmp eq i32 %202, 5
  %203 = zext i1 %tmpVar169 to i32
  br label %204

204:                                              ; preds = %201, %continue135
  %205 = phi i32 [ %165, %continue135 ], [ %203, %201 ]
  %206 = icmp ne i32 %205, 0
  br i1 %206, label %condition_body166, label %continue165

condition_body173:                                ; preds = %213
  store i8 0, i8* %Q4, align 1
  store i8 1, i8* %Q5, align 1
  %load_tx179 = load i64, i64* %tx, align 4
  store i64 %load_tx179, i64* %last, align 4
  br label %continue172

branch170:                                        ; preds = %213
  %load_q5181 = load i8, i8* %Q5, align 1
  %tmpVar182 = xor i8 %load_q5181, -1
  %207 = zext i8 %tmpVar182 to i32
  %208 = icmp ne i32 %207, 0
  br i1 %208, label %221, label %223

condition_body180:                                ; preds = %223
  store i8 6, i8* %status, align 1
  store i8 0, i8* %Q4, align 1
  store i8 0, i8* %run, align 1
  br label %continue172

branch171:                                        ; preds = %223
  %load_q5189 = load i8, i8* %Q5, align 1
  %209 = zext i8 %load_q5189 to i32
  %210 = icmp ne i32 %209, 0
  br i1 %210, label %226, label %228

condition_body188:                                ; preds = %228
  store i16 6, i16* %step, align 2
  %load_tx194 = load i64, i64* %tx, align 4
  store i64 %load_tx194, i64* %last, align 4
  br label %continue172

continue172:                                      ; preds = %condition_body188, %228, %condition_body180, %condition_body173
  br label %continue165

211:                                              ; preds = %218
  %load_tx175 = load i64, i64* %tx, align 4
  %load_last176 = load i64, i64* %last, align 4
  %tmpVar177 = sub i64 %load_tx175, %load_last176
  %load_wait5 = load i64, i64* %wait5, align 4
  %tmpVar178 = icmp sle i64 %tmpVar177, %load_wait5
  %212 = zext i1 %tmpVar178 to i32
  br label %213

213:                                              ; preds = %211, %218
  %214 = phi i32 [ %219, %218 ], [ %212, %211 ]
  %215 = icmp ne i32 %214, 0
  br i1 %215, label %condition_body173, label %branch170

216:                                              ; preds = %condition_body166
  %load_in5 = load i8, i8* %in5, align 1
  %217 = zext i8 %load_in5 to i32
  br label %218

218:                                              ; preds = %216, %condition_body166
  %219 = phi i32 [ %197, %condition_body166 ], [ %217, %216 ]
  %220 = icmp ne i32 %219, 0
  br i1 %220, label %211, label %213

221:                                              ; preds = %branch170
  %load_Tx183 = load i64, i64* %tx, align 4
  %load_last184 = load i64, i64* %last, align 4
  %tmpVar185 = sub i64 %load_Tx183, %load_last184
  %load_wait5186 = load i64, i64* %wait5, align 4
  %tmpVar187 = icmp sgt i64 %tmpVar185, %load_wait5186
  %222 = zext i1 %tmpVar187 to i32
  br label %223

223:                                              ; preds = %221, %branch170
  %224 = phi i32 [ %207, %branch170 ], [ %222, %221 ]
  %225 = icmp ne i32 %224, 0
  br i1 %225, label %condition_body180, label %branch171

226:                                              ; preds = %branch171
  %load_tx190 = load i64, i64* %tx, align 4
  %load_last191 = load i64, i64* %last, align 4
  %tmpVar192 = sub i64 %load_tx190, %load_last191
  %load_delay5 = load i64, i64* %delay5, align 4
  %tmpVar193 = icmp sge i64 %tmpVar192, %load_delay5
  %227 = zext i1 %tmpVar193 to i32
  br label %228

228:                                              ; preds = %226, %branch171
  %229 = phi i32 [ %209, %branch171 ], [ %227, %226 ]
  %230 = icmp ne i32 %229, 0
  br i1 %230, label %condition_body188, label %continue172

condition_body196:                                ; preds = %238
  %load_q6 = load i8, i8* %Q6, align 1
  %tmpVar204 = xor i8 %load_q6, -1
  %231 = zext i8 %tmpVar204 to i32
  %232 = icmp ne i32 %231, 0
  br i1 %232, label %250, label %252

continue195:                                      ; preds = %continue202, %238
  %load_run227 = load i8, i8* %run, align 1
  %233 = zext i8 %load_run227 to i32
  %234 = icmp ne i32 %233, 0
  br i1 %234, label %269, label %272

235:                                              ; preds = %continue165
  %load_step198 = load i16, i16* %step, align 2
  %236 = sext i16 %load_step198 to i32
  %tmpVar199 = icmp eq i32 %236, 6
  %237 = zext i1 %tmpVar199 to i32
  br label %238

238:                                              ; preds = %235, %continue165
  %239 = phi i32 [ %199, %continue165 ], [ %237, %235 ]
  %240 = icmp ne i32 %239, 0
  br i1 %240, label %condition_body196, label %continue195

condition_body203:                                ; preds = %247
  store i8 0, i8* %Q5, align 1
  store i8 1, i8* %Q6, align 1
  %load_tx209 = load i64, i64* %tx, align 4
  store i64 %load_tx209, i64* %last, align 4
  br label %continue202

branch200:                                        ; preds = %247
  %load_q6211 = load i8, i8* %Q6, align 1
  %tmpVar212 = xor i8 %load_q6211, -1
  %241 = zext i8 %tmpVar212 to i32
  %242 = icmp ne i32 %241, 0
  br i1 %242, label %255, label %257

condition_body210:                                ; preds = %257
  store i8 7, i8* %status, align 1
  store i8 0, i8* %Q5, align 1
  store i8 0, i8* %run, align 1
  br label %continue202

branch201:                                        ; preds = %257
  %load_q6219 = load i8, i8* %Q6, align 1
  %243 = zext i8 %load_q6219 to i32
  %244 = icmp ne i32 %243, 0
  br i1 %244, label %260, label %262

condition_body218:                                ; preds = %262
  store i16 7, i16* %step, align 2
  %load_tx224 = load i64, i64* %tx, align 4
  store i64 %load_tx224, i64* %last, align 4
  br label %continue202

continue202:                                      ; preds = %condition_body218, %262, %condition_body210, %condition_body203
  br label %continue195

245:                                              ; preds = %252
  %load_tx205 = load i64, i64* %tx, align 4
  %load_last206 = load i64, i64* %last, align 4
  %tmpVar207 = sub i64 %load_tx205, %load_last206
  %load_wait6 = load i64, i64* %wait6, align 4
  %tmpVar208 = icmp sle i64 %tmpVar207, %load_wait6
  %246 = zext i1 %tmpVar208 to i32
  br label %247

247:                                              ; preds = %245, %252
  %248 = phi i32 [ %253, %252 ], [ %246, %245 ]
  %249 = icmp ne i32 %248, 0
  br i1 %249, label %condition_body203, label %branch200

250:                                              ; preds = %condition_body196
  %load_in6 = load i8, i8* %in6, align 1
  %251 = zext i8 %load_in6 to i32
  br label %252

252:                                              ; preds = %250, %condition_body196
  %253 = phi i32 [ %231, %condition_body196 ], [ %251, %250 ]
  %254 = icmp ne i32 %253, 0
  br i1 %254, label %245, label %247

255:                                              ; preds = %branch200
  %load_Tx213 = load i64, i64* %tx, align 4
  %load_last214 = load i64, i64* %last, align 4
  %tmpVar215 = sub i64 %load_Tx213, %load_last214
  %load_wait6216 = load i64, i64* %wait6, align 4
  %tmpVar217 = icmp sgt i64 %tmpVar215, %load_wait6216
  %256 = zext i1 %tmpVar217 to i32
  br label %257

257:                                              ; preds = %255, %branch200
  %258 = phi i32 [ %241, %branch200 ], [ %256, %255 ]
  %259 = icmp ne i32 %258, 0
  br i1 %259, label %condition_body210, label %branch201

260:                                              ; preds = %branch201
  %load_tx220 = load i64, i64* %tx, align 4
  %load_last221 = load i64, i64* %last, align 4
  %tmpVar222 = sub i64 %load_tx220, %load_last221
  %load_delay6 = load i64, i64* %delay6, align 4
  %tmpVar223 = icmp sge i64 %tmpVar222, %load_delay6
  %261 = zext i1 %tmpVar223 to i32
  br label %262

262:                                              ; preds = %260, %branch201
  %263 = phi i32 [ %243, %branch201 ], [ %261, %260 ]
  %264 = icmp ne i32 %263, 0
  br i1 %264, label %condition_body218, label %continue202

condition_body226:                                ; preds = %272
  %load_q7 = load i8, i8* %Q7, align 1
  %tmpVar234 = xor i8 %load_q7, -1
  %265 = zext i8 %tmpVar234 to i32
  %266 = icmp ne i32 %265, 0
  br i1 %266, label %284, label %286

continue225:                                      ; preds = %continue232, %272
  %load_q0254 = load i8, i8* %Q0, align 1
  %267 = zext i8 %load_q0254 to i32
  %268 = icmp ne i32 %267, 0
  br i1 %268, label %330, label %328

269:                                              ; preds = %continue195
  %load_step228 = load i16, i16* %step, align 2
  %270 = sext i16 %load_step228 to i32
  %tmpVar229 = icmp eq i32 %270, 7
  %271 = zext i1 %tmpVar229 to i32
  br label %272

272:                                              ; preds = %269, %continue195
  %273 = phi i32 [ %233, %continue195 ], [ %271, %269 ]
  %274 = icmp ne i32 %273, 0
  br i1 %274, label %condition_body226, label %continue225

condition_body233:                                ; preds = %281
  store i8 0, i8* %Q6, align 1
  store i8 1, i8* %Q7, align 1
  %load_tx239 = load i64, i64* %tx, align 4
  store i64 %load_tx239, i64* %last, align 4
  br label %continue232

branch230:                                        ; preds = %281
  %load_q7241 = load i8, i8* %Q7, align 1
  %tmpVar242 = xor i8 %load_q7241, -1
  %275 = zext i8 %tmpVar242 to i32
  %276 = icmp ne i32 %275, 0
  br i1 %276, label %289, label %291

condition_body240:                                ; preds = %291
  store i8 8, i8* %status, align 1
  store i8 0, i8* %Q6, align 1
  store i8 0, i8* %run, align 1
  br label %continue232

branch231:                                        ; preds = %291
  %load_q7249 = load i8, i8* %Q7, align 1
  %277 = zext i8 %load_q7249 to i32
  %278 = icmp ne i32 %277, 0
  br i1 %278, label %294, label %296

condition_body248:                                ; preds = %296
  store i16 -1, i16* %step, align 2
  store i8 0, i8* %Q7, align 1
  store i8 0, i8* %run, align 1
  store i8 110, i8* %status, align 1
  br label %continue232

continue232:                                      ; preds = %condition_body248, %296, %condition_body240, %condition_body233
  br label %continue225

279:                                              ; preds = %286
  %load_tx235 = load i64, i64* %tx, align 4
  %load_last236 = load i64, i64* %last, align 4
  %tmpVar237 = sub i64 %load_tx235, %load_last236
  %load_wait7 = load i64, i64* %wait7, align 4
  %tmpVar238 = icmp sle i64 %tmpVar237, %load_wait7
  %280 = zext i1 %tmpVar238 to i32
  br label %281

281:                                              ; preds = %279, %286
  %282 = phi i32 [ %287, %286 ], [ %280, %279 ]
  %283 = icmp ne i32 %282, 0
  br i1 %283, label %condition_body233, label %branch230

284:                                              ; preds = %condition_body226
  %load_in7 = load i8, i8* %in7, align 1
  %285 = zext i8 %load_in7 to i32
  br label %286

286:                                              ; preds = %284, %condition_body226
  %287 = phi i32 [ %265, %condition_body226 ], [ %285, %284 ]
  %288 = icmp ne i32 %287, 0
  br i1 %288, label %279, label %281

289:                                              ; preds = %branch230
  %load_Tx243 = load i64, i64* %tx, align 4
  %load_last244 = load i64, i64* %last, align 4
  %tmpVar245 = sub i64 %load_Tx243, %load_last244
  %load_wait7246 = load i64, i64* %wait7, align 4
  %tmpVar247 = icmp sgt i64 %tmpVar245, %load_wait7246
  %290 = zext i1 %tmpVar247 to i32
  br label %291

291:                                              ; preds = %289, %branch230
  %292 = phi i32 [ %275, %branch230 ], [ %290, %289 ]
  %293 = icmp ne i32 %292, 0
  br i1 %293, label %condition_body240, label %branch231

294:                                              ; preds = %branch231
  %load_tx250 = load i64, i64* %tx, align 4
  %load_last251 = load i64, i64* %last, align 4
  %tmpVar252 = sub i64 %load_tx250, %load_last251
  %load_delay7 = load i64, i64* %delay7, align 4
  %tmpVar253 = icmp sge i64 %tmpVar252, %load_delay7
  %295 = zext i1 %tmpVar253 to i32
  br label %296

296:                                              ; preds = %294, %branch231
  %297 = phi i32 [ %277, %branch231 ], [ %295, %294 ]
  %298 = icmp ne i32 %297, 0
  br i1 %298, label %condition_body248, label %continue232

299:                                              ; preds = %305
  %load_q7261 = load i8, i8* %Q7, align 1
  %300 = zext i8 %load_q7261 to i32
  br label %301

301:                                              ; preds = %299, %305
  %302 = phi i32 [ %306, %305 ], [ %300, %299 ]
  store i32 %302, i8* %QX, align 4
  ret void

303:                                              ; preds = %310
  %load_q6260 = load i8, i8* %Q6, align 1
  %304 = zext i8 %load_q6260 to i32
  br label %305

305:                                              ; preds = %303, %310
  %306 = phi i32 [ %311, %310 ], [ %304, %303 ]
  %307 = icmp ne i32 %306, 0
  br i1 %307, label %301, label %299

308:                                              ; preds = %315
  %load_q5259 = load i8, i8* %Q5, align 1
  %309 = zext i8 %load_q5259 to i32
  br label %310

310:                                              ; preds = %308, %315
  %311 = phi i32 [ %316, %315 ], [ %309, %308 ]
  %312 = icmp ne i32 %311, 0
  br i1 %312, label %305, label %303

313:                                              ; preds = %320
  %load_q4258 = load i8, i8* %Q4, align 1
  %314 = zext i8 %load_q4258 to i32
  br label %315

315:                                              ; preds = %313, %320
  %316 = phi i32 [ %321, %320 ], [ %314, %313 ]
  %317 = icmp ne i32 %316, 0
  br i1 %317, label %310, label %308

318:                                              ; preds = %325
  %load_q3257 = load i8, i8* %Q3, align 1
  %319 = zext i8 %load_q3257 to i32
  br label %320

320:                                              ; preds = %318, %325
  %321 = phi i32 [ %326, %325 ], [ %319, %318 ]
  %322 = icmp ne i32 %321, 0
  br i1 %322, label %315, label %313

323:                                              ; preds = %330
  %load_q2256 = load i8, i8* %Q2, align 1
  %324 = zext i8 %load_q2256 to i32
  br label %325

325:                                              ; preds = %323, %330
  %326 = phi i32 [ %331, %330 ], [ %324, %323 ]
  %327 = icmp ne i32 %326, 0
  br i1 %327, label %320, label %318

328:                                              ; preds = %continue225
  %load_q1255 = load i8, i8* %Q1, align 1
  %329 = zext i8 %load_q1255 to i32
  br label %330

330:                                              ; preds = %328, %continue225
  %331 = phi i32 [ %267, %continue225 ], [ %329, %328 ]
  %332 = icmp ne i32 %331, 0
  br i1 %332, label %325, label %323
}

define void @TMAX(%TMAX_interface* %0) {
entry:
  %IN = getelementptr inbounds %TMAX_interface, %TMAX_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %TMAX_interface, %TMAX_interface* %0, i32 0, i32 1
  %Q = getelementptr inbounds %TMAX_interface, %TMAX_interface* %0, i32 0, i32 2
  %Z = getelementptr inbounds %TMAX_interface, %TMAX_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %TMAX_interface, %TMAX_interface* %0, i32 0, i32 4
  %start = getelementptr inbounds %TMAX_interface, %TMAX_interface* %0, i32 0, i32 5
  %last_in = getelementptr inbounds %TMAX_interface, %TMAX_interface* %0, i32 0, i32 6
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  store i8 0, i8* %Z, align 1
  %load_in = load i8, i8* %IN, align 1
  %tmpVar = xor i8 %load_in, -1
  %2 = icmp ne i8 %tmpVar, 0
  br i1 %2, label %condition_body, label %branch

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  store i8 0, i8* %Q, align 1
  br label %continue8

branch:                                           ; preds = %continue
  %load_IN = load i8, i8* %IN, align 1
  %3 = zext i8 %load_IN to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %7, label %9

condition_body9:                                  ; preds = %9
  store i8 1, i8* %Q, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %start, align 4
  br label %continue8

branch7:                                          ; preds = %9
  %load_tx12 = load i64, i64* %tx, align 4
  %load_start = load i64, i64* %start, align 4
  %tmpVar13 = sub i64 %load_tx12, %load_start
  %load_PT = load i64, i64* %PT, align 4
  %tmpVar14 = icmp sge i64 %tmpVar13, %load_PT
  %5 = zext i1 %tmpVar14 to i32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %12, label %14

condition_body11:                                 ; preds = %14
  store i8 0, i8* %Q, align 1
  store i8 1, i8* %Z, align 1
  br label %continue8

continue8:                                        ; preds = %condition_body11, %14, %condition_body9, %condition_body
  %load_IN15 = load i8, i8* %IN, align 1
  store i8 %load_IN15, i8* %last_in, align 1
  ret void

7:                                                ; preds = %branch
  %load_last_in = load i8, i8* %last_in, align 1
  %tmpVar10 = xor i8 %load_last_in, -1
  %8 = zext i8 %tmpVar10 to i32
  br label %9

9:                                                ; preds = %7, %branch
  %10 = phi i32 [ %3, %branch ], [ %8, %7 ]
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %condition_body9, label %branch7

12:                                               ; preds = %branch7
  %load_Q = load i8, i8* %Q, align 1
  %13 = zext i8 %load_Q to i32
  br label %14

14:                                               ; preds = %12, %branch7
  %15 = phi i32 [ %5, %branch7 ], [ %13, %12 ]
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %condition_body11, label %continue8
}

define void @TMIN(%TMIN_interface* %0) {
entry:
  %IN = getelementptr inbounds %TMIN_interface, %TMIN_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %TMIN_interface, %TMIN_interface* %0, i32 0, i32 1
  %Q = getelementptr inbounds %TMIN_interface, %TMIN_interface* %0, i32 0, i32 2
  %pm = getelementptr inbounds %TMIN_interface, %TMIN_interface* %0, i32 0, i32 3
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %TP_interface, %TP_interface* %pm, i32 0, i32 0
  %load_IN = load i8, i8* %IN, align 1
  store i8 %load_IN, i8* %1, align 1
  %2 = getelementptr inbounds %TP_interface, %TP_interface* %pm, i32 0, i32 1
  %load_PT = load i64, i64* %PT, align 4
  store i64 %load_PT, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  call void @TP(%TP_interface* %pm)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_IN1 = load i8, i8* %IN, align 1
  %3 = zext i8 %load_IN1 to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %7, label %5

5:                                                ; preds = %continue
  %Q2 = getelementptr inbounds %TP_interface, %TP_interface* %pm, i32 0, i32 2
  %load_ = load i8, i8* %Q2, align 1
  %6 = zext i8 %load_ to i32
  br label %7

7:                                                ; preds = %5, %continue
  %8 = phi i32 [ %3, %continue ], [ %6, %5 ]
  store i32 %8, i8* %Q, align 4
  ret void
}

define void @TOF_1(%TOF_1_interface* %0) {
entry:
  %IN = getelementptr inbounds %TOF_1_interface, %TOF_1_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %TOF_1_interface, %TOF_1_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %TOF_1_interface, %TOF_1_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %TOF_1_interface, %TOF_1_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %TOF_1_interface, %TOF_1_interface* %0, i32 0, i32 4
  %start = getelementptr inbounds %TOF_1_interface, %TOF_1_interface* %0, i32 0, i32 5
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_RST = load i8, i8* %RST, align 1
  %2 = icmp ne i8 %load_RST, 0
  br i1 %2, label %condition_body, label %branch

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  store i8 0, i8* %Q, align 1
  br label %continue8

branch:                                           ; preds = %continue
  %load_IN = load i8, i8* %IN, align 1
  %3 = icmp ne i8 %load_IN, 0
  br i1 %3, label %condition_body9, label %branch7

condition_body9:                                  ; preds = %branch
  store i8 1, i8* %Q, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %start, align 4
  br label %continue8

branch7:                                          ; preds = %branch
  %load_tx11 = load i64, i64* %tx, align 4
  %load_start = load i64, i64* %start, align 4
  %tmpVar = sub i64 %load_tx11, %load_start
  %load_PT = load i64, i64* %PT, align 4
  %tmpVar12 = icmp sge i64 %tmpVar, %load_PT
  br i1 %tmpVar12, label %condition_body10, label %continue8

condition_body10:                                 ; preds = %branch7
  store i8 0, i8* %Q, align 1
  br label %continue8

continue8:                                        ; preds = %condition_body10, %branch7, %condition_body9, %condition_body
  ret void
}

define void @TONOF(%TONOF_interface* %0) {
entry:
  %IN = getelementptr inbounds %TONOF_interface, %TONOF_interface* %0, i32 0, i32 0
  %T_ON = getelementptr inbounds %TONOF_interface, %TONOF_interface* %0, i32 0, i32 1
  %T_OFF = getelementptr inbounds %TONOF_interface, %TONOF_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %TONOF_interface, %TONOF_interface* %0, i32 0, i32 3
  %X = getelementptr inbounds %TONOF_interface, %TONOF_interface* %0, i32 0, i32 4
  %old = getelementptr inbounds %TONOF_interface, %TONOF_interface* %0, i32 0, i32 5
  %mode = getelementptr inbounds %TONOF_interface, %TONOF_interface* %0, i32 0, i32 6
  %load_IN = load i8, i8* %IN, align 1
  %1 = zext i8 %load_IN to i32
  %load_old = load i8, i8* %old, align 1
  %2 = zext i8 %load_old to i32
  %tmpVar = xor i32 %1, %2
  %3 = icmp ne i32 %tmpVar, 0
  br i1 %3, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  br label %input

continue:                                         ; preds = %continue1, %entry
  br label %input10

input:                                            ; preds = %condition_body
  %4 = getelementptr inbounds %TON_interface, %TON_interface* %X, i32 0, i32 0
  store i8 0, i8* %4, align 1
  %5 = getelementptr inbounds %TON_interface, %TON_interface* %X, i32 0, i32 1
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input2

call:                                             ; preds = %continue5
  call void @TON(%TON_interface* %X)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %load_IN8 = load i8, i8* %IN, align 1
  store i8 %load_IN8, i8* %mode, align 1
  %load_IN9 = load i8, i8* %IN, align 1
  store i8 %load_IN9, i8* %old, align 1
  br label %continue

input2:                                           ; preds = %input
  %6 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_IN6 = load i8, i8* %IN, align 1
  store i8 %load_IN6, i8* %6, align 1
  %7 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_T_OFF = load i64, i64* %T_OFF, align 4
  store i64 %load_T_OFF, i64* %7, align 4
  %8 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_T_ON = load i64, i64* %T_ON, align 4
  store i64 %load_T_ON, i64* %8, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call7 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i64 %call7, i64* %5, align 4
  br label %call

input10:                                          ; preds = %continue
  %9 = getelementptr inbounds %TON_interface, %TON_interface* %X, i32 0, i32 0
  store i8 1, i8* %9, align 1
  br label %call11

call11:                                           ; preds = %input10
  call void @TON(%TON_interface* %X)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %Q16 = getelementptr inbounds %TON_interface, %TON_interface* %X, i32 0, i32 2
  %load_ = load i8, i8* %Q16, align 1
  %10 = icmp ne i8 %load_, 0
  br i1 %10, label %condition_body15, label %continue14

condition_body15:                                 ; preds = %continue13
  %load_mode = load i8, i8* %mode, align 1
  store i8 %load_mode, i8* %Q, align 1
  br label %continue14

continue14:                                       ; preds = %condition_body15, %continue13
  ret void
}

define void @TP_1(%TP_1_interface* %0) {
entry:
  %IN = getelementptr inbounds %TP_1_interface, %TP_1_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %TP_1_interface, %TP_1_interface* %0, i32 0, i32 1
  %RST = getelementptr inbounds %TP_1_interface, %TP_1_interface* %0, i32 0, i32 2
  %Q = getelementptr inbounds %TP_1_interface, %TP_1_interface* %0, i32 0, i32 3
  %tx = getelementptr inbounds %TP_1_interface, %TP_1_interface* %0, i32 0, i32 4
  %start = getelementptr inbounds %TP_1_interface, %TP_1_interface* %0, i32 0, i32 5
  %ix = getelementptr inbounds %TP_1_interface, %TP_1_interface* %0, i32 0, i32 6
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_RST = load i8, i8* %RST, align 1
  %2 = icmp ne i8 %load_RST, 0
  br i1 %2, label %condition_body, label %branch

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  store i8 0, i8* %Q, align 1
  br label %continue8

branch:                                           ; preds = %continue
  %load_IN = load i8, i8* %IN, align 1
  %3 = zext i8 %load_IN to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %5, label %7

condition_body9:                                  ; preds = %7
  store i8 1, i8* %Q, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %start, align 4
  br label %continue8

branch7:                                          ; preds = %7
  %load_tx11 = load i64, i64* %tx, align 4
  %load_start = load i64, i64* %start, align 4
  %tmpVar12 = sub i64 %load_tx11, %load_start
  %load_PT = load i64, i64* %PT, align 4
  %tmpVar13 = icmp sge i64 %tmpVar12, %load_PT
  br i1 %tmpVar13, label %condition_body10, label %continue8

condition_body10:                                 ; preds = %branch7
  store i8 0, i8* %Q, align 1
  br label %continue8

continue8:                                        ; preds = %condition_body10, %branch7, %condition_body9, %condition_body
  %load_IN14 = load i8, i8* %IN, align 1
  store i8 %load_IN14, i8* %ix, align 1
  ret void

5:                                                ; preds = %branch
  %load_ix = load i8, i8* %ix, align 1
  %tmpVar = xor i8 %load_ix, -1
  %6 = zext i8 %tmpVar to i32
  br label %7

7:                                                ; preds = %5, %branch
  %8 = phi i32 [ %3, %branch ], [ %6, %5 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body9, label %branch7
}

define void @TP_1D(%TP_1D_interface* %0) {
entry:
  %IN = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %0, i32 0, i32 0
  %PT1 = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %0, i32 0, i32 1
  %PTD = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %0, i32 0, i32 2
  %RST = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %0, i32 0, i32 3
  %Q = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %0, i32 0, i32 4
  %W = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %0, i32 0, i32 5
  %tx = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %0, i32 0, i32 6
  %start = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %0, i32 0, i32 7
  %ix = getelementptr inbounds %TP_1D_interface, %TP_1D_interface* %0, i32 0, i32 8
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_RST = load i8, i8* %RST, align 1
  %2 = icmp ne i8 %load_RST, 0
  br i1 %2, label %condition_body, label %branch

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  store i8 0, i8* %Q, align 1
  store i8 0, i8* %RST, align 1
  store i8 0, i8* %W, align 1
  br label %continue9

branch:                                           ; preds = %continue
  %load_W = load i8, i8* %W, align 1
  %3 = icmp ne i8 %load_W, 0
  br i1 %3, label %condition_body10, label %branch7

condition_body10:                                 ; preds = %branch
  %load_tx = load i64, i64* %tx, align 4
  %load_start = load i64, i64* %start, align 4
  %tmpVar = sub i64 %load_tx, %load_start
  %load_PTD = load i64, i64* %PTD, align 4
  %tmpVar13 = icmp sge i64 %tmpVar, %load_PTD
  br i1 %tmpVar13, label %condition_body12, label %continue11

branch7:                                          ; preds = %branch
  %load_IN = load i8, i8* %IN, align 1
  %4 = zext i8 %load_IN to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %6, label %8

condition_body14:                                 ; preds = %8
  store i8 1, i8* %Q, align 1
  %load_tx16 = load i64, i64* %tx, align 4
  store i64 %load_tx16, i64* %start, align 4
  store i8 0, i8* %IN, align 1
  br label %continue9

branch8:                                          ; preds = %8
  %load_tx18 = load i64, i64* %tx, align 4
  %load_start19 = load i64, i64* %start, align 4
  %tmpVar20 = sub i64 %load_tx18, %load_start19
  %load_PT1 = load i64, i64* %PT1, align 4
  %tmpVar21 = icmp sge i64 %tmpVar20, %load_PT1
  br i1 %tmpVar21, label %condition_body17, label %continue9

condition_body17:                                 ; preds = %branch8
  store i8 0, i8* %Q, align 1
  store i8 1, i8* %W, align 1
  %load_tx22 = load i64, i64* %tx, align 4
  store i64 %load_tx22, i64* %start, align 4
  br label %continue9

continue9:                                        ; preds = %condition_body17, %branch8, %condition_body14, %continue11, %condition_body
  %load_IN23 = load i8, i8* %IN, align 1
  store i8 %load_IN23, i8* %ix, align 1
  ret void

condition_body12:                                 ; preds = %condition_body10
  store i8 0, i8* %W, align 1
  br label %continue11

continue11:                                       ; preds = %condition_body12, %condition_body10
  br label %continue9

6:                                                ; preds = %branch7
  %load_ix = load i8, i8* %ix, align 1
  %tmpVar15 = xor i8 %load_ix, -1
  %7 = zext i8 %tmpVar15 to i32
  br label %8

8:                                                ; preds = %6, %branch7
  %9 = phi i32 [ %4, %branch7 ], [ %7, %6 ]
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %condition_body14, label %branch8
}

define void @TP_X(%TP_X_interface* %0) {
entry:
  %IN = getelementptr inbounds %TP_X_interface, %TP_X_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %TP_X_interface, %TP_X_interface* %0, i32 0, i32 1
  %Q = getelementptr inbounds %TP_X_interface, %TP_X_interface* %0, i32 0, i32 2
  %ET = getelementptr inbounds %TP_X_interface, %TP_X_interface* %0, i32 0, i32 3
  %edge = getelementptr inbounds %TP_X_interface, %TP_X_interface* %0, i32 0, i32 4
  %start = getelementptr inbounds %TP_X_interface, %TP_X_interface* %0, i32 0, i32 5
  %tx = getelementptr inbounds %TP_X_interface, %TP_X_interface* %0, i32 0, i32 6
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  %load_IN = load i8, i8* %IN, align 1
  %2 = zext i8 %load_IN to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %6, label %8

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %8
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %start, align 4
  %load_PT = load i64, i64* %PT, align 4
  %tmpVar8 = icmp sgt i64 %load_PT, 0
  %4 = zext i1 %tmpVar8 to i8
  store i8 %4, i8* %Q, align 1
  br label %continue7

branch:                                           ; preds = %8
  %load_Q = load i8, i8* %Q, align 1
  %5 = icmp ne i8 %load_Q, 0
  br i1 %5, label %condition_body9, label %continue7

condition_body9:                                  ; preds = %branch
  %load_tx10 = load i64, i64* %tx, align 4
  %load_start = load i64, i64* %start, align 4
  %tmpVar11 = sub i64 %load_tx10, %load_start
  store i64 %tmpVar11, i64* %ET, align 4
  %load_ET = load i64, i64* %ET, align 4
  %load_PT14 = load i64, i64* %PT, align 4
  %tmpVar15 = icmp sge i64 %load_ET, %load_PT14
  br i1 %tmpVar15, label %condition_body13, label %continue12

continue7:                                        ; preds = %continue12, %branch, %condition_body
  %load_IN16 = load i8, i8* %IN, align 1
  store i8 %load_IN16, i8* %edge, align 1
  ret void

6:                                                ; preds = %continue
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar = xor i8 %load_edge, -1
  %7 = zext i8 %tmpVar to i32
  br label %8

8:                                                ; preds = %6, %continue
  %9 = phi i32 [ %2, %continue ], [ %7, %6 ]
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %condition_body, label %branch

condition_body13:                                 ; preds = %condition_body9
  store i8 0, i8* %Q, align 1
  store i64 0, i64* %ET, align 4
  br label %continue12

continue12:                                       ; preds = %condition_body13, %condition_body9
  br label %continue7
}

define void @FIFO_16(%FIFO_16_interface* %0) {
entry:
  %Din = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 0
  %E = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 1
  %RD = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 2
  %WD = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 3
  %RST = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 4
  %Dout = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 5
  %EMPTY = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 6
  %FULL = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 7
  %fifo = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 8
  %pr = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 9
  %pw = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 10
  %n = getelementptr inbounds %FIFO_16_interface, %FIFO_16_interface* %0, i32 0, i32 11
  %load_RST = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_RST, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  %load_pr = load i16, i16* %pr, align 2
  store i16 %load_pr, i16* %pw, align 2
  store i8 0, i8* %FULL, align 1
  store i8 1, i8* %EMPTY, align 1
  store i32 0, i32* %Dout, align 4
  br label %continue

branch:                                           ; preds = %entry
  %load_E = load i8, i8* %E, align 1
  %2 = icmp ne i8 %load_E, 0
  br i1 %2, label %condition_body1, label %continue

condition_body1:                                  ; preds = %branch
  %load_EMPTY = load i8, i8* %EMPTY, align 1
  %tmpVar = xor i8 %load_EMPTY, -1
  %3 = zext i8 %tmpVar to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %8, label %10

continue:                                         ; preds = %continue13, %branch, %condition_body
  ret void

condition_body3:                                  ; preds = %10
  %load_pr4 = load i16, i16* %pr, align 2
  %5 = sext i16 %load_pr4 to i32
  %tmpVar5 = mul i32 1, %5
  %tmpVar6 = add i32 %tmpVar5, 0
  %tmpVar7 = getelementptr inbounds [17 x i32], [17 x i32]* %fifo, i32 0, i32 %tmpVar6
  %load_tmpVar = load i32, i32* %tmpVar7, align 4
  store i32 %load_tmpVar, i32* %Dout, align 4
  %INC1_instance = alloca %INC1_interface, align 8
  br label %input

continue2:                                        ; preds = %continue8, %10
  %load_FULL = load i8, i8* %FULL, align 1
  %tmpVar15 = xor i8 %load_FULL, -1
  %6 = zext i8 %tmpVar15 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %19, label %21

8:                                                ; preds = %condition_body1
  %load_RD = load i8, i8* %RD, align 1
  %9 = zext i8 %load_RD to i32
  br label %10

10:                                               ; preds = %8, %condition_body1
  %11 = phi i32 [ %3, %condition_body1 ], [ %9, %8 ]
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %condition_body3, label %continue2

input:                                            ; preds = %condition_body3
  %13 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 0
  %load_pr9 = load i16, i16* %pr, align 2
  store i16 %load_pr9, i16* %13, align 2
  %14 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 1
  %load_n = load i16, i16* %n, align 2
  store i16 %load_n, i16* %14, align 2
  br label %call

call:                                             ; preds = %input
  %call10 = call i16 @INC1(%INC1_interface* %INC1_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue8

continue8:                                        ; preds = %output
  store i16 %call10, i16* %pr, align 2
  %load_pr11 = load i16, i16* %pr, align 2
  %15 = sext i16 %load_pr11 to i32
  %load_pw = load i16, i16* %pw, align 2
  %16 = sext i16 %load_pw to i32
  %tmpVar12 = icmp eq i32 %15, %16
  %17 = zext i1 %tmpVar12 to i8
  store i8 %17, i8* %EMPTY, align 1
  store i8 0, i8* %FULL, align 1
  br label %continue2

condition_body14:                                 ; preds = %21
  %load_pw16 = load i16, i16* %pw, align 2
  %18 = sext i16 %load_pw16 to i32
  %tmpVar17 = mul i32 1, %18
  %tmpVar18 = add i32 %tmpVar17, 0
  %tmpVar19 = getelementptr inbounds [17 x i32], [17 x i32]* %fifo, i32 0, i32 %tmpVar18
  %load_Din = load i32, i32* %Din, align 4
  store i32 %load_Din, i32* %tmpVar19, align 4
  %INC1_instance20 = alloca %INC1_interface, align 8
  br label %input21

continue13:                                       ; preds = %continue24, %21
  br label %continue

19:                                               ; preds = %continue2
  %load_WD = load i8, i8* %WD, align 1
  %20 = zext i8 %load_WD to i32
  br label %21

21:                                               ; preds = %19, %continue2
  %22 = phi i32 [ %6, %continue2 ], [ %20, %19 ]
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %condition_body14, label %continue13

input21:                                          ; preds = %condition_body14
  %24 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance20, i32 0, i32 0
  %load_pw25 = load i16, i16* %pw, align 2
  store i16 %load_pw25, i16* %24, align 2
  %25 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance20, i32 0, i32 1
  %load_n26 = load i16, i16* %n, align 2
  store i16 %load_n26, i16* %25, align 2
  br label %call22

call22:                                           ; preds = %input21
  %call27 = call i16 @INC1(%INC1_interface* %INC1_instance20)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  store i16 %call27, i16* %pw, align 2
  %load_pw28 = load i16, i16* %pw, align 2
  %26 = sext i16 %load_pw28 to i32
  %load_pr29 = load i16, i16* %pr, align 2
  %27 = sext i16 %load_pr29 to i32
  %tmpVar30 = icmp eq i32 %26, %27
  %28 = zext i1 %tmpVar30 to i8
  store i8 %28, i8* %FULL, align 1
  store i8 0, i8* %EMPTY, align 1
  br label %continue13
}

define void @FIFO_32(%FIFO_32_interface* %0) {
entry:
  %Din = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 0
  %E = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 1
  %RD = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 2
  %WD = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 3
  %RST = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 4
  %Dout = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 5
  %EMPTY = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 6
  %FULL = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 7
  %fifo = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 8
  %pr = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 9
  %pw = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 10
  %n = getelementptr inbounds %FIFO_32_interface, %FIFO_32_interface* %0, i32 0, i32 11
  %load_RST = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_RST, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  %load_pr = load i16, i16* %pr, align 2
  store i16 %load_pr, i16* %pw, align 2
  store i8 0, i8* %FULL, align 1
  store i8 1, i8* %EMPTY, align 1
  store i32 0, i32* %Dout, align 4
  br label %continue

branch:                                           ; preds = %entry
  %load_E = load i8, i8* %E, align 1
  %2 = icmp ne i8 %load_E, 0
  br i1 %2, label %condition_body1, label %continue

condition_body1:                                  ; preds = %branch
  %load_EMPTY = load i8, i8* %EMPTY, align 1
  %tmpVar = xor i8 %load_EMPTY, -1
  %3 = zext i8 %tmpVar to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %8, label %10

continue:                                         ; preds = %continue13, %branch, %condition_body
  ret void

condition_body3:                                  ; preds = %10
  %load_pr4 = load i16, i16* %pr, align 2
  %5 = sext i16 %load_pr4 to i32
  %tmpVar5 = mul i32 1, %5
  %tmpVar6 = add i32 %tmpVar5, 0
  %tmpVar7 = getelementptr inbounds [33 x i32], [33 x i32]* %fifo, i32 0, i32 %tmpVar6
  %load_tmpVar = load i32, i32* %tmpVar7, align 4
  store i32 %load_tmpVar, i32* %Dout, align 4
  %INC1_instance = alloca %INC1_interface, align 8
  br label %input

continue2:                                        ; preds = %continue8, %10
  %load_FULL = load i8, i8* %FULL, align 1
  %tmpVar15 = xor i8 %load_FULL, -1
  %6 = zext i8 %tmpVar15 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %19, label %21

8:                                                ; preds = %condition_body1
  %load_RD = load i8, i8* %RD, align 1
  %9 = zext i8 %load_RD to i32
  br label %10

10:                                               ; preds = %8, %condition_body1
  %11 = phi i32 [ %3, %condition_body1 ], [ %9, %8 ]
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %condition_body3, label %continue2

input:                                            ; preds = %condition_body3
  %13 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 0
  %load_pr9 = load i16, i16* %pr, align 2
  store i16 %load_pr9, i16* %13, align 2
  %14 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 1
  %load_n = load i16, i16* %n, align 2
  store i16 %load_n, i16* %14, align 2
  br label %call

call:                                             ; preds = %input
  %call10 = call i16 @INC1(%INC1_interface* %INC1_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue8

continue8:                                        ; preds = %output
  store i16 %call10, i16* %pr, align 2
  %load_pr11 = load i16, i16* %pr, align 2
  %15 = sext i16 %load_pr11 to i32
  %load_pw = load i16, i16* %pw, align 2
  %16 = sext i16 %load_pw to i32
  %tmpVar12 = icmp eq i32 %15, %16
  %17 = zext i1 %tmpVar12 to i8
  store i8 %17, i8* %EMPTY, align 1
  store i8 0, i8* %FULL, align 1
  br label %continue2

condition_body14:                                 ; preds = %21
  %load_pw16 = load i16, i16* %pw, align 2
  %18 = sext i16 %load_pw16 to i32
  %tmpVar17 = mul i32 1, %18
  %tmpVar18 = add i32 %tmpVar17, 0
  %tmpVar19 = getelementptr inbounds [33 x i32], [33 x i32]* %fifo, i32 0, i32 %tmpVar18
  %load_Din = load i32, i32* %Din, align 4
  store i32 %load_Din, i32* %tmpVar19, align 4
  %INC1_instance20 = alloca %INC1_interface, align 8
  br label %input21

continue13:                                       ; preds = %continue24, %21
  br label %continue

19:                                               ; preds = %continue2
  %load_WD = load i8, i8* %WD, align 1
  %20 = zext i8 %load_WD to i32
  br label %21

21:                                               ; preds = %19, %continue2
  %22 = phi i32 [ %6, %continue2 ], [ %20, %19 ]
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %condition_body14, label %continue13

input21:                                          ; preds = %condition_body14
  %24 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance20, i32 0, i32 0
  %load_pw25 = load i16, i16* %pw, align 2
  store i16 %load_pw25, i16* %24, align 2
  %25 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance20, i32 0, i32 1
  %load_n26 = load i16, i16* %n, align 2
  store i16 %load_n26, i16* %25, align 2
  br label %call22

call22:                                           ; preds = %input21
  %call27 = call i16 @INC1(%INC1_interface* %INC1_instance20)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  store i16 %call27, i16* %pw, align 2
  %load_pw28 = load i16, i16* %pw, align 2
  %26 = sext i16 %load_pw28 to i32
  %load_pr29 = load i16, i16* %pr, align 2
  %27 = sext i16 %load_pr29 to i32
  %tmpVar30 = icmp eq i32 %26, %27
  %28 = zext i1 %tmpVar30 to i8
  store i8 %28, i8* %FULL, align 1
  store i8 0, i8* %EMPTY, align 1
  br label %continue13
}

define void @STACK_16(%STACK_16_interface* %0) {
entry:
  %Din = getelementptr inbounds %STACK_16_interface, %STACK_16_interface* %0, i32 0, i32 0
  %E = getelementptr inbounds %STACK_16_interface, %STACK_16_interface* %0, i32 0, i32 1
  %RD = getelementptr inbounds %STACK_16_interface, %STACK_16_interface* %0, i32 0, i32 2
  %WD = getelementptr inbounds %STACK_16_interface, %STACK_16_interface* %0, i32 0, i32 3
  %RST = getelementptr inbounds %STACK_16_interface, %STACK_16_interface* %0, i32 0, i32 4
  %Dout = getelementptr inbounds %STACK_16_interface, %STACK_16_interface* %0, i32 0, i32 5
  %EMPTY = getelementptr inbounds %STACK_16_interface, %STACK_16_interface* %0, i32 0, i32 6
  %FULL = getelementptr inbounds %STACK_16_interface, %STACK_16_interface* %0, i32 0, i32 7
  %stack = getelementptr inbounds %STACK_16_interface, %STACK_16_interface* %0, i32 0, i32 8
  %pt = getelementptr inbounds %STACK_16_interface, %STACK_16_interface* %0, i32 0, i32 9
  %n = getelementptr inbounds %STACK_16_interface, %STACK_16_interface* %0, i32 0, i32 10
  %load_RST = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_RST, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i16 0, i16* %pt, align 2
  store i8 1, i8* %EMPTY, align 1
  store i8 0, i8* %FULL, align 1
  store i32 0, i32* %Dout, align 4
  br label %continue

branch:                                           ; preds = %entry
  %load_E = load i8, i8* %E, align 1
  %2 = icmp ne i8 %load_E, 0
  br i1 %2, label %condition_body1, label %continue

condition_body1:                                  ; preds = %branch
  %load_EMPTY = load i8, i8* %EMPTY, align 1
  %tmpVar = xor i8 %load_EMPTY, -1
  %3 = zext i8 %tmpVar to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %12, label %14

continue:                                         ; preds = %continue11, %branch, %condition_body
  ret void

condition_body3:                                  ; preds = %14
  %load_pt = load i16, i16* %pt, align 2
  %5 = sext i16 %load_pt to i32
  %tmpVar4 = sub i32 %5, 1
  %6 = trunc i32 %tmpVar4 to i16
  store i16 %6, i16* %pt, align 2
  %load_pt5 = load i16, i16* %pt, align 2
  %7 = sext i16 %load_pt5 to i32
  %tmpVar6 = mul i32 1, %7
  %tmpVar7 = add i32 %tmpVar6, 0
  %tmpVar8 = getelementptr inbounds [16 x i32], [16 x i32]* %stack, i32 0, i32 %tmpVar7
  %load_tmpVar = load i32, i32* %tmpVar8, align 4
  store i32 %load_tmpVar, i32* %Dout, align 4
  %load_pt9 = load i16, i16* %pt, align 2
  %8 = sext i16 %load_pt9 to i32
  %tmpVar10 = icmp eq i32 %8, 0
  %9 = zext i1 %tmpVar10 to i8
  store i8 %9, i8* %EMPTY, align 1
  store i8 0, i8* %FULL, align 1
  br label %continue2

continue2:                                        ; preds = %condition_body3, %14
  %load_FULL = load i8, i8* %FULL, align 1
  %tmpVar13 = xor i8 %load_FULL, -1
  %10 = zext i8 %tmpVar13 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %23, label %25

12:                                               ; preds = %condition_body1
  %load_RD = load i8, i8* %RD, align 1
  %13 = zext i8 %load_RD to i32
  br label %14

14:                                               ; preds = %12, %condition_body1
  %15 = phi i32 [ %3, %condition_body1 ], [ %13, %12 ]
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %condition_body3, label %continue2

condition_body12:                                 ; preds = %25
  %load_pt14 = load i16, i16* %pt, align 2
  %17 = sext i16 %load_pt14 to i32
  %tmpVar15 = mul i32 1, %17
  %tmpVar16 = add i32 %tmpVar15, 0
  %tmpVar17 = getelementptr inbounds [16 x i32], [16 x i32]* %stack, i32 0, i32 %tmpVar16
  %load_Din = load i32, i32* %Din, align 4
  store i32 %load_Din, i32* %tmpVar17, align 4
  %load_pt18 = load i16, i16* %pt, align 2
  %18 = sext i16 %load_pt18 to i32
  %tmpVar19 = add i32 %18, 1
  %19 = trunc i32 %tmpVar19 to i16
  store i16 %19, i16* %pt, align 2
  %load_pt20 = load i16, i16* %pt, align 2
  %20 = sext i16 %load_pt20 to i32
  %load_n = load i16, i16* %n, align 2
  %21 = sext i16 %load_n to i32
  %tmpVar21 = icmp sgt i32 %20, %21
  %22 = zext i1 %tmpVar21 to i8
  store i8 %22, i8* %FULL, align 1
  store i8 0, i8* %EMPTY, align 1
  br label %continue11

continue11:                                       ; preds = %condition_body12, %25
  br label %continue

23:                                               ; preds = %continue2
  %load_WD = load i8, i8* %WD, align 1
  %24 = zext i8 %load_WD to i32
  br label %25

25:                                               ; preds = %23, %continue2
  %26 = phi i32 [ %10, %continue2 ], [ %24, %23 ]
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %condition_body12, label %continue11
}

define void @STACK_32(%STACK_32_interface* %0) {
entry:
  %Din = getelementptr inbounds %STACK_32_interface, %STACK_32_interface* %0, i32 0, i32 0
  %E = getelementptr inbounds %STACK_32_interface, %STACK_32_interface* %0, i32 0, i32 1
  %RD = getelementptr inbounds %STACK_32_interface, %STACK_32_interface* %0, i32 0, i32 2
  %WD = getelementptr inbounds %STACK_32_interface, %STACK_32_interface* %0, i32 0, i32 3
  %RST = getelementptr inbounds %STACK_32_interface, %STACK_32_interface* %0, i32 0, i32 4
  %Dout = getelementptr inbounds %STACK_32_interface, %STACK_32_interface* %0, i32 0, i32 5
  %EMPTY = getelementptr inbounds %STACK_32_interface, %STACK_32_interface* %0, i32 0, i32 6
  %FULL = getelementptr inbounds %STACK_32_interface, %STACK_32_interface* %0, i32 0, i32 7
  %stack = getelementptr inbounds %STACK_32_interface, %STACK_32_interface* %0, i32 0, i32 8
  %pt = getelementptr inbounds %STACK_32_interface, %STACK_32_interface* %0, i32 0, i32 9
  %n = getelementptr inbounds %STACK_32_interface, %STACK_32_interface* %0, i32 0, i32 10
  %load_RST = load i8, i8* %RST, align 1
  %1 = icmp ne i8 %load_RST, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i16 0, i16* %pt, align 2
  store i8 1, i8* %EMPTY, align 1
  store i8 0, i8* %FULL, align 1
  store i32 0, i32* %Dout, align 4
  br label %continue

branch:                                           ; preds = %entry
  %load_E = load i8, i8* %E, align 1
  %2 = icmp ne i8 %load_E, 0
  br i1 %2, label %condition_body1, label %continue

condition_body1:                                  ; preds = %branch
  %load_EMPTY = load i8, i8* %EMPTY, align 1
  %tmpVar = xor i8 %load_EMPTY, -1
  %3 = zext i8 %tmpVar to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %12, label %14

continue:                                         ; preds = %continue11, %branch, %condition_body
  ret void

condition_body3:                                  ; preds = %14
  %load_pt = load i16, i16* %pt, align 2
  %5 = sext i16 %load_pt to i32
  %tmpVar4 = sub i32 %5, 1
  %6 = trunc i32 %tmpVar4 to i16
  store i16 %6, i16* %pt, align 2
  %load_pt5 = load i16, i16* %pt, align 2
  %7 = sext i16 %load_pt5 to i32
  %tmpVar6 = mul i32 1, %7
  %tmpVar7 = add i32 %tmpVar6, 0
  %tmpVar8 = getelementptr inbounds [32 x i32], [32 x i32]* %stack, i32 0, i32 %tmpVar7
  %load_tmpVar = load i32, i32* %tmpVar8, align 4
  store i32 %load_tmpVar, i32* %Dout, align 4
  %load_pt9 = load i16, i16* %pt, align 2
  %8 = sext i16 %load_pt9 to i32
  %tmpVar10 = icmp eq i32 %8, 0
  %9 = zext i1 %tmpVar10 to i8
  store i8 %9, i8* %EMPTY, align 1
  store i8 0, i8* %FULL, align 1
  br label %continue2

continue2:                                        ; preds = %condition_body3, %14
  %load_FULL = load i8, i8* %FULL, align 1
  %tmpVar13 = xor i8 %load_FULL, -1
  %10 = zext i8 %tmpVar13 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %23, label %25

12:                                               ; preds = %condition_body1
  %load_RD = load i8, i8* %RD, align 1
  %13 = zext i8 %load_RD to i32
  br label %14

14:                                               ; preds = %12, %condition_body1
  %15 = phi i32 [ %3, %condition_body1 ], [ %13, %12 ]
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %condition_body3, label %continue2

condition_body12:                                 ; preds = %25
  %load_pt14 = load i16, i16* %pt, align 2
  %17 = sext i16 %load_pt14 to i32
  %tmpVar15 = mul i32 1, %17
  %tmpVar16 = add i32 %tmpVar15, 0
  %tmpVar17 = getelementptr inbounds [32 x i32], [32 x i32]* %stack, i32 0, i32 %tmpVar16
  %load_Din = load i32, i32* %Din, align 4
  store i32 %load_Din, i32* %tmpVar17, align 4
  %load_pt18 = load i16, i16* %pt, align 2
  %18 = sext i16 %load_pt18 to i32
  %tmpVar19 = add i32 %18, 1
  %19 = trunc i32 %tmpVar19 to i16
  store i16 %19, i16* %pt, align 2
  %load_pt20 = load i16, i16* %pt, align 2
  %20 = sext i16 %load_pt20 to i32
  %load_n = load i16, i16* %n, align 2
  %21 = sext i16 %load_n to i32
  %tmpVar21 = icmp sgt i32 %20, %21
  %22 = zext i1 %tmpVar21 to i8
  store i8 %22, i8* %FULL, align 1
  store i8 0, i8* %EMPTY, align 1
  br label %continue11

continue11:                                       ; preds = %condition_body12, %25
  br label %continue

23:                                               ; preds = %continue2
  %load_WD = load i8, i8* %WD, align 1
  %24 = zext i8 %load_WD to i32
  br label %25

25:                                               ; preds = %23, %continue2
  %26 = phi i32 [ %10, %continue2 ], [ %24, %23 ]
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %condition_body12, label %continue11
}

define i32 @CRC_GEN(%CRC_GEN_interface* %0) {
entry:
  %PT = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 0
  %SIZE = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 1
  %PL = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 2
  %PN = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 3
  %INIT = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 4
  %REV_IN = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 5
  %REV_OUT = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 6
  %XOR_OUT = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 7
  %pos = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 8
  %shift = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 9
  %dx = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 10
  %bits = getelementptr inbounds %CRC_GEN_interface, %CRC_GEN_interface* %0, i32 0, i32 11
  %CRC_GEN = alloca i32, align 4
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %shift, align 2
  store i8 0, i8* %dx, align 1
  store i16 0, i16* %bits, align 2
  store i32 0, i32* %CRC_GEN, align 4
  %load_PL = load i16, i16* %PL, align 2
  %1 = sext i16 %load_PL to i32
  %tmpVar = sub i32 32, %1
  %2 = trunc i32 %tmpVar to i16
  store i16 %2, i16* %shift, align 2
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_PN = load i32, i32* %PN, align 4
  %4 = zext i32 %load_PN to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_shift = load i16, i16* %shift, align 2
  store i16 %load_shift, i16* %5, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %6 = trunc i64 %call1 to i32
  store i32 %6, i32* %PN, align 4
  store i16 0, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %tmpVar4 = icmp sle i16 %load_pos3, 3
  %7 = icmp ne i1 %tmpVar4, false
  br i1 %7, label %14, label %15

for_body:                                         ; preds = %12
  %load_REV_IN = load i8, i8* %REV_IN, align 1
  %8 = icmp ne i8 %load_REV_IN, 0
  br i1 %8, label %condition_body, label %else

increment:                                        ; preds = %continue11
  %tmpVar40 = add i16 %load_pos, 1
  store i16 %tmpVar40, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %12
  store i16 4, i16* %pos, align 2
  %load_CRC_GEN41 = load i32, i32* %CRC_GEN, align 4
  %9 = zext i32 %load_CRC_GEN41 to i64
  %SHL_instance42 = alloca %SHL_interface, align 8
  br label %input43

10:                                               ; preds = %15
  %load_pos7 = load i16, i16* %pos, align 2
  %tmpVar8 = icmp sge i16 %load_pos7, 3
  %11 = icmp ne i1 %tmpVar8, false
  br i1 %11, label %18, label %19

12:                                               ; preds = %19, %15
  %13 = phi i1 [ %16, %15 ], [ %20, %19 ]
  br i1 %13, label %for_body, label %continue2

14:                                               ; preds = %condition_check
  %load_pos5 = load i16, i16* %pos, align 2
  %tmpVar6 = icmp sge i16 %load_pos5, 0
  br label %15

15:                                               ; preds = %14, %condition_check
  %16 = phi i1 [ %tmpVar4, %condition_check ], [ %tmpVar6, %14 ]
  %17 = icmp ne i1 %16, false
  br i1 %17, label %12, label %10

18:                                               ; preds = %10
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 0
  br label %19

19:                                               ; preds = %18, %10
  %20 = phi i1 [ %tmpVar8, %10 ], [ %tmpVar10, %18 ]
  br label %12

condition_body:                                   ; preds = %for_body
  %SHL_instance12 = alloca %SHL_interface, align 8
  br label %input13

else:                                             ; preds = %for_body
  %SHL_instance27 = alloca %SHL_interface, align 8
  br label %input28

continue11:                                       ; preds = %34, %22
  br label %increment

21:                                               ; preds = %continue16
  %REVERSE_instance = alloca %REVERSE_interface, align 8
  br label %input18

22:                                               ; preds = %continue21, %continue16
  %23 = phi i64 [ %call17, %continue16 ], [ %30, %continue21 ]
  store i64 %23, i32* %CRC_GEN, align 4
  br label %continue11

input13:                                          ; preds = %condition_body
  %24 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance12, i32 0, i32 0
  %load_CRC_GEN = load i32, i32* %CRC_GEN, align 4
  %25 = zext i32 %load_CRC_GEN to i64
  store i64 %25, i64* %24, align 4
  %26 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance12, i32 0, i32 1
  store i16 8, i16* %26, align 2
  br label %call14

call14:                                           ; preds = %input13
  %call17 = call i64 @SHL(%SHL_interface* %SHL_instance12)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %27 = icmp ne i64 %call17, 0
  br i1 %27, label %22, label %21

input18:                                          ; preds = %21
  %28 = getelementptr inbounds %REVERSE_interface, %REVERSE_interface* %REVERSE_instance, i32 0, i32 0
  %deref = load [32001 x i8]*, [32001 x i8]** %PT, align 8
  %load_pos22 = load i16, i16* %pos, align 2
  %29 = sext i16 %load_pos22 to i32
  %tmpVar23 = mul i32 1, %29
  %tmpVar24 = add i32 %tmpVar23, 0
  %tmpVar25 = getelementptr inbounds [32001 x i8], [32001 x i8]* %deref, i32 0, i32 %tmpVar24
  %load_tmpVar = load i8, i8* %tmpVar25, align 1
  store i8 %load_tmpVar, i8* %28, align 1
  br label %call19

call19:                                           ; preds = %input18
  %call26 = call i8 @REVERSE(%REVERSE_interface* %REVERSE_instance)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %30 = zext i8 %call26 to i64
  br label %22

31:                                               ; preds = %continue31
  %deref34 = load [32001 x i8]*, [32001 x i8]** %PT, align 8
  %load_pos35 = load i16, i16* %pos, align 2
  %32 = sext i16 %load_pos35 to i32
  %tmpVar36 = mul i32 1, %32
  %tmpVar37 = add i32 %tmpVar36, 0
  %tmpVar38 = getelementptr inbounds [32001 x i8], [32001 x i8]* %deref34, i32 0, i32 %tmpVar37
  %load_tmpVar39 = load i8, i8* %tmpVar38, align 1
  %33 = zext i8 %load_tmpVar39 to i64
  br label %34

34:                                               ; preds = %31, %continue31
  %35 = phi i64 [ %call33, %continue31 ], [ %33, %31 ]
  store i64 %35, i32* %CRC_GEN, align 4
  br label %continue11

input28:                                          ; preds = %else
  %36 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance27, i32 0, i32 0
  %load_CRC_GEN32 = load i32, i32* %CRC_GEN, align 4
  %37 = zext i32 %load_CRC_GEN32 to i64
  store i64 %37, i64* %36, align 4
  %38 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance27, i32 0, i32 1
  store i16 8, i16* %38, align 2
  br label %call29

call29:                                           ; preds = %input28
  %call33 = call i64 @SHL(%SHL_interface* %SHL_instance27)
  br label %output30

output30:                                         ; preds = %call29
  br label %continue31

continue31:                                       ; preds = %output30
  %39 = icmp ne i64 %call33, 0
  br i1 %39, label %34, label %31

input43:                                          ; preds = %continue2
  %40 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance42, i32 0, i32 0
  %load_init = load i32, i32* %INIT, align 4
  %41 = zext i32 %load_init to i64
  store i64 %41, i64* %40, align 4
  %42 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance42, i32 0, i32 1
  %load_shift47 = load i16, i16* %shift, align 2
  store i16 %load_shift47, i16* %42, align 2
  br label %call44

call44:                                           ; preds = %input43
  %call48 = call i64 @SHL(%SHL_interface* %SHL_instance42)
  br label %output45

output45:                                         ; preds = %call44
  br label %continue46

continue46:                                       ; preds = %output45
  %tmpVar49 = xor i64 %9, %call48
  store i64 %tmpVar49, i32* %CRC_GEN, align 4
  br label %condition_check50

condition_check50:                                ; preds = %continue46, %continue81
  %load_pos52 = load i16, i16* %pos, align 2
  %43 = sext i16 %load_pos52 to i32
  %load_size = load i16, i16* %SIZE, align 2
  %44 = sext i16 %load_size to i32
  %tmpVar53 = icmp slt i32 %43, %44
  br i1 %tmpVar53, label %while_body, label %continue51

while_body:                                       ; preds = %condition_check50
  %load_REV_IN57 = load i8, i8* %REV_IN, align 1
  %45 = icmp ne i8 %load_REV_IN57, 0
  br i1 %45, label %condition_body56, label %else54

continue51:                                       ; preds = %condition_check50
  store i16 0, i16* %bits, align 2
  br label %condition_check132

condition_body56:                                 ; preds = %while_body
  %REVERSE_instance58 = alloca %REVERSE_interface, align 8
  br label %input59

else54:                                           ; preds = %while_body
  %deref70 = load [32001 x i8]*, [32001 x i8]** %PT, align 8
  %load_pos71 = load i16, i16* %pos, align 2
  %46 = sext i16 %load_pos71 to i32
  %tmpVar72 = mul i32 1, %46
  %tmpVar73 = add i32 %tmpVar72, 0
  %tmpVar74 = getelementptr inbounds [32001 x i8], [32001 x i8]* %deref70, i32 0, i32 %tmpVar73
  %load_tmpVar75 = load i8, i8* %tmpVar74, align 1
  store i8 %load_tmpVar75, i8* %dx, align 1
  br label %continue55

continue55:                                       ; preds = %else54, %continue62
  %load_pos76 = load i16, i16* %pos, align 2
  %47 = sext i16 %load_pos76 to i32
  %tmpVar77 = add i32 %47, 1
  %48 = trunc i32 %tmpVar77 to i16
  store i16 %48, i16* %pos, align 2
  store i16 0, i16* %bits, align 2
  br label %condition_check78

input59:                                          ; preds = %condition_body56
  %49 = getelementptr inbounds %REVERSE_interface, %REVERSE_interface* %REVERSE_instance58, i32 0, i32 0
  %deref63 = load [32001 x i8]*, [32001 x i8]** %PT, align 8
  %load_pos64 = load i16, i16* %pos, align 2
  %50 = sext i16 %load_pos64 to i32
  %tmpVar65 = mul i32 1, %50
  %tmpVar66 = add i32 %tmpVar65, 0
  %tmpVar67 = getelementptr inbounds [32001 x i8], [32001 x i8]* %deref63, i32 0, i32 %tmpVar66
  %load_tmpVar68 = load i8, i8* %tmpVar67, align 1
  store i8 %load_tmpVar68, i8* %49, align 1
  br label %call60

call60:                                           ; preds = %input59
  %call69 = call i8 @REVERSE(%REVERSE_interface* %REVERSE_instance58)
  br label %output61

output61:                                         ; preds = %call60
  br label %continue62

continue62:                                       ; preds = %output61
  store i8 %call69, i8* %dx, align 1
  br label %continue55

condition_check78:                                ; preds = %increment80, %continue55
  %load_bits = load i16, i16* %bits, align 2
  %load_bits82 = load i16, i16* %bits, align 2
  %tmpVar83 = icmp sle i16 %load_bits82, 7
  %51 = icmp ne i1 %tmpVar83, false
  br i1 %51, label %58, label %59

for_body79:                                       ; preds = %56
  %load_CRC_GEN93 = load i32, i32* %CRC_GEN, align 4
  %shift94 = lshr i32 %load_CRC_GEN93, 31
  %52 = trunc i32 %shift94 to i8
  %53 = icmp ne i8 %52, 0
  br i1 %53, label %condition_body92, label %else90

increment80:                                      ; preds = %continue129
  %tmpVar131 = add i16 %load_bits, 1
  store i16 %tmpVar131, i16* %bits, align 2
  br label %condition_check78

continue81:                                       ; preds = %56
  br label %condition_check50

54:                                               ; preds = %59
  %load_bits86 = load i16, i16* %bits, align 2
  %tmpVar87 = icmp sge i16 %load_bits86, 7
  %55 = icmp ne i1 %tmpVar87, false
  br i1 %55, label %62, label %63

56:                                               ; preds = %63, %59
  %57 = phi i1 [ %60, %59 ], [ %64, %63 ]
  br i1 %57, label %for_body79, label %continue81

58:                                               ; preds = %condition_check78
  %load_bits84 = load i16, i16* %bits, align 2
  %tmpVar85 = icmp sge i16 %load_bits84, 0
  br label %59

59:                                               ; preds = %58, %condition_check78
  %60 = phi i1 [ %tmpVar83, %condition_check78 ], [ %tmpVar85, %58 ]
  %61 = icmp ne i1 %60, false
  br i1 %61, label %56, label %54

62:                                               ; preds = %54
  %load_bits88 = load i16, i16* %bits, align 2
  %tmpVar89 = icmp sle i16 %load_bits88, 0
  br label %63

63:                                               ; preds = %62, %54
  %64 = phi i1 [ %tmpVar87, %54 ], [ %tmpVar89, %62 ]
  br label %56

condition_body92:                                 ; preds = %for_body79
  %SHL_instance95 = alloca %SHL_interface, align 8
  br label %input96

else90:                                           ; preds = %for_body79
  %SHL_instance110 = alloca %SHL_interface, align 8
  br label %input111

continue91:                                       ; preds = %75, %66
  %SHL_instance125 = alloca %SHL_interface, align 8
  br label %input126

65:                                               ; preds = %continue99
  %BOOL_TO_DWORD_instance = alloca %BOOL_TO_DWORD_interface, align 8
  br label %input102

66:                                               ; preds = %continue105, %continue99
  %67 = phi i64 [ %call101, %continue99 ], [ %73, %continue105 ]
  %load_PN108 = load i32, i32* %PN, align 4
  %tmpVar109 = xor i64 %67, i32 %load_PN108
  store i64 %tmpVar109, i32* %CRC_GEN, align 4
  br label %continue91

input96:                                          ; preds = %condition_body92
  %68 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance95, i32 0, i32 0
  %load_CRC_GEN100 = load i32, i32* %CRC_GEN, align 4
  %69 = zext i32 %load_CRC_GEN100 to i64
  store i64 %69, i64* %68, align 4
  %70 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance95, i32 0, i32 1
  store i16 1, i16* %70, align 2
  br label %call97

call97:                                           ; preds = %input96
  %call101 = call i64 @SHL(%SHL_interface* %SHL_instance95)
  br label %output98

output98:                                         ; preds = %call97
  br label %continue99

continue99:                                       ; preds = %output98
  %71 = icmp ne i64 %call101, 0
  br i1 %71, label %66, label %65

input102:                                         ; preds = %65
  %72 = getelementptr inbounds %BOOL_TO_DWORD_interface, %BOOL_TO_DWORD_interface* %BOOL_TO_DWORD_instance, i32 0, i32 0
  %load_DX = load i8, i8* %dx, align 1
  %shift106 = lshr i8 %load_DX, 7
  store i8 %shift106, i8* %72, align 1
  br label %call103

call103:                                          ; preds = %input102
  %call107 = call i32 @BOOL_TO_DWORD(%BOOL_TO_DWORD_interface* %BOOL_TO_DWORD_instance)
  br label %output104

output104:                                        ; preds = %call103
  br label %continue105

continue105:                                      ; preds = %output104
  %73 = zext i32 %call107 to i64
  br label %66

74:                                               ; preds = %continue114
  %BOOL_TO_DWORD_instance117 = alloca %BOOL_TO_DWORD_interface, align 8
  br label %input118

75:                                               ; preds = %continue121, %continue114
  %76 = phi i64 [ %call116, %continue114 ], [ %82, %continue121 ]
  store i64 %76, i32* %CRC_GEN, align 4
  br label %continue91

input111:                                         ; preds = %else90
  %77 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance110, i32 0, i32 0
  %load_CRC_GEN115 = load i32, i32* %CRC_GEN, align 4
  %78 = zext i32 %load_CRC_GEN115 to i64
  store i64 %78, i64* %77, align 4
  %79 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance110, i32 0, i32 1
  store i16 1, i16* %79, align 2
  br label %call112

call112:                                          ; preds = %input111
  %call116 = call i64 @SHL(%SHL_interface* %SHL_instance110)
  br label %output113

output113:                                        ; preds = %call112
  br label %continue114

continue114:                                      ; preds = %output113
  %80 = icmp ne i64 %call116, 0
  br i1 %80, label %75, label %74

input118:                                         ; preds = %74
  %81 = getelementptr inbounds %BOOL_TO_DWORD_interface, %BOOL_TO_DWORD_interface* %BOOL_TO_DWORD_instance117, i32 0, i32 0
  %load_DX122 = load i8, i8* %dx, align 1
  %shift123 = lshr i8 %load_DX122, 7
  store i8 %shift123, i8* %81, align 1
  br label %call119

call119:                                          ; preds = %input118
  %call124 = call i32 @BOOL_TO_DWORD(%BOOL_TO_DWORD_interface* %BOOL_TO_DWORD_instance117)
  br label %output120

output120:                                        ; preds = %call119
  br label %continue121

continue121:                                      ; preds = %output120
  %82 = zext i32 %call124 to i64
  br label %75

input126:                                         ; preds = %continue91
  %83 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance125, i32 0, i32 0
  %load_dx = load i8, i8* %dx, align 1
  %84 = zext i8 %load_dx to i64
  store i64 %84, i64* %83, align 4
  %85 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance125, i32 0, i32 1
  store i16 1, i16* %85, align 2
  br label %call127

call127:                                          ; preds = %input126
  %call130 = call i64 @SHL(%SHL_interface* %SHL_instance125)
  br label %output128

output128:                                        ; preds = %call127
  br label %continue129

continue129:                                      ; preds = %output128
  %86 = trunc i64 %call130 to i8
  store i8 %86, i8* %dx, align 1
  br label %increment80

condition_check132:                               ; preds = %increment134, %continue51
  %load_bits136 = load i16, i16* %bits, align 2
  %load_bits137 = load i16, i16* %bits, align 2
  %tmpVar138 = icmp sle i16 %load_bits137, 31
  %87 = icmp ne i1 %tmpVar138, false
  br i1 %87, label %94, label %95

for_body133:                                      ; preds = %92
  %load_CRC_GEN148 = load i32, i32* %CRC_GEN, align 4
  %shift149 = lshr i32 %load_CRC_GEN148, 31
  %88 = trunc i32 %shift149 to i8
  %89 = icmp ne i8 %88, 0
  br i1 %89, label %condition_body147, label %else145

increment134:                                     ; preds = %continue146
  %tmpVar182 = add i16 %load_bits136, 1
  store i16 %tmpVar182, i16* %bits, align 2
  br label %condition_check132

continue135:                                      ; preds = %92
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input183

90:                                               ; preds = %95
  %load_bits141 = load i16, i16* %bits, align 2
  %tmpVar142 = icmp sge i16 %load_bits141, 31
  %91 = icmp ne i1 %tmpVar142, false
  br i1 %91, label %98, label %99

92:                                               ; preds = %99, %95
  %93 = phi i1 [ %96, %95 ], [ %100, %99 ]
  br i1 %93, label %for_body133, label %continue135

94:                                               ; preds = %condition_check132
  %load_bits139 = load i16, i16* %bits, align 2
  %tmpVar140 = icmp sge i16 %load_bits139, 0
  br label %95

95:                                               ; preds = %94, %condition_check132
  %96 = phi i1 [ %tmpVar138, %condition_check132 ], [ %tmpVar140, %94 ]
  %97 = icmp ne i1 %96, false
  br i1 %97, label %92, label %90

98:                                               ; preds = %90
  %load_bits143 = load i16, i16* %bits, align 2
  %tmpVar144 = icmp sle i16 %load_bits143, 0
  br label %99

99:                                               ; preds = %98, %90
  %100 = phi i1 [ %tmpVar142, %90 ], [ %tmpVar144, %98 ]
  br label %92

condition_body147:                                ; preds = %for_body133
  %SHL_instance150 = alloca %SHL_interface, align 8
  br label %input151

else145:                                          ; preds = %for_body133
  %SHL_instance167 = alloca %SHL_interface, align 8
  br label %input168

continue146:                                      ; preds = %111, %102
  br label %increment134

101:                                              ; preds = %continue154
  %BOOL_TO_DWORD_instance157 = alloca %BOOL_TO_DWORD_interface, align 8
  br label %input158

102:                                              ; preds = %continue161, %continue154
  %103 = phi i64 [ %call156, %continue154 ], [ %109, %continue161 ]
  %load_PN165 = load i32, i32* %PN, align 4
  %tmpVar166 = xor i64 %103, i32 %load_PN165
  store i64 %tmpVar166, i32* %CRC_GEN, align 4
  br label %continue146

input151:                                         ; preds = %condition_body147
  %104 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance150, i32 0, i32 0
  %load_CRC_GEN155 = load i32, i32* %CRC_GEN, align 4
  %105 = zext i32 %load_CRC_GEN155 to i64
  store i64 %105, i64* %104, align 4
  %106 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance150, i32 0, i32 1
  store i16 1, i16* %106, align 2
  br label %call152

call152:                                          ; preds = %input151
  %call156 = call i64 @SHL(%SHL_interface* %SHL_instance150)
  br label %output153

output153:                                        ; preds = %call152
  br label %continue154

continue154:                                      ; preds = %output153
  %107 = icmp ne i64 %call156, 0
  br i1 %107, label %102, label %101

input158:                                         ; preds = %101
  %108 = getelementptr inbounds %BOOL_TO_DWORD_interface, %BOOL_TO_DWORD_interface* %BOOL_TO_DWORD_instance157, i32 0, i32 0
  %load_DX162 = load i8, i8* %dx, align 1
  %shift163 = lshr i8 %load_DX162, 7
  store i8 %shift163, i8* %108, align 1
  br label %call159

call159:                                          ; preds = %input158
  %call164 = call i32 @BOOL_TO_DWORD(%BOOL_TO_DWORD_interface* %BOOL_TO_DWORD_instance157)
  br label %output160

output160:                                        ; preds = %call159
  br label %continue161

continue161:                                      ; preds = %output160
  %109 = zext i32 %call164 to i64
  br label %102

110:                                              ; preds = %continue171
  %BOOL_TO_DWORD_instance174 = alloca %BOOL_TO_DWORD_interface, align 8
  br label %input175

111:                                              ; preds = %continue178, %continue171
  %112 = phi i64 [ %call173, %continue171 ], [ %118, %continue178 ]
  store i64 %112, i32* %CRC_GEN, align 4
  br label %continue146

input168:                                         ; preds = %else145
  %113 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance167, i32 0, i32 0
  %load_CRC_GEN172 = load i32, i32* %CRC_GEN, align 4
  %114 = zext i32 %load_CRC_GEN172 to i64
  store i64 %114, i64* %113, align 4
  %115 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance167, i32 0, i32 1
  store i16 1, i16* %115, align 2
  br label %call169

call169:                                          ; preds = %input168
  %call173 = call i64 @SHL(%SHL_interface* %SHL_instance167)
  br label %output170

output170:                                        ; preds = %call169
  br label %continue171

continue171:                                      ; preds = %output170
  %116 = icmp ne i64 %call173, 0
  br i1 %116, label %111, label %110

input175:                                         ; preds = %110
  %117 = getelementptr inbounds %BOOL_TO_DWORD_interface, %BOOL_TO_DWORD_interface* %BOOL_TO_DWORD_instance174, i32 0, i32 0
  %load_DX179 = load i8, i8* %dx, align 1
  %shift180 = lshr i8 %load_DX179, 7
  store i8 %shift180, i8* %117, align 1
  br label %call176

call176:                                          ; preds = %input175
  %call181 = call i32 @BOOL_TO_DWORD(%BOOL_TO_DWORD_interface* %BOOL_TO_DWORD_instance174)
  br label %output177

output177:                                        ; preds = %call176
  br label %continue178

continue178:                                      ; preds = %output177
  %118 = zext i32 %call181 to i64
  br label %111

input183:                                         ; preds = %continue135
  %119 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_CRC_GEN187 = load i32, i32* %CRC_GEN, align 4
  %120 = zext i32 %load_CRC_GEN187 to i64
  store i64 %120, i64* %119, align 4
  %121 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %load_shift188 = load i16, i16* %shift, align 2
  store i16 %load_shift188, i16* %121, align 2
  br label %call184

call184:                                          ; preds = %input183
  %call189 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output185

output185:                                        ; preds = %call184
  br label %continue186

continue186:                                      ; preds = %output185
  %load_XOR_OUT = load i32, i32* %XOR_OUT, align 4
  %122 = zext i32 %load_XOR_OUT to i64
  %tmpVar190 = xor i64 %call189, %122
  store i64 %tmpVar190, i32* %CRC_GEN, align 4
  %load_REV_OUT = load i8, i8* %REV_OUT, align 1
  %123 = icmp ne i8 %load_REV_OUT, 0
  br i1 %123, label %condition_body192, label %continue191

condition_body192:                                ; preds = %continue186
  %REFLECT_instance = alloca %REFLECT_interface, align 8
  br label %input193

continue191:                                      ; preds = %continue196, %continue186
  %CRC_GEN_ret = load i32, i32* %CRC_GEN, align 4
  ret i32 %CRC_GEN_ret

input193:                                         ; preds = %condition_body192
  %124 = getelementptr inbounds %REFLECT_interface, %REFLECT_interface* %REFLECT_instance, i32 0, i32 0
  %load_CRC_GEN197 = load i32, i32* %CRC_GEN, align 4
  store i32 %load_CRC_GEN197, i32* %124, align 4
  %125 = getelementptr inbounds %REFLECT_interface, %REFLECT_interface* %REFLECT_instance, i32 0, i32 1
  %load_PL198 = load i16, i16* %PL, align 2
  store i16 %load_PL198, i16* %125, align 2
  br label %call194

call194:                                          ; preds = %input193
  %call199 = call i32 @REFLECT(%REFLECT_interface* %REFLECT_instance)
  br label %output195

output195:                                        ; preds = %call194
  br label %continue196

continue196:                                      ; preds = %output195
  store i32 %call199, i32* %CRC_GEN, align 4
  br label %continue191
}

define void @MATRIX(%MATRIX_interface* %0) {
entry:
  %x1 = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 0
  %x2 = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 1
  %x3 = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 2
  %x4 = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 3
  %X5 = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 4
  %Release = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 5
  %code = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 6
  %TP = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 7
  %y1 = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 8
  %y2 = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 9
  %y3 = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 10
  %y4 = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 11
  %line = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 12
  %X = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 13
  %L = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 14
  %i = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 15
  %temp = getelementptr inbounds %MATRIX_interface, %MATRIX_interface* %0, i32 0, i32 16
  store i8 0, i8* %TP, align 1
  store i8 0, i8* %code, align 1
  %load_line = load i8, i8* %line, align 1
  %1 = zext i8 %load_line to i32
  %tmpVar = mul i32 1, %1
  %tmpVar1 = add i32 %tmpVar, 0
  %tmpVar2 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar1
  %2 = load i8, i8* %tmpVar2, align 1
  %erase = and i8 %2, -2
  %load_X1 = load i8, i8* %x1, align 1
  %value = shl i8 %load_X1, 0
  %or = or i8 %erase, %value
  store i8 %or, i8* %tmpVar2, align 1
  %load_line3 = load i8, i8* %line, align 1
  %3 = zext i8 %load_line3 to i32
  %tmpVar4 = mul i32 1, %3
  %tmpVar5 = add i32 %tmpVar4, 0
  %tmpVar6 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar5
  %4 = load i8, i8* %tmpVar6, align 1
  %erase7 = and i8 %4, -3
  %load_X2 = load i8, i8* %x2, align 1
  %value8 = shl i8 %load_X2, 1
  %or9 = or i8 %erase7, %value8
  store i8 %or9, i8* %tmpVar6, align 1
  %load_line10 = load i8, i8* %line, align 1
  %5 = zext i8 %load_line10 to i32
  %tmpVar11 = mul i32 1, %5
  %tmpVar12 = add i32 %tmpVar11, 0
  %tmpVar13 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar12
  %6 = load i8, i8* %tmpVar13, align 1
  %erase14 = and i8 %6, -5
  %load_X3 = load i8, i8* %x3, align 1
  %value15 = shl i8 %load_X3, 2
  %or16 = or i8 %erase14, %value15
  store i8 %or16, i8* %tmpVar13, align 1
  %load_line17 = load i8, i8* %line, align 1
  %7 = zext i8 %load_line17 to i32
  %tmpVar18 = mul i32 1, %7
  %tmpVar19 = add i32 %tmpVar18, 0
  %tmpVar20 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar19
  %8 = load i8, i8* %tmpVar20, align 1
  %erase21 = and i8 %8, -9
  %load_X4 = load i8, i8* %x4, align 1
  %value22 = shl i8 %load_X4, 3
  %or23 = or i8 %erase21, %value22
  store i8 %or23, i8* %tmpVar20, align 1
  %load_line24 = load i8, i8* %line, align 1
  %9 = zext i8 %load_line24 to i32
  %tmpVar25 = mul i32 1, %9
  %tmpVar26 = add i32 %tmpVar25, 0
  %tmpVar27 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar26
  %10 = load i8, i8* %tmpVar27, align 1
  %erase28 = and i8 %10, -17
  %load_X5 = load i8, i8* %X5, align 1
  %value29 = shl i8 %load_X5, 4
  %or30 = or i8 %erase28, %value29
  store i8 %or30, i8* %tmpVar27, align 1
  store i16 0, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %entry
  %load_i = load i16, i16* %i, align 2
  %load_i31 = load i16, i16* %i, align 2
  %tmpVar32 = icmp sle i16 %load_i31, 3
  %11 = icmp ne i1 %tmpVar32, false
  br i1 %11, label %22, label %23

for_body:                                         ; preds = %20
  %load_i40 = load i16, i16* %i, align 2
  %12 = sext i16 %load_i40 to i32
  %tmpVar41 = mul i32 1, %12
  %tmpVar42 = add i32 %tmpVar41, 0
  %tmpVar43 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar42
  %load_tmpVar = load i8, i8* %tmpVar43, align 1
  %13 = zext i8 %load_tmpVar to i32
  %load_i44 = load i16, i16* %i, align 2
  %14 = sext i16 %load_i44 to i32
  %tmpVar45 = mul i32 1, %14
  %tmpVar46 = add i32 %tmpVar45, 0
  %tmpVar47 = getelementptr inbounds [4 x i8], [4 x i8]* %L, i32 0, i32 %tmpVar46
  %load_tmpVar48 = load i8, i8* %tmpVar47, align 1
  %15 = zext i8 %load_tmpVar48 to i32
  %tmpVar49 = icmp ne i32 %13, %15
  br i1 %tmpVar49, label %condition_body, label %continue39

increment:                                        ; preds = %continue39
  %tmpVar206 = add i16 %load_i, 1
  store i16 %tmpVar206, i16* %i, align 2
  br label %condition_check

continue:                                         ; preds = %continue202, %20
  %load_line207 = load i8, i8* %line, align 1
  %16 = zext i8 %load_line207 to i32
  %tmpVar208 = add i32 %16, 1
  %17 = icmp ne i32 %tmpVar208, 0
  br i1 %17, label %74, label %75

18:                                               ; preds = %23
  %load_i35 = load i16, i16* %i, align 2
  %tmpVar36 = icmp sge i16 %load_i35, 3
  %19 = icmp ne i1 %tmpVar36, false
  br i1 %19, label %26, label %27

20:                                               ; preds = %27, %23
  %21 = phi i1 [ %24, %23 ], [ %28, %27 ]
  br i1 %21, label %for_body, label %continue

22:                                               ; preds = %condition_check
  %load_i33 = load i16, i16* %i, align 2
  %tmpVar34 = icmp sge i16 %load_i33, 0
  br label %23

23:                                               ; preds = %22, %condition_check
  %24 = phi i1 [ %tmpVar32, %condition_check ], [ %tmpVar34, %22 ]
  %25 = icmp ne i1 %24, false
  br i1 %25, label %20, label %18

26:                                               ; preds = %18
  %load_i37 = load i16, i16* %i, align 2
  %tmpVar38 = icmp sle i16 %load_i37, 0
  br label %27

27:                                               ; preds = %26, %18
  %28 = phi i1 [ %tmpVar36, %18 ], [ %tmpVar38, %26 ]
  br label %20

condition_body:                                   ; preds = %for_body
  %load_i50 = load i16, i16* %i, align 2
  %29 = sext i16 %load_i50 to i32
  %tmpVar51 = mul i32 1, %29
  %tmpVar52 = add i32 %tmpVar51, 0
  %tmpVar53 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar52
  %load_tmpVar54 = load i8, i8* %tmpVar53, align 1
  %30 = zext i8 %load_tmpVar54 to i32
  %load_i55 = load i16, i16* %i, align 2
  %31 = sext i16 %load_i55 to i32
  %tmpVar56 = mul i32 1, %31
  %tmpVar57 = add i32 %tmpVar56, 0
  %tmpVar58 = getelementptr inbounds [4 x i8], [4 x i8]* %L, i32 0, i32 %tmpVar57
  %load_tmpVar59 = load i8, i8* %tmpVar58, align 1
  %32 = zext i8 %load_tmpVar59 to i32
  %tmpVar60 = xor i32 %30, %32
  store i32 %tmpVar60, i8* %temp, align 4
  %load_temp = load i8, i8* %temp, align 1
  %shift = lshr i8 %load_temp, 0
  %33 = icmp ne i8 %shift, 0
  br i1 %33, label %condition_body65, label %branch

continue39:                                       ; preds = %buffer_block, %for_body
  br label %increment

condition_body65:                                 ; preds = %condition_body
  store i8 1, i8* %code, align 1
  %34 = load i8, i8* %code, align 1
  %erase66 = and i8 %34, 127
  %load_i67 = load i16, i16* %i, align 2
  %35 = sext i16 %load_i67 to i32
  %tmpVar68 = mul i32 1, %35
  %tmpVar69 = add i32 %tmpVar68, 0
  %tmpVar70 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar69
  %load_tmpVar71 = load i8, i8* %tmpVar70, align 1
  %shift72 = lshr i8 %load_tmpVar71, 0
  %value73 = shl i8 %shift72, 7
  %or74 = or i8 %erase66, %value73
  store i8 %or74, i8* %code, align 1
  %load_i75 = load i16, i16* %i, align 2
  %36 = sext i16 %load_i75 to i32
  %tmpVar76 = mul i32 1, %36
  %tmpVar77 = add i32 %tmpVar76, 0
  %tmpVar78 = getelementptr inbounds [4 x i8], [4 x i8]* %L, i32 0, i32 %tmpVar77
  %37 = load i8, i8* %tmpVar78, align 1
  %erase79 = and i8 %37, -2
  %load_i80 = load i16, i16* %i, align 2
  %38 = sext i16 %load_i80 to i32
  %tmpVar81 = mul i32 1, %38
  %tmpVar82 = add i32 %tmpVar81, 0
  %tmpVar83 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar82
  %load_tmpVar84 = load i8, i8* %tmpVar83, align 1
  %shift85 = lshr i8 %load_tmpVar84, 0
  %value86 = shl i8 %shift85, 0
  %or87 = or i8 %erase79, %value86
  store i8 %or87, i8* %tmpVar78, align 1
  br label %continue64

branch:                                           ; preds = %condition_body
  %load_temp89 = load i8, i8* %temp, align 1
  %shift90 = lshr i8 %load_temp89, 1
  %39 = icmp ne i8 %shift90, 0
  br i1 %39, label %condition_body88, label %branch61

condition_body88:                                 ; preds = %branch
  store i8 2, i8* %code, align 1
  %40 = load i8, i8* %code, align 1
  %erase91 = and i8 %40, 127
  %load_i92 = load i16, i16* %i, align 2
  %41 = sext i16 %load_i92 to i32
  %tmpVar93 = mul i32 1, %41
  %tmpVar94 = add i32 %tmpVar93, 0
  %tmpVar95 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar94
  %load_tmpVar96 = load i8, i8* %tmpVar95, align 1
  %shift97 = lshr i8 %load_tmpVar96, 1
  %value98 = shl i8 %shift97, 7
  %or99 = or i8 %erase91, %value98
  store i8 %or99, i8* %code, align 1
  %load_i100 = load i16, i16* %i, align 2
  %42 = sext i16 %load_i100 to i32
  %tmpVar101 = mul i32 1, %42
  %tmpVar102 = add i32 %tmpVar101, 0
  %tmpVar103 = getelementptr inbounds [4 x i8], [4 x i8]* %L, i32 0, i32 %tmpVar102
  %43 = load i8, i8* %tmpVar103, align 1
  %erase104 = and i8 %43, -3
  %load_i105 = load i16, i16* %i, align 2
  %44 = sext i16 %load_i105 to i32
  %tmpVar106 = mul i32 1, %44
  %tmpVar107 = add i32 %tmpVar106, 0
  %tmpVar108 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar107
  %load_tmpVar109 = load i8, i8* %tmpVar108, align 1
  %shift110 = lshr i8 %load_tmpVar109, 1
  %value111 = shl i8 %shift110, 1
  %or112 = or i8 %erase104, %value111
  store i8 %or112, i8* %tmpVar103, align 1
  br label %continue64

branch61:                                         ; preds = %branch
  %load_temp114 = load i8, i8* %temp, align 1
  %shift115 = lshr i8 %load_temp114, 2
  %45 = icmp ne i8 %shift115, 0
  br i1 %45, label %condition_body113, label %branch62

condition_body113:                                ; preds = %branch61
  store i8 3, i8* %code, align 1
  %46 = load i8, i8* %code, align 1
  %erase116 = and i8 %46, 127
  %load_i117 = load i16, i16* %i, align 2
  %47 = sext i16 %load_i117 to i32
  %tmpVar118 = mul i32 1, %47
  %tmpVar119 = add i32 %tmpVar118, 0
  %tmpVar120 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar119
  %load_tmpVar121 = load i8, i8* %tmpVar120, align 1
  %shift122 = lshr i8 %load_tmpVar121, 2
  %value123 = shl i8 %shift122, 7
  %or124 = or i8 %erase116, %value123
  store i8 %or124, i8* %code, align 1
  %load_i125 = load i16, i16* %i, align 2
  %48 = sext i16 %load_i125 to i32
  %tmpVar126 = mul i32 1, %48
  %tmpVar127 = add i32 %tmpVar126, 0
  %tmpVar128 = getelementptr inbounds [4 x i8], [4 x i8]* %L, i32 0, i32 %tmpVar127
  %49 = load i8, i8* %tmpVar128, align 1
  %erase129 = and i8 %49, -5
  %load_i130 = load i16, i16* %i, align 2
  %50 = sext i16 %load_i130 to i32
  %tmpVar131 = mul i32 1, %50
  %tmpVar132 = add i32 %tmpVar131, 0
  %tmpVar133 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar132
  %load_tmpVar134 = load i8, i8* %tmpVar133, align 1
  %shift135 = lshr i8 %load_tmpVar134, 2
  %value136 = shl i8 %shift135, 2
  %or137 = or i8 %erase129, %value136
  store i8 %or137, i8* %tmpVar128, align 1
  br label %continue64

branch62:                                         ; preds = %branch61
  %load_temp139 = load i8, i8* %temp, align 1
  %shift140 = lshr i8 %load_temp139, 3
  %51 = icmp ne i8 %shift140, 0
  br i1 %51, label %condition_body138, label %branch63

condition_body138:                                ; preds = %branch62
  store i8 4, i8* %code, align 1
  %52 = load i8, i8* %code, align 1
  %erase141 = and i8 %52, 127
  %load_i142 = load i16, i16* %i, align 2
  %53 = sext i16 %load_i142 to i32
  %tmpVar143 = mul i32 1, %53
  %tmpVar144 = add i32 %tmpVar143, 0
  %tmpVar145 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar144
  %load_tmpVar146 = load i8, i8* %tmpVar145, align 1
  %shift147 = lshr i8 %load_tmpVar146, 3
  %value148 = shl i8 %shift147, 7
  %or149 = or i8 %erase141, %value148
  store i8 %or149, i8* %code, align 1
  %load_i150 = load i16, i16* %i, align 2
  %54 = sext i16 %load_i150 to i32
  %tmpVar151 = mul i32 1, %54
  %tmpVar152 = add i32 %tmpVar151, 0
  %tmpVar153 = getelementptr inbounds [4 x i8], [4 x i8]* %L, i32 0, i32 %tmpVar152
  %55 = load i8, i8* %tmpVar153, align 1
  %erase154 = and i8 %55, -9
  %load_i155 = load i16, i16* %i, align 2
  %56 = sext i16 %load_i155 to i32
  %tmpVar156 = mul i32 1, %56
  %tmpVar157 = add i32 %tmpVar156, 0
  %tmpVar158 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar157
  %load_tmpVar159 = load i8, i8* %tmpVar158, align 1
  %shift160 = lshr i8 %load_tmpVar159, 3
  %value161 = shl i8 %shift160, 3
  %or162 = or i8 %erase154, %value161
  store i8 %or162, i8* %tmpVar153, align 1
  br label %continue64

branch63:                                         ; preds = %branch62
  %load_temp164 = load i8, i8* %temp, align 1
  %shift165 = lshr i8 %load_temp164, 4
  %57 = icmp ne i8 %shift165, 0
  br i1 %57, label %condition_body163, label %continue64

condition_body163:                                ; preds = %branch63
  store i8 5, i8* %code, align 1
  %58 = load i8, i8* %code, align 1
  %erase166 = and i8 %58, 127
  %load_i167 = load i16, i16* %i, align 2
  %59 = sext i16 %load_i167 to i32
  %tmpVar168 = mul i32 1, %59
  %tmpVar169 = add i32 %tmpVar168, 0
  %tmpVar170 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar169
  %load_tmpVar171 = load i8, i8* %tmpVar170, align 1
  %shift172 = lshr i8 %load_tmpVar171, 4
  %value173 = shl i8 %shift172, 7
  %or174 = or i8 %erase166, %value173
  store i8 %or174, i8* %code, align 1
  %load_i175 = load i16, i16* %i, align 2
  %60 = sext i16 %load_i175 to i32
  %tmpVar176 = mul i32 1, %60
  %tmpVar177 = add i32 %tmpVar176, 0
  %tmpVar178 = getelementptr inbounds [4 x i8], [4 x i8]* %L, i32 0, i32 %tmpVar177
  %61 = load i8, i8* %tmpVar178, align 1
  %erase179 = and i8 %61, -17
  %load_i180 = load i16, i16* %i, align 2
  %62 = sext i16 %load_i180 to i32
  %tmpVar181 = mul i32 1, %62
  %tmpVar182 = add i32 %tmpVar181, 0
  %tmpVar183 = getelementptr inbounds [4 x i8], [4 x i8]* %X, i32 0, i32 %tmpVar182
  %load_tmpVar184 = load i8, i8* %tmpVar183, align 1
  %shift185 = lshr i8 %load_tmpVar184, 4
  %value186 = shl i8 %shift185, 4
  %or187 = or i8 %erase179, %value186
  store i8 %or187, i8* %tmpVar178, align 1
  br label %continue64

continue64:                                       ; preds = %condition_body163, %branch63, %condition_body138, %condition_body113, %condition_body88, %condition_body65
  store i8 1, i8* %TP, align 1
  %63 = load i8, i8* %code, align 1
  %erase188 = and i8 %63, -17
  %load_Line = load i8, i8* %line, align 1
  %shift189 = lshr i8 %load_Line, 0
  %value190 = shl i8 %shift189, 4
  %or191 = or i8 %erase188, %value190
  store i8 %or191, i8* %code, align 1
  %64 = load i8, i8* %code, align 1
  %erase192 = and i8 %64, -33
  %load_Line193 = load i8, i8* %line, align 1
  %shift194 = lshr i8 %load_Line193, 1
  %value195 = shl i8 %shift194, 5
  %or196 = or i8 %erase192, %value195
  store i8 %or196, i8* %code, align 1
  %65 = load i8, i8* %code, align 1
  %erase197 = and i8 %65, -65
  %load_Line198 = load i8, i8* %line, align 1
  %shift199 = lshr i8 %load_Line198, 2
  %value200 = shl i8 %shift199, 6
  %or201 = or i8 %erase197, %value200
  store i8 %or201, i8* %code, align 1
  %load_release = load i8, i8* %Release, align 1
  %tmpVar204 = xor i8 %load_release, -1
  %66 = zext i8 %tmpVar204 to i32
  %67 = icmp ne i32 %66, 0
  br i1 %67, label %68, label %71

condition_body203:                                ; preds = %71
  store i8 0, i8* %code, align 1
  store i8 0, i8* %TP, align 1
  br label %continue202

continue202:                                      ; preds = %condition_body203, %71
  br label %continue

buffer_block:                                     ; No predecessors!
  br label %continue39

68:                                               ; preds = %continue64
  %load_CODE = load i8, i8* %code, align 1
  %69 = zext i8 %load_CODE to i32
  %tmpVar205 = icmp slt i32 %69, 127
  %70 = zext i1 %tmpVar205 to i32
  br label %71

71:                                               ; preds = %68, %continue64
  %72 = phi i32 [ %66, %continue64 ], [ %70, %68 ]
  %73 = icmp ne i32 %72, 0
  br i1 %73, label %condition_body203, label %continue202

74:                                               ; preds = %continue
  br label %75

75:                                               ; preds = %74, %continue
  %76 = phi i32 [ %tmpVar208, %continue ], [ 3, %74 ]
  store i32 %76, i8* %line, align 4
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

input:                                            ; preds = %75
  %77 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  store i64 1, i64* %77, align 4
  %78 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  %load_line210 = load i8, i8* %line, align 1
  %79 = zext i8 %load_line210 to i16
  store i16 %79, i16* %78, align 2
  br label %call

call:                                             ; preds = %input
  %call211 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue209

continue209:                                      ; preds = %output
  %80 = trunc i64 %call211 to i8
  store i8 %80, i8* %temp, align 1
  %load_temp212 = load i8, i8* %temp, align 1
  %shift213 = lshr i8 %load_temp212, 0
  store i8 %shift213, i8* %y1, align 1
  %load_temp214 = load i8, i8* %temp, align 1
  %shift215 = lshr i8 %load_temp214, 1
  store i8 %shift215, i8* %y2, align 1
  %load_temp216 = load i8, i8* %temp, align 1
  %shift217 = lshr i8 %load_temp216, 2
  store i8 %shift217, i8* %y3, align 1
  %load_temp218 = load i8, i8* %temp, align 1
  %shift219 = lshr i8 %load_temp218, 3
  store i8 %shift219, i8* %y4, align 1
  ret void
}

define void @PIN_CODE(%PIN_CODE_interface* %0) {
entry:
  %CB = getelementptr inbounds %PIN_CODE_interface, %PIN_CODE_interface* %0, i32 0, i32 0
  %E = getelementptr inbounds %PIN_CODE_interface, %PIN_CODE_interface* %0, i32 0, i32 1
  %PIN = getelementptr inbounds %PIN_CODE_interface, %PIN_CODE_interface* %0, i32 0, i32 2
  %TP = getelementptr inbounds %PIN_CODE_interface, %PIN_CODE_interface* %0, i32 0, i32 3
  %POS = getelementptr inbounds %PIN_CODE_interface, %PIN_CODE_interface* %0, i32 0, i32 4
  store i8 0, i8* %TP, align 1
  %load_e = load i8, i8* %E, align 1
  %1 = icmp ne i8 %load_e, 0
  br i1 %1, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %load_CB = load i8, i8* %CB, align 1
  %2 = zext i8 %load_CB to i32
  %CODE_instance = alloca %CODE_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %entry
  ret void

condition_body2:                                  ; preds = %continue3
  %load_pos5 = load i16, i16* %POS, align 2
  %3 = sext i16 %load_pos5 to i32
  %tmpVar6 = add i32 %3, 1
  %4 = trunc i32 %tmpVar6 to i16
  store i16 %4, i16* %POS, align 2
  %load_pos9 = load i16, i16* %POS, align 2
  %5 = sext i16 %load_pos9 to i32
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input10

else:                                             ; preds = %continue3
  store i16 1, i16* %POS, align 2
  br label %continue1

continue1:                                        ; preds = %else, %continue7
  br label %continue

input:                                            ; preds = %condition_body
  %6 = getelementptr inbounds %CODE_interface, %CODE_interface* %CODE_instance, i32 0, i32 0
  %7 = bitcast [251 x i8]* %6 to i8*
  %8 = bitcast [9 x i8]* %PIN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %7, i8* align 1 %8, i32 9, i1 false)
  %9 = getelementptr inbounds %CODE_interface, %CODE_interface* %CODE_instance, i32 0, i32 1
  %load_pos = load i16, i16* %POS, align 2
  store i16 %load_pos, i16* %9, align 2
  br label %call

call:                                             ; preds = %input
  %call4 = call i8 @CODE(%CODE_interface* %CODE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  %10 = zext i8 %call4 to i32
  %tmpVar = icmp eq i32 %2, %10
  br i1 %tmpVar, label %condition_body2, label %else

condition_body8:                                  ; preds = %continue13
  store i8 1, i8* %TP, align 1
  store i16 1, i16* %POS, align 2
  br label %continue7

continue7:                                        ; preds = %condition_body8, %continue13
  br label %continue1

input10:                                          ; preds = %condition_body2
  %11 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %12 = bitcast [1024 x i8]* %11 to i8*
  %13 = bitcast [9 x i8]* %PIN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %12, i8* align 1 %13, i32 9, i1 false)
  br label %call11

call11:                                           ; preds = %input10
  %call14 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %14 = sext i16 %call14 to i32
  %tmpVar15 = icmp sgt i32 %5, %14
  br i1 %tmpVar15, label %condition_body8, label %continue7
}

define i8 @_ARRAY_ABS(%_ARRAY_ABS_interface* %0) {
entry:
  %pt = getelementptr inbounds %_ARRAY_ABS_interface, %_ARRAY_ABS_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %_ARRAY_ABS_interface, %_ARRAY_ABS_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %_ARRAY_ABS_interface, %_ARRAY_ABS_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %_ARRAY_ABS_interface, %_ARRAY_ABS_interface* %0, i32 0, i32 3
  %_ARRAY_ABS = alloca i8, align 1
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %_ARRAY_ABS, align 1
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %size, align 2
  %2 = zext i16 %load_size to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = sub i64 %call1, 1
  %4 = trunc i64 %tmpVar to i16
  store i16 %4, i16* %stop, align 2
  store i16 0, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar4 = icmp sle i16 %load_i3, %load_stop
  %5 = icmp ne i1 %tmpVar4, false
  br i1 %5, label %11, label %12

for_body:                                         ; preds = %9
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i12 = load i16, i16* %i, align 2
  %6 = zext i16 %load_i12 to i32
  %tmpVar13 = mul i32 1, %6
  %tmpVar14 = add i32 %tmpVar13, 0
  %tmpVar15 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 %tmpVar14
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input16

increment:                                        ; preds = %continue19
  %tmpVar26 = add i16 %load_i, 1
  store i16 %tmpVar26, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  store i8 1, i8* %_ARRAY_ABS, align 1
  %_ARRAY_ABS_ret = load i8, i8* %_ARRAY_ABS, align 1
  ret i8 %_ARRAY_ABS_ret

7:                                                ; preds = %12
  %load_i7 = load i16, i16* %i, align 2
  %load_stop8 = load i16, i16* %stop, align 2
  %tmpVar9 = icmp sge i16 %load_i7, %load_stop8
  %8 = icmp ne i1 %tmpVar9, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_i5 = load i16, i16* %i, align 2
  %tmpVar6 = icmp sge i16 %load_i5, 0
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar4, %condition_check ], [ %tmpVar6, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_i10 = load i16, i16* %i, align 2
  %tmpVar11 = icmp sle i16 %load_i10, 0
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar9, %7 ], [ %tmpVar11, %15 ]
  br label %9

input16:                                          ; preds = %for_body
  %18 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %deref20 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i21 = load i16, i16* %i, align 2
  %19 = zext i16 %load_i21 to i32
  %tmpVar22 = mul i32 1, %19
  %tmpVar23 = add i32 %tmpVar22, 0
  %tmpVar24 = getelementptr inbounds [32001 x float], [32001 x float]* %deref20, i32 0, i32 %tmpVar23
  %load_tmpVar = load float, float* %tmpVar24, align 4
  %20 = fptoui float %load_tmpVar to i64
  store i64 %20, i64* %18, align 4
  br label %call17

call17:                                           ; preds = %input16
  %call25 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %21 = uitofp i64 %call25 to float
  store float %21, float* %tmpVar15, align 4
  br label %increment
}

define i8 @_ARRAY_ADD(%_ARRAY_ADD_interface* %0) {
entry:
  %pt = getelementptr inbounds %_ARRAY_ADD_interface, %_ARRAY_ADD_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %_ARRAY_ADD_interface, %_ARRAY_ADD_interface* %0, i32 0, i32 1
  %X = getelementptr inbounds %_ARRAY_ADD_interface, %_ARRAY_ADD_interface* %0, i32 0, i32 2
  %i = getelementptr inbounds %_ARRAY_ADD_interface, %_ARRAY_ADD_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %_ARRAY_ADD_interface, %_ARRAY_ADD_interface* %0, i32 0, i32 4
  %_ARRAY_ADD = alloca i8, align 1
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %_ARRAY_ADD, align 1
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %size, align 2
  %2 = zext i16 %load_size to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = sub i64 %call1, 1
  %4 = trunc i64 %tmpVar to i16
  store i16 %4, i16* %stop, align 2
  store i16 0, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar4 = icmp sle i16 %load_i3, %load_stop
  %5 = icmp ne i1 %tmpVar4, false
  br i1 %5, label %12, label %13

for_body:                                         ; preds = %10
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i12 = load i16, i16* %i, align 2
  %6 = zext i16 %load_i12 to i32
  %tmpVar13 = mul i32 1, %6
  %tmpVar14 = add i32 %tmpVar13, 0
  %tmpVar15 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 %tmpVar14
  %deref16 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i17 = load i16, i16* %i, align 2
  %7 = zext i16 %load_i17 to i32
  %tmpVar18 = mul i32 1, %7
  %tmpVar19 = add i32 %tmpVar18, 0
  %tmpVar20 = getelementptr inbounds [32001 x float], [32001 x float]* %deref16, i32 0, i32 %tmpVar19
  %load_tmpVar = load float, float* %tmpVar20, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar21 = fadd float %load_tmpVar, %load_X
  store float %tmpVar21, float* %tmpVar15, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar22 = add i16 %load_i, 1
  store i16 %tmpVar22, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  store i8 1, i8* %_ARRAY_ADD, align 1
  %_ARRAY_ADD_ret = load i8, i8* %_ARRAY_ADD, align 1
  ret i8 %_ARRAY_ADD_ret

8:                                                ; preds = %13
  %load_i7 = load i16, i16* %i, align 2
  %load_stop8 = load i16, i16* %stop, align 2
  %tmpVar9 = icmp sge i16 %load_i7, %load_stop8
  %9 = icmp ne i1 %tmpVar9, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_i5 = load i16, i16* %i, align 2
  %tmpVar6 = icmp sge i16 %load_i5, 0
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar4, %condition_check ], [ %tmpVar6, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_i10 = load i16, i16* %i, align 2
  %tmpVar11 = icmp sle i16 %load_i10, 0
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar9, %8 ], [ %tmpVar11, %16 ]
  br label %10
}

define i8 @_ARRAY_INIT(%_ARRAY_INIT_interface* %0) {
entry:
  %pt = getelementptr inbounds %_ARRAY_INIT_interface, %_ARRAY_INIT_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %_ARRAY_INIT_interface, %_ARRAY_INIT_interface* %0, i32 0, i32 1
  %init = getelementptr inbounds %_ARRAY_INIT_interface, %_ARRAY_INIT_interface* %0, i32 0, i32 2
  %i = getelementptr inbounds %_ARRAY_INIT_interface, %_ARRAY_INIT_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %_ARRAY_INIT_interface, %_ARRAY_INIT_interface* %0, i32 0, i32 4
  %_ARRAY_INIT = alloca i8, align 1
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %_ARRAY_INIT, align 1
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %size, align 2
  %2 = zext i16 %load_size to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = sub i64 %call1, 1
  %4 = trunc i64 %tmpVar to i16
  store i16 %4, i16* %stop, align 2
  store i16 0, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar4 = icmp sle i16 %load_i3, %load_stop
  %5 = icmp ne i1 %tmpVar4, false
  br i1 %5, label %11, label %12

for_body:                                         ; preds = %9
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i12 = load i16, i16* %i, align 2
  %6 = zext i16 %load_i12 to i32
  %tmpVar13 = mul i32 1, %6
  %tmpVar14 = add i32 %tmpVar13, 0
  %tmpVar15 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 %tmpVar14
  %load_init = load float, float* %init, align 4
  store float %load_init, float* %tmpVar15, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar16 = add i16 %load_i, 1
  store i16 %tmpVar16, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  store i8 1, i8* %_ARRAY_INIT, align 1
  %_ARRAY_INIT_ret = load i8, i8* %_ARRAY_INIT, align 1
  ret i8 %_ARRAY_INIT_ret

7:                                                ; preds = %12
  %load_i7 = load i16, i16* %i, align 2
  %load_stop8 = load i16, i16* %stop, align 2
  %tmpVar9 = icmp sge i16 %load_i7, %load_stop8
  %8 = icmp ne i1 %tmpVar9, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_i5 = load i16, i16* %i, align 2
  %tmpVar6 = icmp sge i16 %load_i5, 0
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar4, %condition_check ], [ %tmpVar6, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_i10 = load i16, i16* %i, align 2
  %tmpVar11 = icmp sle i16 %load_i10, 0
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar9, %7 ], [ %tmpVar11, %15 ]
  br label %9
}

define float @_ARRAY_MEDIAN(%_ARRAY_MEDIAN_interface* %0) {
entry:
  %pt = getelementptr inbounds %_ARRAY_MEDIAN_interface, %_ARRAY_MEDIAN_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %_ARRAY_MEDIAN_interface, %_ARRAY_MEDIAN_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %_ARRAY_MEDIAN_interface, %_ARRAY_MEDIAN_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %_ARRAY_MEDIAN_interface, %_ARRAY_MEDIAN_interface* %0, i32 0, i32 3
  %_ARRAY_MEDIAN = alloca float, align 4
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store float 0.000000e+00, float* %_ARRAY_MEDIAN, align 4
  %_ARRAY_SORT_instance = alloca %_ARRAY_SORT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %_ARRAY_SORT_instance, i32 0, i32 0
  %load_pt = load [32001 x float]*, [32001 x float]** %pt, align 8
  store [32001 x float]* %load_pt, [32000 x float]** %1, align 8
  %2 = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %_ARRAY_SORT_instance, i32 0, i32 1
  %load_size = load i16, i16* %size, align 2
  store i16 %load_size, i16* %2, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i8 @_ARRAY_SORT(%_ARRAY_SORT_interface* %_ARRAY_SORT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %3 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size6 = load i16, i16* %size, align 2
  %4 = zext i16 %load_size6 to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %5, align 2
  br label %call3

call3:                                            ; preds = %input2
  %call7 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %tmpVar = sub i64 %call7, 1
  %6 = trunc i64 %tmpVar to i16
  store i16 %6, i16* %stop, align 2
  %EVEN_instance = alloca %EVEN_interface, align 8
  br label %input9

condition_body:                                   ; preds = %continue12
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %SHR_instance19 = alloca %SHR_interface, align 8
  br label %input20

else:                                             ; preds = %continue12
  %SHR_instance29 = alloca %SHR_interface, align 8
  br label %input30

continue8:                                        ; preds = %continue33, %continue23
  %_ARRAY_MEDIAN_ret = load float, float* %_ARRAY_MEDIAN, align 4
  ret float %_ARRAY_MEDIAN_ret

input9:                                           ; preds = %continue5
  %7 = getelementptr inbounds %EVEN_interface, %EVEN_interface* %EVEN_instance, i32 0, i32 0
  %UINT_TO_INT_instance = alloca %UINT_TO_INT_interface, align 8
  br label %input13

call10:                                           ; preds = %continue16
  %call18 = call i8 @EVEN(%EVEN_interface* %EVEN_instance)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  %8 = icmp ne i8 %call18, 0
  br i1 %8, label %condition_body, label %else

input13:                                          ; preds = %input9
  %9 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance, i32 0, i32 0
  %load_stop = load i16, i16* %stop, align 2
  store i16 %load_stop, i16* %9, align 2
  br label %call14

call14:                                           ; preds = %input13
  %call17 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %10 = sext i16 %call17 to i32
  store i32 %10, i32* %7, align 4
  br label %call10

input20:                                          ; preds = %condition_body
  %11 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance19, i32 0, i32 0
  %load_stop24 = load i16, i16* %stop, align 2
  %12 = zext i16 %load_stop24 to i64
  store i64 %12, i64* %11, align 4
  %13 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance19, i32 0, i32 1
  store i16 1, i16* %13, align 2
  br label %call21

call21:                                           ; preds = %input20
  %call25 = call i64 @SHR(%SHR_interface* %SHR_instance19)
  br label %output22

output22:                                         ; preds = %call21
  br label %continue23

continue23:                                       ; preds = %output22
  %14 = trunc i64 %call25 to i32
  %tmpVar26 = mul i32 1, %14
  %tmpVar27 = add i32 %tmpVar26, 0
  %tmpVar28 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 %tmpVar27
  %load_tmpVar = load float, float* %tmpVar28, align 4
  store float %load_tmpVar, float* %_ARRAY_MEDIAN, align 4
  br label %continue8

input30:                                          ; preds = %else
  %15 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance29, i32 0, i32 0
  %load_stop34 = load i16, i16* %stop, align 2
  %16 = zext i16 %load_stop34 to i64
  store i64 %16, i64* %15, align 4
  %17 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance29, i32 0, i32 1
  store i16 1, i16* %17, align 2
  br label %call31

call31:                                           ; preds = %input30
  %call35 = call i64 @SHR(%SHR_interface* %SHR_instance29)
  br label %output32

output32:                                         ; preds = %call31
  br label %continue33

continue33:                                       ; preds = %output32
  %18 = trunc i64 %call35 to i16
  store i16 %18, i16* %i, align 2
  %deref36 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i = load i16, i16* %i, align 2
  %19 = zext i16 %load_i to i32
  %tmpVar37 = mul i32 1, %19
  %tmpVar38 = add i32 %tmpVar37, 0
  %tmpVar39 = getelementptr inbounds [32001 x float], [32001 x float]* %deref36, i32 0, i32 %tmpVar38
  %load_tmpVar40 = load float, float* %tmpVar39, align 4
  %deref41 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i42 = load i16, i16* %i, align 2
  %20 = zext i16 %load_i42 to i32
  %tmpVar43 = add i32 %20, 1
  %tmpVar44 = mul i32 1, %tmpVar43
  %tmpVar45 = add i32 %tmpVar44, 0
  %tmpVar46 = getelementptr inbounds [32001 x float], [32001 x float]* %deref41, i32 0, i32 %tmpVar45
  %load_tmpVar47 = load float, float* %tmpVar46, align 4
  %tmpVar48 = fadd float %load_tmpVar40, %load_tmpVar47
  %tmpVar49 = fmul float %tmpVar48, 5.000000e-01
  store float %tmpVar49, float* %_ARRAY_MEDIAN, align 4
  br label %continue8
}

define i8 @_ARRAY_MUL(%_ARRAY_MUL_interface* %0) {
entry:
  %pt = getelementptr inbounds %_ARRAY_MUL_interface, %_ARRAY_MUL_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %_ARRAY_MUL_interface, %_ARRAY_MUL_interface* %0, i32 0, i32 1
  %X = getelementptr inbounds %_ARRAY_MUL_interface, %_ARRAY_MUL_interface* %0, i32 0, i32 2
  %i = getelementptr inbounds %_ARRAY_MUL_interface, %_ARRAY_MUL_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %_ARRAY_MUL_interface, %_ARRAY_MUL_interface* %0, i32 0, i32 4
  %_ARRAY_MUL = alloca i8, align 1
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %_ARRAY_MUL, align 1
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %size, align 2
  %2 = zext i16 %load_size to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = sub i64 %call1, 1
  %4 = trunc i64 %tmpVar to i16
  store i16 %4, i16* %stop, align 2
  store i16 0, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar4 = icmp sle i16 %load_i3, %load_stop
  %5 = icmp ne i1 %tmpVar4, false
  br i1 %5, label %12, label %13

for_body:                                         ; preds = %10
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i12 = load i16, i16* %i, align 2
  %6 = zext i16 %load_i12 to i32
  %tmpVar13 = mul i32 1, %6
  %tmpVar14 = add i32 %tmpVar13, 0
  %tmpVar15 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 %tmpVar14
  %deref16 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i17 = load i16, i16* %i, align 2
  %7 = zext i16 %load_i17 to i32
  %tmpVar18 = mul i32 1, %7
  %tmpVar19 = add i32 %tmpVar18, 0
  %tmpVar20 = getelementptr inbounds [32001 x float], [32001 x float]* %deref16, i32 0, i32 %tmpVar19
  %load_tmpVar = load float, float* %tmpVar20, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar21 = fmul float %load_tmpVar, %load_X
  store float %tmpVar21, float* %tmpVar15, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar22 = add i16 %load_i, 1
  store i16 %tmpVar22, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  store i8 1, i8* %_ARRAY_MUL, align 1
  %_ARRAY_MUL_ret = load i8, i8* %_ARRAY_MUL, align 1
  ret i8 %_ARRAY_MUL_ret

8:                                                ; preds = %13
  %load_i7 = load i16, i16* %i, align 2
  %load_stop8 = load i16, i16* %stop, align 2
  %tmpVar9 = icmp sge i16 %load_i7, %load_stop8
  %9 = icmp ne i1 %tmpVar9, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_i5 = load i16, i16* %i, align 2
  %tmpVar6 = icmp sge i16 %load_i5, 0
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar4, %condition_check ], [ %tmpVar6, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_i10 = load i16, i16* %i, align 2
  %tmpVar11 = icmp sle i16 %load_i10, 0
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar9, %8 ], [ %tmpVar11, %16 ]
  br label %10
}

define i8 @_ARRAY_SHUFFLE(%_ARRAY_SHUFFLE_interface* %0) {
entry:
  %pt = getelementptr inbounds %_ARRAY_SHUFFLE_interface, %_ARRAY_SHUFFLE_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %_ARRAY_SHUFFLE_interface, %_ARRAY_SHUFFLE_interface* %0, i32 0, i32 1
  %temp = getelementptr inbounds %_ARRAY_SHUFFLE_interface, %_ARRAY_SHUFFLE_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %_ARRAY_SHUFFLE_interface, %_ARRAY_SHUFFLE_interface* %0, i32 0, i32 3
  %i = getelementptr inbounds %_ARRAY_SHUFFLE_interface, %_ARRAY_SHUFFLE_interface* %0, i32 0, i32 4
  %stop = getelementptr inbounds %_ARRAY_SHUFFLE_interface, %_ARRAY_SHUFFLE_interface* %0, i32 0, i32 5
  %_ARRAY_SHUFFLE = alloca i8, align 1
  store float 0.000000e+00, float* %temp, align 4
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %_ARRAY_SHUFFLE, align 1
  %UINT_TO_INT_instance = alloca %UINT_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance, i32 0, i32 0
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call6, i16* %stop, align 2
  store i16 0, i16* %i, align 2
  br label %condition_check

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %size, align 2
  %3 = zext i16 %load_size to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %4, align 2
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = sub i64 %call5, 1
  %5 = trunc i64 %tmpVar to i16
  store i16 %5, i16* %1, align 2
  br label %call

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i8 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar9 = icmp sle i16 %load_i8, %load_stop
  %6 = icmp ne i1 %tmpVar9, false
  br i1 %6, label %11, label %12

for_body:                                         ; preds = %9
  %RDM2_instance = alloca %RDM2_interface, align 8
  br label %input17

increment:                                        ; preds = %continue20
  %tmpVar45 = add i16 %load_i, 1
  store i16 %tmpVar45, i16* %i, align 2
  br label %condition_check

continue7:                                        ; preds = %9
  store i8 1, i8* %_ARRAY_SHUFFLE, align 1
  %_ARRAY_SHUFFLE_ret = load i8, i8* %_ARRAY_SHUFFLE, align 1
  ret i8 %_ARRAY_SHUFFLE_ret

7:                                                ; preds = %12
  %load_i12 = load i16, i16* %i, align 2
  %load_stop13 = load i16, i16* %stop, align 2
  %tmpVar14 = icmp sge i16 %load_i12, %load_stop13
  %8 = icmp ne i1 %tmpVar14, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue7

11:                                               ; preds = %condition_check
  %load_i10 = load i16, i16* %i, align 2
  %tmpVar11 = icmp sge i16 %load_i10, 0
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar9, %condition_check ], [ %tmpVar11, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_i15 = load i16, i16* %i, align 2
  %tmpVar16 = icmp sle i16 %load_i15, 0
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar14, %7 ], [ %tmpVar16, %15 ]
  br label %9

input17:                                          ; preds = %for_body
  %18 = getelementptr inbounds %RDM2_interface, %RDM2_interface* %RDM2_instance, i32 0, i32 0
  %load_i21 = load i16, i16* %i, align 2
  %19 = sext i16 %load_i21 to i32
  %load_pos = load i16, i16* %pos, align 2
  %20 = sext i16 %load_pos to i32
  %tmpVar22 = add i32 %19, %20
  %21 = trunc i32 %tmpVar22 to i16
  store i16 %21, i16* %18, align 2
  %22 = getelementptr inbounds %RDM2_interface, %RDM2_interface* %RDM2_instance, i32 0, i32 1
  store i16 0, i16* %22, align 2
  %23 = getelementptr inbounds %RDM2_interface, %RDM2_interface* %RDM2_instance, i32 0, i32 2
  %load_stop23 = load i16, i16* %stop, align 2
  store i16 %load_stop23, i16* %23, align 2
  br label %call18

call18:                                           ; preds = %input17
  %call24 = call i16 @RDM2(%RDM2_interface* %RDM2_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  store i16 %call24, i16* %pos, align 2
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i25 = load i16, i16* %i, align 2
  %24 = sext i16 %load_i25 to i32
  %tmpVar26 = mul i32 1, %24
  %tmpVar27 = add i32 %tmpVar26, 0
  %tmpVar28 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 %tmpVar27
  %load_tmpVar = load float, float* %tmpVar28, align 4
  store float %load_tmpVar, float* %temp, align 4
  %deref29 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i30 = load i16, i16* %i, align 2
  %25 = sext i16 %load_i30 to i32
  %tmpVar31 = mul i32 1, %25
  %tmpVar32 = add i32 %tmpVar31, 0
  %tmpVar33 = getelementptr inbounds [32001 x float], [32001 x float]* %deref29, i32 0, i32 %tmpVar32
  %deref34 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_pos35 = load i16, i16* %pos, align 2
  %26 = sext i16 %load_pos35 to i32
  %tmpVar36 = mul i32 1, %26
  %tmpVar37 = add i32 %tmpVar36, 0
  %tmpVar38 = getelementptr inbounds [32001 x float], [32001 x float]* %deref34, i32 0, i32 %tmpVar37
  %load_tmpVar39 = load float, float* %tmpVar38, align 4
  store float %load_tmpVar39, float* %tmpVar33, align 4
  %deref40 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_pos41 = load i16, i16* %pos, align 2
  %27 = sext i16 %load_pos41 to i32
  %tmpVar42 = mul i32 1, %27
  %tmpVar43 = add i32 %tmpVar42, 0
  %tmpVar44 = getelementptr inbounds [32001 x float], [32001 x float]* %deref40, i32 0, i32 %tmpVar43
  %load_temp = load float, float* %temp, align 4
  store float %load_temp, float* %tmpVar44, align 4
  br label %increment
}

define i8 @_ARRAY_SORT(%_ARRAY_SORT_interface* %0) {
entry:
  %PT = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 0
  %SIZE = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 1
  %stack_count = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 2
  %stack = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 3
  %links = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 4
  %rechts = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 5
  %pivot = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 6
  %i = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 7
  %j = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 8
  %ende_innen = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 9
  %ende_aussen = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 10
  %tmp = getelementptr inbounds %_ARRAY_SORT_interface, %_ARRAY_SORT_interface* %0, i32 0, i32 11
  %_ARRAY_SORT = alloca i8, align 1
  store i16 0, i16* %stack_count, align 2
  %1 = bitcast [32 x i16]* %stack to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i16* getelementptr (i16, i16* null, i32 1) to i64), i64 32), i1 false)
  store i16 0, i16* %links, align 2
  store i16 0, i16* %rechts, align 2
  store float 0.000000e+00, float* %pivot, align 4
  store i16 0, i16* %i, align 2
  store i16 0, i16* %j, align 2
  store i8 0, i8* %ende_innen, align 1
  store i8 0, i8* %ende_aussen, align 1
  store float 0.000000e+00, float* %tmp, align 4
  store i8 0, i8* %_ARRAY_SORT, align 1
  store i16 1, i16* %links, align 2
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %SIZE, align 2
  %3 = zext i16 %load_size to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %4, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = trunc i64 %call1 to i16
  store i16 %5, i16* %rechts, align 2
  store i16 1, i16* %stack_count, align 2
  br label %condition_check

condition_check:                                  ; preds = %continue, %continue3
  %load_ende_aussen = load i8, i8* %ende_aussen, align 1
  %tmpVar = xor i8 %load_ende_aussen, -1
  br i8 %tmpVar, label %while_body, label %continue2

while_body:                                       ; preds = %condition_check
  %load_links = load i16, i16* %links, align 2
  %6 = zext i16 %load_links to i32
  %load_rechts = load i16, i16* %rechts, align 2
  %7 = zext i16 %load_rechts to i32
  %tmpVar4 = icmp slt i32 %6, %7
  br i1 %tmpVar4, label %condition_body, label %else

continue2:                                        ; preds = %condition_check
  store i8 1, i8* %_ARRAY_SORT, align 1
  %_ARRAY_SORT_ret = load i8, i8* %_ARRAY_SORT, align 1
  ret i8 %_ARRAY_SORT_ret

condition_body:                                   ; preds = %while_body
  %deref = load [32000 x float]*, [32000 x float]** %PT, align 8
  %SHR_instance5 = alloca %SHR_interface, align 8
  br label %input6

else:                                             ; preds = %while_body
  %load_stack_count104 = load i16, i16* %stack_count, align 2
  %8 = zext i16 %load_stack_count104 to i32
  %tmpVar105 = icmp eq i32 %8, 1
  br i1 %tmpVar105, label %condition_body103, label %else101

continue3:                                        ; preds = %continue102, %continue96
  br label %condition_check

input6:                                           ; preds = %condition_body
  %9 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance5, i32 0, i32 0
  %load_rechts10 = load i16, i16* %rechts, align 2
  %10 = zext i16 %load_rechts10 to i32
  %load_links11 = load i16, i16* %links, align 2
  %11 = zext i16 %load_links11 to i32
  %tmpVar12 = add i32 %10, %11
  %12 = sext i32 %tmpVar12 to i64
  store i64 %12, i64* %9, align 4
  %13 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance5, i32 0, i32 1
  store i16 1, i16* %13, align 2
  br label %call7

call7:                                            ; preds = %input6
  %call13 = call i64 @SHR(%SHR_interface* %SHR_instance5)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %14 = sub i64 %call13, 1
  %15 = trunc i64 %14 to i32
  %tmpVar14 = mul i32 1, %15
  %tmpVar15 = add i32 %tmpVar14, 0
  %tmpVar16 = getelementptr inbounds [32000 x float], [32000 x float]* %deref, i32 0, i32 %tmpVar15
  %load_tmpVar = load float, float* %tmpVar16, align 4
  store float %load_tmpVar, float* %pivot, align 4
  %load_links17 = load i16, i16* %links, align 2
  %16 = zext i16 %load_links17 to i32
  %tmpVar18 = sub i32 %16, 1
  %17 = trunc i32 %tmpVar18 to i16
  store i16 %17, i16* %i, align 2
  %load_rechts19 = load i16, i16* %rechts, align 2
  %18 = zext i16 %load_rechts19 to i32
  %tmpVar20 = add i32 %18, 1
  %19 = trunc i32 %tmpVar20 to i16
  store i16 %19, i16* %j, align 2
  store i8 0, i8* %ende_innen, align 1
  br label %while_body22

condition_check21:                                ; preds = %continue56
  %load_ende_innen = load i8, i8* %ende_innen, align 1
  br i8 %load_ende_innen, label %while_body22, label %continue23

while_body22:                                     ; preds = %continue9, %condition_check21
  br label %while_body25

continue23:                                       ; preds = %condition_check21
  %load_stack_count = load i16, i16* %stack_count, align 2
  %20 = sub i16 %load_stack_count, 1
  %21 = zext i16 %20 to i32
  %tmpVar83 = mul i32 1, %21
  %tmpVar84 = add i32 %tmpVar83, 0
  %tmpVar85 = getelementptr inbounds [32 x i16], [32 x i16]* %stack, i32 0, i32 %tmpVar84
  %load_rechts86 = load i16, i16* %rechts, align 2
  store i16 %load_rechts86, i16* %tmpVar85, align 2
  %load_Stack_count = load i16, i16* %stack_count, align 2
  %22 = zext i16 %load_Stack_count to i32
  %tmpVar90 = icmp slt i32 %22, 32
  br i1 %tmpVar90, label %condition_body89, label %else87

condition_check24:                                ; preds = %while_body25
  %deref27 = load [32000 x float]*, [32000 x float]** %PT, align 8
  %load_i = load i16, i16* %i, align 2
  %23 = sub i16 %load_i, 1
  %24 = zext i16 %23 to i32
  %tmpVar28 = mul i32 1, %24
  %tmpVar29 = add i32 %tmpVar28, 0
  %tmpVar30 = getelementptr inbounds [32000 x float], [32000 x float]* %deref27, i32 0, i32 %tmpVar29
  %load_tmpVar31 = load float, float* %tmpVar30, align 4
  %load_pivot = load float, float* %pivot, align 4
  %tmpVar32 = fcmp oge float %load_tmpVar31, %load_pivot
  %25 = zext i1 %tmpVar32 to i32
  %26 = icmp ne i32 %25, 0
  br i1 %26, label %33, label %29

while_body25:                                     ; preds = %while_body22, %33
  %load_i37 = load i16, i16* %i, align 2
  %27 = zext i16 %load_i37 to i32
  %tmpVar38 = add i32 %27, 1
  %28 = trunc i32 %tmpVar38 to i16
  store i16 %28, i16* %i, align 2
  br label %condition_check24

continue26:                                       ; preds = %33
  br label %while_body40

29:                                               ; preds = %condition_check24
  %load_i33 = load i16, i16* %i, align 2
  %30 = zext i16 %load_i33 to i32
  %load_rechts34 = load i16, i16* %rechts, align 2
  %31 = zext i16 %load_rechts34 to i32
  %tmpVar35 = icmp slt i32 %30, %31
  %tmpVar36 = xor i1 %tmpVar35, true
  %32 = zext i1 %tmpVar36 to i32
  br label %33

33:                                               ; preds = %29, %condition_check24
  %34 = phi i32 [ %25, %condition_check24 ], [ %32, %29 ]
  br i32 %34, label %while_body25, label %continue26

condition_check39:                                ; preds = %while_body40
  %deref42 = load [32000 x float]*, [32000 x float]** %PT, align 8
  %load_j = load i16, i16* %j, align 2
  %35 = sub i16 %load_j, 1
  %36 = zext i16 %35 to i32
  %tmpVar43 = mul i32 1, %36
  %tmpVar44 = add i32 %tmpVar43, 0
  %tmpVar45 = getelementptr inbounds [32000 x float], [32000 x float]* %deref42, i32 0, i32 %tmpVar44
  %load_tmpVar46 = load float, float* %tmpVar45, align 4
  %load_pivot47 = load float, float* %pivot, align 4
  %tmpVar48 = fcmp ole float %load_tmpVar46, %load_pivot47
  %37 = zext i1 %tmpVar48 to i32
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %47, label %43

while_body40:                                     ; preds = %continue26, %47
  %load_j53 = load i16, i16* %j, align 2
  %39 = zext i16 %load_j53 to i32
  %tmpVar54 = sub i32 %39, 1
  %40 = trunc i32 %tmpVar54 to i16
  store i16 %40, i16* %j, align 2
  br label %condition_check39

continue41:                                       ; preds = %47
  %load_i58 = load i16, i16* %i, align 2
  %41 = zext i16 %load_i58 to i32
  %load_j59 = load i16, i16* %j, align 2
  %42 = zext i16 %load_j59 to i32
  %tmpVar60 = icmp sge i32 %41, %42
  br i1 %tmpVar60, label %condition_body57, label %else55

43:                                               ; preds = %condition_check39
  %load_j49 = load i16, i16* %j, align 2
  %44 = zext i16 %load_j49 to i32
  %load_links50 = load i16, i16* %links, align 2
  %45 = zext i16 %load_links50 to i32
  %tmpVar51 = icmp sgt i32 %44, %45
  %tmpVar52 = xor i1 %tmpVar51, true
  %46 = zext i1 %tmpVar52 to i32
  br label %47

47:                                               ; preds = %43, %condition_check39
  %48 = phi i32 [ %37, %condition_check39 ], [ %46, %43 ]
  br i32 %48, label %while_body40, label %continue41

condition_body57:                                 ; preds = %continue41
  store i8 1, i8* %ende_innen, align 1
  br label %continue56

else55:                                           ; preds = %continue41
  %deref61 = load [32000 x float]*, [32000 x float]** %PT, align 8
  %load_j62 = load i16, i16* %j, align 2
  %49 = sub i16 %load_j62, 1
  %50 = zext i16 %49 to i32
  %tmpVar63 = mul i32 1, %50
  %tmpVar64 = add i32 %tmpVar63, 0
  %tmpVar65 = getelementptr inbounds [32000 x float], [32000 x float]* %deref61, i32 0, i32 %tmpVar64
  %load_tmpVar66 = load float, float* %tmpVar65, align 4
  store float %load_tmpVar66, float* %tmp, align 4
  %deref67 = load [32000 x float]*, [32000 x float]** %PT, align 8
  %load_j68 = load i16, i16* %j, align 2
  %51 = sub i16 %load_j68, 1
  %52 = zext i16 %51 to i32
  %tmpVar69 = mul i32 1, %52
  %tmpVar70 = add i32 %tmpVar69, 0
  %tmpVar71 = getelementptr inbounds [32000 x float], [32000 x float]* %deref67, i32 0, i32 %tmpVar70
  %deref72 = load [32000 x float]*, [32000 x float]** %PT, align 8
  %load_i73 = load i16, i16* %i, align 2
  %53 = sub i16 %load_i73, 1
  %54 = zext i16 %53 to i32
  %tmpVar74 = mul i32 1, %54
  %tmpVar75 = add i32 %tmpVar74, 0
  %tmpVar76 = getelementptr inbounds [32000 x float], [32000 x float]* %deref72, i32 0, i32 %tmpVar75
  %load_tmpVar77 = load float, float* %tmpVar76, align 4
  store float %load_tmpVar77, float* %tmpVar71, align 4
  %deref78 = load [32000 x float]*, [32000 x float]** %PT, align 8
  %load_i79 = load i16, i16* %i, align 2
  %55 = sub i16 %load_i79, 1
  %56 = zext i16 %55 to i32
  %tmpVar80 = mul i32 1, %56
  %tmpVar81 = add i32 %tmpVar80, 0
  %tmpVar82 = getelementptr inbounds [32000 x float], [32000 x float]* %deref78, i32 0, i32 %tmpVar81
  %load_tmp = load float, float* %tmp, align 4
  store float %load_tmp, float* %tmpVar82, align 4
  br label %continue56

continue56:                                       ; preds = %else55, %condition_body57
  br label %condition_check21

condition_body89:                                 ; preds = %continue23
  %load_stack_count91 = load i16, i16* %stack_count, align 2
  %57 = zext i16 %load_stack_count91 to i32
  %tmpVar92 = add i32 %57, 1
  %58 = trunc i32 %tmpVar92 to i16
  store i16 %58, i16* %stack_count, align 2
  br label %continue88

else87:                                           ; preds = %continue23
  store i8 1, i8* %ende_aussen, align 1
  store i8 0, i8* %_ARRAY_SORT, align 1
  br label %continue88

continue88:                                       ; preds = %else87, %condition_body89
  %MAX_instance = alloca %MAX_interface, align 8
  br label %input93

input93:                                          ; preds = %continue88
  %59 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 0
  %load_links97 = load i16, i16* %links, align 2
  %60 = zext i16 %load_links97 to i64
  store i64 %60, i64* %59, align 4
  %61 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 1
  %load_i98 = load i16, i16* %i, align 2
  %62 = zext i16 %load_i98 to i32
  %tmpVar99 = sub i32 %62, 1
  %63 = sext i32 %tmpVar99 to i64
  store i64 %63, i64* %61, align 4
  br label %call94

call94:                                           ; preds = %input93
  %call100 = call i64 @MAX(%MAX_interface* %MAX_instance)
  br label %output95

output95:                                         ; preds = %call94
  br label %continue96

continue96:                                       ; preds = %output95
  %64 = trunc i64 %call100 to i16
  store i16 %64, i16* %rechts, align 2
  br label %continue3

condition_body103:                                ; preds = %else
  store i8 1, i8* %ende_aussen, align 1
  br label %continue102

else101:                                          ; preds = %else
  %load_rechts106 = load i16, i16* %rechts, align 2
  %65 = zext i16 %load_rechts106 to i32
  %tmpVar107 = add i32 %65, 1
  %66 = trunc i32 %tmpVar107 to i16
  store i16 %66, i16* %links, align 2
  %load_stack_count108 = load i16, i16* %stack_count, align 2
  %67 = zext i16 %load_stack_count108 to i32
  %tmpVar109 = sub i32 %67, 1
  %68 = trunc i32 %tmpVar109 to i16
  store i16 %68, i16* %stack_count, align 2
  %load_stack_count110 = load i16, i16* %stack_count, align 2
  %69 = sub i16 %load_stack_count110, 1
  %70 = zext i16 %69 to i32
  %tmpVar111 = mul i32 1, %70
  %tmpVar112 = add i32 %tmpVar111, 0
  %tmpVar113 = getelementptr inbounds [32 x i16], [32 x i16]* %stack, i32 0, i32 %tmpVar112
  %load_tmpVar114 = load i16, i16* %tmpVar113, align 2
  store i16 %load_tmpVar114, i16* %rechts, align 2
  br label %continue102

continue102:                                      ; preds = %else101, %condition_body103
  br label %continue3
}

define float @ARRAY_AVG(%ARRAY_AVG_interface* %0) {
entry:
  %pt = getelementptr inbounds %ARRAY_AVG_interface, %ARRAY_AVG_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %ARRAY_AVG_interface, %ARRAY_AVG_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %ARRAY_AVG_interface, %ARRAY_AVG_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %ARRAY_AVG_interface, %ARRAY_AVG_interface* %0, i32 0, i32 3
  %ARRAY_AVG = alloca float, align 4
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store float 0.000000e+00, float* %ARRAY_AVG, align 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %size, align 2
  %2 = zext i16 %load_size to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = sub i64 %call1, 1
  %4 = trunc i64 %tmpVar to i16
  store i16 %4, i16* %stop, align 2
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %tmpVar2 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 0
  %load_tmpVar = load float, float* %tmpVar2, align 4
  store float %load_tmpVar, float* %ARRAY_AVG, align 4
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i4 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar5 = icmp sle i16 %load_i4, %load_stop
  %5 = icmp ne i1 %tmpVar5, false
  br i1 %5, label %11, label %12

for_body:                                         ; preds = %9
  %load_ARRAY_AVG = load float, float* %ARRAY_AVG, align 4
  %deref13 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i14 = load i16, i16* %i, align 2
  %6 = zext i16 %load_i14 to i32
  %tmpVar15 = mul i32 1, %6
  %tmpVar16 = add i32 %tmpVar15, 0
  %tmpVar17 = getelementptr inbounds [32001 x float], [32001 x float]* %deref13, i32 0, i32 %tmpVar16
  %load_tmpVar18 = load float, float* %tmpVar17, align 4
  %tmpVar19 = fadd float %load_ARRAY_AVG, %load_tmpVar18
  store float %tmpVar19, float* %ARRAY_AVG, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar20 = add i16 %load_i, 1
  store i16 %tmpVar20, i16* %i, align 2
  br label %condition_check

continue3:                                        ; preds = %9
  %load_ARRAY_AVG21 = load float, float* %ARRAY_AVG, align 4
  %UINT_TO_REAL_instance = alloca %UINT_TO_REAL_interface, align 8
  br label %input22

7:                                                ; preds = %12
  %load_i8 = load i16, i16* %i, align 2
  %load_stop9 = load i16, i16* %stop, align 2
  %tmpVar10 = icmp sge i16 %load_i8, %load_stop9
  %8 = icmp ne i1 %tmpVar10, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue3

11:                                               ; preds = %condition_check
  %load_i6 = load i16, i16* %i, align 2
  %tmpVar7 = icmp sge i16 %load_i6, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar5, %condition_check ], [ %tmpVar7, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_i11 = load i16, i16* %i, align 2
  %tmpVar12 = icmp sle i16 %load_i11, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar10, %7 ], [ %tmpVar12, %15 ]
  br label %9

input22:                                          ; preds = %continue3
  %18 = getelementptr inbounds %UINT_TO_REAL_interface, %UINT_TO_REAL_interface* %UINT_TO_REAL_instance, i32 0, i32 0
  %load_stop26 = load i16, i16* %stop, align 2
  %19 = zext i16 %load_stop26 to i32
  %tmpVar27 = add i32 %19, 1
  %20 = trunc i32 %tmpVar27 to i16
  store i16 %20, i16* %18, align 2
  br label %call23

call23:                                           ; preds = %input22
  %call28 = call float @UINT_TO_REAL(%UINT_TO_REAL_interface* %UINT_TO_REAL_instance)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %tmpVar29 = fdiv float %load_ARRAY_AVG21, %call28
  store float %tmpVar29, float* %ARRAY_AVG, align 4
  %ARRAY_AVG_ret = load float, float* %ARRAY_AVG, align 4
  ret float %ARRAY_AVG_ret
}

define float @ARRAY_GAV(%ARRAY_GAV_interface* %0) {
entry:
  %pt = getelementptr inbounds %ARRAY_GAV_interface, %ARRAY_GAV_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %ARRAY_GAV_interface, %ARRAY_GAV_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %ARRAY_GAV_interface, %ARRAY_GAV_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %ARRAY_GAV_interface, %ARRAY_GAV_interface* %0, i32 0, i32 3
  %ARRAY_GAV = alloca float, align 4
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store float 0.000000e+00, float* %ARRAY_GAV, align 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %size, align 2
  %2 = zext i16 %load_size to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = sub i64 %call1, 1
  %4 = trunc i64 %tmpVar to i16
  store i16 %4, i16* %stop, align 2
  store float 1.000000e+00, float* %ARRAY_GAV, align 4
  store i16 0, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar4 = icmp sle i16 %load_i3, %load_stop
  %5 = icmp ne i1 %tmpVar4, false
  br i1 %5, label %11, label %12

for_body:                                         ; preds = %9
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i13 = load i16, i16* %i, align 2
  %6 = zext i16 %load_i13 to i32
  %tmpVar14 = mul i32 1, %6
  %tmpVar15 = add i32 %tmpVar14, 0
  %tmpVar16 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 %tmpVar15
  %load_tmpVar = load float, float* %tmpVar16, align 4
  %tmpVar17 = fcmp ogt float %load_tmpVar, 0.000000e+00
  br i1 %tmpVar17, label %condition_body, label %else

increment:                                        ; preds = %continue12
  %tmpVar25 = add i16 %load_i, 1
  store i16 %tmpVar25, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  %SQRTN_instance = alloca %SQRTN_interface, align 8
  br label %input26

7:                                                ; preds = %12
  %load_i7 = load i16, i16* %i, align 2
  %load_stop8 = load i16, i16* %stop, align 2
  %tmpVar9 = icmp sge i16 %load_i7, %load_stop8
  %8 = icmp ne i1 %tmpVar9, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_i5 = load i16, i16* %i, align 2
  %tmpVar6 = icmp sge i16 %load_i5, 0
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar4, %condition_check ], [ %tmpVar6, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_i10 = load i16, i16* %i, align 2
  %tmpVar11 = icmp sle i16 %load_i10, 0
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar9, %7 ], [ %tmpVar11, %15 ]
  br label %9

condition_body:                                   ; preds = %for_body
  %load_ARRAY_GAV = load float, float* %ARRAY_GAV, align 4
  %deref18 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i19 = load i16, i16* %i, align 2
  %18 = zext i16 %load_i19 to i32
  %tmpVar20 = mul i32 1, %18
  %tmpVar21 = add i32 %tmpVar20, 0
  %tmpVar22 = getelementptr inbounds [32001 x float], [32001 x float]* %deref18, i32 0, i32 %tmpVar21
  %load_tmpVar23 = load float, float* %tmpVar22, align 4
  %tmpVar24 = fmul float %load_ARRAY_GAV, %load_tmpVar23
  store float %tmpVar24, float* %ARRAY_GAV, align 4
  br label %continue12

else:                                             ; preds = %for_body
  store float 0.000000e+00, float* %ARRAY_GAV, align 4
  %ARRAY_GAV_ret = load float, float* %ARRAY_GAV, align 4
  ret float %ARRAY_GAV_ret

buffer_block:                                     ; No predecessors!
  br label %continue12

continue12:                                       ; preds = %buffer_block, %condition_body
  br label %increment

input26:                                          ; preds = %continue2
  %19 = getelementptr inbounds %SQRTN_interface, %SQRTN_interface* %SQRTN_instance, i32 0, i32 0
  %load_ARRAY_GAV30 = load float, float* %ARRAY_GAV, align 4
  store float %load_ARRAY_GAV30, float* %19, align 4
  %20 = getelementptr inbounds %SQRTN_interface, %SQRTN_interface* %SQRTN_instance, i32 0, i32 1
  %UINT_TO_INT_instance = alloca %UINT_TO_INT_interface, align 8
  br label %input31

call27:                                           ; preds = %continue34
  %call38 = call float @SQRTN(%SQRTN_interface* %SQRTN_instance)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  store float %call38, float* %ARRAY_GAV, align 4
  %ARRAY_GAV_ret39 = load float, float* %ARRAY_GAV, align 4
  ret float %ARRAY_GAV_ret39

input31:                                          ; preds = %input26
  %21 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance, i32 0, i32 0
  %load_stop35 = load i16, i16* %stop, align 2
  store i16 %load_stop35, i16* %21, align 2
  br label %call32

call32:                                           ; preds = %input31
  %call36 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  %22 = sext i16 %call36 to i32
  %tmpVar37 = add i32 %22, 1
  %23 = trunc i32 %tmpVar37 to i16
  store i16 %23, i16* %20, align 2
  br label %call27
}

define float @ARRAY_HAV(%ARRAY_HAV_interface* %0) {
entry:
  %pt = getelementptr inbounds %ARRAY_HAV_interface, %ARRAY_HAV_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %ARRAY_HAV_interface, %ARRAY_HAV_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %ARRAY_HAV_interface, %ARRAY_HAV_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %ARRAY_HAV_interface, %ARRAY_HAV_interface* %0, i32 0, i32 3
  %ARRAY_HAV = alloca float, align 4
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store float 0.000000e+00, float* %ARRAY_HAV, align 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %size, align 2
  %2 = zext i16 %load_size to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = sub i64 %call1, 1
  %4 = trunc i64 %tmpVar to i16
  store i16 %4, i16* %stop, align 2
  store i16 0, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar4 = icmp sle i16 %load_i3, %load_stop
  %5 = icmp ne i1 %tmpVar4, false
  br i1 %5, label %11, label %12

for_body:                                         ; preds = %9
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i13 = load i16, i16* %i, align 2
  %6 = zext i16 %load_i13 to i32
  %tmpVar14 = mul i32 1, %6
  %tmpVar15 = add i32 %tmpVar14, 0
  %tmpVar16 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 %tmpVar15
  %load_tmpVar = load float, float* %tmpVar16, align 4
  %tmpVar17 = fcmp one float %load_tmpVar, 0.000000e+00
  br i1 %tmpVar17, label %condition_body, label %else

increment:                                        ; preds = %continue12
  %tmpVar26 = add i16 %load_i, 1
  store i16 %tmpVar26, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  %UINT_TO_REAL_instance = alloca %UINT_TO_REAL_interface, align 8
  br label %input27

7:                                                ; preds = %12
  %load_i7 = load i16, i16* %i, align 2
  %load_stop8 = load i16, i16* %stop, align 2
  %tmpVar9 = icmp sge i16 %load_i7, %load_stop8
  %8 = icmp ne i1 %tmpVar9, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_i5 = load i16, i16* %i, align 2
  %tmpVar6 = icmp sge i16 %load_i5, 0
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar4, %condition_check ], [ %tmpVar6, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_i10 = load i16, i16* %i, align 2
  %tmpVar11 = icmp sle i16 %load_i10, 0
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar9, %7 ], [ %tmpVar11, %15 ]
  br label %9

condition_body:                                   ; preds = %for_body
  %load_ARRAY_HAV = load float, float* %ARRAY_HAV, align 4
  %deref18 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i19 = load i16, i16* %i, align 2
  %18 = zext i16 %load_i19 to i32
  %tmpVar20 = mul i32 1, %18
  %tmpVar21 = add i32 %tmpVar20, 0
  %tmpVar22 = getelementptr inbounds [32001 x float], [32001 x float]* %deref18, i32 0, i32 %tmpVar21
  %load_tmpVar23 = load float, float* %tmpVar22, align 4
  %tmpVar24 = fdiv float 1.000000e+00, %load_tmpVar23
  %tmpVar25 = fadd float %load_ARRAY_HAV, %tmpVar24
  store float %tmpVar25, float* %ARRAY_HAV, align 4
  br label %continue12

else:                                             ; preds = %for_body
  store float 0.000000e+00, float* %ARRAY_HAV, align 4
  %ARRAY_HAV_ret = load float, float* %ARRAY_HAV, align 4
  ret float %ARRAY_HAV_ret

buffer_block:                                     ; No predecessors!
  br label %continue12

continue12:                                       ; preds = %buffer_block, %condition_body
  br label %increment

input27:                                          ; preds = %continue2
  %19 = getelementptr inbounds %UINT_TO_REAL_interface, %UINT_TO_REAL_interface* %UINT_TO_REAL_instance, i32 0, i32 0
  %load_stop31 = load i16, i16* %stop, align 2
  %20 = zext i16 %load_stop31 to i32
  %tmpVar32 = add i32 %20, 1
  %21 = trunc i32 %tmpVar32 to i16
  store i16 %21, i16* %19, align 2
  br label %call28

call28:                                           ; preds = %input27
  %call33 = call float @UINT_TO_REAL(%UINT_TO_REAL_interface* %UINT_TO_REAL_instance)
  br label %output29

output29:                                         ; preds = %call28
  br label %continue30

continue30:                                       ; preds = %output29
  %load_ARRAY_HAV34 = load float, float* %ARRAY_HAV, align 4
  %tmpVar35 = fdiv float %call33, %load_ARRAY_HAV34
  store float %tmpVar35, float* %ARRAY_HAV, align 4
  %ARRAY_HAV_ret36 = load float, float* %ARRAY_HAV, align 4
  ret float %ARRAY_HAV_ret36
}

define float @ARRAY_MAX(%ARRAY_MAX_interface* %0) {
entry:
  %pt = getelementptr inbounds %ARRAY_MAX_interface, %ARRAY_MAX_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %ARRAY_MAX_interface, %ARRAY_MAX_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %ARRAY_MAX_interface, %ARRAY_MAX_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %ARRAY_MAX_interface, %ARRAY_MAX_interface* %0, i32 0, i32 3
  %ARRAY_MAX = alloca float, align 4
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store float 0.000000e+00, float* %ARRAY_MAX, align 4
  %load_size = load i16, i16* %size, align 2
  %1 = zext i16 %load_size to i32
  %SIZEOF_instance = alloca %SIZEOF_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %SIZEOF_interface, %SIZEOF_interface* %SIZEOF_instance, i32 0, i32 0
  %load_pt = load [32001 x float]*, [32001 x float]** %pt, align 8
  %3 = ptrtoint [32001 x float]* %load_pt to i64
  store i64 %3, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @SIZEOF(%SIZEOF_interface* %SIZEOF_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = sext i16 %call1 to i32
  %tmpVar = sub i32 %1, %4
  %SIZEOF_instance2 = alloca %SIZEOF_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %5 = getelementptr inbounds %SIZEOF_interface, %SIZEOF_interface* %SIZEOF_instance2, i32 0, i32 0
  %load_pt7 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %6 = ptrtoint [32001 x float]* %load_pt7 to i64
  store i64 %6, i64* %5, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call i16 @SIZEOF(%SIZEOF_interface* %SIZEOF_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %7 = sext i16 %call8 to i32
  %tmpVar9 = sdiv i32 %tmpVar, %7
  %8 = trunc i32 %tmpVar9 to i16
  store i16 %8, i16* %stop, align 2
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %tmpVar10 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 0
  %load_tmpVar = load float, float* %tmpVar10, align 4
  store float %load_tmpVar, float* %ARRAY_MAX, align 4
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue6
  %load_i = load i16, i16* %i, align 2
  %load_i12 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar13 = icmp sle i16 %load_i12, %load_stop
  %9 = icmp ne i1 %tmpVar13, false
  br i1 %9, label %15, label %16

for_body:                                         ; preds = %13
  %deref22 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i23 = load i16, i16* %i, align 2
  %10 = zext i16 %load_i23 to i32
  %tmpVar24 = mul i32 1, %10
  %tmpVar25 = add i32 %tmpVar24, 0
  %tmpVar26 = getelementptr inbounds [32001 x float], [32001 x float]* %deref22, i32 0, i32 %tmpVar25
  %load_tmpVar27 = load float, float* %tmpVar26, align 4
  %load_array_max = load float, float* %ARRAY_MAX, align 4
  %tmpVar28 = fcmp ogt float %load_tmpVar27, %load_array_max
  br i1 %tmpVar28, label %condition_body, label %continue21

increment:                                        ; preds = %continue21
  %tmpVar35 = add i16 %load_i, 1
  store i16 %tmpVar35, i16* %i, align 2
  br label %condition_check

continue11:                                       ; preds = %13
  %ARRAY_MAX_ret = load float, float* %ARRAY_MAX, align 4
  ret float %ARRAY_MAX_ret

11:                                               ; preds = %16
  %load_i16 = load i16, i16* %i, align 2
  %load_stop17 = load i16, i16* %stop, align 2
  %tmpVar18 = icmp sge i16 %load_i16, %load_stop17
  %12 = icmp ne i1 %tmpVar18, false
  br i1 %12, label %19, label %20

13:                                               ; preds = %20, %16
  %14 = phi i1 [ %17, %16 ], [ %21, %20 ]
  br i1 %14, label %for_body, label %continue11

15:                                               ; preds = %condition_check
  %load_i14 = load i16, i16* %i, align 2
  %tmpVar15 = icmp sge i16 %load_i14, 1
  br label %16

16:                                               ; preds = %15, %condition_check
  %17 = phi i1 [ %tmpVar13, %condition_check ], [ %tmpVar15, %15 ]
  %18 = icmp ne i1 %17, false
  br i1 %18, label %13, label %11

19:                                               ; preds = %11
  %load_i19 = load i16, i16* %i, align 2
  %tmpVar20 = icmp sle i16 %load_i19, 1
  br label %20

20:                                               ; preds = %19, %11
  %21 = phi i1 [ %tmpVar18, %11 ], [ %tmpVar20, %19 ]
  br label %13

condition_body:                                   ; preds = %for_body
  %deref29 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i30 = load i16, i16* %i, align 2
  %22 = zext i16 %load_i30 to i32
  %tmpVar31 = mul i32 1, %22
  %tmpVar32 = add i32 %tmpVar31, 0
  %tmpVar33 = getelementptr inbounds [32001 x float], [32001 x float]* %deref29, i32 0, i32 %tmpVar32
  %load_tmpVar34 = load float, float* %tmpVar33, align 4
  store float %load_tmpVar34, float* %ARRAY_MAX, align 4
  br label %continue21

continue21:                                       ; preds = %condition_body, %for_body
  br label %increment
}

define float @ARRAY_MIN(%ARRAY_MIN_interface* %0) {
entry:
  %pt = getelementptr inbounds %ARRAY_MIN_interface, %ARRAY_MIN_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %ARRAY_MIN_interface, %ARRAY_MIN_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %ARRAY_MIN_interface, %ARRAY_MIN_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %ARRAY_MIN_interface, %ARRAY_MIN_interface* %0, i32 0, i32 3
  %ARRAY_MIN = alloca float, align 4
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store float 0.000000e+00, float* %ARRAY_MIN, align 4
  %load_size = load i16, i16* %size, align 2
  %1 = zext i16 %load_size to i32
  %SIZEOF_instance = alloca %SIZEOF_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %SIZEOF_interface, %SIZEOF_interface* %SIZEOF_instance, i32 0, i32 0
  %load_pt = load [32001 x float]*, [32001 x float]** %pt, align 8
  %3 = ptrtoint [32001 x float]* %load_pt to i64
  store i64 %3, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @SIZEOF(%SIZEOF_interface* %SIZEOF_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = sext i16 %call1 to i32
  %tmpVar = sub i32 %1, %4
  %SIZEOF_instance2 = alloca %SIZEOF_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %5 = getelementptr inbounds %SIZEOF_interface, %SIZEOF_interface* %SIZEOF_instance2, i32 0, i32 0
  %load_pt7 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %6 = ptrtoint [32001 x float]* %load_pt7 to i64
  store i64 %6, i64* %5, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call i16 @SIZEOF(%SIZEOF_interface* %SIZEOF_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %7 = sext i16 %call8 to i32
  %tmpVar9 = sdiv i32 %tmpVar, %7
  %8 = trunc i32 %tmpVar9 to i16
  store i16 %8, i16* %stop, align 2
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %tmpVar10 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 0
  %load_tmpVar = load float, float* %tmpVar10, align 4
  store float %load_tmpVar, float* %ARRAY_MIN, align 4
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue6
  %load_i = load i16, i16* %i, align 2
  %load_i12 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar13 = icmp sle i16 %load_i12, %load_stop
  %9 = icmp ne i1 %tmpVar13, false
  br i1 %9, label %15, label %16

for_body:                                         ; preds = %13
  %deref22 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i23 = load i16, i16* %i, align 2
  %10 = zext i16 %load_i23 to i32
  %tmpVar24 = mul i32 1, %10
  %tmpVar25 = add i32 %tmpVar24, 0
  %tmpVar26 = getelementptr inbounds [32001 x float], [32001 x float]* %deref22, i32 0, i32 %tmpVar25
  %load_tmpVar27 = load float, float* %tmpVar26, align 4
  %load_array_min = load float, float* %ARRAY_MIN, align 4
  %tmpVar28 = fcmp olt float %load_tmpVar27, %load_array_min
  br i1 %tmpVar28, label %condition_body, label %continue21

increment:                                        ; preds = %continue21
  %tmpVar35 = add i16 %load_i, 1
  store i16 %tmpVar35, i16* %i, align 2
  br label %condition_check

continue11:                                       ; preds = %13
  %ARRAY_MIN_ret = load float, float* %ARRAY_MIN, align 4
  ret float %ARRAY_MIN_ret

11:                                               ; preds = %16
  %load_i16 = load i16, i16* %i, align 2
  %load_stop17 = load i16, i16* %stop, align 2
  %tmpVar18 = icmp sge i16 %load_i16, %load_stop17
  %12 = icmp ne i1 %tmpVar18, false
  br i1 %12, label %19, label %20

13:                                               ; preds = %20, %16
  %14 = phi i1 [ %17, %16 ], [ %21, %20 ]
  br i1 %14, label %for_body, label %continue11

15:                                               ; preds = %condition_check
  %load_i14 = load i16, i16* %i, align 2
  %tmpVar15 = icmp sge i16 %load_i14, 1
  br label %16

16:                                               ; preds = %15, %condition_check
  %17 = phi i1 [ %tmpVar13, %condition_check ], [ %tmpVar15, %15 ]
  %18 = icmp ne i1 %17, false
  br i1 %18, label %13, label %11

19:                                               ; preds = %11
  %load_i19 = load i16, i16* %i, align 2
  %tmpVar20 = icmp sle i16 %load_i19, 1
  br label %20

20:                                               ; preds = %19, %11
  %21 = phi i1 [ %tmpVar18, %11 ], [ %tmpVar20, %19 ]
  br label %13

condition_body:                                   ; preds = %for_body
  %deref29 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i30 = load i16, i16* %i, align 2
  %22 = zext i16 %load_i30 to i32
  %tmpVar31 = mul i32 1, %22
  %tmpVar32 = add i32 %tmpVar31, 0
  %tmpVar33 = getelementptr inbounds [32001 x float], [32001 x float]* %deref29, i32 0, i32 %tmpVar32
  %load_tmpVar34 = load float, float* %tmpVar33, align 4
  store float %load_tmpVar34, float* %ARRAY_MIN, align 4
  br label %continue21

continue21:                                       ; preds = %condition_body, %for_body
  br label %increment
}

define float @ARRAY_SDV(%ARRAY_SDV_interface* %0) {
entry:
  %pt = getelementptr inbounds %ARRAY_SDV_interface, %ARRAY_SDV_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %ARRAY_SDV_interface, %ARRAY_SDV_interface* %0, i32 0, i32 1
  %ARRAY_SDV = alloca float, align 4
  store float 0.000000e+00, float* %ARRAY_SDV, align 4
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %ARRAY_VAR_instance = alloca %ARRAY_VAR_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %2 = fptrunc double %call6 to float
  store float %2, float* %ARRAY_SDV, align 4
  %ARRAY_SDV_ret = load float, float* %ARRAY_SDV, align 4
  ret float %ARRAY_SDV_ret

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %ARRAY_VAR_interface, %ARRAY_VAR_interface* %ARRAY_VAR_instance, i32 0, i32 0
  %load_pt = load [32001 x float]*, [32001 x float]** %pt, align 8
  store [32001 x float]* %load_pt, [32001 x float]** %3, align 8
  %4 = getelementptr inbounds %ARRAY_VAR_interface, %ARRAY_VAR_interface* %ARRAY_VAR_instance, i32 0, i32 1
  %load_size = load i16, i16* %size, align 2
  store i16 %load_size, i16* %4, align 2
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call float @ARRAY_VAR(%ARRAY_VAR_interface* %ARRAY_VAR_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %5 = fptosi float %call5 to i32
  store i32 %5, i32* %1, align 4
  br label %call
}

define float @ARRAY_SPR(%ARRAY_SPR_interface* %0) {
entry:
  %pt = getelementptr inbounds %ARRAY_SPR_interface, %ARRAY_SPR_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %ARRAY_SPR_interface, %ARRAY_SPR_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %ARRAY_SPR_interface, %ARRAY_SPR_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %ARRAY_SPR_interface, %ARRAY_SPR_interface* %0, i32 0, i32 3
  %array_max = getelementptr inbounds %ARRAY_SPR_interface, %ARRAY_SPR_interface* %0, i32 0, i32 4
  %array_min = getelementptr inbounds %ARRAY_SPR_interface, %ARRAY_SPR_interface* %0, i32 0, i32 5
  %ARRAY_SPR = alloca float, align 4
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store float 0.000000e+00, float* %array_max, align 4
  store float 0.000000e+00, float* %array_min, align 4
  store float 0.000000e+00, float* %ARRAY_SPR, align 4
  %load_size = load i16, i16* %size, align 2
  %1 = zext i16 %load_size to i32
  %SIZEOF_instance = alloca %SIZEOF_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %SIZEOF_interface, %SIZEOF_interface* %SIZEOF_instance, i32 0, i32 0
  %load_pt = load [32001 x float]*, [32001 x float]** %pt, align 8
  %3 = ptrtoint [32001 x float]* %load_pt to i64
  store i64 %3, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @SIZEOF(%SIZEOF_interface* %SIZEOF_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = sext i16 %call1 to i32
  %tmpVar = sub i32 %1, %4
  %SIZEOF_instance2 = alloca %SIZEOF_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %5 = getelementptr inbounds %SIZEOF_interface, %SIZEOF_interface* %SIZEOF_instance2, i32 0, i32 0
  %load_pt7 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %6 = ptrtoint [32001 x float]* %load_pt7 to i64
  store i64 %6, i64* %5, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call i16 @SIZEOF(%SIZEOF_interface* %SIZEOF_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %7 = sext i16 %call8 to i32
  %tmpVar9 = sdiv i32 %tmpVar, %7
  %8 = trunc i32 %tmpVar9 to i16
  store i16 %8, i16* %stop, align 2
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %tmpVar10 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 0
  %load_tmpVar = load float, float* %tmpVar10, align 4
  store float %load_tmpVar, float* %array_min, align 4
  %deref11 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %tmpVar12 = getelementptr inbounds [32001 x float], [32001 x float]* %deref11, i32 0, i32 0
  %load_tmpVar13 = load float, float* %tmpVar12, align 4
  store float %load_tmpVar13, float* %array_max, align 4
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue6
  %load_i = load i16, i16* %i, align 2
  %load_i15 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar16 = icmp sle i16 %load_i15, %load_stop
  %9 = icmp ne i1 %tmpVar16, false
  br i1 %9, label %15, label %16

for_body:                                         ; preds = %13
  %deref25 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i26 = load i16, i16* %i, align 2
  %10 = zext i16 %load_i26 to i32
  %tmpVar27 = mul i32 1, %10
  %tmpVar28 = add i32 %tmpVar27, 0
  %tmpVar29 = getelementptr inbounds [32001 x float], [32001 x float]* %deref25, i32 0, i32 %tmpVar28
  %load_tmpVar30 = load float, float* %tmpVar29, align 4
  %load_array_max = load float, float* %array_max, align 4
  %tmpVar31 = fcmp ogt float %load_tmpVar30, %load_array_max
  br i1 %tmpVar31, label %condition_body, label %branch

increment:                                        ; preds = %continue24
  %tmpVar52 = add i16 %load_i, 1
  store i16 %tmpVar52, i16* %i, align 2
  br label %condition_check

continue14:                                       ; preds = %13
  %load_array_max53 = load float, float* %array_max, align 4
  %load_array_min54 = load float, float* %array_min, align 4
  %tmpVar55 = fsub float %load_array_max53, %load_array_min54
  store float %tmpVar55, float* %ARRAY_SPR, align 4
  %ARRAY_SPR_ret = load float, float* %ARRAY_SPR, align 4
  ret float %ARRAY_SPR_ret

11:                                               ; preds = %16
  %load_i19 = load i16, i16* %i, align 2
  %load_stop20 = load i16, i16* %stop, align 2
  %tmpVar21 = icmp sge i16 %load_i19, %load_stop20
  %12 = icmp ne i1 %tmpVar21, false
  br i1 %12, label %19, label %20

13:                                               ; preds = %20, %16
  %14 = phi i1 [ %17, %16 ], [ %21, %20 ]
  br i1 %14, label %for_body, label %continue14

15:                                               ; preds = %condition_check
  %load_i17 = load i16, i16* %i, align 2
  %tmpVar18 = icmp sge i16 %load_i17, 1
  br label %16

16:                                               ; preds = %15, %condition_check
  %17 = phi i1 [ %tmpVar16, %condition_check ], [ %tmpVar18, %15 ]
  %18 = icmp ne i1 %17, false
  br i1 %18, label %13, label %11

19:                                               ; preds = %11
  %load_i22 = load i16, i16* %i, align 2
  %tmpVar23 = icmp sle i16 %load_i22, 1
  br label %20

20:                                               ; preds = %19, %11
  %21 = phi i1 [ %tmpVar21, %11 ], [ %tmpVar23, %19 ]
  br label %13

condition_body:                                   ; preds = %for_body
  %deref32 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i33 = load i16, i16* %i, align 2
  %22 = zext i16 %load_i33 to i32
  %tmpVar34 = mul i32 1, %22
  %tmpVar35 = add i32 %tmpVar34, 0
  %tmpVar36 = getelementptr inbounds [32001 x float], [32001 x float]* %deref32, i32 0, i32 %tmpVar35
  %load_tmpVar37 = load float, float* %tmpVar36, align 4
  store float %load_tmpVar37, float* %array_max, align 4
  br label %continue24

branch:                                           ; preds = %for_body
  %deref39 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i40 = load i16, i16* %i, align 2
  %23 = zext i16 %load_i40 to i32
  %tmpVar41 = mul i32 1, %23
  %tmpVar42 = add i32 %tmpVar41, 0
  %tmpVar43 = getelementptr inbounds [32001 x float], [32001 x float]* %deref39, i32 0, i32 %tmpVar42
  %load_tmpVar44 = load float, float* %tmpVar43, align 4
  %load_array_min = load float, float* %array_min, align 4
  %tmpVar45 = fcmp olt float %load_tmpVar44, %load_array_min
  br i1 %tmpVar45, label %condition_body38, label %continue24

condition_body38:                                 ; preds = %branch
  %deref46 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i47 = load i16, i16* %i, align 2
  %24 = zext i16 %load_i47 to i32
  %tmpVar48 = mul i32 1, %24
  %tmpVar49 = add i32 %tmpVar48, 0
  %tmpVar50 = getelementptr inbounds [32001 x float], [32001 x float]* %deref46, i32 0, i32 %tmpVar49
  %load_tmpVar51 = load float, float* %tmpVar50, align 4
  store float %load_tmpVar51, float* %array_min, align 4
  br label %continue24

continue24:                                       ; preds = %condition_body38, %branch, %condition_body
  br label %increment
}

define float @ARRAY_SUM(%ARRAY_SUM_interface* %0) {
entry:
  %pt = getelementptr inbounds %ARRAY_SUM_interface, %ARRAY_SUM_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %ARRAY_SUM_interface, %ARRAY_SUM_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %ARRAY_SUM_interface, %ARRAY_SUM_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %ARRAY_SUM_interface, %ARRAY_SUM_interface* %0, i32 0, i32 3
  %ARRAY_SUM = alloca float, align 4
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store float 0.000000e+00, float* %ARRAY_SUM, align 4
  %load_size = load i16, i16* %size, align 2
  %1 = zext i16 %load_size to i32
  %SIZEOF_instance = alloca %SIZEOF_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %SIZEOF_interface, %SIZEOF_interface* %SIZEOF_instance, i32 0, i32 0
  %load_pt = load [32001 x float]*, [32001 x float]** %pt, align 8
  %3 = ptrtoint [32001 x float]* %load_pt to i64
  store i64 %3, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @SIZEOF(%SIZEOF_interface* %SIZEOF_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = sext i16 %call1 to i32
  %tmpVar = sub i32 %1, %4
  %SIZEOF_instance2 = alloca %SIZEOF_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %5 = getelementptr inbounds %SIZEOF_interface, %SIZEOF_interface* %SIZEOF_instance2, i32 0, i32 0
  %load_pt7 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %6 = ptrtoint [32001 x float]* %load_pt7 to i64
  store i64 %6, i64* %5, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call i16 @SIZEOF(%SIZEOF_interface* %SIZEOF_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %7 = sext i16 %call8 to i32
  %tmpVar9 = sdiv i32 %tmpVar, %7
  %8 = trunc i32 %tmpVar9 to i16
  store i16 %8, i16* %stop, align 2
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %tmpVar10 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 0
  %load_tmpVar = load float, float* %tmpVar10, align 4
  store float %load_tmpVar, float* %ARRAY_SUM, align 4
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue6
  %load_i = load i16, i16* %i, align 2
  %load_i12 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar13 = icmp sle i16 %load_i12, %load_stop
  %9 = icmp ne i1 %tmpVar13, false
  br i1 %9, label %15, label %16

for_body:                                         ; preds = %13
  %load_array_sum = load float, float* %ARRAY_SUM, align 4
  %deref21 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i22 = load i16, i16* %i, align 2
  %10 = zext i16 %load_i22 to i32
  %tmpVar23 = mul i32 1, %10
  %tmpVar24 = add i32 %tmpVar23, 0
  %tmpVar25 = getelementptr inbounds [32001 x float], [32001 x float]* %deref21, i32 0, i32 %tmpVar24
  %load_tmpVar26 = load float, float* %tmpVar25, align 4
  %tmpVar27 = fadd float %load_array_sum, %load_tmpVar26
  store float %tmpVar27, float* %ARRAY_SUM, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar28 = add i16 %load_i, 1
  store i16 %tmpVar28, i16* %i, align 2
  br label %condition_check

continue11:                                       ; preds = %13
  %ARRAY_SUM_ret = load float, float* %ARRAY_SUM, align 4
  ret float %ARRAY_SUM_ret

11:                                               ; preds = %16
  %load_i16 = load i16, i16* %i, align 2
  %load_stop17 = load i16, i16* %stop, align 2
  %tmpVar18 = icmp sge i16 %load_i16, %load_stop17
  %12 = icmp ne i1 %tmpVar18, false
  br i1 %12, label %19, label %20

13:                                               ; preds = %20, %16
  %14 = phi i1 [ %17, %16 ], [ %21, %20 ]
  br i1 %14, label %for_body, label %continue11

15:                                               ; preds = %condition_check
  %load_i14 = load i16, i16* %i, align 2
  %tmpVar15 = icmp sge i16 %load_i14, 1
  br label %16

16:                                               ; preds = %15, %condition_check
  %17 = phi i1 [ %tmpVar13, %condition_check ], [ %tmpVar15, %15 ]
  %18 = icmp ne i1 %17, false
  br i1 %18, label %13, label %11

19:                                               ; preds = %11
  %load_i19 = load i16, i16* %i, align 2
  %tmpVar20 = icmp sle i16 %load_i19, 1
  br label %20

20:                                               ; preds = %19, %11
  %21 = phi i1 [ %tmpVar18, %11 ], [ %tmpVar20, %19 ]
  br label %13
}

define float @ARRAY_TREND(%ARRAY_TREND_interface* %0) {
entry:
  %pt = getelementptr inbounds %ARRAY_TREND_interface, %ARRAY_TREND_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %ARRAY_TREND_interface, %ARRAY_TREND_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %ARRAY_TREND_interface, %ARRAY_TREND_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %ARRAY_TREND_interface, %ARRAY_TREND_interface* %0, i32 0, i32 3
  %x = getelementptr inbounds %ARRAY_TREND_interface, %ARRAY_TREND_interface* %0, i32 0, i32 4
  %stop2 = getelementptr inbounds %ARRAY_TREND_interface, %ARRAY_TREND_interface* %0, i32 0, i32 5
  %ARRAY_TREND = alloca float, align 4
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store float 0.000000e+00, float* %x, align 4
  store i16 0, i16* %stop2, align 2
  store float 0.000000e+00, float* %ARRAY_TREND, align 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %size, align 2
  %2 = zext i16 %load_size to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = sub i64 %call1, 1
  %4 = trunc i64 %tmpVar to i16
  store i16 %4, i16* %stop, align 2
  %SHR_instance2 = alloca %SHR_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %5 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance2, i32 0, i32 0
  %load_stop = load i16, i16* %stop, align 2
  %6 = zext i16 %load_stop to i64
  store i64 %6, i64* %5, align 4
  %7 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance2, i32 0, i32 1
  store i16 1, i16* %7, align 2
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i64 @SHR(%SHR_interface* %SHR_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %8 = trunc i64 %call7 to i16
  store i16 %8, i16* %stop2, align 2
  store i16 0, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue6
  %load_i = load i16, i16* %i, align 2
  %load_i9 = load i16, i16* %i, align 2
  %load_stop2 = load i16, i16* %stop2, align 2
  %tmpVar10 = icmp sle i16 %load_i9, %load_stop2
  %9 = icmp ne i1 %tmpVar10, false
  br i1 %9, label %15, label %16

for_body:                                         ; preds = %13
  %load_x = load float, float* %x, align 4
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i18 = load i16, i16* %i, align 2
  %10 = zext i16 %load_i18 to i32
  %tmpVar19 = mul i32 1, %10
  %tmpVar20 = add i32 %tmpVar19, 0
  %tmpVar21 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 %tmpVar20
  %load_tmpVar = load float, float* %tmpVar21, align 4
  %tmpVar22 = fsub float %load_x, %load_tmpVar
  store float %tmpVar22, float* %x, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar23 = add i16 %load_i, 1
  store i16 %tmpVar23, i16* %i, align 2
  br label %condition_check

continue8:                                        ; preds = %13
  %EVEN_instance = alloca %EVEN_interface, align 8
  br label %input25

11:                                               ; preds = %16
  %load_i13 = load i16, i16* %i, align 2
  %load_stop214 = load i16, i16* %stop2, align 2
  %tmpVar15 = icmp sge i16 %load_i13, %load_stop214
  %12 = icmp ne i1 %tmpVar15, false
  br i1 %12, label %19, label %20

13:                                               ; preds = %20, %16
  %14 = phi i1 [ %17, %16 ], [ %21, %20 ]
  br i1 %14, label %for_body, label %continue8

15:                                               ; preds = %condition_check
  %load_i11 = load i16, i16* %i, align 2
  %tmpVar12 = icmp sge i16 %load_i11, 0
  br label %16

16:                                               ; preds = %15, %condition_check
  %17 = phi i1 [ %tmpVar10, %condition_check ], [ %tmpVar12, %15 ]
  %18 = icmp ne i1 %17, false
  br i1 %18, label %13, label %11

19:                                               ; preds = %11
  %load_i16 = load i16, i16* %i, align 2
  %tmpVar17 = icmp sle i16 %load_i16, 0
  br label %20

20:                                               ; preds = %19, %11
  %21 = phi i1 [ %tmpVar15, %11 ], [ %tmpVar17, %19 ]
  br label %13

condition_body:                                   ; preds = %continue28
  %load_stop236 = load i16, i16* %stop2, align 2
  store i16 %load_stop236, i16* %i, align 2
  br label %condition_check37

else:                                             ; preds = %continue28
  %load_stop262 = load i16, i16* %stop2, align 2
  %22 = zext i16 %load_stop262 to i32
  %tmpVar63 = add i32 %22, 1
  %23 = trunc i32 %tmpVar63 to i16
  store i16 %23, i16* %i, align 2
  br label %condition_check64

continue24:                                       ; preds = %continue67, %continue40
  %load_x92 = load float, float* %x, align 4
  %UINT_TO_REAL_instance = alloca %UINT_TO_REAL_interface, align 8
  br label %input93

input25:                                          ; preds = %continue8
  %24 = getelementptr inbounds %EVEN_interface, %EVEN_interface* %EVEN_instance, i32 0, i32 0
  %UINT_TO_INT_instance = alloca %UINT_TO_INT_interface, align 8
  br label %input29

call26:                                           ; preds = %continue32
  %call35 = call i8 @EVEN(%EVEN_interface* %EVEN_instance)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  %25 = icmp ne i8 %call35, 0
  br i1 %25, label %condition_body, label %else

input29:                                          ; preds = %input25
  %26 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance, i32 0, i32 0
  %load_stop33 = load i16, i16* %stop, align 2
  store i16 %load_stop33, i16* %26, align 2
  br label %call30

call30:                                           ; preds = %input29
  %call34 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  %27 = sext i16 %call34 to i32
  store i32 %27, i32* %24, align 4
  br label %call26

condition_check37:                                ; preds = %increment39, %condition_body
  %load_i41 = load i16, i16* %i, align 2
  %load_i42 = load i16, i16* %i, align 2
  %load_stop43 = load i16, i16* %stop, align 2
  %tmpVar44 = icmp sle i16 %load_i42, %load_stop43
  %28 = icmp ne i1 %tmpVar44, false
  br i1 %28, label %34, label %35

for_body38:                                       ; preds = %32
  %load_X = load float, float* %x, align 4
  %deref54 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i55 = load i16, i16* %i, align 2
  %29 = zext i16 %load_i55 to i32
  %tmpVar56 = mul i32 1, %29
  %tmpVar57 = add i32 %tmpVar56, 0
  %tmpVar58 = getelementptr inbounds [32001 x float], [32001 x float]* %deref54, i32 0, i32 %tmpVar57
  %load_tmpVar59 = load float, float* %tmpVar58, align 4
  %tmpVar60 = fadd float %load_X, %load_tmpVar59
  store float %tmpVar60, float* %x, align 4
  br label %increment39

increment39:                                      ; preds = %for_body38
  %tmpVar61 = add i16 %load_i41, 1
  store i16 %tmpVar61, i16* %i, align 2
  br label %condition_check37

continue40:                                       ; preds = %32
  br label %continue24

30:                                               ; preds = %35
  %load_i48 = load i16, i16* %i, align 2
  %load_stop49 = load i16, i16* %stop, align 2
  %tmpVar50 = icmp sge i16 %load_i48, %load_stop49
  %31 = icmp ne i1 %tmpVar50, false
  br i1 %31, label %38, label %39

32:                                               ; preds = %39, %35
  %33 = phi i1 [ %36, %35 ], [ %40, %39 ]
  br i1 %33, label %for_body38, label %continue40

34:                                               ; preds = %condition_check37
  %load_i45 = load i16, i16* %i, align 2
  %load_stop246 = load i16, i16* %stop2, align 2
  %tmpVar47 = icmp sge i16 %load_i45, %load_stop246
  br label %35

35:                                               ; preds = %34, %condition_check37
  %36 = phi i1 [ %tmpVar44, %condition_check37 ], [ %tmpVar47, %34 ]
  %37 = icmp ne i1 %36, false
  br i1 %37, label %32, label %30

38:                                               ; preds = %30
  %load_i51 = load i16, i16* %i, align 2
  %load_stop252 = load i16, i16* %stop2, align 2
  %tmpVar53 = icmp sle i16 %load_i51, %load_stop252
  br label %39

39:                                               ; preds = %38, %30
  %40 = phi i1 [ %tmpVar50, %30 ], [ %tmpVar53, %38 ]
  br label %32

condition_check64:                                ; preds = %increment66, %else
  %load_i68 = load i16, i16* %i, align 2
  %load_i69 = load i16, i16* %i, align 2
  %load_stop70 = load i16, i16* %stop, align 2
  %tmpVar71 = icmp sle i16 %load_i69, %load_stop70
  %41 = icmp ne i1 %tmpVar71, false
  br i1 %41, label %47, label %50

for_body65:                                       ; preds = %45
  %load_X83 = load float, float* %x, align 4
  %deref84 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i85 = load i16, i16* %i, align 2
  %42 = zext i16 %load_i85 to i32
  %tmpVar86 = mul i32 1, %42
  %tmpVar87 = add i32 %tmpVar86, 0
  %tmpVar88 = getelementptr inbounds [32001 x float], [32001 x float]* %deref84, i32 0, i32 %tmpVar87
  %load_tmpVar89 = load float, float* %tmpVar88, align 4
  %tmpVar90 = fadd float %load_X83, %load_tmpVar89
  store float %tmpVar90, float* %x, align 4
  br label %increment66

increment66:                                      ; preds = %for_body65
  %tmpVar91 = add i16 %load_i68, 1
  store i16 %tmpVar91, i16* %i, align 2
  br label %condition_check64

continue67:                                       ; preds = %45
  br label %continue24

43:                                               ; preds = %50
  %load_i76 = load i16, i16* %i, align 2
  %load_stop77 = load i16, i16* %stop, align 2
  %tmpVar78 = icmp sge i16 %load_i76, %load_stop77
  %44 = icmp ne i1 %tmpVar78, false
  br i1 %44, label %53, label %56

45:                                               ; preds = %56, %50
  %46 = phi i1 [ %51, %50 ], [ %57, %56 ]
  br i1 %46, label %for_body65, label %continue67

47:                                               ; preds = %condition_check64
  %load_i72 = load i16, i16* %i, align 2
  %load_stop273 = load i16, i16* %stop2, align 2
  %48 = zext i16 %load_stop273 to i32
  %tmpVar74 = add i32 %48, 1
  %49 = trunc i32 %tmpVar74 to i16
  %tmpVar75 = icmp sge i16 %load_i72, %49
  br label %50

50:                                               ; preds = %47, %condition_check64
  %51 = phi i1 [ %tmpVar71, %condition_check64 ], [ %tmpVar75, %47 ]
  %52 = icmp ne i1 %51, false
  br i1 %52, label %45, label %43

53:                                               ; preds = %43
  %load_i79 = load i16, i16* %i, align 2
  %load_stop280 = load i16, i16* %stop2, align 2
  %54 = zext i16 %load_stop280 to i32
  %tmpVar81 = add i32 %54, 1
  %55 = trunc i32 %tmpVar81 to i16
  %tmpVar82 = icmp sle i16 %load_i79, %55
  br label %56

56:                                               ; preds = %53, %43
  %57 = phi i1 [ %tmpVar78, %43 ], [ %tmpVar82, %53 ]
  br label %45

input93:                                          ; preds = %continue24
  %58 = getelementptr inbounds %UINT_TO_REAL_interface, %UINT_TO_REAL_interface* %UINT_TO_REAL_instance, i32 0, i32 0
  %load_stop297 = load i16, i16* %stop2, align 2
  %59 = zext i16 %load_stop297 to i32
  %tmpVar98 = add i32 %59, 1
  %60 = trunc i32 %tmpVar98 to i16
  store i16 %60, i16* %58, align 2
  br label %call94

call94:                                           ; preds = %input93
  %call99 = call float @UINT_TO_REAL(%UINT_TO_REAL_interface* %UINT_TO_REAL_instance)
  br label %output95

output95:                                         ; preds = %call94
  br label %continue96

continue96:                                       ; preds = %output95
  %tmpVar100 = fdiv float %load_x92, %call99
  store float %tmpVar100, float* %ARRAY_TREND, align 4
  %ARRAY_TREND_ret = load float, float* %ARRAY_TREND, align 4
  ret float %ARRAY_TREND_ret
}

define float @ARRAY_VAR(%ARRAY_VAR_interface* %0) {
entry:
  %pt = getelementptr inbounds %ARRAY_VAR_interface, %ARRAY_VAR_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %ARRAY_VAR_interface, %ARRAY_VAR_interface* %0, i32 0, i32 1
  %avg = getelementptr inbounds %ARRAY_VAR_interface, %ARRAY_VAR_interface* %0, i32 0, i32 2
  %i = getelementptr inbounds %ARRAY_VAR_interface, %ARRAY_VAR_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %ARRAY_VAR_interface, %ARRAY_VAR_interface* %0, i32 0, i32 4
  %ARRAY_VAR = alloca float, align 4
  store float 0.000000e+00, float* %avg, align 4
  store i16 0, i16* %i, align 2
  store i16 0, i16* %stop, align 2
  store float 0.000000e+00, float* %ARRAY_VAR, align 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %size, align 2
  %2 = zext i16 %load_size to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = sub i64 %call1, 1
  %4 = trunc i64 %tmpVar to i16
  store i16 %4, i16* %stop, align 2
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %tmpVar2 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 0
  %load_tmpVar = load float, float* %tmpVar2, align 4
  store float %load_tmpVar, float* %avg, align 4
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i4 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar5 = icmp sle i16 %load_i4, %load_stop
  %5 = icmp ne i1 %tmpVar5, false
  br i1 %5, label %11, label %12

for_body:                                         ; preds = %9
  %load_avg = load float, float* %avg, align 4
  %deref13 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i14 = load i16, i16* %i, align 2
  %6 = zext i16 %load_i14 to i32
  %tmpVar15 = mul i32 1, %6
  %tmpVar16 = add i32 %tmpVar15, 0
  %tmpVar17 = getelementptr inbounds [32001 x float], [32001 x float]* %deref13, i32 0, i32 %tmpVar16
  %load_tmpVar18 = load float, float* %tmpVar17, align 4
  %tmpVar19 = fadd float %load_avg, %load_tmpVar18
  store float %tmpVar19, float* %avg, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar20 = add i16 %load_i, 1
  store i16 %tmpVar20, i16* %i, align 2
  br label %condition_check

continue3:                                        ; preds = %9
  %load_avg21 = load float, float* %avg, align 4
  %UINT_TO_REAL_instance = alloca %UINT_TO_REAL_interface, align 8
  br label %input22

7:                                                ; preds = %12
  %load_i8 = load i16, i16* %i, align 2
  %load_stop9 = load i16, i16* %stop, align 2
  %tmpVar10 = icmp sge i16 %load_i8, %load_stop9
  %8 = icmp ne i1 %tmpVar10, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue3

11:                                               ; preds = %condition_check
  %load_i6 = load i16, i16* %i, align 2
  %tmpVar7 = icmp sge i16 %load_i6, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar5, %condition_check ], [ %tmpVar7, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_i11 = load i16, i16* %i, align 2
  %tmpVar12 = icmp sle i16 %load_i11, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar10, %7 ], [ %tmpVar12, %15 ]
  br label %9

input22:                                          ; preds = %continue3
  %18 = getelementptr inbounds %UINT_TO_REAL_interface, %UINT_TO_REAL_interface* %UINT_TO_REAL_instance, i32 0, i32 0
  %load_stop26 = load i16, i16* %stop, align 2
  %19 = zext i16 %load_stop26 to i32
  %tmpVar27 = add i32 %19, 1
  %20 = trunc i32 %tmpVar27 to i16
  store i16 %20, i16* %18, align 2
  br label %call23

call23:                                           ; preds = %input22
  %call28 = call float @UINT_TO_REAL(%UINT_TO_REAL_interface* %UINT_TO_REAL_instance)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %tmpVar29 = fdiv float %load_avg21, %call28
  store float %tmpVar29, float* %avg, align 4
  %deref30 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %tmpVar31 = getelementptr inbounds [32001 x float], [32001 x float]* %deref30, i32 0, i32 0
  %load_tmpVar32 = load float, float* %tmpVar31, align 4
  %load_avg33 = load float, float* %avg, align 4
  %tmpVar34 = fsub float %load_tmpVar32, %load_avg33
  %deref35 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %tmpVar36 = getelementptr inbounds [32001 x float], [32001 x float]* %deref35, i32 0, i32 0
  %load_tmpVar37 = load float, float* %tmpVar36, align 4
  %load_avg38 = load float, float* %avg, align 4
  %tmpVar39 = fsub float %load_tmpVar37, %load_avg38
  %tmpVar40 = fmul float %tmpVar34, %tmpVar39
  store float %tmpVar40, float* %ARRAY_VAR, align 4
  store i16 1, i16* %i, align 2
  br label %condition_check41

condition_check41:                                ; preds = %increment43, %continue25
  %load_i45 = load i16, i16* %i, align 2
  %load_i46 = load i16, i16* %i, align 2
  %load_stop47 = load i16, i16* %stop, align 2
  %tmpVar48 = icmp sle i16 %load_i46, %load_stop47
  %21 = icmp ne i1 %tmpVar48, false
  br i1 %21, label %28, label %29

for_body42:                                       ; preds = %26
  %load_array_var = load float, float* %ARRAY_VAR, align 4
  %deref56 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i57 = load i16, i16* %i, align 2
  %22 = zext i16 %load_i57 to i32
  %tmpVar58 = mul i32 1, %22
  %tmpVar59 = add i32 %tmpVar58, 0
  %tmpVar60 = getelementptr inbounds [32001 x float], [32001 x float]* %deref56, i32 0, i32 %tmpVar59
  %load_tmpVar61 = load float, float* %tmpVar60, align 4
  %load_avg62 = load float, float* %avg, align 4
  %tmpVar63 = fsub float %load_tmpVar61, %load_avg62
  %deref64 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i65 = load i16, i16* %i, align 2
  %23 = zext i16 %load_i65 to i32
  %tmpVar66 = mul i32 1, %23
  %tmpVar67 = add i32 %tmpVar66, 0
  %tmpVar68 = getelementptr inbounds [32001 x float], [32001 x float]* %deref64, i32 0, i32 %tmpVar67
  %load_tmpVar69 = load float, float* %tmpVar68, align 4
  %load_avg70 = load float, float* %avg, align 4
  %tmpVar71 = fsub float %load_tmpVar69, %load_avg70
  %tmpVar72 = fmul float %tmpVar63, %tmpVar71
  %tmpVar73 = fadd float %load_array_var, %tmpVar72
  store float %tmpVar73, float* %ARRAY_VAR, align 4
  br label %increment43

increment43:                                      ; preds = %for_body42
  %tmpVar74 = add i16 %load_i45, 1
  store i16 %tmpVar74, i16* %i, align 2
  br label %condition_check41

continue44:                                       ; preds = %26
  %load_ARRAY_VAR = load float, float* %ARRAY_VAR, align 4
  %UINT_TO_REAL_instance75 = alloca %UINT_TO_REAL_interface, align 8
  br label %input76

24:                                               ; preds = %29
  %load_i51 = load i16, i16* %i, align 2
  %load_stop52 = load i16, i16* %stop, align 2
  %tmpVar53 = icmp sge i16 %load_i51, %load_stop52
  %25 = icmp ne i1 %tmpVar53, false
  br i1 %25, label %32, label %33

26:                                               ; preds = %33, %29
  %27 = phi i1 [ %30, %29 ], [ %34, %33 ]
  br i1 %27, label %for_body42, label %continue44

28:                                               ; preds = %condition_check41
  %load_i49 = load i16, i16* %i, align 2
  %tmpVar50 = icmp sge i16 %load_i49, 1
  br label %29

29:                                               ; preds = %28, %condition_check41
  %30 = phi i1 [ %tmpVar48, %condition_check41 ], [ %tmpVar50, %28 ]
  %31 = icmp ne i1 %30, false
  br i1 %31, label %26, label %24

32:                                               ; preds = %24
  %load_i54 = load i16, i16* %i, align 2
  %tmpVar55 = icmp sle i16 %load_i54, 1
  br label %33

33:                                               ; preds = %32, %24
  %34 = phi i1 [ %tmpVar53, %24 ], [ %tmpVar55, %32 ]
  br label %26

input76:                                          ; preds = %continue44
  %35 = getelementptr inbounds %UINT_TO_REAL_interface, %UINT_TO_REAL_interface* %UINT_TO_REAL_instance75, i32 0, i32 0
  %load_stop80 = load i16, i16* %stop, align 2
  store i16 %load_stop80, i16* %35, align 2
  br label %call77

call77:                                           ; preds = %input76
  %call81 = call float @UINT_TO_REAL(%UINT_TO_REAL_interface* %UINT_TO_REAL_instance75)
  br label %output78

output78:                                         ; preds = %call77
  br label %continue79

continue79:                                       ; preds = %output78
  %tmpVar82 = fdiv float %load_ARRAY_VAR, %call81
  store float %tmpVar82, float* %ARRAY_VAR, align 4
  %ARRAY_VAR_ret = load float, float* %ARRAY_VAR, align 4
  ret float %ARRAY_VAR_ret
}

define i8 @IS_SORTED(%IS_SORTED_interface* %0) {
entry:
  %pt = getelementptr inbounds %IS_SORTED_interface, %IS_SORTED_interface* %0, i32 0, i32 0
  %size = getelementptr inbounds %IS_SORTED_interface, %IS_SORTED_interface* %0, i32 0, i32 1
  %stop = getelementptr inbounds %IS_SORTED_interface, %IS_SORTED_interface* %0, i32 0, i32 2
  %i = getelementptr inbounds %IS_SORTED_interface, %IS_SORTED_interface* %0, i32 0, i32 3
  %IS_SORTED = alloca i8, align 1
  store i16 0, i16* %stop, align 2
  store i16 0, i16* %i, align 2
  store i8 0, i8* %IS_SORTED, align 1
  %UINT_TO_INT_instance = alloca %UINT_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %UINT_TO_INT_interface, %UINT_TO_INT_interface* %UINT_TO_INT_instance, i32 0, i32 0
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i16 @UINT_TO_INT(%UINT_TO_INT_interface* %UINT_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call6, i16* %stop, align 2
  store i16 0, i16* %i, align 2
  br label %condition_check

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_size = load i16, i16* %size, align 2
  %3 = zext i16 %load_size to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %4, align 2
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = sub i64 %call5, 2
  %5 = trunc i64 %tmpVar to i16
  store i16 %5, i16* %1, align 2
  br label %call

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i8 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar9 = icmp sle i16 %load_i8, %load_stop
  %6 = icmp ne i1 %tmpVar9, false
  br i1 %6, label %13, label %14

for_body:                                         ; preds = %11
  %deref = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i18 = load i16, i16* %i, align 2
  %7 = sext i16 %load_i18 to i32
  %tmpVar19 = mul i32 1, %7
  %tmpVar20 = add i32 %tmpVar19, 0
  %tmpVar21 = getelementptr inbounds [32001 x float], [32001 x float]* %deref, i32 0, i32 %tmpVar20
  %load_tmpVar = load float, float* %tmpVar21, align 4
  %deref22 = load [32001 x float]*, [32001 x float]** %pt, align 8
  %load_i23 = load i16, i16* %i, align 2
  %8 = sext i16 %load_i23 to i32
  %tmpVar24 = add i32 %8, 1
  %tmpVar25 = mul i32 1, %tmpVar24
  %tmpVar26 = add i32 %tmpVar25, 0
  %tmpVar27 = getelementptr inbounds [32001 x float], [32001 x float]* %deref22, i32 0, i32 %tmpVar26
  %load_tmpVar28 = load float, float* %tmpVar27, align 4
  %tmpVar29 = fcmp ogt float %load_tmpVar, %load_tmpVar28
  br i1 %tmpVar29, label %condition_body, label %continue17

increment:                                        ; preds = %continue17
  %tmpVar30 = add i16 %load_i, 1
  store i16 %tmpVar30, i16* %i, align 2
  br label %condition_check

continue7:                                        ; preds = %11
  store i8 1, i8* %IS_SORTED, align 1
  %IS_SORTED_ret31 = load i8, i8* %IS_SORTED, align 1
  ret i8 %IS_SORTED_ret31

9:                                                ; preds = %14
  %load_i12 = load i16, i16* %i, align 2
  %load_stop13 = load i16, i16* %stop, align 2
  %tmpVar14 = icmp sge i16 %load_i12, %load_stop13
  %10 = icmp ne i1 %tmpVar14, false
  br i1 %10, label %17, label %18

11:                                               ; preds = %18, %14
  %12 = phi i1 [ %15, %14 ], [ %19, %18 ]
  br i1 %12, label %for_body, label %continue7

13:                                               ; preds = %condition_check
  %load_i10 = load i16, i16* %i, align 2
  %tmpVar11 = icmp sge i16 %load_i10, 0
  br label %14

14:                                               ; preds = %13, %condition_check
  %15 = phi i1 [ %tmpVar9, %condition_check ], [ %tmpVar11, %13 ]
  %16 = icmp ne i1 %15, false
  br i1 %16, label %11, label %9

17:                                               ; preds = %9
  %load_i15 = load i16, i16* %i, align 2
  %tmpVar16 = icmp sle i16 %load_i15, 0
  br label %18

18:                                               ; preds = %17, %9
  %19 = phi i1 [ %tmpVar14, %9 ], [ %tmpVar16, %17 ]
  br label %11

condition_body:                                   ; preds = %for_body
  store i8 0, i8* %IS_SORTED, align 1
  %IS_SORTED_ret = load i8, i8* %IS_SORTED, align 1
  ret i8 %IS_SORTED_ret

buffer_block:                                     ; No predecessors!
  br label %continue17

continue17:                                       ; preds = %buffer_block, %for_body
  br label %increment
}

define float @CABS(%CABS_interface* %0) {
entry:
  %X = getelementptr inbounds %CABS_interface, %CABS_interface* %0, i32 0, i32 0
  %CABS = alloca float, align 4
  store float 0.000000e+00, float* %CABS, align 4
  %HYPOT_instance = alloca %HYPOT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %HYPOT_interface, %HYPOT_interface* %HYPOT_instance, i32 0, i32 0
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re, align 4
  store float %load_, float* %1, align 4
  %2 = getelementptr inbounds %HYPOT_interface, %HYPOT_interface* %HYPOT_instance, i32 0, i32 1
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_1 = load float, float* %im, align 4
  store float %load_1, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call float @HYPOT(%HYPOT_interface* %HYPOT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call2, float* %CABS, align 4
  %CABS_ret = load float, float* %CABS, align 4
  ret float %CABS_ret
}

define %COMPLEX @CACOS(%CACOS_interface* %0) {
entry:
  %X = getelementptr inbounds %CACOS_interface, %CACOS_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %CACOS_interface, %CACOS_interface* %0, i32 0, i32 1
  %CACOS = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %Y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %2 = bitcast %COMPLEX* %CACOS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %2, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %CACOSH_instance = alloca %CACOSH_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %CACOSH_interface, %CACOSH_interface* %CACOSH_instance, i32 0, i32 0
  %load_x = load %COMPLEX, %COMPLEX* %X, align 4
  store %COMPLEX %load_x, %COMPLEX* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call %COMPLEX @CACOSH(%CACOSH_interface* %CACOSH_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store %COMPLEX %call1, %COMPLEX* %Y, align 4
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %CACOS, i32 0, i32 0
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_ = load float, float* %im, align 4
  store float %load_, float* %re, align 4
  %im2 = getelementptr inbounds %COMPLEX, %COMPLEX* %CACOS, i32 0, i32 1
  %re3 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_4 = load float, float* %re3, align 4
  %tmpVar = fneg float %load_4
  store float %tmpVar, float* %im2, align 4
  %CACOS_ret = load %COMPLEX, %COMPLEX* %CACOS, align 4
  ret %COMPLEX %CACOS_ret
}

define %COMPLEX @CACOSH(%CACOSH_interface* %0) {
entry:
  %X = getelementptr inbounds %CACOSH_interface, %CACOSH_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %CACOSH_interface, %CACOSH_interface* %0, i32 0, i32 1
  %CACOSH = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %Y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %2 = bitcast %COMPLEX* %CACOSH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %2, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %re1 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re1, align 4
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_2 = load float, float* %im, align 4
  %tmpVar = fsub float %load_, %load_2
  %re3 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_4 = load float, float* %re3, align 4
  %im5 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_6 = load float, float* %im5, align 4
  %tmpVar7 = fadd float %load_4, %load_6
  %tmpVar8 = fmul float %tmpVar, %tmpVar7
  %tmpVar9 = fsub float %tmpVar8, 1.000000e+00
  store float %tmpVar9, float* %re, align 4
  %im10 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %re11 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_12 = load float, float* %re11, align 4
  %tmpVar13 = fmul float 2.000000e+00, %load_12
  %im14 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_15 = load float, float* %im14, align 4
  %tmpVar16 = fmul float %tmpVar13, %load_15
  store float %tmpVar16, float* %im10, align 4
  %CSQRT_instance = alloca %CSQRT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %CSQRT_interface, %CSQRT_interface* %CSQRT_instance, i32 0, i32 0
  %load_y = load %COMPLEX, %COMPLEX* %Y, align 4
  store %COMPLEX %load_y, %COMPLEX* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call17 = call %COMPLEX @CSQRT(%CSQRT_interface* %CSQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store %COMPLEX %call17, %COMPLEX* %Y, align 4
  %re18 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %re19 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_20 = load float, float* %re19, align 4
  %re21 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_22 = load float, float* %re21, align 4
  %tmpVar23 = fadd float %load_20, %load_22
  store float %tmpVar23, float* %re18, align 4
  %im24 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %im25 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_26 = load float, float* %im25, align 4
  %im27 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_28 = load float, float* %im27, align 4
  %tmpVar29 = fadd float %load_26, %load_28
  store float %tmpVar29, float* %im24, align 4
  %CLOG_instance = alloca %CLOG_interface, align 8
  br label %input30

input30:                                          ; preds = %continue
  %4 = getelementptr inbounds %CLOG_interface, %CLOG_interface* %CLOG_instance, i32 0, i32 0
  %load_y34 = load %COMPLEX, %COMPLEX* %Y, align 4
  store %COMPLEX %load_y34, %COMPLEX* %4, align 4
  br label %call31

call31:                                           ; preds = %input30
  %call35 = call %COMPLEX @CLOG(%CLOG_interface* %CLOG_instance)
  br label %output32

output32:                                         ; preds = %call31
  br label %continue33

continue33:                                       ; preds = %output32
  store %COMPLEX %call35, %COMPLEX* %CACOSH, align 4
  %CACOSH_ret = load %COMPLEX, %COMPLEX* %CACOSH, align 4
  ret %COMPLEX %CACOSH_ret
}

define %COMPLEX @CADD(%CADD_interface* %0) {
entry:
  %X = getelementptr inbounds %CADD_interface, %CADD_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %CADD_interface, %CADD_interface* %0, i32 0, i32 1
  %CADD = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CADD to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %CADD, i32 0, i32 0
  %re1 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re1, align 4
  %re2 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_3 = load float, float* %re2, align 4
  %tmpVar = fadd float %load_, %load_3
  store float %tmpVar, float* %re, align 4
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %CADD, i32 0, i32 1
  %im4 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_5 = load float, float* %im4, align 4
  %im6 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_7 = load float, float* %im6, align 4
  %tmpVar8 = fadd float %load_5, %load_7
  store float %tmpVar8, float* %im, align 4
  %CADD_ret = load %COMPLEX, %COMPLEX* %CADD, align 4
  ret %COMPLEX %CADD_ret
}

define float @CARG(%CARG_interface* %0) {
entry:
  %X = getelementptr inbounds %CARG_interface, %CARG_interface* %0, i32 0, i32 0
  %CARG = alloca float, align 4
  store float 0.000000e+00, float* %CARG, align 4
  %ATAN2_instance = alloca %ATAN2_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ATAN2_interface, %ATAN2_interface* %ATAN2_instance, i32 0, i32 0
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_ = load float, float* %im, align 4
  store float %load_, float* %1, align 4
  %2 = getelementptr inbounds %ATAN2_interface, %ATAN2_interface* %ATAN2_instance, i32 0, i32 1
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_1 = load float, float* %re, align 4
  store float %load_1, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call float @ATAN2(%ATAN2_interface* %ATAN2_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call2, float* %CARG, align 4
  %CARG_ret = load float, float* %CARG, align 4
  ret float %CARG_ret
}

define %COMPLEX @CASIN(%CASIN_interface* %0) {
entry:
  %X = getelementptr inbounds %CASIN_interface, %CASIN_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %CASIN_interface, %CASIN_interface* %0, i32 0, i32 1
  %CASIN = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %Y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %2 = bitcast %COMPLEX* %CASIN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %2, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_ = load float, float* %im, align 4
  %tmpVar = fneg float %load_
  store float %tmpVar, float* %re, align 4
  %im1 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %re2 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_3 = load float, float* %re2, align 4
  store float %load_3, float* %im1, align 4
  %CASINH_instance = alloca %CASINH_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %CASINH_interface, %CASINH_interface* %CASINH_instance, i32 0, i32 0
  %load_y = load %COMPLEX, %COMPLEX* %Y, align 4
  store %COMPLEX %load_y, %COMPLEX* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call %COMPLEX @CASINH(%CASINH_interface* %CASINH_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store %COMPLEX %call4, %COMPLEX* %Y, align 4
  %re5 = getelementptr inbounds %COMPLEX, %COMPLEX* %CASIN, i32 0, i32 0
  %im6 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_7 = load float, float* %im6, align 4
  store float %load_7, float* %re5, align 4
  %im8 = getelementptr inbounds %COMPLEX, %COMPLEX* %CASIN, i32 0, i32 1
  %re9 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_10 = load float, float* %re9, align 4
  %tmpVar11 = fneg float %load_10
  store float %tmpVar11, float* %im8, align 4
  %CASIN_ret = load %COMPLEX, %COMPLEX* %CASIN, align 4
  ret %COMPLEX %CASIN_ret
}

define %COMPLEX @CASINH(%CASINH_interface* %0) {
entry:
  %X = getelementptr inbounds %CASINH_interface, %CASINH_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %CASINH_interface, %CASINH_interface* %0, i32 0, i32 1
  %CASINH = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %Y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %2 = bitcast %COMPLEX* %CASINH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %2, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %re1 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re1, align 4
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_2 = load float, float* %im, align 4
  %tmpVar = fsub float %load_, %load_2
  %re3 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_4 = load float, float* %re3, align 4
  %im5 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_6 = load float, float* %im5, align 4
  %tmpVar7 = fadd float %load_4, %load_6
  %tmpVar8 = fmul float %tmpVar, %tmpVar7
  %tmpVar9 = fadd float %tmpVar8, 1.000000e+00
  store float %tmpVar9, float* %re, align 4
  %im10 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %re11 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_12 = load float, float* %re11, align 4
  %tmpVar13 = fmul float 2.000000e+00, %load_12
  %im14 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_15 = load float, float* %im14, align 4
  %tmpVar16 = fmul float %tmpVar13, %load_15
  store float %tmpVar16, float* %im10, align 4
  %CSQRT_instance = alloca %CSQRT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %CSQRT_interface, %CSQRT_interface* %CSQRT_instance, i32 0, i32 0
  %load_y = load %COMPLEX, %COMPLEX* %Y, align 4
  store %COMPLEX %load_y, %COMPLEX* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call17 = call %COMPLEX @CSQRT(%CSQRT_interface* %CSQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store %COMPLEX %call17, %COMPLEX* %Y, align 4
  %re18 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %re19 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_20 = load float, float* %re19, align 4
  %re21 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_22 = load float, float* %re21, align 4
  %tmpVar23 = fadd float %load_20, %load_22
  store float %tmpVar23, float* %re18, align 4
  %im24 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %im25 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_26 = load float, float* %im25, align 4
  %im27 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_28 = load float, float* %im27, align 4
  %tmpVar29 = fadd float %load_26, %load_28
  store float %tmpVar29, float* %im24, align 4
  %CLOG_instance = alloca %CLOG_interface, align 8
  br label %input30

input30:                                          ; preds = %continue
  %4 = getelementptr inbounds %CLOG_interface, %CLOG_interface* %CLOG_instance, i32 0, i32 0
  %load_y34 = load %COMPLEX, %COMPLEX* %Y, align 4
  store %COMPLEX %load_y34, %COMPLEX* %4, align 4
  br label %call31

call31:                                           ; preds = %input30
  %call35 = call %COMPLEX @CLOG(%CLOG_interface* %CLOG_instance)
  br label %output32

output32:                                         ; preds = %call31
  br label %continue33

continue33:                                       ; preds = %output32
  store %COMPLEX %call35, %COMPLEX* %CASINH, align 4
  %CASINH_ret = load %COMPLEX, %COMPLEX* %CASINH, align 4
  ret %COMPLEX %CASINH_ret
}

define %COMPLEX @CATAN(%CATAN_interface* %0) {
entry:
  %X = getelementptr inbounds %CATAN_interface, %CATAN_interface* %0, i32 0, i32 0
  %r2 = getelementptr inbounds %CATAN_interface, %CATAN_interface* %0, i32 0, i32 1
  %num = getelementptr inbounds %CATAN_interface, %CATAN_interface* %0, i32 0, i32 2
  %den = getelementptr inbounds %CATAN_interface, %CATAN_interface* %0, i32 0, i32 3
  %CATAN = alloca %COMPLEX, align 8
  store float 0.000000e+00, float* %r2, align 4
  store float 0.000000e+00, float* %num, align 4
  store float 0.000000e+00, float* %den, align 4
  %1 = bitcast %COMPLEX* %CATAN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re, align 4
  %re1 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_2 = load float, float* %re1, align 4
  %tmpVar = fmul float %load_, %load_2
  store float %tmpVar, float* %r2, align 4
  %load_r2 = load float, float* %r2, align 4
  %tmpVar3 = fsub float 1.000000e+00, %load_r2
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_4 = load float, float* %im, align 4
  %im5 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_6 = load float, float* %im5, align 4
  %tmpVar7 = fmul float %load_4, %load_6
  %tmpVar8 = fsub float %tmpVar3, %tmpVar7
  store float %tmpVar8, float* %den, align 4
  %re9 = getelementptr inbounds %COMPLEX, %COMPLEX* %CATAN, i32 0, i32 0
  %ATAN_instance = alloca %ATAN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %ATAN_interface, %ATAN_interface* %ATAN_instance, i32 0, i32 0
  %re10 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_11 = load float, float* %re10, align 4
  %tmpVar12 = fmul float 2.000000e+00, %load_11
  %load_den = load float, float* %den, align 4
  %tmpVar13 = fdiv float %tmpVar12, %load_den
  %3 = fpext float %tmpVar13 to double
  store double %3, double* %2, align 8
  br label %call

call:                                             ; preds = %input
  %call14 = call double @ATAN(%ATAN_interface* %ATAN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar15 = fmul double 5.000000e-01, %call14
  %4 = fptrunc double %tmpVar15 to float
  store float %4, float* %re9, align 4
  %im16 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_17 = load float, float* %im16, align 4
  %tmpVar18 = fadd float %load_17, 1.000000e+00
  store float %tmpVar18, float* %num, align 4
  %load_r219 = load float, float* %r2, align 4
  %load_num = load float, float* %num, align 4
  %load_num20 = load float, float* %num, align 4
  %tmpVar21 = fmul float %load_num, %load_num20
  %tmpVar22 = fadd float %load_r219, %tmpVar21
  store float %tmpVar22, float* %num, align 4
  %im23 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_24 = load float, float* %im23, align 4
  %tmpVar25 = fsub float %load_24, 1.000000e+00
  store float %tmpVar25, float* %den, align 4
  %load_r226 = load float, float* %r2, align 4
  %load_den27 = load float, float* %den, align 4
  %load_den28 = load float, float* %den, align 4
  %tmpVar29 = fmul float %load_den27, %load_den28
  %tmpVar30 = fadd float %load_r226, %tmpVar29
  store float %tmpVar30, float* %den, align 4
  %im31 = getelementptr inbounds %COMPLEX, %COMPLEX* %CATAN, i32 0, i32 1
  %LN_instance = alloca %LN_interface, align 8
  br label %input32

input32:                                          ; preds = %continue
  %5 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %load_num36 = load float, float* %num, align 4
  %6 = fptosi float %load_num36 to i32
  store i32 %6, i32* %5, align 4
  br label %call33

call33:                                           ; preds = %input32
  %call37 = call double @LN(%LN_interface* %LN_instance)
  br label %output34

output34:                                         ; preds = %call33
  br label %continue35

continue35:                                       ; preds = %output34
  %LN_instance38 = alloca %LN_interface, align 8
  br label %input39

input39:                                          ; preds = %continue35
  %7 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance38, i32 0, i32 0
  %load_den43 = load float, float* %den, align 4
  %8 = fptosi float %load_den43 to i32
  store i32 %8, i32* %7, align 4
  br label %call40

call40:                                           ; preds = %input39
  %call44 = call double @LN(%LN_interface* %LN_instance38)
  br label %output41

output41:                                         ; preds = %call40
  br label %continue42

continue42:                                       ; preds = %output41
  %tmpVar45 = fsub double %call37, %call44
  %tmpVar46 = fmul double 2.500000e-01, %tmpVar45
  %9 = fptrunc double %tmpVar46 to float
  store float %9, float* %im31, align 4
  %CATAN_ret = load %COMPLEX, %COMPLEX* %CATAN, align 4
  ret %COMPLEX %CATAN_ret
}

define %COMPLEX @CATANH(%CATANH_interface* %0) {
entry:
  %X = getelementptr inbounds %CATANH_interface, %CATANH_interface* %0, i32 0, i32 0
  %i2 = getelementptr inbounds %CATANH_interface, %CATANH_interface* %0, i32 0, i32 1
  %num = getelementptr inbounds %CATANH_interface, %CATANH_interface* %0, i32 0, i32 2
  %den = getelementptr inbounds %CATANH_interface, %CATANH_interface* %0, i32 0, i32 3
  %CATANH = alloca %COMPLEX, align 8
  store float 0.000000e+00, float* %i2, align 4
  store float 0.000000e+00, float* %num, align 4
  store float 0.000000e+00, float* %den, align 4
  %1 = bitcast %COMPLEX* %CATANH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_ = load float, float* %im, align 4
  %im1 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_2 = load float, float* %im1, align 4
  %tmpVar = fmul float %load_, %load_2
  store float %tmpVar, float* %i2, align 4
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_3 = load float, float* %re, align 4
  %tmpVar4 = fadd float 1.000000e+00, %load_3
  store float %tmpVar4, float* %num, align 4
  %load_i2 = load float, float* %i2, align 4
  %load_num = load float, float* %num, align 4
  %load_num5 = load float, float* %num, align 4
  %tmpVar6 = fmul float %load_num, %load_num5
  %tmpVar7 = fadd float %load_i2, %tmpVar6
  store float %tmpVar7, float* %num, align 4
  %re8 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_9 = load float, float* %re8, align 4
  %tmpVar10 = fsub float 1.000000e+00, %load_9
  store float %tmpVar10, float* %den, align 4
  %load_i211 = load float, float* %i2, align 4
  %load_den = load float, float* %den, align 4
  %load_den12 = load float, float* %den, align 4
  %tmpVar13 = fmul float %load_den, %load_den12
  %tmpVar14 = fadd float %load_i211, %tmpVar13
  store float %tmpVar14, float* %den, align 4
  %re15 = getelementptr inbounds %COMPLEX, %COMPLEX* %CATANH, i32 0, i32 0
  %LN_instance = alloca %LN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %load_num16 = load float, float* %num, align 4
  %3 = fptosi float %load_num16 to i32
  store i32 %3, i32* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call17 = call double @LN(%LN_interface* %LN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %LN_instance18 = alloca %LN_interface, align 8
  br label %input19

input19:                                          ; preds = %continue
  %4 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance18, i32 0, i32 0
  %load_den23 = load float, float* %den, align 4
  %5 = fptosi float %load_den23 to i32
  store i32 %5, i32* %4, align 4
  br label %call20

call20:                                           ; preds = %input19
  %call24 = call double @LN(%LN_interface* %LN_instance18)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  %tmpVar25 = fsub double %call17, %call24
  %tmpVar26 = fmul double 2.500000e-01, %tmpVar25
  %6 = fptrunc double %tmpVar26 to float
  store float %6, float* %re15, align 4
  %re27 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_28 = load float, float* %re27, align 4
  %re29 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_30 = load float, float* %re29, align 4
  %tmpVar31 = fmul float %load_28, %load_30
  %tmpVar32 = fsub float 1.000000e+00, %tmpVar31
  %load_i233 = load float, float* %i2, align 4
  %tmpVar34 = fsub float %tmpVar32, %load_i233
  store float %tmpVar34, float* %den, align 4
  %im35 = getelementptr inbounds %COMPLEX, %COMPLEX* %CATANH, i32 0, i32 1
  %ATAN_instance = alloca %ATAN_interface, align 8
  br label %input36

input36:                                          ; preds = %continue22
  %7 = getelementptr inbounds %ATAN_interface, %ATAN_interface* %ATAN_instance, i32 0, i32 0
  %im40 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_41 = load float, float* %im40, align 4
  %tmpVar42 = fmul float 2.000000e+00, %load_41
  %load_den43 = load float, float* %den, align 4
  %tmpVar44 = fdiv float %tmpVar42, %load_den43
  %8 = fpext float %tmpVar44 to double
  store double %8, double* %7, align 8
  br label %call37

call37:                                           ; preds = %input36
  %call45 = call double @ATAN(%ATAN_interface* %ATAN_instance)
  br label %output38

output38:                                         ; preds = %call37
  br label %continue39

continue39:                                       ; preds = %output38
  %tmpVar46 = fmul double 5.000000e-01, %call45
  %9 = fptrunc double %tmpVar46 to float
  store float %9, float* %im35, align 4
  %CATANH_ret = load %COMPLEX, %COMPLEX* %CATANH, align 4
  ret %COMPLEX %CATANH_ret
}

define %COMPLEX @CCON(%CCON_interface* %0) {
entry:
  %X = getelementptr inbounds %CCON_interface, %CCON_interface* %0, i32 0, i32 0
  %CCON = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CCON to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %CCON, i32 0, i32 0
  %re1 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re1, align 4
  store float %load_, float* %re, align 4
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %CCON, i32 0, i32 1
  %im2 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_3 = load float, float* %im2, align 4
  %tmpVar = fneg float %load_3
  store float %tmpVar, float* %im, align 4
  %CCON_ret = load %COMPLEX, %COMPLEX* %CCON, align 4
  ret %COMPLEX %CCON_ret
}

define %COMPLEX @CCOS(%CCOS_interface* %0) {
entry:
  %X = getelementptr inbounds %CCOS_interface, %CCOS_interface* %0, i32 0, i32 0
  %CCOS = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CCOS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %CCOSH_instance = alloca %CCOSH_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %CCOSH_interface, %CCOSH_interface* %CCOSH_instance, i32 0, i32 0
  %CSET_instance = alloca %CSET_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call7 = call %COMPLEX @CCOSH(%CCOSH_interface* %CCOSH_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store %COMPLEX %call7, %COMPLEX* %CCOS, align 4
  %CCOS_ret = load %COMPLEX, %COMPLEX* %CCOS, align 4
  ret %COMPLEX %CCOS_ret

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %CSET_interface, %CSET_interface* %CSET_instance, i32 0, i32 0
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_ = load float, float* %im, align 4
  %tmpVar = fneg float %load_
  store float %tmpVar, float* %3, align 4
  %4 = getelementptr inbounds %CSET_interface, %CSET_interface* %CSET_instance, i32 0, i32 1
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_5 = load float, float* %re, align 4
  store float %load_5, float* %4, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call6 = call %COMPLEX @CSET(%CSET_interface* %CSET_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store %COMPLEX %call6, %COMPLEX* %2, align 4
  br label %call
}

define %COMPLEX @CCOSH(%CCOSH_interface* %0) {
entry:
  %X = getelementptr inbounds %CCOSH_interface, %CCOSH_interface* %0, i32 0, i32 0
  %CCOSH = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CCOSH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %CCOSH, i32 0, i32 0
  %COSH_instance = alloca %COSH_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %COSH_interface, %COSH_interface* %COSH_instance, i32 0, i32 0
  %re1 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re1, align 4
  store float %load_, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call float @COSH(%COSH_interface* %COSH_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = fpext float %call2 to double
  %COS_instance = alloca %COS_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %4 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance, i32 0, i32 0
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_7 = load float, float* %im, align 4
  %5 = fptosi float %load_7 to i32
  store i32 %5, i32* %4, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call double @COS(%COS_interface* %COS_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %tmpVar = fmul double %3, %call8
  %6 = fptrunc double %tmpVar to float
  store float %6, float* %re, align 4
  %im9 = getelementptr inbounds %COMPLEX, %COMPLEX* %CCOSH, i32 0, i32 1
  %SINH_instance = alloca %SINH_interface, align 8
  br label %input10

input10:                                          ; preds = %continue6
  %7 = getelementptr inbounds %SINH_interface, %SINH_interface* %SINH_instance, i32 0, i32 0
  %re14 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_15 = load float, float* %re14, align 4
  store float %load_15, float* %7, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call16 = call float @SINH(%SINH_interface* %SINH_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %8 = fpext float %call16 to double
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input17

input17:                                          ; preds = %continue13
  %9 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %im21 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_22 = load float, float* %im21, align 4
  %10 = fptosi float %load_22 to i32
  store i32 %10, i32* %9, align 4
  br label %call18

call18:                                           ; preds = %input17
  %call23 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %tmpVar24 = fmul double %8, %call23
  %11 = fptrunc double %tmpVar24 to float
  store float %11, float* %im9, align 4
  %CCOSH_ret = load %COMPLEX, %COMPLEX* %CCOSH, align 4
  ret %COMPLEX %CCOSH_ret
}

define %COMPLEX @CDIV(%CDIV_interface* %0) {
entry:
  %X = getelementptr inbounds %CDIV_interface, %CDIV_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %CDIV_interface, %CDIV_interface* %0, i32 0, i32 1
  %Temp = getelementptr inbounds %CDIV_interface, %CDIV_interface* %0, i32 0, i32 2
  %CDIV = alloca %COMPLEX, align 8
  store float 0.000000e+00, float* %Temp, align 4
  %1 = bitcast %COMPLEX* %CDIV to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_ = load float, float* %re, align 4
  %re1 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_2 = load float, float* %re1, align 4
  %tmpVar = fmul float %load_, %load_2
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_3 = load float, float* %im, align 4
  %im4 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_5 = load float, float* %im4, align 4
  %tmpVar6 = fmul float %load_3, %load_5
  %tmpVar7 = fadd float %tmpVar, %tmpVar6
  store float %tmpVar7, float* %Temp, align 4
  %re8 = getelementptr inbounds %COMPLEX, %COMPLEX* %CDIV, i32 0, i32 0
  %re9 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_10 = load float, float* %re9, align 4
  %re11 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_12 = load float, float* %re11, align 4
  %tmpVar13 = fmul float %load_10, %load_12
  %im14 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_15 = load float, float* %im14, align 4
  %im16 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_17 = load float, float* %im16, align 4
  %tmpVar18 = fmul float %load_15, %load_17
  %tmpVar19 = fadd float %tmpVar13, %tmpVar18
  %load_temp = load float, float* %Temp, align 4
  %tmpVar20 = fdiv float %tmpVar19, %load_temp
  store float %tmpVar20, float* %re8, align 4
  %im21 = getelementptr inbounds %COMPLEX, %COMPLEX* %CDIV, i32 0, i32 1
  %im22 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_23 = load float, float* %im22, align 4
  %re24 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_25 = load float, float* %re24, align 4
  %tmpVar26 = fmul float %load_23, %load_25
  %re27 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_28 = load float, float* %re27, align 4
  %im29 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_30 = load float, float* %im29, align 4
  %tmpVar31 = fmul float %load_28, %load_30
  %tmpVar32 = fsub float %tmpVar26, %tmpVar31
  %load_temp33 = load float, float* %Temp, align 4
  %tmpVar34 = fdiv float %tmpVar32, %load_temp33
  store float %tmpVar34, float* %im21, align 4
  %CDIV_ret = load %COMPLEX, %COMPLEX* %CDIV, align 4
  ret %COMPLEX %CDIV_ret
}

define %COMPLEX @CEXP(%CEXP_interface* %0) {
entry:
  %X = getelementptr inbounds %CEXP_interface, %CEXP_interface* %0, i32 0, i32 0
  %Temp = getelementptr inbounds %CEXP_interface, %CEXP_interface* %0, i32 0, i32 1
  %CEXP = alloca %COMPLEX, align 8
  store float 0.000000e+00, float* %Temp, align 4
  %1 = bitcast %COMPLEX* %CEXP to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re, align 4
  %3 = fptosi float %load_ to i32
  store i32 %3, i32* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = fptrunc double %call1 to float
  store float %4, float* %Temp, align 4
  %re2 = getelementptr inbounds %COMPLEX, %COMPLEX* %CEXP, i32 0, i32 0
  %load_temp = load float, float* %Temp, align 4
  %5 = fpext float %load_temp to double
  %COS_instance = alloca %COS_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %6 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance, i32 0, i32 0
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_7 = load float, float* %im, align 4
  %7 = fptosi float %load_7 to i32
  store i32 %7, i32* %6, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call double @COS(%COS_interface* %COS_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %tmpVar = fmul double %5, %call8
  %8 = fptrunc double %tmpVar to float
  store float %8, float* %re2, align 4
  %im9 = getelementptr inbounds %COMPLEX, %COMPLEX* %CEXP, i32 0, i32 1
  %load_temp10 = load float, float* %Temp, align 4
  %9 = fpext float %load_temp10 to double
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input11

input11:                                          ; preds = %continue6
  %10 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %im15 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_16 = load float, float* %im15, align 4
  %11 = fptosi float %load_16 to i32
  store i32 %11, i32* %10, align 4
  br label %call12

call12:                                           ; preds = %input11
  %call17 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %tmpVar18 = fmul double %9, %call17
  %12 = fptrunc double %tmpVar18 to float
  store float %12, float* %im9, align 4
  %CEXP_ret = load %COMPLEX, %COMPLEX* %CEXP, align 4
  ret %COMPLEX %CEXP_ret
}

define %COMPLEX @CINV(%CINV_interface* %0) {
entry:
  %X = getelementptr inbounds %CINV_interface, %CINV_interface* %0, i32 0, i32 0
  %temp = getelementptr inbounds %CINV_interface, %CINV_interface* %0, i32 0, i32 1
  %CINV = alloca %COMPLEX, align 8
  store float 0.000000e+00, float* %temp, align 4
  %1 = bitcast %COMPLEX* %CINV to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re, align 4
  %re1 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_2 = load float, float* %re1, align 4
  %tmpVar = fmul float %load_, %load_2
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_3 = load float, float* %im, align 4
  %im4 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_5 = load float, float* %im4, align 4
  %tmpVar6 = fmul float %load_3, %load_5
  %tmpVar7 = fadd float %tmpVar, %tmpVar6
  store float %tmpVar7, float* %temp, align 4
  %re8 = getelementptr inbounds %COMPLEX, %COMPLEX* %CINV, i32 0, i32 0
  %re9 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_10 = load float, float* %re9, align 4
  %load_temp = load float, float* %temp, align 4
  %tmpVar11 = fdiv float %load_10, %load_temp
  store float %tmpVar11, float* %re8, align 4
  %im12 = getelementptr inbounds %COMPLEX, %COMPLEX* %CINV, i32 0, i32 1
  %im13 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_14 = load float, float* %im13, align 4
  %tmpVar15 = fneg float %load_14
  %load_temp16 = load float, float* %temp, align 4
  %tmpVar17 = fdiv float %tmpVar15, %load_temp16
  store float %tmpVar17, float* %im12, align 4
  %CINV_ret = load %COMPLEX, %COMPLEX* %CINV, align 4
  ret %COMPLEX %CINV_ret
}

define %COMPLEX @CLOG(%CLOG_interface* %0) {
entry:
  %X = getelementptr inbounds %CLOG_interface, %CLOG_interface* %0, i32 0, i32 0
  %CLOG = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CLOG to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %CLOG, i32 0, i32 0
  %LN_instance = alloca %LN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %HYPOT_instance = alloca %HYPOT_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call8 = call double @LN(%LN_interface* %LN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = fptrunc double %call8 to float
  store float %3, float* %re, align 4
  %im9 = getelementptr inbounds %COMPLEX, %COMPLEX* %CLOG, i32 0, i32 1
  %ATAN2_instance = alloca %ATAN2_interface, align 8
  br label %input10

input1:                                           ; preds = %input
  %4 = getelementptr inbounds %HYPOT_interface, %HYPOT_interface* %HYPOT_instance, i32 0, i32 0
  %re5 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re5, align 4
  store float %load_, float* %4, align 4
  %5 = getelementptr inbounds %HYPOT_interface, %HYPOT_interface* %HYPOT_instance, i32 0, i32 1
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_6 = load float, float* %im, align 4
  store float %load_6, float* %5, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call7 = call float @HYPOT(%HYPOT_interface* %HYPOT_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %6 = fptosi float %call7 to i32
  store i32 %6, i32* %2, align 4
  br label %call

input10:                                          ; preds = %continue
  %7 = getelementptr inbounds %ATAN2_interface, %ATAN2_interface* %ATAN2_instance, i32 0, i32 0
  %im14 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_15 = load float, float* %im14, align 4
  store float %load_15, float* %7, align 4
  %8 = getelementptr inbounds %ATAN2_interface, %ATAN2_interface* %ATAN2_instance, i32 0, i32 1
  %re16 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_17 = load float, float* %re16, align 4
  store float %load_17, float* %8, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call18 = call float @ATAN2(%ATAN2_interface* %ATAN2_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  store float %call18, float* %im9, align 4
  %CLOG_ret = load %COMPLEX, %COMPLEX* %CLOG, align 4
  ret %COMPLEX %CLOG_ret
}

define %COMPLEX @CMUL(%CMUL_interface* %0) {
entry:
  %X = getelementptr inbounds %CMUL_interface, %CMUL_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %CMUL_interface, %CMUL_interface* %0, i32 0, i32 1
  %CMUL = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CMUL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %CMUL, i32 0, i32 0
  %re1 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re1, align 4
  %re2 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_3 = load float, float* %re2, align 4
  %tmpVar = fmul float %load_, %load_3
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_4 = load float, float* %im, align 4
  %im5 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_6 = load float, float* %im5, align 4
  %tmpVar7 = fmul float %load_4, %load_6
  %tmpVar8 = fsub float %tmpVar, %tmpVar7
  store float %tmpVar8, float* %re, align 4
  %im9 = getelementptr inbounds %COMPLEX, %COMPLEX* %CMUL, i32 0, i32 1
  %re10 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_11 = load float, float* %re10, align 4
  %im12 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_13 = load float, float* %im12, align 4
  %tmpVar14 = fmul float %load_11, %load_13
  %im15 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_16 = load float, float* %im15, align 4
  %re17 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_18 = load float, float* %re17, align 4
  %tmpVar19 = fmul float %load_16, %load_18
  %tmpVar20 = fadd float %tmpVar14, %tmpVar19
  store float %tmpVar20, float* %im9, align 4
  %CMUL_ret = load %COMPLEX, %COMPLEX* %CMUL, align 4
  ret %COMPLEX %CMUL_ret
}

define %COMPLEX @CPOL(%CPOL_interface* %0) {
entry:
  %L = getelementptr inbounds %CPOL_interface, %CPOL_interface* %0, i32 0, i32 0
  %A = getelementptr inbounds %CPOL_interface, %CPOL_interface* %0, i32 0, i32 1
  %CPOL = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CPOL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %CPOL, i32 0, i32 0
  %load_L = load float, float* %L, align 4
  %2 = fpext float %load_L to double
  %COS_instance = alloca %COS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance, i32 0, i32 0
  %load_A = load float, float* %A, align 4
  %4 = fptosi float %load_A to i32
  store i32 %4, i32* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call double @COS(%COS_interface* %COS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = fmul double %2, %call1
  %5 = fptrunc double %tmpVar to float
  store float %5, float* %re, align 4
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %CPOL, i32 0, i32 1
  %load_L2 = load float, float* %L, align 4
  %6 = fpext float %load_L2 to double
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %7 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %load_A7 = load float, float* %A, align 4
  %8 = fptosi float %load_A7 to i32
  store i32 %8, i32* %7, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %tmpVar9 = fmul double %6, %call8
  %9 = fptrunc double %tmpVar9 to float
  store float %9, float* %im, align 4
  %CPOL_ret = load %COMPLEX, %COMPLEX* %CPOL, align 4
  ret %COMPLEX %CPOL_ret
}

define %COMPLEX @CPOW(%CPOW_interface* %0) {
entry:
  %X = getelementptr inbounds %CPOW_interface, %CPOW_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %CPOW_interface, %CPOW_interface* %0, i32 0, i32 1
  %CPOW = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CPOW to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %CEXP_instance = alloca %CEXP_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %CEXP_interface, %CEXP_interface* %CEXP_instance, i32 0, i32 0
  %CMUL_instance = alloca %CMUL_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call11 = call %COMPLEX @CEXP(%CEXP_interface* %CEXP_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store %COMPLEX %call11, %COMPLEX* %CPOW, align 4
  %CPOW_ret = load %COMPLEX, %COMPLEX* %CPOW, align 4
  ret %COMPLEX %CPOW_ret

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %CMUL_interface, %CMUL_interface* %CMUL_instance, i32 0, i32 0
  %load_Y = load %COMPLEX, %COMPLEX* %Y, align 4
  store %COMPLEX %load_Y, %COMPLEX* %3, align 4
  %4 = getelementptr inbounds %CMUL_interface, %CMUL_interface* %CMUL_instance, i32 0, i32 1
  %CLOG_instance = alloca %CLOG_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  %call10 = call %COMPLEX @CMUL(%CMUL_interface* %CMUL_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store %COMPLEX %call10, %COMPLEX* %2, align 4
  br label %call

input5:                                           ; preds = %input1
  %5 = getelementptr inbounds %CLOG_interface, %CLOG_interface* %CLOG_instance, i32 0, i32 0
  %load_X = load %COMPLEX, %COMPLEX* %X, align 4
  store %COMPLEX %load_X, %COMPLEX* %5, align 4
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call %COMPLEX @CLOG(%CLOG_interface* %CLOG_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  store %COMPLEX %call9, %COMPLEX* %4, align 4
  br label %call2
}

define %COMPLEX @CSET(%CSET_interface* %0) {
entry:
  %RE = getelementptr inbounds %CSET_interface, %CSET_interface* %0, i32 0, i32 0
  %IM = getelementptr inbounds %CSET_interface, %CSET_interface* %0, i32 0, i32 1
  %CSET = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CSET to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %CSET, i32 0, i32 0
  %load_RE = load float, float* %RE, align 4
  store float %load_RE, float* %re, align 4
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %CSET, i32 0, i32 1
  %load_IM = load float, float* %IM, align 4
  store float %load_IM, float* %im, align 4
  %CSET_ret = load %COMPLEX, %COMPLEX* %CSET, align 4
  ret %COMPLEX %CSET_ret
}

define %COMPLEX @CSIN(%CSIN_interface* %0) {
entry:
  %X = getelementptr inbounds %CSIN_interface, %CSIN_interface* %0, i32 0, i32 0
  %CSIN = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CSIN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %CSIN, i32 0, i32 0
  %COSH_instance = alloca %COSH_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %COSH_interface, %COSH_interface* %COSH_instance, i32 0, i32 0
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_ = load float, float* %im, align 4
  store float %load_, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @COSH(%COSH_interface* %COSH_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = fpext float %call1 to double
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %4 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %re6 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_7 = load float, float* %re6, align 4
  %5 = fptosi float %load_7 to i32
  store i32 %5, i32* %4, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call8 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %tmpVar = fmul double %3, %call8
  %6 = fptrunc double %tmpVar to float
  store float %6, float* %re, align 4
  %im9 = getelementptr inbounds %COMPLEX, %COMPLEX* %CSIN, i32 0, i32 1
  %SINH_instance = alloca %SINH_interface, align 8
  br label %input10

input10:                                          ; preds = %continue5
  %7 = getelementptr inbounds %SINH_interface, %SINH_interface* %SINH_instance, i32 0, i32 0
  %im14 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_15 = load float, float* %im14, align 4
  store float %load_15, float* %7, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call16 = call float @SINH(%SINH_interface* %SINH_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %8 = fpext float %call16 to double
  %COS_instance = alloca %COS_interface, align 8
  br label %input17

input17:                                          ; preds = %continue13
  %9 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance, i32 0, i32 0
  %re21 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_22 = load float, float* %re21, align 4
  %10 = fptosi float %load_22 to i32
  store i32 %10, i32* %9, align 4
  br label %call18

call18:                                           ; preds = %input17
  %call23 = call double @COS(%COS_interface* %COS_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %tmpVar24 = fmul double %8, %call23
  %11 = fptrunc double %tmpVar24 to float
  store float %11, float* %im9, align 4
  %CSIN_ret = load %COMPLEX, %COMPLEX* %CSIN, align 4
  ret %COMPLEX %CSIN_ret
}

define %COMPLEX @CSINH(%CSINH_interface* %0) {
entry:
  %X = getelementptr inbounds %CSINH_interface, %CSINH_interface* %0, i32 0, i32 0
  %CSINH = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CSINH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %CSINH, i32 0, i32 0
  %SINH_instance = alloca %SINH_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %SINH_interface, %SINH_interface* %SINH_instance, i32 0, i32 0
  %re1 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re1, align 4
  store float %load_, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call float @SINH(%SINH_interface* %SINH_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = fpext float %call2 to double
  %COS_instance = alloca %COS_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %4 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance, i32 0, i32 0
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_7 = load float, float* %im, align 4
  %5 = fptosi float %load_7 to i32
  store i32 %5, i32* %4, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call double @COS(%COS_interface* %COS_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %tmpVar = fmul double %3, %call8
  %6 = fptrunc double %tmpVar to float
  store float %6, float* %re, align 4
  %im9 = getelementptr inbounds %COMPLEX, %COMPLEX* %CSINH, i32 0, i32 1
  %COSH_instance = alloca %COSH_interface, align 8
  br label %input10

input10:                                          ; preds = %continue6
  %7 = getelementptr inbounds %COSH_interface, %COSH_interface* %COSH_instance, i32 0, i32 0
  %re14 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_15 = load float, float* %re14, align 4
  store float %load_15, float* %7, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call16 = call float @COSH(%COSH_interface* %COSH_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %8 = fpext float %call16 to double
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input17

input17:                                          ; preds = %continue13
  %9 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %im21 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_22 = load float, float* %im21, align 4
  %10 = fptosi float %load_22 to i32
  store i32 %10, i32* %9, align 4
  br label %call18

call18:                                           ; preds = %input17
  %call23 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %tmpVar24 = fmul double %8, %call23
  %11 = fptrunc double %tmpVar24 to float
  store float %11, float* %im9, align 4
  %CSINH_ret = load %COMPLEX, %COMPLEX* %CSINH, align 4
  ret %COMPLEX %CSINH_ret
}

define %COMPLEX @CSQRT(%CSQRT_interface* %0) {
entry:
  %X = getelementptr inbounds %CSQRT_interface, %CSQRT_interface* %0, i32 0, i32 0
  %temp = getelementptr inbounds %CSQRT_interface, %CSQRT_interface* %0, i32 0, i32 1
  %CSQRT = alloca %COMPLEX, align 8
  store float 0.000000e+00, float* %temp, align 4
  %1 = bitcast %COMPLEX* %CSQRT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %HYPOT_instance = alloca %HYPOT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %HYPOT_interface, %HYPOT_interface* %HYPOT_instance, i32 0, i32 0
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re, align 4
  store float %load_, float* %2, align 4
  %3 = getelementptr inbounds %HYPOT_interface, %HYPOT_interface* %HYPOT_instance, i32 0, i32 1
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_1 = load float, float* %im, align 4
  store float %load_1, float* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call float @HYPOT(%HYPOT_interface* %HYPOT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call2, float* %temp, align 4
  %re3 = getelementptr inbounds %COMPLEX, %COMPLEX* %CSQRT, i32 0, i32 0
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input4

input4:                                           ; preds = %continue
  %4 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_temp = load float, float* %temp, align 4
  %re8 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_9 = load float, float* %re8, align 4
  %tmpVar = fadd float %load_temp, %load_9
  %tmpVar10 = fmul float 5.000000e-01, %tmpVar
  %5 = fptosi float %tmpVar10 to i32
  store i32 %5, i32* %4, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call11 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %6 = fptrunc double %call11 to float
  store float %6, float* %re3, align 4
  %im12 = getelementptr inbounds %COMPLEX, %COMPLEX* %CSQRT, i32 0, i32 1
  %SGN_instance = alloca %SGN_interface, align 8
  br label %input13

input13:                                          ; preds = %continue7
  %7 = getelementptr inbounds %SGN_interface, %SGN_interface* %SGN_instance, i32 0, i32 0
  %im17 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_18 = load float, float* %im17, align 4
  store float %load_18, float* %7, align 4
  br label %call14

call14:                                           ; preds = %input13
  %call19 = call i16 @SGN(%SGN_interface* %SGN_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %8 = sitofp i16 %call19 to double
  %SQRT_instance20 = alloca %SQRT_interface, align 8
  br label %input21

input21:                                          ; preds = %continue16
  %9 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance20, i32 0, i32 0
  %load_temp25 = load float, float* %temp, align 4
  %re26 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_27 = load float, float* %re26, align 4
  %tmpVar28 = fsub float %load_temp25, %load_27
  %tmpVar29 = fmul float 5.000000e-01, %tmpVar28
  %10 = fptosi float %tmpVar29 to i32
  store i32 %10, i32* %9, align 4
  br label %call22

call22:                                           ; preds = %input21
  %call30 = call double @SQRT(%SQRT_interface* %SQRT_instance20)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %tmpVar31 = fmul double %8, %call30
  %11 = fptrunc double %tmpVar31 to float
  store float %11, float* %im12, align 4
  %CSQRT_ret = load %COMPLEX, %COMPLEX* %CSQRT, align 4
  ret %COMPLEX %CSQRT_ret
}

define %COMPLEX @CSUB(%CSUB_interface* %0) {
entry:
  %X = getelementptr inbounds %CSUB_interface, %CSUB_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %CSUB_interface, %CSUB_interface* %0, i32 0, i32 1
  %CSUB = alloca %COMPLEX, align 8
  %1 = bitcast %COMPLEX* %CSUB to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %CSUB, i32 0, i32 0
  %re1 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_ = load float, float* %re1, align 4
  %re2 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 0
  %load_3 = load float, float* %re2, align 4
  %tmpVar = fsub float %load_, %load_3
  store float %tmpVar, float* %re, align 4
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %CSUB, i32 0, i32 1
  %im4 = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_5 = load float, float* %im4, align 4
  %im6 = getelementptr inbounds %COMPLEX, %COMPLEX* %Y, i32 0, i32 1
  %load_7 = load float, float* %im6, align 4
  %tmpVar8 = fsub float %load_5, %load_7
  store float %tmpVar8, float* %im, align 4
  %CSUB_ret = load %COMPLEX, %COMPLEX* %CSUB, align 4
  ret %COMPLEX %CSUB_ret
}

define %COMPLEX @CTAN(%CTAN_interface* %0) {
entry:
  %X = getelementptr inbounds %CTAN_interface, %CTAN_interface* %0, i32 0, i32 0
  %temp = getelementptr inbounds %CTAN_interface, %CTAN_interface* %0, i32 0, i32 1
  %xi2 = getelementptr inbounds %CTAN_interface, %CTAN_interface* %0, i32 0, i32 2
  %xr2 = getelementptr inbounds %CTAN_interface, %CTAN_interface* %0, i32 0, i32 3
  %CTAN = alloca %COMPLEX, align 8
  store float 0.000000e+00, float* %temp, align 4
  store float 0.000000e+00, float* %xi2, align 4
  store float 0.000000e+00, float* %xr2, align 4
  %1 = bitcast %COMPLEX* %CTAN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_ = load float, float* %im, align 4
  %tmpVar = fmul float 2.000000e+00, %load_
  store float %tmpVar, float* %xi2, align 4
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_1 = load float, float* %re, align 4
  %tmpVar2 = fmul float 2.000000e+00, %load_1
  store float %tmpVar2, float* %xr2, align 4
  %COS_instance = alloca %COS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance, i32 0, i32 0
  %load_xr2 = load float, float* %xr2, align 4
  %3 = fptosi float %load_xr2 to i32
  store i32 %3, i32* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call3 = call double @COS(%COS_interface* %COS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %COSH_instance = alloca %COSH_interface, align 8
  br label %input4

input4:                                           ; preds = %continue
  %4 = getelementptr inbounds %COSH_interface, %COSH_interface* %COSH_instance, i32 0, i32 0
  %load_xi2 = load float, float* %xi2, align 4
  store float %load_xi2, float* %4, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call float @COSH(%COSH_interface* %COSH_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %5 = fpext float %call8 to double
  %tmpVar9 = fadd double %call3, %5
  %tmpVar10 = fdiv double 1.000000e+00, %tmpVar9
  %6 = fptrunc double %tmpVar10 to float
  store float %6, float* %temp, align 4
  %re11 = getelementptr inbounds %COMPLEX, %COMPLEX* %CTAN, i32 0, i32 0
  %load_temp = load float, float* %temp, align 4
  %7 = fpext float %load_temp to double
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input12

input12:                                          ; preds = %continue7
  %8 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %load_xr216 = load float, float* %xr2, align 4
  %9 = fptosi float %load_xr216 to i32
  store i32 %9, i32* %8, align 4
  br label %call13

call13:                                           ; preds = %input12
  %call17 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %tmpVar18 = fmul double %7, %call17
  %10 = fptrunc double %tmpVar18 to float
  store float %10, float* %re11, align 4
  %im19 = getelementptr inbounds %COMPLEX, %COMPLEX* %CTAN, i32 0, i32 1
  %load_temp20 = load float, float* %temp, align 4
  %SINH_instance = alloca %SINH_interface, align 8
  br label %input21

input21:                                          ; preds = %continue15
  %11 = getelementptr inbounds %SINH_interface, %SINH_interface* %SINH_instance, i32 0, i32 0
  %load_xi225 = load float, float* %xi2, align 4
  store float %load_xi225, float* %11, align 4
  br label %call22

call22:                                           ; preds = %input21
  %call26 = call float @SINH(%SINH_interface* %SINH_instance)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %tmpVar27 = fmul float %load_temp20, %call26
  store float %tmpVar27, float* %im19, align 4
  %CTAN_ret = load %COMPLEX, %COMPLEX* %CTAN, align 4
  ret %COMPLEX %CTAN_ret
}

define %COMPLEX @CTANH(%CTANH_interface* %0) {
entry:
  %X = getelementptr inbounds %CTANH_interface, %CTANH_interface* %0, i32 0, i32 0
  %temp = getelementptr inbounds %CTANH_interface, %CTANH_interface* %0, i32 0, i32 1
  %xi2 = getelementptr inbounds %CTANH_interface, %CTANH_interface* %0, i32 0, i32 2
  %xr2 = getelementptr inbounds %CTANH_interface, %CTANH_interface* %0, i32 0, i32 3
  %CTANH = alloca %COMPLEX, align 8
  store float 0.000000e+00, float* %temp, align 4
  store float 0.000000e+00, float* %xi2, align 4
  store float 0.000000e+00, float* %xr2, align 4
  %1 = bitcast %COMPLEX* %CTANH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%COMPLEX* @COMPLEX__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %im = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 1
  %load_ = load float, float* %im, align 4
  %tmpVar = fmul float 2.000000e+00, %load_
  store float %tmpVar, float* %xi2, align 4
  %re = getelementptr inbounds %COMPLEX, %COMPLEX* %X, i32 0, i32 0
  %load_1 = load float, float* %re, align 4
  %tmpVar2 = fmul float 2.000000e+00, %load_1
  store float %tmpVar2, float* %xr2, align 4
  %COSH_instance = alloca %COSH_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %COSH_interface, %COSH_interface* %COSH_instance, i32 0, i32 0
  %load_xr2 = load float, float* %xr2, align 4
  store float %load_xr2, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call3 = call float @COSH(%COSH_interface* %COSH_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = fpext float %call3 to double
  %COS_instance = alloca %COS_interface, align 8
  br label %input4

input4:                                           ; preds = %continue
  %4 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance, i32 0, i32 0
  %load_xi2 = load float, float* %xi2, align 4
  %5 = fptosi float %load_xi2 to i32
  store i32 %5, i32* %4, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call double @COS(%COS_interface* %COS_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %tmpVar9 = fadd double %3, %call8
  %tmpVar10 = fdiv double 1.000000e+00, %tmpVar9
  %6 = fptrunc double %tmpVar10 to float
  store float %6, float* %temp, align 4
  %re11 = getelementptr inbounds %COMPLEX, %COMPLEX* %CTANH, i32 0, i32 0
  %load_temp = load float, float* %temp, align 4
  %SINH_instance = alloca %SINH_interface, align 8
  br label %input12

input12:                                          ; preds = %continue7
  %7 = getelementptr inbounds %SINH_interface, %SINH_interface* %SINH_instance, i32 0, i32 0
  %load_xr216 = load float, float* %xr2, align 4
  store float %load_xr216, float* %7, align 4
  br label %call13

call13:                                           ; preds = %input12
  %call17 = call float @SINH(%SINH_interface* %SINH_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %tmpVar18 = fmul float %load_temp, %call17
  store float %tmpVar18, float* %re11, align 4
  %im19 = getelementptr inbounds %COMPLEX, %COMPLEX* %CTANH, i32 0, i32 1
  %load_temp20 = load float, float* %temp, align 4
  %8 = fpext float %load_temp20 to double
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input21

input21:                                          ; preds = %continue15
  %9 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %load_xi225 = load float, float* %xi2, align 4
  %10 = fptosi float %load_xi225 to i32
  store i32 %10, i32* %9, align 4
  br label %call22

call22:                                           ; preds = %input21
  %call26 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %tmpVar27 = fmul double %8, %call26
  %11 = fptrunc double %tmpVar27 to float
  store float %11, float* %im19, align 4
  %CTANH_ret = load %COMPLEX, %COMPLEX* %CTANH, align 4
  ret %COMPLEX %CTANH_ret
}

define %REAL2 @R2_ABS(%R2_ABS_interface* %0) {
entry:
  %X = getelementptr inbounds %R2_ABS_interface, %R2_ABS_interface* %0, i32 0, i32 0
  %R2_ABS = alloca %REAL2, align 8
  %1 = bitcast %REAL2* %R2_ABS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%REAL2* @REAL2__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %RX = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 1
  %load_ = load float, float* %RX, align 4
  %tmpVar = fcmp oge float %load_, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %RX1 = getelementptr inbounds %REAL2, %REAL2* %R2_ABS, i32 0, i32 1
  %RX2 = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 1
  %load_3 = load float, float* %RX2, align 4
  store float %load_3, float* %RX1, align 4
  %R1 = getelementptr inbounds %REAL2, %REAL2* %R2_ABS, i32 0, i32 0
  %R14 = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 0
  %load_5 = load float, float* %R14, align 4
  store float %load_5, float* %R1, align 4
  br label %continue

else:                                             ; preds = %entry
  %RX6 = getelementptr inbounds %REAL2, %REAL2* %R2_ABS, i32 0, i32 1
  %RX7 = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 1
  %load_8 = load float, float* %RX7, align 4
  %tmpVar9 = fneg float %load_8
  store float %tmpVar9, float* %RX6, align 4
  %R110 = getelementptr inbounds %REAL2, %REAL2* %R2_ABS, i32 0, i32 0
  %R111 = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 0
  %load_12 = load float, float* %R111, align 4
  %tmpVar13 = fneg float %load_12
  store float %tmpVar13, float* %R110, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body
  %R2_ABS_ret = load %REAL2, %REAL2* %R2_ABS, align 4
  ret %REAL2 %R2_ABS_ret
}

define %REAL2 @R2_ADD(%R2_ADD_interface* %0) {
entry:
  %X = getelementptr inbounds %R2_ADD_interface, %R2_ADD_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %R2_ADD_interface, %R2_ADD_interface* %0, i32 0, i32 1
  %temp = getelementptr inbounds %R2_ADD_interface, %R2_ADD_interface* %0, i32 0, i32 2
  %R2_ADD = alloca %REAL2, align 8
  store float 0.000000e+00, float* %temp, align 4
  %1 = bitcast %REAL2* %R2_ADD to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%REAL2* @REAL2__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %RX = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 1
  %load_ = load float, float* %RX, align 4
  store float %load_, float* %temp, align 4
  %RX1 = getelementptr inbounds %REAL2, %REAL2* %R2_ADD, i32 0, i32 1
  %load_Y = load float, float* %Y, align 4
  %R1 = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 0
  %load_2 = load float, float* %R1, align 4
  %tmpVar = fadd float %load_Y, %load_2
  %RX3 = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 1
  %load_4 = load float, float* %RX3, align 4
  %tmpVar5 = fadd float %tmpVar, %load_4
  store float %tmpVar5, float* %RX1, align 4
  %R16 = getelementptr inbounds %REAL2, %REAL2* %R2_ADD, i32 0, i32 0
  %load_temp = load float, float* %temp, align 4
  %RX7 = getelementptr inbounds %REAL2, %REAL2* %R2_ADD, i32 0, i32 1
  %load_8 = load float, float* %RX7, align 4
  %tmpVar9 = fsub float %load_temp, %load_8
  %load_Y10 = load float, float* %Y, align 4
  %tmpVar11 = fadd float %tmpVar9, %load_Y10
  %R112 = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 0
  %load_13 = load float, float* %R112, align 4
  %tmpVar14 = fadd float %tmpVar11, %load_13
  store float %tmpVar14, float* %R16, align 4
  %R2_ADD_ret = load %REAL2, %REAL2* %R2_ADD, align 4
  ret %REAL2 %R2_ADD_ret
}

define %REAL2 @R2_ADD2(%R2_ADD2_interface* %0) {
entry:
  %X = getelementptr inbounds %R2_ADD2_interface, %R2_ADD2_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %R2_ADD2_interface, %R2_ADD2_interface* %0, i32 0, i32 1
  %R2_ADD2 = alloca %REAL2, align 8
  %1 = bitcast %REAL2* %R2_ADD2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%REAL2* @REAL2__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %R1 = getelementptr inbounds %REAL2, %REAL2* %R2_ADD2, i32 0, i32 0
  %R11 = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 0
  %load_ = load float, float* %R11, align 4
  %R12 = getelementptr inbounds %REAL2, %REAL2* %Y, i32 0, i32 0
  %load_3 = load float, float* %R12, align 4
  %tmpVar = fadd float %load_, %load_3
  store float %tmpVar, float* %R1, align 4
  %RX = getelementptr inbounds %REAL2, %REAL2* %R2_ADD2, i32 0, i32 1
  %RX4 = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 1
  %load_5 = load float, float* %RX4, align 4
  %RX6 = getelementptr inbounds %REAL2, %REAL2* %Y, i32 0, i32 1
  %load_7 = load float, float* %RX6, align 4
  %tmpVar8 = fadd float %load_5, %load_7
  store float %tmpVar8, float* %RX, align 4
  %R2_ADD2_ret = load %REAL2, %REAL2* %R2_ADD2, align 4
  ret %REAL2 %R2_ADD2_ret
}

define %REAL2 @R2_MUL(%R2_MUL_interface* %0) {
entry:
  %X = getelementptr inbounds %R2_MUL_interface, %R2_MUL_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %R2_MUL_interface, %R2_MUL_interface* %0, i32 0, i32 1
  %R2_MUL = alloca %REAL2, align 8
  %1 = bitcast %REAL2* %R2_MUL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%REAL2* @REAL2__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %RX = getelementptr inbounds %REAL2, %REAL2* %R2_MUL, i32 0, i32 1
  %RX1 = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 1
  %load_ = load float, float* %RX1, align 4
  %load_Y = load float, float* %Y, align 4
  %tmpVar = fmul float %load_, %load_Y
  store float %tmpVar, float* %RX, align 4
  %R1 = getelementptr inbounds %REAL2, %REAL2* %R2_MUL, i32 0, i32 0
  %R12 = getelementptr inbounds %REAL2, %REAL2* %X, i32 0, i32 0
  %load_3 = load float, float* %R12, align 4
  %load_Y4 = load float, float* %Y, align 4
  %tmpVar5 = fmul float %load_3, %load_Y4
  store float %tmpVar5, float* %R1, align 4
  %R2_MUL_ret = load %REAL2, %REAL2* %R2_MUL, align 4
  ret %REAL2 %R2_MUL_ret
}

define %REAL2 @R2_SET(%R2_SET_interface* %0) {
entry:
  %X = getelementptr inbounds %R2_SET_interface, %R2_SET_interface* %0, i32 0, i32 0
  %R2_SET = alloca %REAL2, align 8
  %1 = bitcast %REAL2* %R2_SET to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%REAL2* @REAL2__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 2), i1 false)
  %RX = getelementptr inbounds %REAL2, %REAL2* %R2_SET, i32 0, i32 1
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %RX, align 4
  %R1 = getelementptr inbounds %REAL2, %REAL2* %R2_SET, i32 0, i32 0
  store float 0.000000e+00, float* %R1, align 4
  %R2_SET_ret = load %REAL2, %REAL2* %R2_SET, align 4
  ret %REAL2 %R2_SET_ret
}

define float @F_LIN(%F_LIN_interface* %0) {
entry:
  %X = getelementptr inbounds %F_LIN_interface, %F_LIN_interface* %0, i32 0, i32 0
  %A = getelementptr inbounds %F_LIN_interface, %F_LIN_interface* %0, i32 0, i32 1
  %B = getelementptr inbounds %F_LIN_interface, %F_LIN_interface* %0, i32 0, i32 2
  %F_LIN = alloca float, align 4
  store float 0.000000e+00, float* %F_LIN, align 4
  %load_A = load float, float* %A, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fmul float %load_A, %load_X
  %load_B = load float, float* %B, align 4
  %tmpVar1 = fadd float %tmpVar, %load_B
  store float %tmpVar1, float* %F_LIN, align 4
  %F_LIN_ret = load float, float* %F_LIN, align 4
  ret float %F_LIN_ret
}

define float @F_LIN2(%F_LIN2_interface* %0) {
entry:
  %X = getelementptr inbounds %F_LIN2_interface, %F_LIN2_interface* %0, i32 0, i32 0
  %X1 = getelementptr inbounds %F_LIN2_interface, %F_LIN2_interface* %0, i32 0, i32 1
  %Y1 = getelementptr inbounds %F_LIN2_interface, %F_LIN2_interface* %0, i32 0, i32 2
  %X2 = getelementptr inbounds %F_LIN2_interface, %F_LIN2_interface* %0, i32 0, i32 3
  %Y2 = getelementptr inbounds %F_LIN2_interface, %F_LIN2_interface* %0, i32 0, i32 4
  %F_LIN2 = alloca float, align 4
  store float 0.000000e+00, float* %F_LIN2, align 4
  %load_Y2 = load float, float* %Y2, align 4
  %load_Y1 = load float, float* %Y1, align 4
  %tmpVar = fsub float %load_Y2, %load_Y1
  %load_X2 = load float, float* %X2, align 4
  %load_X1 = load float, float* %X1, align 4
  %tmpVar1 = fsub float %load_X2, %load_X1
  %tmpVar2 = fdiv float %tmpVar, %tmpVar1
  %load_X = load float, float* %X, align 4
  %load_X13 = load float, float* %X1, align 4
  %tmpVar4 = fsub float %load_X, %load_X13
  %tmpVar5 = fmul float %tmpVar2, %tmpVar4
  %load_Y16 = load float, float* %Y1, align 4
  %tmpVar7 = fadd float %tmpVar5, %load_Y16
  store float %tmpVar7, float* %F_LIN2, align 4
  %F_LIN2_ret = load float, float* %F_LIN2, align 4
  ret float %F_LIN2_ret
}

define float @F_POLY(%F_POLY_interface* %0) {
entry:
  %X = getelementptr inbounds %F_POLY_interface, %F_POLY_interface* %0, i32 0, i32 0
  %C = getelementptr inbounds %F_POLY_interface, %F_POLY_interface* %0, i32 0, i32 1
  %F_POLY = alloca float, align 4
  store float 0.000000e+00, float* %F_POLY, align 4
  %tmpVar = getelementptr inbounds [8 x float], [8 x float]* %C, i32 0, i32 7
  %load_tmpVar = load float, float* %tmpVar, align 4
  %load_x = load float, float* %X, align 4
  %tmpVar1 = fmul float %load_tmpVar, %load_x
  %tmpVar2 = getelementptr inbounds [8 x float], [8 x float]* %C, i32 0, i32 6
  %load_tmpVar3 = load float, float* %tmpVar2, align 4
  %tmpVar4 = fadd float %tmpVar1, %load_tmpVar3
  %load_x5 = load float, float* %X, align 4
  %tmpVar6 = fmul float %tmpVar4, %load_x5
  %tmpVar7 = getelementptr inbounds [8 x float], [8 x float]* %C, i32 0, i32 5
  %load_tmpVar8 = load float, float* %tmpVar7, align 4
  %tmpVar9 = fadd float %tmpVar6, %load_tmpVar8
  %load_x10 = load float, float* %X, align 4
  %tmpVar11 = fmul float %tmpVar9, %load_x10
  %tmpVar12 = getelementptr inbounds [8 x float], [8 x float]* %C, i32 0, i32 4
  %load_tmpVar13 = load float, float* %tmpVar12, align 4
  %tmpVar14 = fadd float %tmpVar11, %load_tmpVar13
  %load_x15 = load float, float* %X, align 4
  %tmpVar16 = fmul float %tmpVar14, %load_x15
  %tmpVar17 = getelementptr inbounds [8 x float], [8 x float]* %C, i32 0, i32 3
  %load_tmpVar18 = load float, float* %tmpVar17, align 4
  %tmpVar19 = fadd float %tmpVar16, %load_tmpVar18
  %load_x20 = load float, float* %X, align 4
  %tmpVar21 = fmul float %tmpVar19, %load_x20
  %tmpVar22 = getelementptr inbounds [8 x float], [8 x float]* %C, i32 0, i32 2
  %load_tmpVar23 = load float, float* %tmpVar22, align 4
  %tmpVar24 = fadd float %tmpVar21, %load_tmpVar23
  %load_x25 = load float, float* %X, align 4
  %tmpVar26 = fmul float %tmpVar24, %load_x25
  %tmpVar27 = getelementptr inbounds [8 x float], [8 x float]* %C, i32 0, i32 1
  %load_tmpVar28 = load float, float* %tmpVar27, align 4
  %tmpVar29 = fadd float %tmpVar26, %load_tmpVar28
  %load_x30 = load float, float* %X, align 4
  %tmpVar31 = fmul float %tmpVar29, %load_x30
  %tmpVar32 = getelementptr inbounds [8 x float], [8 x float]* %C, i32 0, i32 0
  %load_tmpVar33 = load float, float* %tmpVar32, align 4
  %tmpVar34 = fadd float %tmpVar31, %load_tmpVar33
  store float %tmpVar34, float* %F_POLY, align 4
  %F_POLY_ret = load float, float* %F_POLY, align 4
  ret float %F_POLY_ret
}

define float @F_POWER(%F_POWER_interface* %0) {
entry:
  %a = getelementptr inbounds %F_POWER_interface, %F_POWER_interface* %0, i32 0, i32 0
  %x = getelementptr inbounds %F_POWER_interface, %F_POWER_interface* %0, i32 0, i32 1
  %n = getelementptr inbounds %F_POWER_interface, %F_POWER_interface* %0, i32 0, i32 2
  %F_POWER = alloca float, align 4
  store float 0.000000e+00, float* %F_POWER, align 4
  %load_a = load float, float* %a, align 4
  %1 = fpext float %load_a to double
  %EXPT_instance = alloca %EXPT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %EXPT_interface, %EXPT_interface* %EXPT_instance, i32 0, i32 0
  %load_X = load float, float* %x, align 4
  %3 = fptosi float %load_X to i32
  store i32 %3, i32* %2, align 4
  %4 = getelementptr inbounds %EXPT_interface, %EXPT_interface* %EXPT_instance, i32 0, i32 1
  %load_N = load float, float* %n, align 4
  %5 = fptosi float %load_N to i32
  store i32 %5, i32* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call double @EXPT(%EXPT_interface* %EXPT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = fmul double %1, %call1
  %6 = fptrunc double %tmpVar to float
  store float %6, float* %F_POWER, align 4
  %F_POWER_ret = load float, float* %F_POWER, align 4
  ret float %F_POWER_ret
}

define float @F_QUAD(%F_QUAD_interface* %0) {
entry:
  %X = getelementptr inbounds %F_QUAD_interface, %F_QUAD_interface* %0, i32 0, i32 0
  %A = getelementptr inbounds %F_QUAD_interface, %F_QUAD_interface* %0, i32 0, i32 1
  %B = getelementptr inbounds %F_QUAD_interface, %F_QUAD_interface* %0, i32 0, i32 2
  %C = getelementptr inbounds %F_QUAD_interface, %F_QUAD_interface* %0, i32 0, i32 3
  %F_QUAD = alloca float, align 4
  store float 0.000000e+00, float* %F_QUAD, align 4
  %load_A = load float, float* %A, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fmul float %load_A, %load_X
  %load_B = load float, float* %B, align 4
  %tmpVar1 = fadd float %tmpVar, %load_B
  %load_X2 = load float, float* %X, align 4
  %tmpVar3 = fmul float %tmpVar1, %load_X2
  %load_C = load float, float* %C, align 4
  %tmpVar4 = fadd float %tmpVar3, %load_C
  store float %tmpVar4, float* %F_QUAD, align 4
  %F_QUAD_ret = load float, float* %F_QUAD, align 4
  ret float %F_QUAD_ret
}

define i8 @FRMP_B(%FRMP_B_interface* %0) {
entry:
  %START = getelementptr inbounds %FRMP_B_interface, %FRMP_B_interface* %0, i32 0, i32 0
  %DIR = getelementptr inbounds %FRMP_B_interface, %FRMP_B_interface* %0, i32 0, i32 1
  %TD = getelementptr inbounds %FRMP_B_interface, %FRMP_B_interface* %0, i32 0, i32 2
  %TR = getelementptr inbounds %FRMP_B_interface, %FRMP_B_interface* %0, i32 0, i32 3
  %FRMP_B = alloca i8, align 1
  store i8 0, i8* %FRMP_B, align 1
  %load_TD = load i64, i64* %TD, align 4
  %load_TR = load i64, i64* %TR, align 4
  %tmpVar = icmp slt i64 %load_TD, %load_TR
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %SEL_instance43 = alloca %SEL_interface, align 8
  br label %input44

continue:                                         ; preds = %continue47, %continue35
  %FRMP_B_ret = load i8, i8* %FRMP_B, align 1
  ret i8 %FRMP_B_ret

input:                                            ; preds = %condition_body
  %1 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %DWORD_TO_BYTE_instance = alloca %DWORD_TO_BYTE_interface, align 8
  br label %input2

call:                                             ; preds = %continue29
  %call33 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %2 = trunc i64 %call33 to i8
  store i8 %2, i8* %FRMP_B, align 1
  %load_DIR37 = load i8, i8* %DIR, align 1
  %3 = icmp ne i8 %load_DIR37, 0
  br i1 %3, label %condition_body36, label %else34

input2:                                           ; preds = %input
  %4 = getelementptr inbounds %DWORD_TO_BYTE_interface, %DWORD_TO_BYTE_interface* %DWORD_TO_BYTE_instance, i32 0, i32 0
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input6

call3:                                            ; preds = %continue21
  %call25 = call i8 @DWORD_TO_BYTE(%DWORD_TO_BYTE_interface* %DWORD_TO_BYTE_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %5 = zext i8 %call25 to i64
  store i64 %5, i64* %1, align 4
  %6 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input26

input6:                                           ; preds = %input2
  %7 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input10

call7:                                            ; preds = %continue13
  %call16 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %TIME_TO_DWORD_instance17 = alloca %TIME_TO_DWORD_interface, align 8
  br label %input18

input10:                                          ; preds = %input6
  %8 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_TD14 = load i64, i64* %TD, align 4
  store i64 %load_TD14, i64* %8, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call15 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %9 = zext i32 %call15 to i64
  store i64 %9, i64* %7, align 4
  %10 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 8, i16* %10, align 2
  br label %call7

input18:                                          ; preds = %continue9
  %11 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance17, i32 0, i32 0
  %load_TR22 = load i64, i64* %TR, align 4
  store i64 %load_TR22, i64* %11, align 4
  br label %call19

call19:                                           ; preds = %input18
  %call23 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance17)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %12 = zext i32 %call23 to i64
  %tmpVar24 = sdiv i64 %call16, %12
  %13 = trunc i64 %tmpVar24 to i32
  store i32 %13, i32* %4, align 4
  br label %call3

input26:                                          ; preds = %continue5
  %14 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_DIR = load i8, i8* %DIR, align 1
  store i8 %load_DIR, i8* %14, align 1
  %15 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_START = load i8, i8* %START, align 1
  %16 = zext i8 %load_START to i64
  store i64 %16, i64* %15, align 4
  %17 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_START30 = load i8, i8* %START, align 1
  %18 = zext i8 %load_START30 to i32
  %tmpVar31 = sub i32 255, %18
  %19 = sext i32 %tmpVar31 to i64
  store i64 %19, i64* %17, align 4
  br label %call27

call27:                                           ; preds = %input26
  %call32 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  store i64 %call32, i64* %6, align 4
  br label %call

condition_body36:                                 ; preds = %continue1
  %load_START38 = load i8, i8* %START, align 1
  %20 = zext i8 %load_START38 to i32
  %load_FRMP_B = load i8, i8* %FRMP_B, align 1
  %21 = zext i8 %load_FRMP_B to i32
  %tmpVar39 = add i32 %20, %21
  %22 = trunc i32 %tmpVar39 to i8
  store i8 %22, i8* %FRMP_B, align 1
  br label %continue35

else34:                                           ; preds = %continue1
  %load_START40 = load i8, i8* %START, align 1
  %23 = zext i8 %load_START40 to i32
  %load_FRMP_B41 = load i8, i8* %FRMP_B, align 1
  %24 = zext i8 %load_FRMP_B41 to i32
  %tmpVar42 = sub i32 %23, %24
  %25 = trunc i32 %tmpVar42 to i8
  store i8 %25, i8* %FRMP_B, align 1
  br label %continue35

continue35:                                       ; preds = %else34, %condition_body36
  br label %continue

input44:                                          ; preds = %else
  %26 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance43, i32 0, i32 0
  %load_DIR48 = load i8, i8* %DIR, align 1
  store i8 %load_DIR48, i8* %26, align 1
  %27 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance43, i32 0, i32 1
  store i64 0, i64* %27, align 4
  %28 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance43, i32 0, i32 2
  store i64 255, i64* %28, align 4
  br label %call45

call45:                                           ; preds = %input44
  %call49 = call i64 @SEL(%SEL_interface* %SEL_instance43)
  br label %output46

output46:                                         ; preds = %call45
  br label %continue47

continue47:                                       ; preds = %output46
  %29 = trunc i64 %call49 to i8
  store i8 %29, i8* %FRMP_B, align 1
  br label %continue
}

define void @FT_AVG(%FT_AVG_interface* %0) {
entry:
  %IN = getelementptr inbounds %FT_AVG_interface, %FT_AVG_interface* %0, i32 0, i32 0
  %E = getelementptr inbounds %FT_AVG_interface, %FT_AVG_interface* %0, i32 0, i32 1
  %N = getelementptr inbounds %FT_AVG_interface, %FT_AVG_interface* %0, i32 0, i32 2
  %RST = getelementptr inbounds %FT_AVG_interface, %FT_AVG_interface* %0, i32 0, i32 3
  %AVG = getelementptr inbounds %FT_AVG_interface, %FT_AVG_interface* %0, i32 0, i32 4
  %buff = getelementptr inbounds %FT_AVG_interface, %FT_AVG_interface* %0, i32 0, i32 5
  %i = getelementptr inbounds %FT_AVG_interface, %FT_AVG_interface* %0, i32 0, i32 6
  %init = getelementptr inbounds %FT_AVG_interface, %FT_AVG_interface* %0, i32 0, i32 7
  %N1 = getelementptr inbounds %DELAY_interface, %DELAY_interface* %buff, i32 0, i32 1
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %1, align 4
  %2 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %3 = sext i16 %load_N to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 32, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = trunc i64 %call2 to i16
  store i16 %5, i16* %N1, align 2
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %6 = zext i8 %tmpVar to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %11, label %9

condition_body:                                   ; preds = %11
  store i16 1, i16* %i, align 2
  br label %condition_check

branch:                                           ; preds = %11
  %load_E = load i8, i8* %E, align 1
  %8 = icmp ne i8 %load_E, 0
  br i1 %8, label %condition_body21, label %continue3

condition_body21:                                 ; preds = %branch
  br label %input22

continue3:                                        ; preds = %continue32, %branch, %continue4
  ret void

9:                                                ; preds = %continue
  %load_rst = load i8, i8* %RST, align 1
  %10 = zext i8 %load_rst to i32
  br label %11

11:                                               ; preds = %9, %continue
  %12 = phi i32 [ %6, %continue ], [ %10, %9 ]
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %condition_body, label %branch

condition_check:                                  ; preds = %increment, %condition_body
  %load_i = load i16, i16* %i, align 2
  %load_i5 = load i16, i16* %i, align 2
  %load_N6 = load i16, i16* %N, align 2
  %tmpVar7 = icmp sle i16 %load_i5, %load_N6
  %14 = icmp ne i1 %tmpVar7, false
  br i1 %14, label %19, label %20

for_body:                                         ; preds = %17
  br label %input15

increment:                                        ; preds = %continue18
  %tmpVar19 = add i16 %load_i, 1
  store i16 %tmpVar19, i16* %i, align 2
  br label %condition_check

continue4:                                        ; preds = %17
  %load_in20 = load float, float* %IN, align 4
  store float %load_in20, float* %AVG, align 4
  store i8 1, i8* %init, align 1
  br label %continue3

15:                                               ; preds = %20
  %load_i10 = load i16, i16* %i, align 2
  %load_N11 = load i16, i16* %N, align 2
  %tmpVar12 = icmp sge i16 %load_i10, %load_N11
  %16 = icmp ne i1 %tmpVar12, false
  br i1 %16, label %23, label %24

17:                                               ; preds = %24, %20
  %18 = phi i1 [ %21, %20 ], [ %25, %24 ]
  br i1 %18, label %for_body, label %continue4

19:                                               ; preds = %condition_check
  %load_i8 = load i16, i16* %i, align 2
  %tmpVar9 = icmp sge i16 %load_i8, 1
  br label %20

20:                                               ; preds = %19, %condition_check
  %21 = phi i1 [ %tmpVar7, %condition_check ], [ %tmpVar9, %19 ]
  %22 = icmp ne i1 %21, false
  br i1 %22, label %17, label %15

23:                                               ; preds = %15
  %load_i13 = load i16, i16* %i, align 2
  %tmpVar14 = icmp sle i16 %load_i13, 1
  br label %24

24:                                               ; preds = %23, %15
  %25 = phi i1 [ %tmpVar12, %15 ], [ %tmpVar14, %23 ]
  br label %17

input15:                                          ; preds = %for_body
  %26 = getelementptr inbounds %DELAY_interface, %DELAY_interface* %buff, i32 0, i32 0
  %load_in = load float, float* %IN, align 4
  store float %load_in, float* %26, align 4
  br label %call16

call16:                                           ; preds = %input15
  call void @DELAY(%DELAY_interface* %buff)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  br label %increment

input22:                                          ; preds = %condition_body21
  %27 = getelementptr inbounds %DELAY_interface, %DELAY_interface* %buff, i32 0, i32 0
  %load_in26 = load float, float* %IN, align 4
  store float %load_in26, float* %27, align 4
  br label %call23

call23:                                           ; preds = %input22
  call void @DELAY(%DELAY_interface* %buff)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %load_avg = load float, float* %AVG, align 4
  %load_in27 = load float, float* %IN, align 4
  %out = getelementptr inbounds %DELAY_interface, %DELAY_interface* %buff, i32 0, i32 3
  %load_ = load float, float* %out, align 4
  %tmpVar28 = fsub float %load_in27, %load_
  %INT_TO_REAL_instance = alloca %INT_TO_REAL_interface, align 8
  br label %input29

input29:                                          ; preds = %continue25
  %28 = getelementptr inbounds %INT_TO_REAL_interface, %INT_TO_REAL_interface* %INT_TO_REAL_instance, i32 0, i32 0
  %load_N33 = load i16, i16* %N, align 2
  store i16 %load_N33, i16* %28, align 2
  br label %call30

call30:                                           ; preds = %input29
  %call34 = call float @INT_TO_REAL(%INT_TO_REAL_interface* %INT_TO_REAL_instance)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  %tmpVar35 = fdiv float %tmpVar28, %call34
  %tmpVar36 = fadd float %load_avg, %tmpVar35
  store float %tmpVar36, float* %AVG, align 4
  br label %continue3
}

define void @FT_MIN_MAX(%FT_MIN_MAX_interface* %0) {
entry:
  %in = getelementptr inbounds %FT_MIN_MAX_interface, %FT_MIN_MAX_interface* %0, i32 0, i32 0
  %rst = getelementptr inbounds %FT_MIN_MAX_interface, %FT_MIN_MAX_interface* %0, i32 0, i32 1
  %mx = getelementptr inbounds %FT_MIN_MAX_interface, %FT_MIN_MAX_interface* %0, i32 0, i32 2
  %mn = getelementptr inbounds %FT_MIN_MAX_interface, %FT_MIN_MAX_interface* %0, i32 0, i32 3
  %init = getelementptr inbounds %FT_MIN_MAX_interface, %FT_MIN_MAX_interface* %0, i32 0, i32 4
  %load_rst = load i8, i8* %rst, align 1
  %1 = zext i8 %load_rst to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %5, label %3

condition_body:                                   ; preds = %5
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %mn, align 4
  %load_in2 = load float, float* %in, align 4
  store float %load_in2, float* %mx, align 4
  store i8 1, i8* %init, align 1
  br label %continue

branch:                                           ; preds = %5
  %load_in4 = load float, float* %in, align 4
  %load_mn = load float, float* %mn, align 4
  %tmpVar5 = fcmp olt float %load_in4, %load_mn
  br i1 %tmpVar5, label %condition_body3, label %branch1

condition_body3:                                  ; preds = %branch
  %load_in6 = load float, float* %in, align 4
  store float %load_in6, float* %mn, align 4
  br label %continue

branch1:                                          ; preds = %branch
  %load_in8 = load float, float* %in, align 4
  %load_mx = load float, float* %mx, align 4
  %tmpVar9 = fcmp ogt float %load_in8, %load_mx
  br i1 %tmpVar9, label %condition_body7, label %continue

condition_body7:                                  ; preds = %branch1
  %load_in10 = load float, float* %in, align 4
  store float %load_in10, float* %mx, align 4
  br label %continue

continue:                                         ; preds = %condition_body7, %branch1, %condition_body3, %condition_body
  ret void

3:                                                ; preds = %entry
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %4 = zext i8 %tmpVar to i32
  br label %5

5:                                                ; preds = %3, %entry
  %6 = phi i32 [ %1, %entry ], [ %4, %3 ]
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %condition_body, label %branch
}

define void @FT_RMP(%FT_RMP_interface* %0) {
entry:
  %Rmp = getelementptr inbounds %FT_RMP_interface, %FT_RMP_interface* %0, i32 0, i32 0
  %in = getelementptr inbounds %FT_RMP_interface, %FT_RMP_interface* %0, i32 0, i32 1
  %KR = getelementptr inbounds %FT_RMP_interface, %FT_RMP_interface* %0, i32 0, i32 2
  %KF = getelementptr inbounds %FT_RMP_interface, %FT_RMP_interface* %0, i32 0, i32 3
  %out = getelementptr inbounds %FT_RMP_interface, %FT_RMP_interface* %0, i32 0, i32 4
  %busy = getelementptr inbounds %FT_RMP_interface, %FT_RMP_interface* %0, i32 0, i32 5
  %UD = getelementptr inbounds %FT_RMP_interface, %FT_RMP_interface* %0, i32 0, i32 6
  %tx = getelementptr inbounds %FT_RMP_interface, %FT_RMP_interface* %0, i32 0, i32 7
  %last = getelementptr inbounds %FT_RMP_interface, %FT_RMP_interface* %0, i32 0, i32 8
  %init = getelementptr inbounds %FT_RMP_interface, %FT_RMP_interface* %0, i32 0, i32 9
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %load_last = load i64, i64* %last, align 4
  %tmpVar = sub i64 %call6, %load_last
  store i64 %tmpVar, i64* %tx, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar8 = xor i8 %load_init, -1
  %2 = icmp ne i8 %tmpVar8, 0
  br i1 %2, label %condition_body, label %continue7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  store i8 1, i8* %init, align 1
  %load_tx = load i64, i64* %tx, align 4
  store i64 %load_tx, i64* %last, align 4
  store i64 0, i64* %tx, align 4
  %load_in = load float, float* %in, align 4
  store float %load_in, float* %out, align 4
  br label %continue7

continue7:                                        ; preds = %condition_body, %continue
  %load_rmp = load i8, i8* %Rmp, align 1
  %tmpVar12 = xor i8 %load_rmp, -1
  %3 = icmp ne i8 %tmpVar12, 0
  br i1 %3, label %condition_body11, label %branch

condition_body11:                                 ; preds = %continue7
  %load_in13 = load float, float* %in, align 4
  store float %load_in13, float* %out, align 4
  store i8 0, i8* %busy, align 1
  br label %continue10

branch:                                           ; preds = %continue7
  %load_out = load float, float* %out, align 4
  %load_in15 = load float, float* %in, align 4
  %tmpVar16 = fcmp ogt float %load_out, %load_in15
  br i1 %tmpVar16, label %condition_body14, label %branch9

condition_body14:                                 ; preds = %branch
  %load_out17 = load float, float* %out, align 4
  %TIME_TO_REAL_instance = alloca %TIME_TO_REAL_interface, align 8
  br label %input18

branch9:                                          ; preds = %branch
  %load_out35 = load float, float* %out, align 4
  %load_in36 = load float, float* %in, align 4
  %tmpVar37 = fcmp olt float %load_out35, %load_in36
  br i1 %tmpVar37, label %condition_body34, label %continue10

condition_body34:                                 ; preds = %branch9
  %load_out38 = load float, float* %out, align 4
  %TIME_TO_REAL_instance39 = alloca %TIME_TO_REAL_interface, align 8
  br label %input40

continue10:                                       ; preds = %continue52, %branch9, %continue30, %condition_body11
  %load_out59 = load float, float* %out, align 4
  %load_in60 = load float, float* %in, align 4
  %tmpVar61 = fcmp olt float %load_out59, %load_in60
  br i1 %tmpVar61, label %condition_body58, label %branch56

input18:                                          ; preds = %condition_body14
  %4 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance, i32 0, i32 0
  %load_tx22 = load i64, i64* %tx, align 4
  store i64 %load_tx22, i64* %4, align 4
  br label %call19

call19:                                           ; preds = %input18
  %call23 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %tmpVar24 = fmul float %call23, 0x3F50624DE0000000
  %load_KF = load float, float* %KF, align 4
  %tmpVar25 = fmul float %tmpVar24, %load_KF
  %tmpVar26 = fsub float %load_out17, %tmpVar25
  store float %tmpVar26, float* %out, align 4
  %MAX_instance = alloca %MAX_interface, align 8
  br label %input27

input27:                                          ; preds = %continue21
  %5 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 0
  %load_in31 = load float, float* %in, align 4
  %6 = fptoui float %load_in31 to i64
  store i64 %6, i64* %5, align 4
  %7 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 1
  %load_out32 = load float, float* %out, align 4
  %8 = fptoui float %load_out32 to i64
  store i64 %8, i64* %7, align 4
  br label %call28

call28:                                           ; preds = %input27
  %call33 = call i64 @MAX(%MAX_interface* %MAX_instance)
  br label %output29

output29:                                         ; preds = %call28
  br label %continue30

continue30:                                       ; preds = %output29
  %9 = uitofp i64 %call33 to float
  store float %9, float* %out, align 4
  br label %continue10

input40:                                          ; preds = %condition_body34
  %10 = getelementptr inbounds %TIME_TO_REAL_interface, %TIME_TO_REAL_interface* %TIME_TO_REAL_instance39, i32 0, i32 0
  %load_tx44 = load i64, i64* %tx, align 4
  store i64 %load_tx44, i64* %10, align 4
  br label %call41

call41:                                           ; preds = %input40
  %call45 = call float @TIME_TO_REAL(%TIME_TO_REAL_interface* %TIME_TO_REAL_instance39)
  br label %output42

output42:                                         ; preds = %call41
  br label %continue43

continue43:                                       ; preds = %output42
  %tmpVar46 = fmul float %call45, 0x3F50624DE0000000
  %load_KR = load float, float* %KR, align 4
  %tmpVar47 = fmul float %tmpVar46, %load_KR
  %tmpVar48 = fadd float %load_out38, %tmpVar47
  store float %tmpVar48, float* %out, align 4
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input49

input49:                                          ; preds = %continue43
  %11 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_in53 = load float, float* %in, align 4
  %12 = fptoui float %load_in53 to i64
  store i64 %12, i64* %11, align 4
  %13 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_out54 = load float, float* %out, align 4
  %14 = fptoui float %load_out54 to i64
  store i64 %14, i64* %13, align 4
  br label %call50

call50:                                           ; preds = %input49
  %call55 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output51

output51:                                         ; preds = %call50
  br label %continue52

continue52:                                       ; preds = %output51
  %15 = uitofp i64 %call55 to float
  store float %15, float* %out, align 4
  br label %continue10

condition_body58:                                 ; preds = %continue10
  store i8 1, i8* %busy, align 1
  store i8 1, i8* %UD, align 1
  br label %continue57

branch56:                                         ; preds = %continue10
  %load_out63 = load float, float* %out, align 4
  %load_in64 = load float, float* %in, align 4
  %tmpVar65 = fcmp ogt float %load_out63, %load_in64
  br i1 %tmpVar65, label %condition_body62, label %else

condition_body62:                                 ; preds = %branch56
  store i8 1, i8* %busy, align 1
  store i8 0, i8* %UD, align 1
  br label %continue57

else:                                             ; preds = %branch56
  store i8 0, i8* %busy, align 1
  br label %continue57

continue57:                                       ; preds = %else, %condition_body62, %condition_body58
  %load_last66 = load i64, i64* %last, align 4
  %load_tx67 = load i64, i64* %tx, align 4
  %tmpVar68 = add i64 %load_last66, %load_tx67
  store i64 %tmpVar68, i64* %last, align 4
  ret void
}

define float @LINEAR_INT(%LINEAR_INT_interface* %0) {
entry:
  %X = getelementptr inbounds %LINEAR_INT_interface, %LINEAR_INT_interface* %0, i32 0, i32 0
  %XY = getelementptr inbounds %LINEAR_INT_interface, %LINEAR_INT_interface* %0, i32 0, i32 1
  %Pts = getelementptr inbounds %LINEAR_INT_interface, %LINEAR_INT_interface* %0, i32 0, i32 2
  %i = getelementptr inbounds %LINEAR_INT_interface, %LINEAR_INT_interface* %0, i32 0, i32 3
  %LINEAR_INT = alloca float, align 4
  store i16 0, i16* %i, align 2
  store float 0.000000e+00, float* %LINEAR_INT, align 4
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_pts = load i16, i16* %Pts, align 2
  %2 = sext i16 %load_pts to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  store i64 20, i64* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = trunc i64 %call1 to i16
  store i16 %4, i16* %Pts, align 2
  store i16 2, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %continue, %while_body
  %load_i = load i16, i16* %i, align 2
  %5 = sext i16 %load_i to i32
  %load_pts3 = load i16, i16* %Pts, align 2
  %6 = sext i16 %load_pts3 to i32
  %tmpVar = icmp slt i32 %5, %6
  %7 = zext i1 %tmpVar to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %27, label %31

while_body:                                       ; preds = %31
  %load_i10 = load i16, i16* %i, align 2
  %9 = sext i16 %load_i10 to i32
  %tmpVar11 = add i32 %9, 1
  %10 = trunc i32 %tmpVar11 to i16
  store i16 %10, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %31
  %load_i12 = load i16, i16* %i, align 2
  %11 = sub i16 %load_i12, 1
  %12 = sext i16 %11 to i32
  %tmpVar13 = mul i32 2, %12
  %tmpVar14 = add i32 %tmpVar13, 0
  %tmpVar15 = add i32 1, %tmpVar14
  %tmpVar16 = getelementptr inbounds [40 x float], [40 x float]* %XY, i32 0, i32 %tmpVar15
  %load_tmpVar17 = load float, float* %tmpVar16, align 4
  %load_i18 = load i16, i16* %i, align 2
  %13 = sext i16 %load_i18 to i32
  %tmpVar19 = sub i32 %13, 1
  %14 = sub i32 %tmpVar19, 1
  %tmpVar20 = mul i32 2, %14
  %tmpVar21 = add i32 %tmpVar20, 0
  %tmpVar22 = add i32 1, %tmpVar21
  %tmpVar23 = getelementptr inbounds [40 x float], [40 x float]* %XY, i32 0, i32 %tmpVar22
  %load_tmpVar24 = load float, float* %tmpVar23, align 4
  %tmpVar25 = fsub float %load_tmpVar17, %load_tmpVar24
  %load_X26 = load float, float* %X, align 4
  %tmpVar27 = fmul float %tmpVar25, %load_X26
  %load_i28 = load i16, i16* %i, align 2
  %15 = sub i16 %load_i28, 1
  %16 = sext i16 %15 to i32
  %tmpVar29 = mul i32 2, %16
  %tmpVar30 = add i32 %tmpVar29, 0
  %tmpVar31 = add i32 1, %tmpVar30
  %tmpVar32 = getelementptr inbounds [40 x float], [40 x float]* %XY, i32 0, i32 %tmpVar31
  %load_tmpVar33 = load float, float* %tmpVar32, align 4
  %load_i34 = load i16, i16* %i, align 2
  %17 = sext i16 %load_i34 to i32
  %tmpVar35 = sub i32 %17, 1
  %18 = sub i32 %tmpVar35, 1
  %tmpVar36 = mul i32 2, %18
  %tmpVar37 = add i32 %tmpVar36, 0
  %tmpVar38 = add i32 0, %tmpVar37
  %tmpVar39 = getelementptr inbounds [40 x float], [40 x float]* %XY, i32 0, i32 %tmpVar38
  %load_tmpVar40 = load float, float* %tmpVar39, align 4
  %tmpVar41 = fmul float %load_tmpVar33, %load_tmpVar40
  %tmpVar42 = fsub float %tmpVar27, %tmpVar41
  %load_i43 = load i16, i16* %i, align 2
  %19 = sext i16 %load_i43 to i32
  %tmpVar44 = sub i32 %19, 1
  %20 = sub i32 %tmpVar44, 1
  %tmpVar45 = mul i32 2, %20
  %tmpVar46 = add i32 %tmpVar45, 0
  %tmpVar47 = add i32 1, %tmpVar46
  %tmpVar48 = getelementptr inbounds [40 x float], [40 x float]* %XY, i32 0, i32 %tmpVar47
  %load_tmpVar49 = load float, float* %tmpVar48, align 4
  %load_i50 = load i16, i16* %i, align 2
  %21 = sub i16 %load_i50, 1
  %22 = sext i16 %21 to i32
  %tmpVar51 = mul i32 2, %22
  %tmpVar52 = add i32 %tmpVar51, 0
  %tmpVar53 = add i32 0, %tmpVar52
  %tmpVar54 = getelementptr inbounds [40 x float], [40 x float]* %XY, i32 0, i32 %tmpVar53
  %load_tmpVar55 = load float, float* %tmpVar54, align 4
  %tmpVar56 = fmul float %load_tmpVar49, %load_tmpVar55
  %tmpVar57 = fadd float %tmpVar42, %tmpVar56
  %load_i58 = load i16, i16* %i, align 2
  %23 = sub i16 %load_i58, 1
  %24 = sext i16 %23 to i32
  %tmpVar59 = mul i32 2, %24
  %tmpVar60 = add i32 %tmpVar59, 0
  %tmpVar61 = add i32 0, %tmpVar60
  %tmpVar62 = getelementptr inbounds [40 x float], [40 x float]* %XY, i32 0, i32 %tmpVar61
  %load_tmpVar63 = load float, float* %tmpVar62, align 4
  %load_i64 = load i16, i16* %i, align 2
  %25 = sext i16 %load_i64 to i32
  %tmpVar65 = sub i32 %25, 1
  %26 = sub i32 %tmpVar65, 1
  %tmpVar66 = mul i32 2, %26
  %tmpVar67 = add i32 %tmpVar66, 0
  %tmpVar68 = add i32 0, %tmpVar67
  %tmpVar69 = getelementptr inbounds [40 x float], [40 x float]* %XY, i32 0, i32 %tmpVar68
  %load_tmpVar70 = load float, float* %tmpVar69, align 4
  %tmpVar71 = fsub float %load_tmpVar63, %load_tmpVar70
  %tmpVar72 = fdiv float %tmpVar57, %tmpVar71
  store float %tmpVar72, float* %LINEAR_INT, align 4
  %LINEAR_INT_ret = load float, float* %LINEAR_INT, align 4
  ret float %LINEAR_INT_ret

27:                                               ; preds = %condition_check
  %load_i4 = load i16, i16* %i, align 2
  %28 = sub i16 %load_i4, 1
  %29 = sext i16 %28 to i32
  %tmpVar5 = mul i32 2, %29
  %tmpVar6 = add i32 %tmpVar5, 0
  %tmpVar7 = add i32 0, %tmpVar6
  %tmpVar8 = getelementptr inbounds [40 x float], [40 x float]* %XY, i32 0, i32 %tmpVar7
  %load_tmpVar = load float, float* %tmpVar8, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar9 = fcmp olt float %load_tmpVar, %load_X
  %30 = zext i1 %tmpVar9 to i32
  br label %31

31:                                               ; preds = %27, %condition_check
  %32 = phi i32 [ %7, %condition_check ], [ %30, %27 ]
  br i32 %32, label %while_body, label %continue2
}

define float @POLYNOM_INT(%POLYNOM_INT_interface* %0) {
entry:
  %X = getelementptr inbounds %POLYNOM_INT_interface, %POLYNOM_INT_interface* %0, i32 0, i32 0
  %XY = getelementptr inbounds %POLYNOM_INT_interface, %POLYNOM_INT_interface* %0, i32 0, i32 1
  %Pts = getelementptr inbounds %POLYNOM_INT_interface, %POLYNOM_INT_interface* %0, i32 0, i32 2
  %I = getelementptr inbounds %POLYNOM_INT_interface, %POLYNOM_INT_interface* %0, i32 0, i32 3
  %J = getelementptr inbounds %POLYNOM_INT_interface, %POLYNOM_INT_interface* %0, i32 0, i32 4
  %stop = getelementptr inbounds %POLYNOM_INT_interface, %POLYNOM_INT_interface* %0, i32 0, i32 5
  %POLYNOM_INT = alloca float, align 4
  store i16 0, i16* %I, align 2
  store i16 0, i16* %J, align 2
  store i16 0, i16* %stop, align 2
  store float 0.000000e+00, float* %POLYNOM_INT, align 4
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_pts = load i16, i16* %Pts, align 2
  %2 = sext i16 %load_pts to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  store i64 5, i64* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = trunc i64 %call1 to i16
  store i16 %4, i16* %Pts, align 2
  store i16 1, i16* %I, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %I, align 2
  %load_i3 = load i16, i16* %I, align 2
  %load_pts4 = load i16, i16* %Pts, align 2
  %tmpVar = icmp sle i16 %load_i3, %load_pts4
  %5 = icmp ne i1 %tmpVar, false
  br i1 %5, label %12, label %13

for_body:                                         ; preds = %10
  %load_i12 = load i16, i16* %I, align 2
  %6 = sext i16 %load_i12 to i32
  %tmpVar13 = add i32 %6, 1
  %7 = trunc i32 %tmpVar13 to i16
  store i16 %7, i16* %stop, align 2
  %load_pts14 = load i16, i16* %Pts, align 2
  store i16 %load_pts14, i16* %J, align 2
  br label %condition_check15

increment:                                        ; preds = %continue18
  %tmpVar65 = add i16 %load_i, 1
  store i16 %tmpVar65, i16* %I, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  store float 0.000000e+00, float* %POLYNOM_INT, align 4
  %load_pts66 = load i16, i16* %Pts, align 2
  store i16 %load_pts66, i16* %I, align 2
  br label %condition_check67

8:                                                ; preds = %13
  %load_i7 = load i16, i16* %I, align 2
  %load_pts8 = load i16, i16* %Pts, align 2
  %tmpVar9 = icmp sge i16 %load_i7, %load_pts8
  %9 = icmp ne i1 %tmpVar9, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_i5 = load i16, i16* %I, align 2
  %tmpVar6 = icmp sge i16 %load_i5, 1
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar6, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_i10 = load i16, i16* %I, align 2
  %tmpVar11 = icmp sle i16 %load_i10, 1
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar9, %8 ], [ %tmpVar11, %16 ]
  br label %10

condition_check15:                                ; preds = %increment17, %for_body
  %load_j = load i16, i16* %J, align 2
  %load_j19 = load i16, i16* %J, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar20 = icmp sle i16 %load_j19, %load_stop
  %19 = icmp ne i1 %tmpVar20, false
  br i1 %19, label %35, label %36

for_body16:                                       ; preds = %33
  %load_j30 = load i16, i16* %J, align 2
  %20 = sub i16 %load_j30, 1
  %21 = sext i16 %20 to i32
  %tmpVar31 = mul i32 2, %21
  %tmpVar32 = add i32 %tmpVar31, 0
  %tmpVar33 = add i32 1, %tmpVar32
  %tmpVar34 = getelementptr inbounds [10 x float], [10 x float]* %XY, i32 0, i32 %tmpVar33
  %load_j35 = load i16, i16* %J, align 2
  %22 = sub i16 %load_j35, 1
  %23 = sext i16 %22 to i32
  %tmpVar36 = mul i32 2, %23
  %tmpVar37 = add i32 %tmpVar36, 0
  %tmpVar38 = add i32 1, %tmpVar37
  %tmpVar39 = getelementptr inbounds [10 x float], [10 x float]* %XY, i32 0, i32 %tmpVar38
  %load_tmpVar = load float, float* %tmpVar39, align 4
  %load_j40 = load i16, i16* %J, align 2
  %24 = sext i16 %load_j40 to i32
  %tmpVar41 = sub i32 %24, 1
  %25 = sub i32 %tmpVar41, 1
  %tmpVar42 = mul i32 2, %25
  %tmpVar43 = add i32 %tmpVar42, 0
  %tmpVar44 = add i32 1, %tmpVar43
  %tmpVar45 = getelementptr inbounds [10 x float], [10 x float]* %XY, i32 0, i32 %tmpVar44
  %load_tmpVar46 = load float, float* %tmpVar45, align 4
  %tmpVar47 = fsub float %load_tmpVar, %load_tmpVar46
  %load_j48 = load i16, i16* %J, align 2
  %26 = sub i16 %load_j48, 1
  %27 = sext i16 %26 to i32
  %tmpVar49 = mul i32 2, %27
  %tmpVar50 = add i32 %tmpVar49, 0
  %tmpVar51 = add i32 0, %tmpVar50
  %tmpVar52 = getelementptr inbounds [10 x float], [10 x float]* %XY, i32 0, i32 %tmpVar51
  %load_tmpVar53 = load float, float* %tmpVar52, align 4
  %load_j54 = load i16, i16* %J, align 2
  %28 = sext i16 %load_j54 to i32
  %load_i55 = load i16, i16* %I, align 2
  %29 = sext i16 %load_i55 to i32
  %tmpVar56 = sub i32 %28, %29
  %30 = sub i32 %tmpVar56, 1
  %tmpVar57 = mul i32 2, %30
  %tmpVar58 = add i32 %tmpVar57, 0
  %tmpVar59 = add i32 0, %tmpVar58
  %tmpVar60 = getelementptr inbounds [10 x float], [10 x float]* %XY, i32 0, i32 %tmpVar59
  %load_tmpVar61 = load float, float* %tmpVar60, align 4
  %tmpVar62 = fsub float %load_tmpVar53, %load_tmpVar61
  %tmpVar63 = fdiv float %tmpVar47, %tmpVar62
  store float %tmpVar63, float* %tmpVar34, align 4
  br label %increment17

increment17:                                      ; preds = %for_body16
  %tmpVar64 = add i16 %load_j, -1
  store i16 %tmpVar64, i16* %J, align 2
  br label %condition_check15

continue18:                                       ; preds = %33
  br label %increment

31:                                               ; preds = %36
  %load_j24 = load i16, i16* %J, align 2
  %load_stop25 = load i16, i16* %stop, align 2
  %tmpVar26 = icmp sge i16 %load_j24, %load_stop25
  %32 = icmp ne i1 %tmpVar26, false
  br i1 %32, label %39, label %40

33:                                               ; preds = %40, %36
  %34 = phi i1 [ %37, %36 ], [ %41, %40 ]
  br i1 %34, label %for_body16, label %continue18

35:                                               ; preds = %condition_check15
  %load_j21 = load i16, i16* %J, align 2
  %load_pts22 = load i16, i16* %Pts, align 2
  %tmpVar23 = icmp sge i16 %load_j21, %load_pts22
  br label %36

36:                                               ; preds = %35, %condition_check15
  %37 = phi i1 [ %tmpVar20, %condition_check15 ], [ %tmpVar23, %35 ]
  %38 = icmp ne i1 %37, false
  br i1 %38, label %33, label %31

39:                                               ; preds = %31
  %load_j27 = load i16, i16* %J, align 2
  %load_pts28 = load i16, i16* %Pts, align 2
  %tmpVar29 = icmp sle i16 %load_j27, %load_pts28
  br label %40

40:                                               ; preds = %39, %31
  %41 = phi i1 [ %tmpVar26, %31 ], [ %tmpVar29, %39 ]
  br label %33

condition_check67:                                ; preds = %increment69, %continue2
  %load_i71 = load i16, i16* %I, align 2
  %load_i72 = load i16, i16* %I, align 2
  %tmpVar73 = icmp sle i16 %load_i72, 1
  %42 = icmp ne i1 %tmpVar73, false
  br i1 %42, label %51, label %52

for_body68:                                       ; preds = %49
  %load_POLYNOM_INT = load float, float* %POLYNOM_INT, align 4
  %load_X = load float, float* %X, align 4
  %load_i82 = load i16, i16* %I, align 2
  %43 = sub i16 %load_i82, 1
  %44 = sext i16 %43 to i32
  %tmpVar83 = mul i32 2, %44
  %tmpVar84 = add i32 %tmpVar83, 0
  %tmpVar85 = add i32 0, %tmpVar84
  %tmpVar86 = getelementptr inbounds [10 x float], [10 x float]* %XY, i32 0, i32 %tmpVar85
  %load_tmpVar87 = load float, float* %tmpVar86, align 4
  %tmpVar88 = fsub float %load_X, %load_tmpVar87
  %tmpVar89 = fmul float %load_POLYNOM_INT, %tmpVar88
  %load_i90 = load i16, i16* %I, align 2
  %45 = sub i16 %load_i90, 1
  %46 = sext i16 %45 to i32
  %tmpVar91 = mul i32 2, %46
  %tmpVar92 = add i32 %tmpVar91, 0
  %tmpVar93 = add i32 1, %tmpVar92
  %tmpVar94 = getelementptr inbounds [10 x float], [10 x float]* %XY, i32 0, i32 %tmpVar93
  %load_tmpVar95 = load float, float* %tmpVar94, align 4
  %tmpVar96 = fadd float %tmpVar89, %load_tmpVar95
  store float %tmpVar96, float* %POLYNOM_INT, align 4
  br label %increment69

increment69:                                      ; preds = %for_body68
  %tmpVar97 = add i16 %load_i71, -1
  store i16 %tmpVar97, i16* %I, align 2
  br label %condition_check67

continue70:                                       ; preds = %49
  %POLYNOM_INT_ret = load float, float* %POLYNOM_INT, align 4
  ret float %POLYNOM_INT_ret

47:                                               ; preds = %52
  %load_i77 = load i16, i16* %I, align 2
  %tmpVar78 = icmp sge i16 %load_i77, 1
  %48 = icmp ne i1 %tmpVar78, false
  br i1 %48, label %55, label %56

49:                                               ; preds = %56, %52
  %50 = phi i1 [ %53, %52 ], [ %57, %56 ]
  br i1 %50, label %for_body68, label %continue70

51:                                               ; preds = %condition_check67
  %load_i74 = load i16, i16* %I, align 2
  %load_pts75 = load i16, i16* %Pts, align 2
  %tmpVar76 = icmp sge i16 %load_i74, %load_pts75
  br label %52

52:                                               ; preds = %51, %condition_check67
  %53 = phi i1 [ %tmpVar73, %condition_check67 ], [ %tmpVar76, %51 ]
  %54 = icmp ne i1 %53, false
  br i1 %54, label %49, label %47

55:                                               ; preds = %47
  %load_i79 = load i16, i16* %I, align 2
  %load_pts80 = load i16, i16* %Pts, align 2
  %tmpVar81 = icmp sle i16 %load_i79, %load_pts80
  br label %56

56:                                               ; preds = %55, %47
  %57 = phi i1 [ %tmpVar78, %47 ], [ %tmpVar81, %55 ]
  br label %49
}

define float @CIRCLE_A(%CIRCLE_A_interface* %0) {
entry:
  %rx = getelementptr inbounds %CIRCLE_A_interface, %CIRCLE_A_interface* %0, i32 0, i32 0
  %ax = getelementptr inbounds %CIRCLE_A_interface, %CIRCLE_A_interface* %0, i32 0, i32 1
  %CIRCLE_A = alloca float, align 4
  store float 0.000000e+00, float* %CIRCLE_A, align 4
  %load_Rx = load float, float* %rx, align 4
  %load_RX = load float, float* %rx, align 4
  %tmpVar = fmul float %load_Rx, %load_RX
  %tmpVar1 = fmul float %tmpVar, 0x3F81DF46A0000000
  %load_Ax = load float, float* %ax, align 4
  %tmpVar2 = fmul float %tmpVar1, %load_Ax
  store float %tmpVar2, float* %CIRCLE_A, align 4
  %CIRCLE_A_ret = load float, float* %CIRCLE_A, align 4
  ret float %CIRCLE_A_ret
}

define float @CIRCLE_C(%CIRCLE_C_interface* %0) {
entry:
  %Rx = getelementptr inbounds %CIRCLE_C_interface, %CIRCLE_C_interface* %0, i32 0, i32 0
  %Ax = getelementptr inbounds %CIRCLE_C_interface, %CIRCLE_C_interface* %0, i32 0, i32 1
  %CIRCLE_C = alloca float, align 4
  store float 0.000000e+00, float* %CIRCLE_C, align 4
  %load_Rx = load float, float* %Rx, align 4
  %tmpVar = fmul float 0x3F91DF46A0000000, %load_Rx
  %load_Ax = load float, float* %Ax, align 4
  %tmpVar1 = fmul float %tmpVar, %load_Ax
  store float %tmpVar1, float* %CIRCLE_C, align 4
  %CIRCLE_C_ret = load float, float* %CIRCLE_C, align 4
  ret float %CIRCLE_C_ret
}

define float @CIRCLE_SEG(%CIRCLE_SEG_interface* %0) {
entry:
  %RX = getelementptr inbounds %CIRCLE_SEG_interface, %CIRCLE_SEG_interface* %0, i32 0, i32 0
  %HX = getelementptr inbounds %CIRCLE_SEG_interface, %CIRCLE_SEG_interface* %0, i32 0, i32 1
  %CIRCLE_SEG = alloca float, align 4
  store float 0.000000e+00, float* %CIRCLE_SEG, align 4
  %load_RX = load float, float* %RX, align 4
  %tmpVar = fcmp ogt float %load_RX, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %ACOS_instance = alloca %ACOS_interface, align 8
  br label %input

continue:                                         ; preds = %continue15, %entry
  %CIRCLE_SEG_ret = load float, float* %CIRCLE_SEG, align 4
  ret float %CIRCLE_SEG_ret

input:                                            ; preds = %condition_body
  %1 = getelementptr inbounds %ACOS_interface, %ACOS_interface* %ACOS_instance, i32 0, i32 0
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input2

call:                                             ; preds = %continue5
  %call10 = call double @ACOS(%ACOS_interface* %ACOS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %tmpVar11 = fmul double 2.000000e+00, %call10
  %2 = fptrunc double %tmpVar11 to float
  store float %2, float* %CIRCLE_SEG, align 4
  %load_CIRCLE_SEG = load float, float* %CIRCLE_SEG, align 4
  %3 = fpext float %load_CIRCLE_SEG to double
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input12

input2:                                           ; preds = %input
  %4 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %4, align 4
  %5 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_HX = load float, float* %HX, align 4
  %load_RX6 = load float, float* %RX, align 4
  %tmpVar7 = fdiv float %load_HX, %load_RX6
  %6 = fptoui float %tmpVar7 to i64
  store i64 %6, i64* %5, align 4
  %7 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 2, i64* %7, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call8 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %8 = uitofp i64 %call8 to double
  %tmpVar9 = fsub double 1.000000e+00, %8
  %9 = fptosi double %tmpVar9 to i32
  store i32 %9, i32* %1, align 4
  br label %call

input12:                                          ; preds = %continue1
  %10 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %load_CIRCLE_SEG16 = load float, float* %CIRCLE_SEG, align 4
  %11 = fptosi float %load_CIRCLE_SEG16 to i32
  store i32 %11, i32* %10, align 4
  br label %call13

call13:                                           ; preds = %input12
  %call17 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %tmpVar18 = fsub double %3, %call17
  %load_RX19 = load float, float* %RX, align 4
  %12 = fpext float %load_RX19 to double
  %tmpVar20 = fmul double %tmpVar18, %12
  %load_RX21 = load float, float* %RX, align 4
  %13 = fpext float %load_RX21 to double
  %tmpVar22 = fmul double %tmpVar20, %13
  %tmpVar23 = fdiv double %tmpVar22, 2.000000e+00
  %14 = fptrunc double %tmpVar23 to float
  store float %14, float* %CIRCLE_SEG, align 4
  br label %continue
}

define float @CONE_V(%CONE_V_interface* %0) {
entry:
  %rx = getelementptr inbounds %CONE_V_interface, %CONE_V_interface* %0, i32 0, i32 0
  %hx = getelementptr inbounds %CONE_V_interface, %CONE_V_interface* %0, i32 0, i32 1
  %CONE_V = alloca float, align 4
  store float 0.000000e+00, float* %CONE_V, align 4
  %load_RX = load float, float* %rx, align 4
  %tmpVar = fmul float 0x3FF0C15240000000, %load_RX
  %load_RX1 = load float, float* %rx, align 4
  %tmpVar2 = fmul float %tmpVar, %load_RX1
  %load_hx = load float, float* %hx, align 4
  %tmpVar3 = fmul float %tmpVar2, %load_hx
  store float %tmpVar3, float* %CONE_V, align 4
  %CONE_V_ret = load float, float* %CONE_V, align 4
  ret float %CONE_V_ret
}

define float @ELLIPSE_A(%ELLIPSE_A_interface* %0) {
entry:
  %R1 = getelementptr inbounds %ELLIPSE_A_interface, %ELLIPSE_A_interface* %0, i32 0, i32 0
  %R2 = getelementptr inbounds %ELLIPSE_A_interface, %ELLIPSE_A_interface* %0, i32 0, i32 1
  %ELLIPSE_A = alloca float, align 4
  store float 0.000000e+00, float* %ELLIPSE_A, align 4
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 0), align 4
  %load_R1 = load float, float* %R1, align 4
  %tmpVar = fmul float %load_, %load_R1
  %load_R2 = load float, float* %R2, align 4
  %tmpVar1 = fmul float %tmpVar, %load_R2
  store float %tmpVar1, float* %ELLIPSE_A, align 4
  %ELLIPSE_A_ret = load float, float* %ELLIPSE_A, align 4
  ret float %ELLIPSE_A_ret
}

define float @ELLIPSE_C(%ELLIPSE_C_interface* %0) {
entry:
  %R1 = getelementptr inbounds %ELLIPSE_C_interface, %ELLIPSE_C_interface* %0, i32 0, i32 0
  %R2 = getelementptr inbounds %ELLIPSE_C_interface, %ELLIPSE_C_interface* %0, i32 0, i32 1
  %ELLIPSE_C = alloca float, align 4
  store float 0.000000e+00, float* %ELLIPSE_C, align 4
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 0), align 4
  %1 = fpext float %load_ to double
  %load_R1 = load float, float* %R1, align 4
  %load_R2 = load float, float* %R2, align 4
  %tmpVar = fadd float %load_R1, %load_R2
  %tmpVar1 = fmul float 3.000000e+00, %tmpVar
  %2 = fpext float %tmpVar1 to double
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_r1 = load float, float* %R1, align 4
  %tmpVar2 = fmul float 3.000000e+00, %load_r1
  %load_R23 = load float, float* %R2, align 4
  %tmpVar4 = fadd float %tmpVar2, %load_R23
  %load_r2 = load float, float* %R2, align 4
  %tmpVar5 = fmul float 3.000000e+00, %load_r2
  %load_r16 = load float, float* %R1, align 4
  %tmpVar7 = fadd float %tmpVar5, %load_r16
  %tmpVar8 = fmul float %tmpVar4, %tmpVar7
  %4 = fptosi float %tmpVar8 to i32
  store i32 %4, i32* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call9 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar10 = fsub double %2, %call9
  %tmpVar11 = fmul double %1, %tmpVar10
  %5 = fptrunc double %tmpVar11 to float
  store float %5, float* %ELLIPSE_C, align 4
  %ELLIPSE_C_ret = load float, float* %ELLIPSE_C, align 4
  ret float %ELLIPSE_C_ret
}

define float @SPHERE_V(%SPHERE_V_interface* %0) {
entry:
  %rx = getelementptr inbounds %SPHERE_V_interface, %SPHERE_V_interface* %0, i32 0, i32 0
  %SPHERE_V = alloca float, align 4
  store float 0.000000e+00, float* %SPHERE_V, align 4
  %load_Rx = load float, float* %rx, align 4
  %tmpVar = fmul float 0x4010C15240000000, %load_Rx
  %load_RX = load float, float* %rx, align 4
  %tmpVar1 = fmul float %tmpVar, %load_RX
  %load_RX2 = load float, float* %rx, align 4
  %tmpVar3 = fmul float %tmpVar1, %load_RX2
  store float %tmpVar3, float* %SPHERE_V, align 4
  %SPHERE_V_ret = load float, float* %SPHERE_V, align 4
  ret float %SPHERE_V_ret
}

define float @TRIANGLE_A(%TRIANGLE_A_interface* %0) {
entry:
  %S1 = getelementptr inbounds %TRIANGLE_A_interface, %TRIANGLE_A_interface* %0, i32 0, i32 0
  %A = getelementptr inbounds %TRIANGLE_A_interface, %TRIANGLE_A_interface* %0, i32 0, i32 1
  %S2 = getelementptr inbounds %TRIANGLE_A_interface, %TRIANGLE_A_interface* %0, i32 0, i32 2
  %S3 = getelementptr inbounds %TRIANGLE_A_interface, %TRIANGLE_A_interface* %0, i32 0, i32 3
  %TRIANGLE_A = alloca float, align 4
  store float 0.000000e+00, float* %TRIANGLE_A, align 4
  %load_A = load float, float* %A, align 4
  %tmpVar = fcmp oeq float %load_A, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %load_S122 = load float, float* %S1, align 4
  %load_S223 = load float, float* %S2, align 4
  %tmpVar24 = fmul float %load_S122, %load_S223
  %1 = fpext float %tmpVar24 to double
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input25

continue:                                         ; preds = %continue28, %continue1
  %TRIANGLE_A_ret = load float, float* %TRIANGLE_A, align 4
  ret float %TRIANGLE_A_ret

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_s1 = load float, float* %S1, align 4
  %load_s2 = load float, float* %S2, align 4
  %tmpVar2 = fadd float %load_s1, %load_s2
  %load_S3 = load float, float* %S3, align 4
  %tmpVar3 = fadd float %tmpVar2, %load_S3
  %load_s14 = load float, float* %S1, align 4
  %load_s25 = load float, float* %S2, align 4
  %tmpVar6 = fadd float %load_s14, %load_s25
  %load_S37 = load float, float* %S3, align 4
  %tmpVar8 = fsub float %tmpVar6, %load_S37
  %tmpVar9 = fmul float %tmpVar3, %tmpVar8
  %load_S2 = load float, float* %S2, align 4
  %load_S310 = load float, float* %S3, align 4
  %tmpVar11 = fadd float %load_S2, %load_S310
  %load_S1 = load float, float* %S1, align 4
  %tmpVar12 = fsub float %tmpVar11, %load_S1
  %tmpVar13 = fmul float %tmpVar9, %tmpVar12
  %load_S314 = load float, float* %S3, align 4
  %load_S115 = load float, float* %S1, align 4
  %tmpVar16 = fadd float %load_S314, %load_S115
  %load_S217 = load float, float* %S2, align 4
  %tmpVar18 = fsub float %tmpVar16, %load_S217
  %tmpVar19 = fmul float %tmpVar13, %tmpVar18
  %3 = fptosi float %tmpVar19 to i32
  store i32 %3, i32* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call20 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %tmpVar21 = fmul double %call20, 2.500000e-01
  %4 = fptrunc double %tmpVar21 to float
  store float %4, float* %TRIANGLE_A, align 4
  br label %continue

input25:                                          ; preds = %else
  %5 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %RAD_instance = alloca %RAD_interface, align 8
  br label %input29

call26:                                           ; preds = %continue32
  %call35 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  %tmpVar36 = fmul double %1, %call35
  %tmpVar37 = fmul double %tmpVar36, 5.000000e-01
  %6 = fptrunc double %tmpVar37 to float
  store float %6, float* %TRIANGLE_A, align 4
  br label %continue

input29:                                          ; preds = %input25
  %7 = getelementptr inbounds %RAD_interface, %RAD_interface* %RAD_instance, i32 0, i32 0
  %load_A33 = load float, float* %A, align 4
  store float %load_A33, float* %7, align 4
  br label %call30

call30:                                           ; preds = %input29
  %call34 = call float @RAD(%RAD_interface* %RAD_instance)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  %8 = fptosi float %call34 to i32
  store i32 %8, i32* %5, align 4
  br label %call26
}

define float @V3_ABS(%V3_ABS_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_ABS_interface, %V3_ABS_interface* %0, i32 0, i32 0
  %V3_ABS = alloca float, align 4
  store float 0.000000e+00, float* %V3_ABS, align 4
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %X = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 0
  %load_ = load float, float* %X, align 4
  %X1 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 0
  %load_2 = load float, float* %X1, align 4
  %tmpVar = fmul float %load_, %load_2
  %Y = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 1
  %load_3 = load float, float* %Y, align 4
  %Y4 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 1
  %load_5 = load float, float* %Y4, align 4
  %tmpVar6 = fmul float %load_3, %load_5
  %tmpVar7 = fadd float %tmpVar, %tmpVar6
  %Z = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 2
  %load_8 = load float, float* %Z, align 4
  %Z9 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 2
  %load_10 = load float, float* %Z9, align 4
  %tmpVar11 = fmul float %load_8, %load_10
  %tmpVar12 = fadd float %tmpVar7, %tmpVar11
  %2 = fptosi float %tmpVar12 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call13 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = fptrunc double %call13 to float
  store float %3, float* %V3_ABS, align 4
  %V3_ABS_ret = load float, float* %V3_ABS, align 4
  ret float %V3_ABS_ret
}

define %VECTOR_3 @V3_ADD(%V3_ADD_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_ADD_interface, %V3_ADD_interface* %0, i32 0, i32 0
  %B = getelementptr inbounds %V3_ADD_interface, %V3_ADD_interface* %0, i32 0, i32 1
  %V3_ADD = alloca %VECTOR_3, align 8
  %1 = bitcast %VECTOR_3* %V3_ADD to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%VECTOR_3* @VECTOR_3__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 3), i1 false)
  %X = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_ADD, i32 0, i32 0
  %X1 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 0
  %load_ = load float, float* %X1, align 4
  %X2 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 0
  %load_3 = load float, float* %X2, align 4
  %tmpVar = fadd float %load_, %load_3
  store float %tmpVar, float* %X, align 4
  %Y = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_ADD, i32 0, i32 1
  %Y4 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 1
  %load_5 = load float, float* %Y4, align 4
  %Y6 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 1
  %load_7 = load float, float* %Y6, align 4
  %tmpVar8 = fadd float %load_5, %load_7
  store float %tmpVar8, float* %Y, align 4
  %Z = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_ADD, i32 0, i32 2
  %Z9 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 2
  %load_10 = load float, float* %Z9, align 4
  %Z11 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 2
  %load_12 = load float, float* %Z11, align 4
  %tmpVar13 = fadd float %load_10, %load_12
  store float %tmpVar13, float* %Z, align 4
  %V3_ADD_ret = load %VECTOR_3, %VECTOR_3* %V3_ADD, align 4
  ret %VECTOR_3 %V3_ADD_ret
}

define float @V3_ANG(%V3_ANG_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_ANG_interface, %V3_ANG_interface* %0, i32 0, i32 0
  %B = getelementptr inbounds %V3_ANG_interface, %V3_ANG_interface* %0, i32 0, i32 1
  %d = getelementptr inbounds %V3_ANG_interface, %V3_ANG_interface* %0, i32 0, i32 2
  %V3_ANG = alloca float, align 4
  store float 0.000000e+00, float* %d, align 4
  store float 0.000000e+00, float* %V3_ANG, align 4
  %V3_ABS_instance = alloca %V3_ABS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %V3_ABS_interface, %V3_ABS_interface* %V3_ABS_instance, i32 0, i32 0
  %load_A = load %VECTOR_3, %VECTOR_3* %A, align 4
  store %VECTOR_3 %load_A, %VECTOR_3* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @V3_ABS(%V3_ABS_interface* %V3_ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %V3_ABS_instance2 = alloca %V3_ABS_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %2 = getelementptr inbounds %V3_ABS_interface, %V3_ABS_interface* %V3_ABS_instance2, i32 0, i32 0
  %load_B = load %VECTOR_3, %VECTOR_3* %B, align 4
  store %VECTOR_3 %load_B, %VECTOR_3* %2, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call float @V3_ABS(%V3_ABS_interface* %V3_ABS_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %tmpVar = fmul float %call1, %call7
  store float %tmpVar, float* %d, align 4
  %load_d = load float, float* %d, align 4
  %tmpVar9 = fcmp ogt float %load_d, 0.000000e+00
  br i1 %tmpVar9, label %condition_body, label %continue8

condition_body:                                   ; preds = %continue6
  %ACOS_instance = alloca %ACOS_interface, align 8
  br label %input10

continue8:                                        ; preds = %continue13, %continue6
  %V3_ANG_ret = load float, float* %V3_ANG, align 4
  ret float %V3_ANG_ret

input10:                                          ; preds = %condition_body
  %3 = getelementptr inbounds %ACOS_interface, %ACOS_interface* %ACOS_instance, i32 0, i32 0
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input14

call11:                                           ; preds = %continue17
  %call28 = call double @ACOS(%ACOS_interface* %ACOS_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %4 = fptrunc double %call28 to float
  store float %4, float* %V3_ANG, align 4
  br label %continue8

input14:                                          ; preds = %input10
  %5 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 undef, i64* %5, align 4
  %6 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %V3_DPRO_instance = alloca %V3_DPRO_interface, align 8
  br label %input18

call15:                                           ; preds = %continue21
  %call27 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %7 = trunc i64 %call27 to i32
  store i32 %7, i32* %3, align 4
  br label %call11

input18:                                          ; preds = %input14
  %8 = getelementptr inbounds %V3_DPRO_interface, %V3_DPRO_interface* %V3_DPRO_instance, i32 0, i32 0
  %load_A22 = load %VECTOR_3, %VECTOR_3* %A, align 4
  store %VECTOR_3 %load_A22, %VECTOR_3* %8, align 4
  %9 = getelementptr inbounds %V3_DPRO_interface, %V3_DPRO_interface* %V3_DPRO_instance, i32 0, i32 1
  %load_B23 = load %VECTOR_3, %VECTOR_3* %B, align 4
  store %VECTOR_3 %load_B23, %VECTOR_3* %9, align 4
  br label %call19

call19:                                           ; preds = %input18
  %call24 = call float @V3_DPRO(%V3_DPRO_interface* %V3_DPRO_instance)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %load_d25 = load float, float* %d, align 4
  %tmpVar26 = fdiv float %call24, %load_d25
  %10 = fptoui float %tmpVar26 to i64
  store i64 %10, i64* %6, align 4
  %11 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 1, i64* %11, align 4
  br label %call15
}

define float @V3_DPRO(%V3_DPRO_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_DPRO_interface, %V3_DPRO_interface* %0, i32 0, i32 0
  %B = getelementptr inbounds %V3_DPRO_interface, %V3_DPRO_interface* %0, i32 0, i32 1
  %V3_DPRO = alloca float, align 4
  store float 0.000000e+00, float* %V3_DPRO, align 4
  %X = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 0
  %load_ = load float, float* %X, align 4
  %X1 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 0
  %load_2 = load float, float* %X1, align 4
  %tmpVar = fmul float %load_, %load_2
  %Y = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 1
  %load_3 = load float, float* %Y, align 4
  %Y4 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 1
  %load_5 = load float, float* %Y4, align 4
  %tmpVar6 = fmul float %load_3, %load_5
  %tmpVar7 = fadd float %tmpVar, %tmpVar6
  %Z = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 2
  %load_8 = load float, float* %Z, align 4
  %Z9 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 2
  %load_10 = load float, float* %Z9, align 4
  %tmpVar11 = fmul float %load_8, %load_10
  %tmpVar12 = fadd float %tmpVar7, %tmpVar11
  store float %tmpVar12, float* %V3_DPRO, align 4
  %V3_DPRO_ret = load float, float* %V3_DPRO, align 4
  ret float %V3_DPRO_ret
}

define %VECTOR_3 @V3_NORM(%V3_NORM_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_NORM_interface, %V3_NORM_interface* %0, i32 0, i32 0
  %la = getelementptr inbounds %V3_NORM_interface, %V3_NORM_interface* %0, i32 0, i32 1
  %V3_NORM = alloca %VECTOR_3, align 8
  store float 0.000000e+00, float* %la, align 4
  %1 = bitcast %VECTOR_3* %V3_NORM to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%VECTOR_3* @VECTOR_3__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 3), i1 false)
  %V3_ABS_instance = alloca %V3_ABS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %V3_ABS_interface, %V3_ABS_interface* %V3_ABS_instance, i32 0, i32 0
  %load_A = load %VECTOR_3, %VECTOR_3* %A, align 4
  store %VECTOR_3 %load_A, %VECTOR_3* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @V3_ABS(%V3_ABS_interface* %V3_ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call1, float* %la, align 4
  %load_la = load float, float* %la, align 4
  %tmpVar = fcmp ogt float %load_la, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue2

condition_body:                                   ; preds = %continue
  %V3_SMUL_instance = alloca %V3_SMUL_interface, align 8
  br label %input3

continue2:                                        ; preds = %continue6, %continue
  %V3_NORM_ret = load %VECTOR_3, %VECTOR_3* %V3_NORM, align 4
  ret %VECTOR_3 %V3_NORM_ret

input3:                                           ; preds = %condition_body
  %3 = getelementptr inbounds %V3_SMUL_interface, %V3_SMUL_interface* %V3_SMUL_instance, i32 0, i32 0
  %load_A7 = load %VECTOR_3, %VECTOR_3* %A, align 4
  store %VECTOR_3 %load_A7, %VECTOR_3* %3, align 4
  %4 = getelementptr inbounds %V3_SMUL_interface, %V3_SMUL_interface* %V3_SMUL_instance, i32 0, i32 1
  %load_la8 = load float, float* %la, align 4
  %tmpVar9 = fdiv float 1.000000e+00, %load_la8
  store float %tmpVar9, float* %4, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call10 = call %VECTOR_3 @V3_SMUL(%V3_SMUL_interface* %V3_SMUL_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  store %VECTOR_3 %call10, %VECTOR_3* %V3_NORM, align 4
  br label %continue2
}

define i8 @V3_NUL(%V3_NUL_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_NUL_interface, %V3_NUL_interface* %0, i32 0, i32 0
  %V3_NUL = alloca i8, align 1
  store i8 0, i8* %V3_NUL, align 1
  %X = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 0
  %load_ = load float, float* %X, align 4
  %tmpVar = fcmp oeq float %load_, 0.000000e+00
  %1 = zext i1 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %7, label %9

3:                                                ; preds = %9
  %Z = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 2
  %load_3 = load float, float* %Z, align 4
  %tmpVar4 = fcmp oeq float %load_3, 0.000000e+00
  %4 = zext i1 %tmpVar4 to i32
  br label %5

5:                                                ; preds = %3, %9
  %6 = phi i32 [ %10, %9 ], [ %4, %3 ]
  store i32 %6, i8* %V3_NUL, align 4
  %V3_NUL_ret = load i8, i8* %V3_NUL, align 1
  ret i8 %V3_NUL_ret

7:                                                ; preds = %entry
  %Y = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 1
  %load_1 = load float, float* %Y, align 4
  %tmpVar2 = fcmp oeq float %load_1, 0.000000e+00
  %8 = zext i1 %tmpVar2 to i32
  br label %9

9:                                                ; preds = %7, %entry
  %10 = phi i32 [ %1, %entry ], [ %8, %7 ]
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %3, label %5
}

define i8 @V3_PAR(%V3_PAR_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_PAR_interface, %V3_PAR_interface* %0, i32 0, i32 0
  %B = getelementptr inbounds %V3_PAR_interface, %V3_PAR_interface* %0, i32 0, i32 1
  %V3_PAR = alloca i8, align 1
  store i8 0, i8* %V3_PAR, align 1
  %V3_ABS_instance = alloca %V3_ABS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %V3_ABS_interface, %V3_ABS_interface* %V3_ABS_instance, i32 0, i32 0
  %V3_XPRO_instance = alloca %V3_XPRO_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call float @V3_ABS(%V3_ABS_interface* %V3_ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = fcmp oeq float %call6, 0.000000e+00
  %2 = zext i1 %tmpVar to i8
  store i8 %2, i8* %V3_PAR, align 1
  %V3_PAR_ret = load i8, i8* %V3_PAR, align 1
  ret i8 %V3_PAR_ret

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %V3_XPRO_interface, %V3_XPRO_interface* %V3_XPRO_instance, i32 0, i32 0
  %load_A = load %VECTOR_3, %VECTOR_3* %A, align 4
  store %VECTOR_3 %load_A, %VECTOR_3* %3, align 4
  %4 = getelementptr inbounds %V3_XPRO_interface, %V3_XPRO_interface* %V3_XPRO_instance, i32 0, i32 1
  %load_B = load %VECTOR_3, %VECTOR_3* %B, align 4
  store %VECTOR_3 %load_B, %VECTOR_3* %4, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call %VECTOR_3 @V3_XPRO(%V3_XPRO_interface* %V3_XPRO_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store %VECTOR_3 %call5, %VECTOR_3* %1, align 4
  br label %call
}

define %VECTOR_3 @V3_REV(%V3_REV_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_REV_interface, %V3_REV_interface* %0, i32 0, i32 0
  %V3_REV = alloca %VECTOR_3, align 8
  %1 = bitcast %VECTOR_3* %V3_REV to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%VECTOR_3* @VECTOR_3__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 3), i1 false)
  %X = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_REV, i32 0, i32 0
  %X1 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 0
  %load_ = load float, float* %X1, align 4
  %tmpVar = fneg float %load_
  store float %tmpVar, float* %X, align 4
  %Y = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_REV, i32 0, i32 1
  %Y2 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 1
  %load_3 = load float, float* %Y2, align 4
  %tmpVar4 = fneg float %load_3
  store float %tmpVar4, float* %Y, align 4
  %Z = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_REV, i32 0, i32 2
  %Z5 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 2
  %load_6 = load float, float* %Z5, align 4
  %tmpVar7 = fneg float %load_6
  store float %tmpVar7, float* %Z, align 4
  %V3_REV_ret = load %VECTOR_3, %VECTOR_3* %V3_REV, align 4
  ret %VECTOR_3 %V3_REV_ret
}

define %VECTOR_3 @V3_SMUL(%V3_SMUL_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_SMUL_interface, %V3_SMUL_interface* %0, i32 0, i32 0
  %M = getelementptr inbounds %V3_SMUL_interface, %V3_SMUL_interface* %0, i32 0, i32 1
  %V3_SMUL = alloca %VECTOR_3, align 8
  %1 = bitcast %VECTOR_3* %V3_SMUL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%VECTOR_3* @VECTOR_3__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 3), i1 false)
  %X = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_SMUL, i32 0, i32 0
  %X1 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 0
  %load_ = load float, float* %X1, align 4
  %load_M = load float, float* %M, align 4
  %tmpVar = fmul float %load_, %load_M
  store float %tmpVar, float* %X, align 4
  %Y = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_SMUL, i32 0, i32 1
  %Y2 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 1
  %load_3 = load float, float* %Y2, align 4
  %load_M4 = load float, float* %M, align 4
  %tmpVar5 = fmul float %load_3, %load_M4
  store float %tmpVar5, float* %Y, align 4
  %Z = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_SMUL, i32 0, i32 2
  %Z6 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 2
  %load_7 = load float, float* %Z6, align 4
  %load_M8 = load float, float* %M, align 4
  %tmpVar9 = fmul float %load_7, %load_M8
  store float %tmpVar9, float* %Z, align 4
  %V3_SMUL_ret = load %VECTOR_3, %VECTOR_3* %V3_SMUL, align 4
  ret %VECTOR_3 %V3_SMUL_ret
}

define %VECTOR_3 @V3_SUB(%V3_SUB_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_SUB_interface, %V3_SUB_interface* %0, i32 0, i32 0
  %B = getelementptr inbounds %V3_SUB_interface, %V3_SUB_interface* %0, i32 0, i32 1
  %V3_SUB = alloca %VECTOR_3, align 8
  %1 = bitcast %VECTOR_3* %V3_SUB to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%VECTOR_3* @VECTOR_3__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 3), i1 false)
  %X = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_SUB, i32 0, i32 0
  %X1 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 0
  %load_ = load float, float* %X1, align 4
  %X2 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 0
  %load_3 = load float, float* %X2, align 4
  %tmpVar = fsub float %load_, %load_3
  store float %tmpVar, float* %X, align 4
  %Y = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_SUB, i32 0, i32 1
  %Y4 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 1
  %load_5 = load float, float* %Y4, align 4
  %Y6 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 1
  %load_7 = load float, float* %Y6, align 4
  %tmpVar8 = fsub float %load_5, %load_7
  store float %tmpVar8, float* %Y, align 4
  %Z = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_SUB, i32 0, i32 2
  %Z9 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 2
  %load_10 = load float, float* %Z9, align 4
  %Z11 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 2
  %load_12 = load float, float* %Z11, align 4
  %tmpVar13 = fsub float %load_10, %load_12
  store float %tmpVar13, float* %Z, align 4
  %V3_SUB_ret = load %VECTOR_3, %VECTOR_3* %V3_SUB, align 4
  ret %VECTOR_3 %V3_SUB_ret
}

define float @V3_XANG(%V3_XANG_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_XANG_interface, %V3_XANG_interface* %0, i32 0, i32 0
  %la = getelementptr inbounds %V3_XANG_interface, %V3_XANG_interface* %0, i32 0, i32 1
  %V3_XANG = alloca float, align 4
  store float 0.000000e+00, float* %la, align 4
  store float 0.000000e+00, float* %V3_XANG, align 4
  %V3_ABS_instance = alloca %V3_ABS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %V3_ABS_interface, %V3_ABS_interface* %V3_ABS_instance, i32 0, i32 0
  %load_a = load %VECTOR_3, %VECTOR_3* %A, align 4
  store %VECTOR_3 %load_a, %VECTOR_3* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @V3_ABS(%V3_ABS_interface* %V3_ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call1, float* %la, align 4
  %load_la = load float, float* %la, align 4
  %tmpVar = fcmp ogt float %load_la, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue2

condition_body:                                   ; preds = %continue
  %ACOS_instance = alloca %ACOS_interface, align 8
  br label %input3

continue2:                                        ; preds = %continue6, %continue
  %V3_XANG_ret = load float, float* %V3_XANG, align 4
  ret float %V3_XANG_ret

input3:                                           ; preds = %condition_body
  %2 = getelementptr inbounds %ACOS_interface, %ACOS_interface* %ACOS_instance, i32 0, i32 0
  %X = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 0
  %load_ = load float, float* %X, align 4
  %load_la7 = load float, float* %la, align 4
  %tmpVar8 = fdiv float %load_, %load_la7
  %3 = fptosi float %tmpVar8 to i32
  store i32 %3, i32* %2, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call9 = call double @ACOS(%ACOS_interface* %ACOS_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %4 = fptrunc double %call9 to float
  store float %4, float* %V3_XANG, align 4
  br label %continue2
}

define %VECTOR_3 @V3_XPRO(%V3_XPRO_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_XPRO_interface, %V3_XPRO_interface* %0, i32 0, i32 0
  %B = getelementptr inbounds %V3_XPRO_interface, %V3_XPRO_interface* %0, i32 0, i32 1
  %V3_XPRO = alloca %VECTOR_3, align 8
  %1 = bitcast %VECTOR_3* %V3_XPRO to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%VECTOR_3* @VECTOR_3__init to i8*), i64 mul nuw (i64 ptrtoint (float* getelementptr (float, float* null, i32 1) to i64), i64 3), i1 false)
  %X = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_XPRO, i32 0, i32 0
  %Y = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 1
  %load_ = load float, float* %Y, align 4
  %Z = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 2
  %load_1 = load float, float* %Z, align 4
  %tmpVar = fmul float %load_, %load_1
  %Z2 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 2
  %load_3 = load float, float* %Z2, align 4
  %Y4 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 1
  %load_5 = load float, float* %Y4, align 4
  %tmpVar6 = fmul float %load_3, %load_5
  %tmpVar7 = fsub float %tmpVar, %tmpVar6
  store float %tmpVar7, float* %X, align 4
  %Y8 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_XPRO, i32 0, i32 1
  %Z9 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 2
  %load_10 = load float, float* %Z9, align 4
  %X11 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 0
  %load_12 = load float, float* %X11, align 4
  %tmpVar13 = fmul float %load_10, %load_12
  %X14 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 0
  %load_15 = load float, float* %X14, align 4
  %Z16 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 2
  %load_17 = load float, float* %Z16, align 4
  %tmpVar18 = fmul float %load_15, %load_17
  %tmpVar19 = fsub float %tmpVar13, %tmpVar18
  store float %tmpVar19, float* %Y8, align 4
  %Z20 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %V3_XPRO, i32 0, i32 2
  %X21 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 0
  %load_22 = load float, float* %X21, align 4
  %Y23 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 1
  %load_24 = load float, float* %Y23, align 4
  %tmpVar25 = fmul float %load_22, %load_24
  %Y26 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 1
  %load_27 = load float, float* %Y26, align 4
  %X28 = getelementptr inbounds %VECTOR_3, %VECTOR_3* %B, i32 0, i32 0
  %load_29 = load float, float* %X28, align 4
  %tmpVar30 = fmul float %load_27, %load_29
  %tmpVar31 = fsub float %tmpVar25, %tmpVar30
  store float %tmpVar31, float* %Z20, align 4
  %V3_XPRO_ret = load %VECTOR_3, %VECTOR_3* %V3_XPRO, align 4
  ret %VECTOR_3 %V3_XPRO_ret
}

define float @V3_YANG(%V3_YANG_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_YANG_interface, %V3_YANG_interface* %0, i32 0, i32 0
  %la = getelementptr inbounds %V3_YANG_interface, %V3_YANG_interface* %0, i32 0, i32 1
  %V3_YANG = alloca float, align 4
  store float 0.000000e+00, float* %la, align 4
  store float 0.000000e+00, float* %V3_YANG, align 4
  %V3_ABS_instance = alloca %V3_ABS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %V3_ABS_interface, %V3_ABS_interface* %V3_ABS_instance, i32 0, i32 0
  %load_a = load %VECTOR_3, %VECTOR_3* %A, align 4
  store %VECTOR_3 %load_a, %VECTOR_3* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @V3_ABS(%V3_ABS_interface* %V3_ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call1, float* %la, align 4
  %load_la = load float, float* %la, align 4
  %tmpVar = fcmp ogt float %load_la, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue2

condition_body:                                   ; preds = %continue
  %ACOS_instance = alloca %ACOS_interface, align 8
  br label %input3

continue2:                                        ; preds = %continue6, %continue
  %V3_YANG_ret = load float, float* %V3_YANG, align 4
  ret float %V3_YANG_ret

input3:                                           ; preds = %condition_body
  %2 = getelementptr inbounds %ACOS_interface, %ACOS_interface* %ACOS_instance, i32 0, i32 0
  %Y = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 1
  %load_ = load float, float* %Y, align 4
  %load_la7 = load float, float* %la, align 4
  %tmpVar8 = fdiv float %load_, %load_la7
  %3 = fptosi float %tmpVar8 to i32
  store i32 %3, i32* %2, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call9 = call double @ACOS(%ACOS_interface* %ACOS_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %4 = fptrunc double %call9 to float
  store float %4, float* %V3_YANG, align 4
  br label %continue2
}

define float @V3_ZANG(%V3_ZANG_interface* %0) {
entry:
  %A = getelementptr inbounds %V3_ZANG_interface, %V3_ZANG_interface* %0, i32 0, i32 0
  %la = getelementptr inbounds %V3_ZANG_interface, %V3_ZANG_interface* %0, i32 0, i32 1
  %V3_ZANG = alloca float, align 4
  store float 0.000000e+00, float* %la, align 4
  store float 0.000000e+00, float* %V3_ZANG, align 4
  %V3_ABS_instance = alloca %V3_ABS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %V3_ABS_interface, %V3_ABS_interface* %V3_ABS_instance, i32 0, i32 0
  %load_a = load %VECTOR_3, %VECTOR_3* %A, align 4
  store %VECTOR_3 %load_a, %VECTOR_3* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @V3_ABS(%V3_ABS_interface* %V3_ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call1, float* %la, align 4
  %load_la = load float, float* %la, align 4
  %tmpVar = fcmp ogt float %load_la, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue2

condition_body:                                   ; preds = %continue
  %ACOS_instance = alloca %ACOS_interface, align 8
  br label %input3

continue2:                                        ; preds = %continue6, %continue
  %V3_ZANG_ret = load float, float* %V3_ZANG, align 4
  ret float %V3_ZANG_ret

input3:                                           ; preds = %condition_body
  %2 = getelementptr inbounds %ACOS_interface, %ACOS_interface* %ACOS_instance, i32 0, i32 0
  %Z = getelementptr inbounds %VECTOR_3, %VECTOR_3* %A, i32 0, i32 2
  %load_ = load float, float* %Z, align 4
  %load_la7 = load float, float* %la, align 4
  %tmpVar8 = fdiv float %load_, %load_la7
  %3 = fptosi float %tmpVar8 to i32
  store i32 %3, i32* %2, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call9 = call double @ACOS(%ACOS_interface* %ACOS_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %4 = fptrunc double %call9 to float
  store float %4, float* %V3_ZANG, align 4
  br label %continue2
}

define float @ACOSH(%ACOSH_interface* %0) {
entry:
  %X = getelementptr inbounds %ACOSH_interface, %ACOSH_interface* %0, i32 0, i32 0
  %ACOSH = alloca float, align 4
  store float 0.000000e+00, float* %ACOSH, align 4
  %LN_instance = alloca %LN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call10 = call double @LN(%LN_interface* %LN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %2 = fptrunc double %call10 to float
  store float %2, float* %ACOSH, align 4
  %ACOSH_ret = load float, float* %ACOSH, align 4
  ret float %ACOSH_ret

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  %load_X5 = load float, float* %X, align 4
  %tmpVar = fmul float %load_X, %load_X5
  %tmpVar6 = fsub float %tmpVar, 1.000000e+00
  %4 = fptosi float %tmpVar6 to i32
  store i32 %4, i32* %3, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call7 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %load_X8 = load float, float* %X, align 4
  %5 = fpext float %load_X8 to double
  %tmpVar9 = fadd double %call7, %5
  %6 = fptosi double %tmpVar9 to i32
  store i32 %6, i32* %1, align 4
  br label %call
}

define float @ACOTH(%ACOTH_interface* %0) {
entry:
  %X = getelementptr inbounds %ACOTH_interface, %ACOTH_interface* %0, i32 0, i32 0
  %ACOTH = alloca float, align 4
  store float 0.000000e+00, float* %ACOTH, align 4
  %LN_instance = alloca %LN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %tmpVar = fadd float %load_x, 1.000000e+00
  %load_x1 = load float, float* %X, align 4
  %tmpVar2 = fsub float %load_x1, 1.000000e+00
  %tmpVar3 = fdiv float %tmpVar, %tmpVar2
  %2 = fptosi float %tmpVar3 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call double @LN(%LN_interface* %LN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar5 = fmul double %call4, 5.000000e-01
  %3 = fptrunc double %tmpVar5 to float
  store float %3, float* %ACOTH, align 4
  %ACOTH_ret = load float, float* %ACOTH, align 4
  ret float %ACOTH_ret
}

define float @AGDF(%AGDF_interface* %0) {
entry:
  %X = getelementptr inbounds %AGDF_interface, %AGDF_interface* %0, i32 0, i32 0
  %AGDF = alloca float, align 4
  store float 0.000000e+00, float* %AGDF, align 4
  %LN_instance = alloca %LN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input1

call:                                             ; preds = %continue9
  %call13 = call double @LN(%LN_interface* %LN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %2 = fptrunc double %call13 to float
  store float %2, float* %AGDF, align 4
  %AGDF_ret = load float, float* %AGDF, align 4
  ret float %AGDF_ret

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  %4 = fptosi float %load_X to i32
  store i32 %4, i32* %3, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = fadd double 1.000000e+00, %call5
  %COS_instance = alloca %COS_interface, align 8
  br label %input6

input6:                                           ; preds = %continue4
  %5 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance, i32 0, i32 0
  %load_X10 = load float, float* %X, align 4
  %6 = fptosi float %load_X10 to i32
  store i32 %6, i32* %5, align 4
  br label %call7

call7:                                            ; preds = %input6
  %call11 = call double @COS(%COS_interface* %COS_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %tmpVar12 = fdiv double %tmpVar, %call11
  %7 = fptosi double %tmpVar12 to i32
  store i32 %7, i32* %1, align 4
  br label %call
}

define float @ASINH(%ASINH_interface* %0) {
entry:
  %X = getelementptr inbounds %ASINH_interface, %ASINH_interface* %0, i32 0, i32 0
  %ASINH = alloca float, align 4
  store float 0.000000e+00, float* %ASINH, align 4
  %LN_instance = alloca %LN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call10 = call double @LN(%LN_interface* %LN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %2 = fptrunc double %call10 to float
  store float %2, float* %ASINH, align 4
  %ASINH_ret = load float, float* %ASINH, align 4
  ret float %ASINH_ret

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  %load_X5 = load float, float* %X, align 4
  %tmpVar = fmul float %load_X, %load_X5
  %tmpVar6 = fadd float %tmpVar, 1.000000e+00
  %4 = fptosi float %tmpVar6 to i32
  store i32 %4, i32* %3, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call7 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %load_X8 = load float, float* %X, align 4
  %5 = fpext float %load_X8 to double
  %tmpVar9 = fadd double %call7, %5
  %6 = fptosi double %tmpVar9 to i32
  store i32 %6, i32* %1, align 4
  br label %call
}

define float @ATAN2(%ATAN2_interface* %0) {
entry:
  %Y = getelementptr inbounds %ATAN2_interface, %ATAN2_interface* %0, i32 0, i32 0
  %X = getelementptr inbounds %ATAN2_interface, %ATAN2_interface* %0, i32 0, i32 1
  %ATAN2 = alloca float, align 4
  store float 0.000000e+00, float* %ATAN2, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp ogt float %load_X, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  %ATAN_instance = alloca %ATAN_interface, align 8
  br label %input

branch:                                           ; preds = %entry
  %load_X8 = load float, float* %X, align 4
  %tmpVar9 = fcmp olt float %load_X8, 0.000000e+00
  br i1 %tmpVar9, label %condition_body7, label %branch1

condition_body7:                                  ; preds = %branch
  %load_Y13 = load float, float* %Y, align 4
  %tmpVar14 = fcmp oge float %load_Y13, 0.000000e+00
  br i1 %tmpVar14, label %condition_body12, label %else10

branch1:                                          ; preds = %branch
  %load_Y37 = load float, float* %Y, align 4
  %tmpVar38 = fcmp ogt float %load_Y37, 0.000000e+00
  br i1 %tmpVar38, label %condition_body36, label %branch2

condition_body36:                                 ; preds = %branch1
  %load_39 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 3), align 4
  store float %load_39, float* %ATAN2, align 4
  br label %continue

branch2:                                          ; preds = %branch1
  %load_Y41 = load float, float* %Y, align 4
  %tmpVar42 = fcmp olt float %load_Y41, 0.000000e+00
  br i1 %tmpVar42, label %condition_body40, label %else

condition_body40:                                 ; preds = %branch2
  %load_43 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 3), align 4
  %tmpVar44 = fneg float %load_43
  store float %tmpVar44, float* %ATAN2, align 4
  br label %continue

else:                                             ; preds = %branch2
  store float 0.000000e+00, float* %ATAN2, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body40, %condition_body36, %continue11, %continue3
  %ATAN2_ret = load float, float* %ATAN2, align 4
  ret float %ATAN2_ret

input:                                            ; preds = %condition_body
  %1 = getelementptr inbounds %ATAN_interface, %ATAN_interface* %ATAN_instance, i32 0, i32 0
  %load_Y = load float, float* %Y, align 4
  %load_X4 = load float, float* %X, align 4
  %tmpVar5 = fdiv float %load_Y, %load_X4
  %2 = fpext float %tmpVar5 to double
  store double %2, double* %1, align 8
  br label %call

call:                                             ; preds = %input
  %call6 = call double @ATAN(%ATAN_interface* %ATAN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  %3 = fptrunc double %call6 to float
  store float %3, float* %ATAN2, align 4
  br label %continue

condition_body12:                                 ; preds = %condition_body7
  %ATAN_instance15 = alloca %ATAN_interface, align 8
  br label %input16

else10:                                           ; preds = %condition_body7
  %ATAN_instance25 = alloca %ATAN_interface, align 8
  br label %input26

continue11:                                       ; preds = %continue29, %continue19
  br label %continue

input16:                                          ; preds = %condition_body12
  %4 = getelementptr inbounds %ATAN_interface, %ATAN_interface* %ATAN_instance15, i32 0, i32 0
  %load_Y20 = load float, float* %Y, align 4
  %load_X21 = load float, float* %X, align 4
  %tmpVar22 = fdiv float %load_Y20, %load_X21
  %5 = fpext float %tmpVar22 to double
  store double %5, double* %4, align 8
  br label %call17

call17:                                           ; preds = %input16
  %call23 = call double @ATAN(%ATAN_interface* %ATAN_instance15)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 0), align 4
  %6 = fpext float %load_ to double
  %tmpVar24 = fadd double %call23, %6
  %7 = fptrunc double %tmpVar24 to float
  store float %7, float* %ATAN2, align 4
  br label %continue11

input26:                                          ; preds = %else10
  %8 = getelementptr inbounds %ATAN_interface, %ATAN_interface* %ATAN_instance25, i32 0, i32 0
  %load_Y30 = load float, float* %Y, align 4
  %load_X31 = load float, float* %X, align 4
  %tmpVar32 = fdiv float %load_Y30, %load_X31
  %9 = fpext float %tmpVar32 to double
  store double %9, double* %8, align 8
  br label %call27

call27:                                           ; preds = %input26
  %call33 = call double @ATAN(%ATAN_interface* %ATAN_instance25)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  %load_34 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 0), align 4
  %10 = fpext float %load_34 to double
  %tmpVar35 = fsub double %call33, %10
  %11 = fptrunc double %tmpVar35 to float
  store float %11, float* %ATAN2, align 4
  br label %continue11
}

define float @ATANH(%ATANH_interface* %0) {
entry:
  %X = getelementptr inbounds %ATANH_interface, %ATANH_interface* %0, i32 0, i32 0
  %ATANH = alloca float, align 4
  store float 0.000000e+00, float* %ATANH, align 4
  %LN_instance = alloca %LN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %tmpVar = fadd float 1.000000e+00, %load_x
  %load_x1 = load float, float* %X, align 4
  %tmpVar2 = fsub float 1.000000e+00, %load_x1
  %tmpVar3 = fdiv float %tmpVar, %tmpVar2
  %2 = fptosi float %tmpVar3 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call double @LN(%LN_interface* %LN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar5 = fmul double %call4, 5.000000e-01
  %3 = fptrunc double %tmpVar5 to float
  store float %3, float* %ATANH, align 4
  %ATANH_ret = load float, float* %ATANH, align 4
  ret float %ATANH_ret
}

define float @BETA(%BETA_interface* %0) {
entry:
  %X = getelementptr inbounds %BETA_interface, %BETA_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %BETA_interface, %BETA_interface* %0, i32 0, i32 1
  %BETA = alloca float, align 4
  store float 0.000000e+00, float* %BETA, align 4
  %GAMMA_instance = alloca %GAMMA_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %GAMMA_interface, %GAMMA_interface* %GAMMA_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @GAMMA(%GAMMA_interface* %GAMMA_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %GAMMA_instance2 = alloca %GAMMA_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %2 = getelementptr inbounds %GAMMA_interface, %GAMMA_interface* %GAMMA_instance2, i32 0, i32 0
  %load_Y = load float, float* %Y, align 4
  store float %load_Y, float* %2, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call float @GAMMA(%GAMMA_interface* %GAMMA_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %tmpVar = fmul float %call1, %call7
  %GAMMA_instance8 = alloca %GAMMA_interface, align 8
  br label %input9

input9:                                           ; preds = %continue6
  %3 = getelementptr inbounds %GAMMA_interface, %GAMMA_interface* %GAMMA_instance8, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %load_y = load float, float* %Y, align 4
  %tmpVar13 = fadd float %load_x, %load_y
  store float %tmpVar13, float* %3, align 4
  br label %call10

call10:                                           ; preds = %input9
  %call14 = call float @GAMMA(%GAMMA_interface* %GAMMA_instance8)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  %tmpVar15 = fdiv float %tmpVar, %call14
  store float %tmpVar15, float* %BETA, align 4
  %BETA_ret = load float, float* %BETA, align 4
  ret float %BETA_ret
}

define i32 @BINOM(%BINOM_interface* %0) {
entry:
  %N = getelementptr inbounds %BINOM_interface, %BINOM_interface* %0, i32 0, i32 0
  %K = getelementptr inbounds %BINOM_interface, %BINOM_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %BINOM_interface, %BINOM_interface* %0, i32 0, i32 2
  %BINOM = alloca i32, align 4
  store i16 0, i16* %i, align 2
  store i32 0, i32* %BINOM, align 4
  %load_K = load i16, i16* %K, align 2
  %1 = sext i16 %load_K to i32
  %tmpVar = mul i32 2, %1
  %load_n = load i16, i16* %N, align 2
  %2 = sext i16 %load_n to i32
  %tmpVar1 = icmp sgt i32 %tmpVar, %2
  br i1 %tmpVar1, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %load_n2 = load i16, i16* %N, align 2
  %3 = sext i16 %load_n2 to i32
  %load_k = load i16, i16* %K, align 2
  %4 = sext i16 %load_k to i32
  %tmpVar3 = sub i32 %3, %4
  %5 = trunc i32 %tmpVar3 to i16
  store i16 %5, i16* %K, align 2
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  %load_k7 = load i16, i16* %K, align 2
  %6 = sext i16 %load_k7 to i32
  %load_n8 = load i16, i16* %N, align 2
  %7 = sext i16 %load_n8 to i32
  %tmpVar9 = icmp sgt i32 %6, %7
  br i1 %tmpVar9, label %condition_body6, label %branch

condition_body6:                                  ; preds = %continue
  %BINOM_ret = load i32, i32* %BINOM, align 4
  ret i32 %BINOM_ret

buffer_block:                                     ; No predecessors!
  br label %continue5

branch:                                           ; preds = %continue
  %load_k11 = load i16, i16* %K, align 2
  %8 = sext i16 %load_k11 to i32
  %tmpVar12 = icmp eq i32 %8, 0
  %9 = zext i1 %tmpVar12 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %20, label %16

condition_body10:                                 ; preds = %20
  store i32 1, i32* %BINOM, align 4
  br label %continue5

branch4:                                          ; preds = %20
  %load_k17 = load i16, i16* %K, align 2
  %11 = sext i16 %load_k17 to i32
  %tmpVar18 = icmp eq i32 %11, 1
  br i1 %tmpVar18, label %condition_body16, label %else

condition_body16:                                 ; preds = %branch4
  %load_n19 = load i16, i16* %N, align 2
  %12 = sext i16 %load_n19 to i32
  store i32 %12, i32* %BINOM, align 4
  br label %continue5

else:                                             ; preds = %branch4
  %load_n20 = load i16, i16* %N, align 2
  %13 = sext i16 %load_n20 to i32
  store i32 %13, i32* %BINOM, align 4
  %load_n21 = load i16, i16* %N, align 2
  %14 = sext i16 %load_n21 to i32
  %tmpVar22 = add i32 %14, 1
  %15 = trunc i32 %tmpVar22 to i16
  store i16 %15, i16* %N, align 2
  store i16 2, i16* %i, align 2
  br label %condition_check

continue5:                                        ; preds = %continue23, %condition_body16, %condition_body10, %buffer_block
  %BINOM_ret41 = load i32, i32* %BINOM, align 4
  ret i32 %BINOM_ret41

16:                                               ; preds = %branch
  %load_k13 = load i16, i16* %K, align 2
  %17 = sext i16 %load_k13 to i32
  %load_n14 = load i16, i16* %N, align 2
  %18 = sext i16 %load_n14 to i32
  %tmpVar15 = icmp eq i32 %17, %18
  %19 = zext i1 %tmpVar15 to i32
  br label %20

20:                                               ; preds = %16, %branch
  %21 = phi i32 [ %9, %branch ], [ %19, %16 ]
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %condition_body10, label %branch4

condition_check:                                  ; preds = %increment, %else
  %load_i = load i16, i16* %i, align 2
  %load_i24 = load i16, i16* %i, align 2
  %load_k25 = load i16, i16* %K, align 2
  %tmpVar26 = icmp sle i16 %load_i24, %load_k25
  %23 = icmp ne i1 %tmpVar26, false
  br i1 %23, label %31, label %32

for_body:                                         ; preds = %29
  %load_BINOM = load i32, i32* %BINOM, align 4
  %load_n34 = load i16, i16* %N, align 2
  %24 = sext i16 %load_n34 to i32
  %load_i35 = load i16, i16* %i, align 2
  %25 = sext i16 %load_i35 to i32
  %tmpVar36 = sub i32 %24, %25
  %tmpVar37 = mul i32 %load_BINOM, %tmpVar36
  %load_i38 = load i16, i16* %i, align 2
  %26 = sext i16 %load_i38 to i32
  %tmpVar39 = sdiv i32 %tmpVar37, %26
  store i32 %tmpVar39, i32* %BINOM, align 4
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar40 = add i16 %load_i, 1
  store i16 %tmpVar40, i16* %i, align 2
  br label %condition_check

continue23:                                       ; preds = %29
  br label %continue5

27:                                               ; preds = %32
  %load_i29 = load i16, i16* %i, align 2
  %load_k30 = load i16, i16* %K, align 2
  %tmpVar31 = icmp sge i16 %load_i29, %load_k30
  %28 = icmp ne i1 %tmpVar31, false
  br i1 %28, label %35, label %36

29:                                               ; preds = %36, %32
  %30 = phi i1 [ %33, %32 ], [ %37, %36 ]
  br i1 %30, label %for_body, label %continue23

31:                                               ; preds = %condition_check
  %load_i27 = load i16, i16* %i, align 2
  %tmpVar28 = icmp sge i16 %load_i27, 2
  br label %32

32:                                               ; preds = %31, %condition_check
  %33 = phi i1 [ %tmpVar26, %condition_check ], [ %tmpVar28, %31 ]
  %34 = icmp ne i1 %33, false
  br i1 %34, label %29, label %27

35:                                               ; preds = %27
  %load_i32 = load i16, i16* %i, align 2
  %tmpVar33 = icmp sle i16 %load_i32, 2
  br label %36

36:                                               ; preds = %35, %27
  %37 = phi i1 [ %tmpVar31, %27 ], [ %tmpVar33, %35 ]
  br label %29
}

define float @CAUCHY(%CAUCHY_interface* %0) {
entry:
  %X = getelementptr inbounds %CAUCHY_interface, %CAUCHY_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %CAUCHY_interface, %CAUCHY_interface* %0, i32 0, i32 1
  %U = getelementptr inbounds %CAUCHY_interface, %CAUCHY_interface* %0, i32 0, i32 2
  %tmp = getelementptr inbounds %CAUCHY_interface, %CAUCHY_interface* %0, i32 0, i32 3
  %CAUCHY = alloca float, align 4
  store float 0.000000e+00, float* %tmp, align 4
  store float 0.000000e+00, float* %CAUCHY, align 4
  %load_x = load float, float* %X, align 4
  %load_t = load float, float* %T, align 4
  %tmpVar = fsub float %load_x, %load_t
  store float %tmpVar, float* %tmp, align 4
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 5), align 4
  %load_U = load float, float* %U, align 4
  %tmpVar1 = fmul float %load_, %load_U
  %load_U2 = load float, float* %U, align 4
  %load_U3 = load float, float* %U, align 4
  %tmpVar4 = fmul float %load_U2, %load_U3
  %load_tmp = load float, float* %tmp, align 4
  %load_tmp5 = load float, float* %tmp, align 4
  %tmpVar6 = fmul float %load_tmp, %load_tmp5
  %tmpVar7 = fadd float %tmpVar4, %tmpVar6
  %tmpVar8 = fdiv float %tmpVar1, %tmpVar7
  store float %tmpVar8, float* %CAUCHY, align 4
  %CAUCHY_ret = load float, float* %CAUCHY, align 4
  ret float %CAUCHY_ret
}

define float @CAUCHYCD(%CAUCHYCD_interface* %0) {
entry:
  %X = getelementptr inbounds %CAUCHYCD_interface, %CAUCHYCD_interface* %0, i32 0, i32 0
  %T = getelementptr inbounds %CAUCHYCD_interface, %CAUCHYCD_interface* %0, i32 0, i32 1
  %U = getelementptr inbounds %CAUCHYCD_interface, %CAUCHYCD_interface* %0, i32 0, i32 2
  %CAUCHYCD = alloca float, align 4
  store float 0.000000e+00, float* %CAUCHYCD, align 4
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 5), align 4
  %1 = fpext float %load_ to double
  %ATAN_instance = alloca %ATAN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %ATAN_interface, %ATAN_interface* %ATAN_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  %load_T = load float, float* %T, align 4
  %tmpVar = fsub float %load_X, %load_T
  %load_U = load float, float* %U, align 4
  %tmpVar1 = fdiv float %tmpVar, %load_U
  %3 = fpext float %tmpVar1 to double
  store double %3, double* %2, align 8
  br label %call

call:                                             ; preds = %input
  %call2 = call double @ATAN(%ATAN_interface* %ATAN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar3 = fmul double %1, %call2
  %tmpVar4 = fadd double 5.000000e-01, %tmpVar3
  %4 = fptrunc double %tmpVar4 to float
  store float %4, float* %CAUCHYCD, align 4
  %CAUCHYCD_ret = load float, float* %CAUCHYCD, align 4
  ret float %CAUCHYCD_ret
}

define i16 @CEIL(%CEIL_interface* %0) {
entry:
  %X = getelementptr inbounds %CEIL_interface, %CEIL_interface* %0, i32 0, i32 0
  %CEIL = alloca i16, align 2
  store i16 0, i16* %CEIL, align 2
  %REAL_TO_INT_instance = alloca %REAL_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %REAL_TO_INT_interface, %REAL_TO_INT_interface* %REAL_TO_INT_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  store float %load_x, float* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @REAL_TO_INT(%REAL_TO_INT_interface* %REAL_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %CEIL, align 2
  %load_CEIL = load i16, i16* %CEIL, align 2
  %2 = sitofp i16 %load_CEIL to float
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp olt float %2, %load_X
  br i1 %tmpVar, label %condition_body, label %continue2

condition_body:                                   ; preds = %continue
  %load_CEIL3 = load i16, i16* %CEIL, align 2
  %3 = sext i16 %load_CEIL3 to i32
  %tmpVar4 = add i32 %3, 1
  %4 = trunc i32 %tmpVar4 to i16
  store i16 %4, i16* %CEIL, align 2
  br label %continue2

continue2:                                        ; preds = %condition_body, %continue
  %CEIL_ret = load i16, i16* %CEIL, align 2
  ret i16 %CEIL_ret
}

define i32 @CEIL2(%CEIL2_interface* %0) {
entry:
  %X = getelementptr inbounds %CEIL2_interface, %CEIL2_interface* %0, i32 0, i32 0
  %CEIL2 = alloca i32, align 4
  store i32 0, i32* %CEIL2, align 4
  %REAL_TO_DINT_instance = alloca %REAL_TO_DINT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %REAL_TO_DINT_interface, %REAL_TO_DINT_interface* %REAL_TO_DINT_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @REAL_TO_DINT(%REAL_TO_DINT_interface* %REAL_TO_DINT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %CEIL2, align 4
  %DINT_TO_REAL_instance = alloca %DINT_TO_REAL_interface, align 8
  br label %input3

condition_body:                                   ; preds = %continue6
  %load_CEIL29 = load i32, i32* %CEIL2, align 4
  %tmpVar10 = add i32 %load_CEIL29, 1
  store i32 %tmpVar10, i32* %CEIL2, align 4
  br label %continue2

continue2:                                        ; preds = %condition_body, %continue6
  %CEIL2_ret = load i32, i32* %CEIL2, align 4
  ret i32 %CEIL2_ret

input3:                                           ; preds = %continue
  %2 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance, i32 0, i32 0
  %load_CEIL2 = load i32, i32* %CEIL2, align 4
  store i32 %load_CEIL2, i32* %2, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %load_X8 = load float, float* %X, align 4
  %tmpVar = fcmp olt float %call7, %load_X8
  br i1 %tmpVar, label %condition_body, label %continue2
}

define i8 @CMP(%CMP_interface* %0) {
entry:
  %X = getelementptr inbounds %CMP_interface, %CMP_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %CMP_interface, %CMP_interface* %0, i32 0, i32 1
  %N = getelementptr inbounds %CMP_interface, %CMP_interface* %0, i32 0, i32 2
  %tmp = getelementptr inbounds %CMP_interface, %CMP_interface* %0, i32 0, i32 3
  %CMP = alloca i8, align 1
  store float 0.000000e+00, float* %tmp, align 4
  store i8 0, i8* %CMP, align 1
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %2 = fptoui float %load_x to i64
  store i64 %2, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = uitofp i64 %call1 to float
  store float %3, float* %tmp, align 4
  %load_tmp = load float, float* %tmp, align 4
  %tmpVar = fcmp ogt float %load_tmp, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %continue
  %EXP10_instance = alloca %EXP10_interface, align 8
  br label %input3

else:                                             ; preds = %continue
  %EXP10_instance26 = alloca %EXP10_interface, align 8
  br label %input27

continue2:                                        ; preds = %continue30, %continue6
  %ABS_instance33 = alloca %ABS_interface, align 8
  br label %input34

input3:                                           ; preds = %condition_body
  %4 = getelementptr inbounds %EXP10_interface, %EXP10_interface* %EXP10_instance, i32 0, i32 0
  %INT_TO_REAL_instance = alloca %INT_TO_REAL_interface, align 8
  br label %input7

call4:                                            ; preds = %continue10
  %call25 = call float @EXP10(%EXP10_interface* %EXP10_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  store float %call25, float* %tmp, align 4
  br label %continue2

input7:                                           ; preds = %input3
  %5 = getelementptr inbounds %INT_TO_REAL_interface, %INT_TO_REAL_interface* %INT_TO_REAL_instance, i32 0, i32 0
  %FLOOR_instance = alloca %FLOOR_interface, align 8
  br label %input11

call8:                                            ; preds = %continue14
  %call24 = call float @INT_TO_REAL(%INT_TO_REAL_interface* %INT_TO_REAL_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  store float %call24, float* %4, align 4
  br label %call4

input11:                                          ; preds = %input7
  %6 = getelementptr inbounds %FLOOR_interface, %FLOOR_interface* %FLOOR_instance, i32 0, i32 0
  %LOG_instance = alloca %LOG_interface, align 8
  br label %input15

call12:                                           ; preds = %continue18
  %call21 = call i16 @FLOOR(%FLOOR_interface* %FLOOR_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %7 = sext i16 %call21 to i32
  %load_N = load i16, i16* %N, align 2
  %8 = sext i16 %load_N to i32
  %tmpVar22 = sub i32 %7, %8
  %tmpVar23 = add i32 %tmpVar22, 1
  %9 = trunc i32 %tmpVar23 to i16
  store i16 %9, i16* %5, align 2
  br label %call8

input15:                                          ; preds = %input11
  %10 = getelementptr inbounds %LOG_interface, %LOG_interface* %LOG_instance, i32 0, i32 0
  %load_tmp19 = load float, float* %tmp, align 4
  %11 = fptoui float %load_tmp19 to i64
  store i64 %11, i64* %10, align 4
  br label %call16

call16:                                           ; preds = %input15
  %call20 = call i64 @LOG(%LOG_interface* %LOG_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %12 = uitofp i64 %call20 to float
  store float %12, float* %6, align 4
  br label %call12

input27:                                          ; preds = %else
  %13 = getelementptr inbounds %EXP10_interface, %EXP10_interface* %EXP10_instance26, i32 0, i32 0
  %load_tmp31 = load float, float* %tmp, align 4
  store float %load_tmp31, float* %13, align 4
  br label %call28

call28:                                           ; preds = %input27
  %call32 = call float @EXP10(%EXP10_interface* %EXP10_instance26)
  br label %output29

output29:                                         ; preds = %call28
  br label %continue30

continue30:                                       ; preds = %output29
  store float %call32, float* %tmp, align 4
  br label %continue2

input34:                                          ; preds = %continue2
  %14 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance33, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  %load_Y = load float, float* %Y, align 4
  %tmpVar38 = fsub float %load_X, %load_Y
  %15 = fptoui float %tmpVar38 to i64
  store i64 %15, i64* %14, align 4
  br label %call35

call35:                                           ; preds = %input34
  %call39 = call i64 @ABS(%ABS_interface* %ABS_instance33)
  br label %output36

output36:                                         ; preds = %call35
  br label %continue37

continue37:                                       ; preds = %output36
  %16 = uitofp i64 %call39 to double
  %load_tmp40 = load float, float* %tmp, align 4
  %17 = fpext float %load_tmp40 to double
  %tmpVar41 = fcmp olt double %16, %17
  %18 = zext i1 %tmpVar41 to i8
  store i8 %18, i8* %CMP, align 1
  %CMP_ret = load i8, i8* %CMP, align 1
  ret i8 %CMP_ret
}

define float @COSH(%COSH_interface* %0) {
entry:
  %X = getelementptr inbounds %COSH_interface, %COSH_interface* %0, i32 0, i32 0
  %t = getelementptr inbounds %COSH_interface, %COSH_interface* %0, i32 0, i32 1
  %COSH = alloca float, align 4
  store float 0.000000e+00, float* %t, align 4
  store float 0.000000e+00, float* %COSH, align 4
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  %2 = fptosi float %load_X to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = fptrunc double %call1 to float
  store float %3, float* %t, align 4
  %load_T = load float, float* %t, align 4
  %tmpVar = fdiv float 1.000000e+00, %load_T
  %load_T2 = load float, float* %t, align 4
  %tmpVar3 = fadd float %tmpVar, %load_T2
  %tmpVar4 = fmul float %tmpVar3, 5.000000e-01
  store float %tmpVar4, float* %COSH, align 4
  %COSH_ret = load float, float* %COSH, align 4
  ret float %COSH_ret
}

define float @COTH(%COTH_interface* %0) {
entry:
  %X = getelementptr inbounds %COTH_interface, %COTH_interface* %0, i32 0, i32 0
  %COTH = alloca float, align 4
  store float 0.000000e+00, float* %COTH, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp ogt float %load_X, 2.000000e+01
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store float 1.000000e+00, float* %COTH, align 4
  br label %continue

branch:                                           ; preds = %entry
  %load_X2 = load float, float* %X, align 4
  %tmpVar3 = fcmp olt float %load_X2, -2.000000e+01
  br i1 %tmpVar3, label %condition_body1, label %else

condition_body1:                                  ; preds = %branch
  store float -1.000000e+00, float* %COTH, align 4
  br label %continue

else:                                             ; preds = %branch
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input

continue:                                         ; preds = %continue4, %condition_body1, %condition_body
  %COTH_ret = load float, float* %COTH, align 4
  ret float %COTH_ret

input:                                            ; preds = %else
  %1 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %load_X5 = load float, float* %X, align 4
  %tmpVar6 = fmul float %load_X5, 2.000000e+00
  %2 = fptosi float %tmpVar6 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call7 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue4

continue4:                                        ; preds = %output
  %tmpVar8 = fsub double %call7, 1.000000e+00
  %tmpVar9 = fdiv double 2.000000e+00, %tmpVar8
  %tmpVar10 = fadd double 1.000000e+00, %tmpVar9
  %3 = fptrunc double %tmpVar10 to float
  store float %3, float* %COTH, align 4
  br label %continue
}

define i32 @D_TRUNC(%D_TRUNC_interface* %0) {
entry:
  %X = getelementptr inbounds %D_TRUNC_interface, %D_TRUNC_interface* %0, i32 0, i32 0
  %D_TRUNC = alloca i32, align 4
  store i32 0, i32* %D_TRUNC, align 4
  %REAL_TO_DINT_instance = alloca %REAL_TO_DINT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %REAL_TO_DINT_interface, %REAL_TO_DINT_interface* %REAL_TO_DINT_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @REAL_TO_DINT(%REAL_TO_DINT_interface* %REAL_TO_DINT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %D_TRUNC, align 4
  %load_X3 = load float, float* %X, align 4
  %tmpVar = fcmp ogt float %load_X3, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %continue
  %DINT_TO_REAL_instance = alloca %DINT_TO_REAL_interface, align 8
  br label %input6

else:                                             ; preds = %continue
  %DINT_TO_REAL_instance17 = alloca %DINT_TO_REAL_interface, align 8
  br label %input18

continue2:                                        ; preds = %continue15, %continue4
  %D_TRUNC_ret = load i32, i32* %D_TRUNC, align 4
  ret i32 %D_TRUNC_ret

condition_body5:                                  ; preds = %continue9
  %load_D_TRUNC13 = load i32, i32* %D_TRUNC, align 4
  %tmpVar14 = sub i32 %load_D_TRUNC13, 1
  store i32 %tmpVar14, i32* %D_TRUNC, align 4
  br label %continue4

continue4:                                        ; preds = %condition_body5, %continue9
  br label %continue2

input6:                                           ; preds = %condition_body
  %2 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance, i32 0, i32 0
  %load_D_TRUNC = load i32, i32* %D_TRUNC, align 4
  store i32 %load_D_TRUNC, i32* %2, align 4
  br label %call7

call7:                                            ; preds = %input6
  %call10 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %load_X11 = load float, float* %X, align 4
  %tmpVar12 = fcmp ogt float %call10, %load_X11
  br i1 %tmpVar12, label %condition_body5, label %continue4

condition_body16:                                 ; preds = %continue21
  %load_D_TRUNC26 = load i32, i32* %D_TRUNC, align 4
  %tmpVar27 = add i32 %load_D_TRUNC26, 1
  store i32 %tmpVar27, i32* %D_TRUNC, align 4
  br label %continue15

continue15:                                       ; preds = %condition_body16, %continue21
  br label %continue2

input18:                                          ; preds = %else
  %3 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance17, i32 0, i32 0
  %load_D_TRUNC22 = load i32, i32* %D_TRUNC, align 4
  store i32 %load_D_TRUNC22, i32* %3, align 4
  br label %call19

call19:                                           ; preds = %input18
  %call23 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance17)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %load_X24 = load float, float* %X, align 4
  %tmpVar25 = fcmp olt float %call23, %load_X24
  br i1 %tmpVar25, label %condition_body16, label %continue15
}

define i16 @DEC1(%DEC1_interface* %0) {
entry:
  %X = getelementptr inbounds %DEC1_interface, %DEC1_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %DEC1_interface, %DEC1_interface* %0, i32 0, i32 1
  %DEC1 = alloca i16, align 2
  store i16 0, i16* %DEC1, align 2
  %load_X = load i16, i16* %X, align 2
  %1 = sext i16 %load_X to i32
  %tmpVar = icmp eq i32 %1, 0
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_N = load i16, i16* %N, align 2
  %2 = sext i16 %load_N to i32
  %tmpVar1 = sub i32 %2, 1
  %3 = trunc i32 %tmpVar1 to i16
  store i16 %3, i16* %DEC1, align 2
  br label %continue

else:                                             ; preds = %entry
  %load_X2 = load i16, i16* %X, align 2
  %4 = sext i16 %load_X2 to i32
  %tmpVar3 = sub i32 %4, 1
  %5 = trunc i32 %tmpVar3 to i16
  store i16 %5, i16* %DEC1, align 2
  br label %continue

continue:                                         ; preds = %else, %condition_body
  %DEC1_ret = load i16, i16* %DEC1, align 2
  ret i16 %DEC1_ret
}

define float @DEG(%DEG_interface* %0) {
entry:
  %rad = getelementptr inbounds %DEG_interface, %DEG_interface* %0, i32 0, i32 0
  %DEG = alloca float, align 4
  store float 0.000000e+00, float* %DEG, align 4
  %MODR_instance = alloca %MODR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 0
  %load_RAD = load float, float* %rad, align 4
  %tmpVar = fmul float 0x404CA5DC20000000, %load_RAD
  store float %tmpVar, float* %1, align 4
  %2 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 1
  store float 3.600000e+02, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @MODR(%MODR_interface* %MODR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call1, float* %DEG, align 4
  %DEG_ret = load float, float* %DEG, align 4
  ret float %DEG_ret
}

define i8 @DIFFER(%DIFFER_interface* %0) {
entry:
  %in1 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %0, i32 0, i32 0
  %in2 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %0, i32 0, i32 1
  %X = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %0, i32 0, i32 2
  %DIFFER = alloca i8, align 1
  store i8 0, i8* %DIFFER, align 1
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_in1 = load float, float* %in1, align 4
  %load_in2 = load float, float* %in2, align 4
  %tmpVar = fsub float %load_in1, %load_in2
  %2 = fptoui float %tmpVar to i64
  store i64 %2, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = uitofp i64 %call1 to double
  %load_X = load float, float* %X, align 4
  %4 = fpext float %load_X to double
  %tmpVar2 = fcmp ogt double %3, %4
  %5 = zext i1 %tmpVar2 to i8
  store i8 %5, i8* %DIFFER, align 1
  %DIFFER_ret = load i8, i8* %DIFFER, align 1
  ret i8 %DIFFER_ret
}

define float @ERF(%ERF_interface* %0) {
entry:
  %X = getelementptr inbounds %ERF_interface, %ERF_interface* %0, i32 0, i32 0
  %x2 = getelementptr inbounds %ERF_interface, %ERF_interface* %0, i32 0, i32 1
  %ax2 = getelementptr inbounds %ERF_interface, %ERF_interface* %0, i32 0, i32 2
  %ERF = alloca float, align 4
  store float 0.000000e+00, float* %x2, align 4
  store float 0.000000e+00, float* %ax2, align 4
  store float 0.000000e+00, float* %ERF, align 4
  %load_X = load float, float* %X, align 4
  %load_X1 = load float, float* %X, align 4
  %tmpVar = fmul float %load_X, %load_X1
  store float %tmpVar, float* %x2, align 4
  %load_x2 = load float, float* %x2, align 4
  %tmpVar2 = fmul float 0x3FC2D0E560000000, %load_x2
  %tmpVar3 = fadd float %tmpVar2, 1.000000e+00
  store float %tmpVar3, float* %ax2, align 4
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input4

call:                                             ; preds = %continue7
  %call14 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %SGN_instance = alloca %SGN_interface, align 8
  br label %input15

input4:                                           ; preds = %input
  %2 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %load_X2 = load float, float* %x2, align 4
  %tmpVar8 = fneg float %load_X2
  %load_aX2 = load float, float* %ax2, align 4
  %tmpVar9 = fadd float 0x3FD17CC1C0000000, %load_aX2
  %load_ax2 = load float, float* %ax2, align 4
  %tmpVar10 = fdiv float %tmpVar9, %load_ax2
  %tmpVar11 = fmul float %tmpVar8, %tmpVar10
  %3 = fptosi float %tmpVar11 to i32
  store i32 %3, i32* %2, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call12 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %tmpVar13 = fsub double 1.000000e+00, %call12
  %4 = fptosi double %tmpVar13 to i32
  store i32 %4, i32* %1, align 4
  br label %call

input15:                                          ; preds = %continue
  %5 = getelementptr inbounds %SGN_interface, %SGN_interface* %SGN_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  store float %load_x, float* %5, align 4
  br label %call16

call16:                                           ; preds = %input15
  %call19 = call i16 @SGN(%SGN_interface* %SGN_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %6 = sitofp i16 %call19 to double
  %tmpVar20 = fmul double %call14, %6
  %7 = fptrunc double %tmpVar20 to float
  store float %7, float* %ERF, align 4
  %ERF_ret = load float, float* %ERF, align 4
  ret float %ERF_ret
}

define float @ERFC(%ERFC_interface* %0) {
entry:
  %X = getelementptr inbounds %ERFC_interface, %ERFC_interface* %0, i32 0, i32 0
  %ERFC = alloca float, align 4
  store float 0.000000e+00, float* %ERFC, align 4
  %ERF_instance = alloca %ERF_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ERF_interface, %ERF_interface* %ERF_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @ERF(%ERF_interface* %ERF_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = fsub float 1.000000e+00, %call1
  store float %tmpVar, float* %ERFC, align 4
  %ERFC_ret = load float, float* %ERFC, align 4
  ret float %ERFC_ret
}

define i8 @EVEN(%EVEN_interface* %0) {
entry:
  %in = getelementptr inbounds %EVEN_interface, %EVEN_interface* %0, i32 0, i32 0
  %EVEN = alloca i8, align 1
  store i8 0, i8* %EVEN, align 1
  %load_in = load i32, i32* %in, align 4
  %shift = ashr i32 %load_in, 0
  %1 = trunc i32 %shift to i8
  %tmpVar = xor i8 %1, -1
  store i8 %tmpVar, i8* %EVEN, align 1
  %EVEN_ret = load i8, i8* %EVEN, align 1
  ret i8 %EVEN_ret
}

define float @EXP10(%EXP10_interface* %0) {
entry:
  %X = getelementptr inbounds %EXP10_interface, %EXP10_interface* %0, i32 0, i32 0
  %EXP10 = alloca float, align 4
  store float 0.000000e+00, float* %EXP10, align 4
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  %tmpVar = fmul float %load_X, 0x40026BB1C0000000
  %2 = fptosi float %tmpVar to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = fptrunc double %call1 to float
  store float %3, float* %EXP10, align 4
  %EXP10_ret = load float, float* %EXP10, align 4
  ret float %EXP10_ret
}

define float @EXPN(%EXPN_interface* %0) {
entry:
  %X = getelementptr inbounds %EXPN_interface, %EXPN_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %EXPN_interface, %EXPN_interface* %0, i32 0, i32 1
  %sign = getelementptr inbounds %EXPN_interface, %EXPN_interface* %0, i32 0, i32 2
  %EXPN = alloca float, align 4
  store i8 0, i8* %sign, align 1
  store float 0.000000e+00, float* %EXPN, align 4
  %load_n = load i16, i16* %N, align 2
  %shift = ashr i16 %load_n, 15
  %1 = trunc i16 %shift to i8
  store i8 %1, i8* %sign, align 1
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_N = load i16, i16* %N, align 2
  %3 = sext i16 %load_N to i64
  store i64 %3, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = trunc i64 %call1 to i16
  store i16 %4, i16* %N, align 2
  %load_N3 = load i16, i16* %N, align 2
  %shift4 = ashr i16 %load_N3, 0
  %5 = trunc i16 %shift4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %condition_body, label %else

condition_body:                                   ; preds = %continue
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %EXPN, align 4
  br label %continue2

else:                                             ; preds = %continue
  store float 1.000000e+00, float* %EXPN, align 4
  br label %continue2

continue2:                                        ; preds = %else, %condition_body
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input5

input5:                                           ; preds = %continue2
  %7 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_N9 = load i16, i16* %N, align 2
  %8 = sext i16 %load_N9 to i64
  store i64 %8, i64* %7, align 4
  %9 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 1, i16* %9, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call10 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %10 = trunc i64 %call10 to i16
  store i16 %10, i16* %N, align 2
  br label %condition_check

condition_check:                                  ; preds = %continue8, %continue26
  %load_N12 = load i16, i16* %N, align 2
  %11 = sext i16 %load_N12 to i32
  %tmpVar = icmp sgt i32 %11, 0
  br i1 %tmpVar, label %while_body, label %continue11

while_body:                                       ; preds = %condition_check
  %load_X13 = load float, float* %X, align 4
  %load_X14 = load float, float* %X, align 4
  %tmpVar15 = fmul float %load_X13, %load_X14
  store float %tmpVar15, float* %X, align 4
  %load_N18 = load i16, i16* %N, align 2
  %shift19 = ashr i16 %load_N18, 0
  %12 = trunc i16 %shift19 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %condition_body17, label %continue16

continue11:                                       ; preds = %condition_check
  %load_sign = load i8, i8* %sign, align 1
  %14 = icmp ne i8 %load_sign, 0
  br i1 %14, label %condition_body30, label %continue29

condition_body17:                                 ; preds = %while_body
  %load_EXPN = load float, float* %EXPN, align 4
  %load_X20 = load float, float* %X, align 4
  %tmpVar21 = fmul float %load_EXPN, %load_X20
  store float %tmpVar21, float* %EXPN, align 4
  br label %continue16

continue16:                                       ; preds = %condition_body17, %while_body
  %SHR_instance22 = alloca %SHR_interface, align 8
  br label %input23

input23:                                          ; preds = %continue16
  %15 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance22, i32 0, i32 0
  %load_N27 = load i16, i16* %N, align 2
  %16 = sext i16 %load_N27 to i64
  store i64 %16, i64* %15, align 4
  %17 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance22, i32 0, i32 1
  store i16 1, i16* %17, align 2
  br label %call24

call24:                                           ; preds = %input23
  %call28 = call i64 @SHR(%SHR_interface* %SHR_instance22)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %18 = trunc i64 %call28 to i16
  store i16 %18, i16* %N, align 2
  br label %condition_check

condition_body30:                                 ; preds = %continue11
  %load_EXPN31 = load float, float* %EXPN, align 4
  %tmpVar32 = fdiv float 1.000000e+00, %load_EXPN31
  store float %tmpVar32, float* %EXPN, align 4
  br label %continue29

continue29:                                       ; preds = %condition_body30, %continue11
  %EXPN_ret = load float, float* %EXPN, align 4
  ret float %EXPN_ret
}

define i32 @FACT(%FACT_interface* %0) {
entry:
  %X = getelementptr inbounds %FACT_interface, %FACT_interface* %0, i32 0, i32 0
  %FACT = alloca i32, align 4
  store i32 0, i32* %FACT, align 4
  %load_X = load i16, i16* %X, align 2
  %1 = sext i16 %load_X to i32
  %tmpVar = icmp sge i32 %1, 0
  %2 = zext i1 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %5, label %8

condition_body:                                   ; preds = %8
  %load_X3 = load i16, i16* %X, align 2
  %4 = sext i16 %load_X3 to i32
  %tmpVar4 = mul i32 1, %4
  %tmpVar5 = add i32 %tmpVar4, 0
  %tmpVar6 = getelementptr inbounds [13 x i32], [13 x i32]* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 9), i32 0, i32 %tmpVar5
  %load_ = load i32, i32* %tmpVar6, align 4
  store i32 %load_, i32* %FACT, align 4
  br label %continue

else:                                             ; preds = %8
  store i32 -1, i32* %FACT, align 4
  br label %continue

continue:                                         ; preds = %else, %condition_body
  %FACT_ret = load i32, i32* %FACT, align 4
  ret i32 %FACT_ret

5:                                                ; preds = %entry
  %load_X1 = load i16, i16* %X, align 2
  %6 = sext i16 %load_X1 to i32
  %tmpVar2 = icmp sle i32 %6, 12
  %7 = zext i1 %tmpVar2 to i32
  br label %8

8:                                                ; preds = %5, %entry
  %9 = phi i32 [ %2, %entry ], [ %7, %5 ]
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %condition_body, label %else
}

define i32 @FIB(%FIB_interface* %0) {
entry:
  %X = getelementptr inbounds %FIB_interface, %FIB_interface* %0, i32 0, i32 0
  %t1 = getelementptr inbounds %FIB_interface, %FIB_interface* %0, i32 0, i32 1
  %t2 = getelementptr inbounds %FIB_interface, %FIB_interface* %0, i32 0, i32 2
  %FIB = alloca i32, align 4
  store i32 0, i32* %t1, align 4
  store i32 0, i32* %t2, align 4
  store i32 0, i32* %FIB, align 4
  %load_X = load i16, i16* %X, align 2
  %1 = sext i16 %load_X to i32
  %tmpVar = icmp slt i32 %1, 0
  %2 = zext i1 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %9, label %6

condition_body:                                   ; preds = %9
  store i32 -1, i32* %FIB, align 4
  br label %continue

branch:                                           ; preds = %9
  %load_x = load i16, i16* %X, align 2
  %4 = sext i16 %load_x to i32
  %tmpVar4 = icmp slt i32 %4, 2
  br i1 %tmpVar4, label %condition_body3, label %else

condition_body3:                                  ; preds = %branch
  %load_X5 = load i16, i16* %X, align 2
  %5 = sext i16 %load_X5 to i32
  store i32 %5, i32* %FIB, align 4
  %FIB_ret = load i32, i32* %FIB, align 4
  ret i32 %FIB_ret

buffer_block:                                     ; No predecessors!
  br label %continue

else:                                             ; preds = %branch
  store i32 1, i32* %t2, align 4
  br label %condition_check

continue:                                         ; preds = %continue15, %buffer_block, %condition_body
  %FIB_ret25 = load i32, i32* %FIB, align 4
  ret i32 %FIB_ret25

6:                                                ; preds = %entry
  %load_X1 = load i16, i16* %X, align 2
  %7 = sext i16 %load_X1 to i32
  %tmpVar2 = icmp sgt i32 %7, 46
  %8 = zext i1 %tmpVar2 to i32
  br label %9

9:                                                ; preds = %6, %entry
  %10 = phi i32 [ %2, %entry ], [ %8, %6 ]
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %condition_body, label %branch

condition_check:                                  ; preds = %else, %while_body
  %load_X7 = load i16, i16* %X, align 2
  %12 = sext i16 %load_X7 to i32
  %tmpVar8 = icmp sgt i32 %12, 3
  br i1 %tmpVar8, label %while_body, label %continue6

while_body:                                       ; preds = %condition_check
  %load_X9 = load i16, i16* %X, align 2
  %13 = sext i16 %load_X9 to i32
  %tmpVar10 = sub i32 %13, 2
  %14 = trunc i32 %tmpVar10 to i16
  store i16 %14, i16* %X, align 2
  %load_t1 = load i32, i32* %t1, align 4
  %load_t2 = load i32, i32* %t2, align 4
  %tmpVar11 = add i32 %load_t1, %load_t2
  store i32 %tmpVar11, i32* %t1, align 4
  %load_t112 = load i32, i32* %t1, align 4
  %load_t213 = load i32, i32* %t2, align 4
  %tmpVar14 = add i32 %load_t112, %load_t213
  store i32 %tmpVar14, i32* %t2, align 4
  br label %condition_check

continue6:                                        ; preds = %condition_check
  %load_X17 = load i16, i16* %X, align 2
  %15 = sext i16 %load_X17 to i32
  %tmpVar18 = icmp sgt i32 %15, 2
  br i1 %tmpVar18, label %condition_body16, label %continue15

condition_body16:                                 ; preds = %continue6
  %load_t119 = load i32, i32* %t1, align 4
  %load_t220 = load i32, i32* %t2, align 4
  %tmpVar21 = add i32 %load_t119, %load_t220
  store i32 %tmpVar21, i32* %t1, align 4
  br label %continue15

continue15:                                       ; preds = %condition_body16, %continue6
  %load_t122 = load i32, i32* %t1, align 4
  %load_t223 = load i32, i32* %t2, align 4
  %tmpVar24 = add i32 %load_t122, %load_t223
  store i32 %tmpVar24, i32* %FIB, align 4
  br label %continue
}

define i16 @FLOOR(%FLOOR_interface* %0) {
entry:
  %X = getelementptr inbounds %FLOOR_interface, %FLOOR_interface* %0, i32 0, i32 0
  %FLOOR = alloca i16, align 2
  store i16 0, i16* %FLOOR, align 2
  %REAL_TO_INT_instance = alloca %REAL_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %REAL_TO_INT_interface, %REAL_TO_INT_interface* %REAL_TO_INT_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @REAL_TO_INT(%REAL_TO_INT_interface* %REAL_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %FLOOR, align 2
  %load_FLOOR = load i16, i16* %FLOOR, align 2
  %2 = sitofp i16 %load_FLOOR to float
  %load_X3 = load float, float* %X, align 4
  %tmpVar = fcmp ogt float %2, %load_X3
  br i1 %tmpVar, label %condition_body, label %continue2

condition_body:                                   ; preds = %continue
  %load_FLOOR4 = load i16, i16* %FLOOR, align 2
  %3 = sext i16 %load_FLOOR4 to i32
  %tmpVar5 = sub i32 %3, 1
  %4 = trunc i32 %tmpVar5 to i16
  store i16 %4, i16* %FLOOR, align 2
  br label %continue2

continue2:                                        ; preds = %condition_body, %continue
  %FLOOR_ret = load i16, i16* %FLOOR, align 2
  ret i16 %FLOOR_ret
}

define i32 @FLOOR2(%FLOOR2_interface* %0) {
entry:
  %X = getelementptr inbounds %FLOOR2_interface, %FLOOR2_interface* %0, i32 0, i32 0
  %FLOOR2 = alloca i32, align 4
  store i32 0, i32* %FLOOR2, align 4
  %REAL_TO_DINT_instance = alloca %REAL_TO_DINT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %REAL_TO_DINT_interface, %REAL_TO_DINT_interface* %REAL_TO_DINT_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @REAL_TO_DINT(%REAL_TO_DINT_interface* %REAL_TO_DINT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %FLOOR2, align 4
  %DINT_TO_REAL_instance = alloca %DINT_TO_REAL_interface, align 8
  br label %input3

condition_body:                                   ; preds = %continue6
  %load_FLOOR29 = load i32, i32* %FLOOR2, align 4
  %tmpVar10 = sub i32 %load_FLOOR29, 1
  store i32 %tmpVar10, i32* %FLOOR2, align 4
  br label %continue2

continue2:                                        ; preds = %condition_body, %continue6
  %FLOOR2_ret = load i32, i32* %FLOOR2, align 4
  ret i32 %FLOOR2_ret

input3:                                           ; preds = %continue
  %2 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance, i32 0, i32 0
  %load_FLOOR2 = load i32, i32* %FLOOR2, align 4
  store i32 %load_FLOOR2, i32* %2, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %load_X8 = load float, float* %X, align 4
  %tmpVar = fcmp ogt float %call7, %load_X8
  br i1 %tmpVar, label %condition_body, label %continue2
}

define float @FRACT(%FRACT_interface* %0) {
entry:
  %x = getelementptr inbounds %FRACT_interface, %FRACT_interface* %0, i32 0, i32 0
  %FRACT = alloca float, align 4
  store float 0.000000e+00, float* %FRACT, align 4
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input

condition_body:                                   ; preds = %continue1
  %load_x3 = load float, float* %x, align 4
  %DINT_TO_REAL_instance = alloca %DINT_TO_REAL_interface, align 8
  br label %input4

else:                                             ; preds = %continue1
  store float 0.000000e+00, float* %FRACT, align 4
  br label %continue

continue:                                         ; preds = %else, %continue7
  %FRACT_ret = load float, float* %FRACT, align 4
  ret float %FRACT_ret

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_x = load float, float* %x, align 4
  %2 = fptoui float %load_x to i64
  store i64 %2, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %3 = uitofp i64 %call2 to double
  %tmpVar = fcmp olt double %3, 2.000000e+09
  br i1 %tmpVar, label %condition_body, label %else

input4:                                           ; preds = %condition_body
  %4 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance, i32 0, i32 0
  %D_TRUNC_instance = alloca %D_TRUNC_interface, align 8
  br label %input8

call5:                                            ; preds = %continue11
  %call14 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %tmpVar15 = fsub float %load_x3, %call14
  store float %tmpVar15, float* %FRACT, align 4
  br label %continue

input8:                                           ; preds = %input4
  %5 = getelementptr inbounds %D_TRUNC_interface, %D_TRUNC_interface* %D_TRUNC_instance, i32 0, i32 0
  %load_x12 = load float, float* %x, align 4
  store float %load_x12, float* %5, align 4
  br label %call9

call9:                                            ; preds = %input8
  %call13 = call i32 @D_TRUNC(%D_TRUNC_interface* %D_TRUNC_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  store i32 %call13, i32* %4, align 4
  br label %call5
}

define float @GAMMA(%GAMMA_interface* %0) {
entry:
  %X = getelementptr inbounds %GAMMA_interface, %GAMMA_interface* %0, i32 0, i32 0
  %GAMMA = alloca float, align 4
  store float 0.000000e+00, float* %GAMMA, align 4
  %load_x = load float, float* %X, align 4
  %tmpVar = fcmp ogt float %load_x, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input

continue:                                         ; preds = %continue7, %entry
  %GAMMA_ret = load float, float* %GAMMA, align 4
  ret float %GAMMA_ret

input:                                            ; preds = %condition_body
  %1 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 1), align 4
  %load_X = load float, float* %X, align 4
  %tmpVar2 = fdiv float %load_, %load_X
  %2 = fptosi float %tmpVar2 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call3 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %EXPT_instance = alloca %EXPT_interface, align 8
  br label %input4

input4:                                           ; preds = %continue1
  %3 = getelementptr inbounds %EXPT_interface, %EXPT_interface* %EXPT_instance, i32 0, i32 0
  %load_8 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 7), align 4
  %load_x9 = load float, float* %X, align 4
  %load_x10 = load float, float* %X, align 4
  %tmpVar11 = fmul float 1.200000e+01, %load_x10
  %load_X12 = load float, float* %X, align 4
  %tmpVar13 = fdiv float 0x3FB99999A0000000, %load_X12
  %tmpVar14 = fsub float %tmpVar11, %tmpVar13
  %tmpVar15 = fdiv float 1.000000e+00, %tmpVar14
  %tmpVar16 = fadd float %load_x9, %tmpVar15
  %tmpVar17 = fmul float %load_8, %tmpVar16
  %4 = fptosi float %tmpVar17 to i32
  store i32 %4, i32* %3, align 4
  %5 = getelementptr inbounds %EXPT_interface, %EXPT_interface* %EXPT_instance, i32 0, i32 1
  %load_X18 = load float, float* %X, align 4
  %6 = fptosi float %load_X18 to i32
  store i32 %6, i32* %5, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call19 = call double @EXPT(%EXPT_interface* %EXPT_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %tmpVar20 = fmul double %call3, %call19
  %7 = fptrunc double %tmpVar20 to float
  store float %7, float* %GAMMA, align 4
  br label %continue
}

define float @GAUSS(%GAUSS_interface* %0) {
entry:
  %X = getelementptr inbounds %GAUSS_interface, %GAUSS_interface* %0, i32 0, i32 0
  %U = getelementptr inbounds %GAUSS_interface, %GAUSS_interface* %0, i32 0, i32 1
  %SI = getelementptr inbounds %GAUSS_interface, %GAUSS_interface* %0, i32 0, i32 2
  %temp = getelementptr inbounds %GAUSS_interface, %GAUSS_interface* %0, i32 0, i32 3
  %si_inv = getelementptr inbounds %GAUSS_interface, %GAUSS_interface* %0, i32 0, i32 4
  %GAUSS = alloca float, align 4
  store float 0.000000e+00, float* %temp, align 4
  store float 0.000000e+00, float* %si_inv, align 4
  store float 0.000000e+00, float* %GAUSS, align 4
  %load_X = load float, float* %X, align 4
  %load_U = load float, float* %U, align 4
  %tmpVar = fsub float %load_X, %load_U
  store float %tmpVar, float* %temp, align 4
  %load_si = load float, float* %SI, align 4
  %tmpVar1 = fdiv float 1.000000e+00, %load_si
  store float %tmpVar1, float* %si_inv, align 4
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %load_Temp = load float, float* %temp, align 4
  %load_Temp2 = load float, float* %temp, align 4
  %tmpVar3 = fmul float %load_Temp, %load_Temp2
  %load_si_inv = load float, float* %si_inv, align 4
  %tmpVar4 = fmul float %tmpVar3, %load_si_inv
  %load_si_inv5 = load float, float* %si_inv, align 4
  %tmpVar6 = fmul float %tmpVar4, %load_si_inv5
  %tmpVar7 = fmul float %tmpVar6, -5.000000e-01
  %2 = fptosi float %tmpVar7 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call8 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar9 = fmul double %call8, 0x3FD988453365DE00
  %load_si_inv10 = load float, float* %si_inv, align 4
  %3 = fpext float %load_si_inv10 to double
  %tmpVar11 = fmul double %tmpVar9, %3
  %4 = fptrunc double %tmpVar11 to float
  store float %4, float* %GAUSS, align 4
  %GAUSS_ret = load float, float* %GAUSS, align 4
  ret float %GAUSS_ret
}

define float @GAUSSCD(%GAUSSCD_interface* %0) {
entry:
  %X = getelementptr inbounds %GAUSSCD_interface, %GAUSSCD_interface* %0, i32 0, i32 0
  %U = getelementptr inbounds %GAUSSCD_interface, %GAUSSCD_interface* %0, i32 0, i32 1
  %SI = getelementptr inbounds %GAUSSCD_interface, %GAUSSCD_interface* %0, i32 0, i32 2
  %GAUSSCD = alloca float, align 4
  store float 0.000000e+00, float* %GAUSSCD, align 4
  %ERF_instance = alloca %ERF_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ERF_interface, %ERF_interface* %ERF_instance, i32 0, i32 0
  %load_X = load float, float* %X, align 4
  %load_U = load float, float* %U, align 4
  %tmpVar = fsub float %load_X, %load_U
  %load_SI = load float, float* %SI, align 4
  %tmpVar1 = fmul float %load_SI, 0x3FF6A09E60000000
  %tmpVar2 = fdiv float %tmpVar, %tmpVar1
  store float %tmpVar2, float* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call3 = call float @ERF(%ERF_interface* %ERF_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar4 = fadd float %call3, 1.000000e+00
  %tmpVar5 = fmul float %tmpVar4, 5.000000e-01
  store float %tmpVar5, float* %GAUSSCD, align 4
  %GAUSSCD_ret = load float, float* %GAUSSCD, align 4
  ret float %GAUSSCD_ret
}

define i16 @GCD(%GCD_interface* %0) {
entry:
  %A = getelementptr inbounds %GCD_interface, %GCD_interface* %0, i32 0, i32 0
  %B = getelementptr inbounds %GCD_interface, %GCD_interface* %0, i32 0, i32 1
  %t = getelementptr inbounds %GCD_interface, %GCD_interface* %0, i32 0, i32 2
  %GCD = alloca i16, align 2
  store i32 0, i32* %t, align 4
  store i16 0, i16* %GCD, align 2
  %load_A = load i32, i32* %A, align 4
  %tmpVar = icmp eq i32 %load_A, 0
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  %DINT_TO_INT_instance = alloca %DINT_TO_INT_interface, align 8
  br label %input

branch:                                           ; preds = %entry
  %load_B9 = load i32, i32* %B, align 4
  %tmpVar10 = icmp eq i32 %load_B9, 0
  br i1 %tmpVar10, label %condition_body8, label %else

condition_body8:                                  ; preds = %branch
  %DINT_TO_INT_instance11 = alloca %DINT_TO_INT_interface, align 8
  br label %input12

else:                                             ; preds = %branch
  %ABS_instance24 = alloca %ABS_interface, align 8
  br label %input25

continue:                                         ; preds = %continue117, %continue15, %continue1
  %GCD_ret = load i16, i16* %GCD, align 2
  ret i16 %GCD_ret

input:                                            ; preds = %condition_body
  %1 = getelementptr inbounds %DINT_TO_INT_interface, %DINT_TO_INT_interface* %DINT_TO_INT_instance, i32 0, i32 0
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input2

call:                                             ; preds = %continue5
  %call7 = call i16 @DINT_TO_INT(%DINT_TO_INT_interface* %DINT_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store i16 %call7, i16* %GCD, align 2
  br label %continue

input2:                                           ; preds = %input
  %2 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_B = load i32, i32* %B, align 4
  %3 = sext i32 %load_B to i64
  store i64 %3, i64* %2, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %4 = trunc i64 %call6 to i32
  store i32 %4, i32* %1, align 4
  br label %call

input12:                                          ; preds = %condition_body8
  %5 = getelementptr inbounds %DINT_TO_INT_interface, %DINT_TO_INT_interface* %DINT_TO_INT_instance11, i32 0, i32 0
  %ABS_instance16 = alloca %ABS_interface, align 8
  br label %input17

call13:                                           ; preds = %continue20
  %call23 = call i16 @DINT_TO_INT(%DINT_TO_INT_interface* %DINT_TO_INT_instance11)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  store i16 %call23, i16* %GCD, align 2
  br label %continue

input17:                                          ; preds = %input12
  %6 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance16, i32 0, i32 0
  %load_A21 = load i32, i32* %A, align 4
  %7 = sext i32 %load_A21 to i64
  store i64 %7, i64* %6, align 4
  br label %call18

call18:                                           ; preds = %input17
  %call22 = call i64 @ABS(%ABS_interface* %ABS_instance16)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %8 = trunc i64 %call22 to i32
  store i32 %8, i32* %5, align 4
  br label %call13

input25:                                          ; preds = %else
  %9 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance24, i32 0, i32 0
  %load_A29 = load i32, i32* %A, align 4
  %10 = sext i32 %load_A29 to i64
  store i64 %10, i64* %9, align 4
  br label %call26

call26:                                           ; preds = %input25
  %call30 = call i64 @ABS(%ABS_interface* %ABS_instance24)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  %11 = trunc i64 %call30 to i32
  store i32 %11, i32* %A, align 4
  %ABS_instance31 = alloca %ABS_interface, align 8
  br label %input32

input32:                                          ; preds = %continue28
  %12 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance31, i32 0, i32 0
  %load_B36 = load i32, i32* %B, align 4
  %13 = sext i32 %load_B36 to i64
  store i64 %13, i64* %12, align 4
  br label %call33

call33:                                           ; preds = %input32
  %call37 = call i64 @ABS(%ABS_interface* %ABS_instance31)
  br label %output34

output34:                                         ; preds = %call33
  br label %continue35

continue35:                                       ; preds = %output34
  %14 = trunc i64 %call37 to i32
  store i32 %14, i32* %B, align 4
  store i16 1, i16* %GCD, align 2
  br label %condition_check

condition_check:                                  ; preds = %continue35, %continue59
  %load_A39 = load i32, i32* %A, align 4
  %shift = ashr i32 %load_A39, 0
  %15 = trunc i32 %shift to i8
  %16 = zext i8 %15 to i32
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %21, label %18

while_body:                                       ; preds = %21
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input43

continue38:                                       ; preds = %21
  br label %condition_check61

18:                                               ; preds = %condition_check
  %load_B40 = load i32, i32* %B, align 4
  %shift41 = ashr i32 %load_B40, 0
  %19 = trunc i32 %shift41 to i8
  %20 = zext i8 %19 to i32
  br label %21

21:                                               ; preds = %18, %condition_check
  %22 = phi i32 [ %16, %condition_check ], [ %20, %18 ]
  %tmpVar42 = xor i32 %22, -1
  br i32 %tmpVar42, label %while_body, label %continue38

input43:                                          ; preds = %while_body
  %23 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_A47 = load i32, i32* %A, align 4
  %24 = sext i32 %load_A47 to i64
  store i64 %24, i64* %23, align 4
  %25 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 1, i16* %25, align 2
  br label %call44

call44:                                           ; preds = %input43
  %call48 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output45

output45:                                         ; preds = %call44
  br label %continue46

continue46:                                       ; preds = %output45
  %26 = trunc i64 %call48 to i32
  store i32 %26, i32* %A, align 4
  %SHR_instance49 = alloca %SHR_interface, align 8
  br label %input50

input50:                                          ; preds = %continue46
  %27 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance49, i32 0, i32 0
  %load_B54 = load i32, i32* %B, align 4
  %28 = sext i32 %load_B54 to i64
  store i64 %28, i64* %27, align 4
  %29 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance49, i32 0, i32 1
  store i16 1, i16* %29, align 2
  br label %call51

call51:                                           ; preds = %input50
  %call55 = call i64 @SHR(%SHR_interface* %SHR_instance49)
  br label %output52

output52:                                         ; preds = %call51
  br label %continue53

continue53:                                       ; preds = %output52
  %30 = trunc i64 %call55 to i32
  store i32 %30, i32* %B, align 4
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input56

input56:                                          ; preds = %continue53
  %31 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_GCD = load i16, i16* %GCD, align 2
  %32 = sext i16 %load_GCD to i64
  store i64 %32, i64* %31, align 4
  %33 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 1, i16* %33, align 2
  br label %call57

call57:                                           ; preds = %input56
  %call60 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output58

output58:                                         ; preds = %call57
  br label %continue59

continue59:                                       ; preds = %output58
  %34 = trunc i64 %call60 to i16
  store i16 %34, i16* %GCD, align 2
  br label %condition_check

condition_check61:                                ; preds = %continue38, %continue68
  %load_A64 = load i32, i32* %A, align 4
  %tmpVar65 = icmp sgt i32 %load_A64, 0
  br i1 %tmpVar65, label %while_body62, label %continue63

while_body62:                                     ; preds = %condition_check61
  %load_A70 = load i32, i32* %A, align 4
  %shift71 = ashr i32 %load_A70, 0
  %35 = trunc i32 %shift71 to i8
  %tmpVar72 = xor i8 %35, -1
  %36 = icmp ne i8 %tmpVar72, 0
  br i1 %36, label %condition_body69, label %branch66

continue63:                                       ; preds = %condition_check61
  %load_GCD112 = load i16, i16* %GCD, align 2
  %37 = sext i16 %load_GCD112 to i32
  %DINT_TO_INT_instance113 = alloca %DINT_TO_INT_interface, align 8
  br label %input114

condition_body69:                                 ; preds = %while_body62
  %SHR_instance73 = alloca %SHR_interface, align 8
  br label %input74

branch66:                                         ; preds = %while_body62
  %load_B81 = load i32, i32* %B, align 4
  %shift82 = ashr i32 %load_B81, 0
  %38 = trunc i32 %shift82 to i8
  %tmpVar83 = xor i8 %38, -1
  %39 = icmp ne i8 %tmpVar83, 0
  br i1 %39, label %condition_body80, label %else67

condition_body80:                                 ; preds = %branch66
  %SHR_instance84 = alloca %SHR_interface, align 8
  br label %input85

else67:                                           ; preds = %branch66
  %SHR_instance91 = alloca %SHR_interface, align 8
  br label %input92

continue68:                                       ; preds = %continue107, %continue88, %continue77
  br label %condition_check61

input74:                                          ; preds = %condition_body69
  %40 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance73, i32 0, i32 0
  %load_A78 = load i32, i32* %A, align 4
  %41 = sext i32 %load_A78 to i64
  store i64 %41, i64* %40, align 4
  %42 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance73, i32 0, i32 1
  store i16 1, i16* %42, align 2
  br label %call75

call75:                                           ; preds = %input74
  %call79 = call i64 @SHR(%SHR_interface* %SHR_instance73)
  br label %output76

output76:                                         ; preds = %call75
  br label %continue77

continue77:                                       ; preds = %output76
  %43 = trunc i64 %call79 to i32
  store i32 %43, i32* %A, align 4
  br label %continue68

input85:                                          ; preds = %condition_body80
  %44 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance84, i32 0, i32 0
  %load_B89 = load i32, i32* %B, align 4
  %45 = sext i32 %load_B89 to i64
  store i64 %45, i64* %44, align 4
  %46 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance84, i32 0, i32 1
  store i16 1, i16* %46, align 2
  br label %call86

call86:                                           ; preds = %input85
  %call90 = call i64 @SHR(%SHR_interface* %SHR_instance84)
  br label %output87

output87:                                         ; preds = %call86
  br label %continue88

continue88:                                       ; preds = %output87
  %47 = trunc i64 %call90 to i32
  store i32 %47, i32* %B, align 4
  br label %continue68

input92:                                          ; preds = %else67
  %48 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance91, i32 0, i32 0
  %ABS_instance96 = alloca %ABS_interface, align 8
  br label %input97

call93:                                           ; preds = %continue100
  %call105 = call i64 @SHR(%SHR_interface* %SHR_instance91)
  br label %output94

output94:                                         ; preds = %call93
  br label %continue95

continue95:                                       ; preds = %output94
  %49 = trunc i64 %call105 to i32
  store i32 %49, i32* %t, align 4
  %load_A109 = load i32, i32* %A, align 4
  %load_B110 = load i32, i32* %B, align 4
  %tmpVar111 = icmp slt i32 %load_A109, %load_B110
  br i1 %tmpVar111, label %condition_body108, label %else106

input97:                                          ; preds = %input92
  %50 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance96, i32 0, i32 0
  %load_A101 = load i32, i32* %A, align 4
  %load_B102 = load i32, i32* %B, align 4
  %tmpVar103 = sub i32 %load_A101, %load_B102
  %51 = sext i32 %tmpVar103 to i64
  store i64 %51, i64* %50, align 4
  br label %call98

call98:                                           ; preds = %input97
  %call104 = call i64 @ABS(%ABS_interface* %ABS_instance96)
  br label %output99

output99:                                         ; preds = %call98
  br label %continue100

continue100:                                      ; preds = %output99
  store i64 %call104, i64* %48, align 4
  %52 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance91, i32 0, i32 1
  store i16 1, i16* %52, align 2
  br label %call93

condition_body108:                                ; preds = %continue95
  %load_t = load i32, i32* %t, align 4
  store i32 %load_t, i32* %B, align 4
  br label %continue107

else106:                                          ; preds = %continue95
  %load_T = load i32, i32* %t, align 4
  store i32 %load_T, i32* %A, align 4
  br label %continue107

continue107:                                      ; preds = %else106, %condition_body108
  br label %continue68

input114:                                         ; preds = %continue63
  %53 = getelementptr inbounds %DINT_TO_INT_interface, %DINT_TO_INT_interface* %DINT_TO_INT_instance113, i32 0, i32 0
  %load_B118 = load i32, i32* %B, align 4
  store i32 %load_B118, i32* %53, align 4
  br label %call115

call115:                                          ; preds = %input114
  %call119 = call i16 @DINT_TO_INT(%DINT_TO_INT_interface* %DINT_TO_INT_instance113)
  br label %output116

output116:                                        ; preds = %call115
  br label %continue117

continue117:                                      ; preds = %output116
  %54 = sext i16 %call119 to i32
  %tmpVar120 = mul i32 %37, %54
  %55 = trunc i32 %tmpVar120 to i16
  store i16 %55, i16* %GCD, align 2
  br label %continue
}

define float @GDF(%GDF_interface* %0) {
entry:
  %X = getelementptr inbounds %GDF_interface, %GDF_interface* %0, i32 0, i32 0
  %GDF = alloca float, align 4
  store float 0.000000e+00, float* %GDF, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp oeq float %load_X, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store float 0.000000e+00, float* %GDF, align 4
  br label %continue

branch:                                           ; preds = %entry
  %load_X3 = load float, float* %X, align 4
  %tmpVar4 = fcmp ogt float %load_X3, 1.500000e+01
  br i1 %tmpVar4, label %condition_body2, label %branch1

condition_body2:                                  ; preds = %branch
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 3), align 4
  store float %load_, float* %GDF, align 4
  br label %continue

branch1:                                          ; preds = %branch
  %load_X6 = load float, float* %X, align 4
  %tmpVar7 = fcmp olt float %load_X6, -1.500000e+01
  br i1 %tmpVar7, label %condition_body5, label %else

condition_body5:                                  ; preds = %branch1
  %load_8 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 3), align 4
  %tmpVar9 = fneg float %load_8
  store float %tmpVar9, float* %GDF, align 4
  br label %continue

else:                                             ; preds = %branch1
  %ATAN_instance = alloca %ATAN_interface, align 8
  br label %input

continue:                                         ; preds = %continue10, %condition_body5, %condition_body2, %condition_body
  %GDF_ret = load float, float* %GDF, align 4
  ret float %GDF_ret

input:                                            ; preds = %else
  %1 = getelementptr inbounds %ATAN_interface, %ATAN_interface* %ATAN_instance, i32 0, i32 0
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input11

call:                                             ; preds = %continue14
  %call17 = call double @ATAN(%ATAN_interface* %ATAN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue10

continue10:                                       ; preds = %output
  %tmpVar18 = fmul double %call17, 2.000000e+00
  %load_19 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 3), align 4
  %2 = fpext float %load_19 to double
  %tmpVar20 = fsub double %tmpVar18, %2
  %3 = fptrunc double %tmpVar20 to float
  store float %3, float* %GDF, align 4
  br label %continue

input11:                                          ; preds = %input
  %4 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %load_X15 = load float, float* %X, align 4
  %5 = fptosi float %load_X15 to i32
  store i32 %5, i32* %4, align 4
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  store double %call16, double* %1, align 8
  br label %call
}

define float @GOLD(%GOLD_interface* %0) {
entry:
  %X = getelementptr inbounds %GOLD_interface, %GOLD_interface* %0, i32 0, i32 0
  %GOLD = alloca float, align 4
  store float 0.000000e+00, float* %GOLD, align 4
  %load_X = load float, float* %X, align 4
  %1 = fpext float %load_X to double
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_X1 = load float, float* %X, align 4
  %load_X2 = load float, float* %X, align 4
  %tmpVar = fmul float %load_X1, %load_X2
  %tmpVar3 = fadd float %tmpVar, 4.000000e+00
  %3 = fptosi float %tmpVar3 to i32
  store i32 %3, i32* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar5 = fadd double %1, %call4
  %tmpVar6 = fmul double %tmpVar5, 5.000000e-01
  %4 = fptrunc double %tmpVar6 to float
  store float %4, float* %GOLD, align 4
  %GOLD_ret = load float, float* %GOLD, align 4
  ret float %GOLD_ret
}

define float @HYPOT(%HYPOT_interface* %0) {
entry:
  %X = getelementptr inbounds %HYPOT_interface, %HYPOT_interface* %0, i32 0, i32 0
  %Y = getelementptr inbounds %HYPOT_interface, %HYPOT_interface* %0, i32 0, i32 1
  %HYPOT = alloca float, align 4
  store float 0.000000e+00, float* %HYPOT, align 4
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %load_x1 = load float, float* %X, align 4
  %tmpVar = fmul float %load_x, %load_x1
  %load_y = load float, float* %Y, align 4
  %load_y2 = load float, float* %Y, align 4
  %tmpVar3 = fmul float %load_y, %load_y2
  %tmpVar4 = fadd float %tmpVar, %tmpVar3
  %2 = fptosi float %tmpVar4 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call5 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = fptrunc double %call5 to float
  store float %3, float* %HYPOT, align 4
  %HYPOT_ret = load float, float* %HYPOT, align 4
  ret float %HYPOT_ret
}

define i16 @INC(%INC_interface* %0) {
entry:
  %X = getelementptr inbounds %INC_interface, %INC_interface* %0, i32 0, i32 0
  %D = getelementptr inbounds %INC_interface, %INC_interface* %0, i32 0, i32 1
  %M = getelementptr inbounds %INC_interface, %INC_interface* %0, i32 0, i32 2
  %INC = alloca i16, align 2
  store i16 0, i16* %INC, align 2
  %load_X = load i16, i16* %X, align 2
  %1 = sext i16 %load_X to i32
  %load_D = load i16, i16* %D, align 2
  %2 = sext i16 %load_D to i32
  %tmpVar = add i32 %1, %2
  %load_M = load i16, i16* %M, align 2
  %3 = sext i16 %load_M to i32
  %tmpVar1 = add i32 %tmpVar, %3
  %tmpVar2 = add i32 %tmpVar1, 1
  %load_M3 = load i16, i16* %M, align 2
  %4 = sext i16 %load_M3 to i32
  %tmpVar4 = add i32 %4, 1
  %tmpVar5 = srem i32 %tmpVar2, %tmpVar4
  %5 = trunc i32 %tmpVar5 to i16
  store i16 %5, i16* %INC, align 2
  %INC_ret = load i16, i16* %INC, align 2
  ret i16 %INC_ret
}

define i16 @INC1(%INC1_interface* %0) {
entry:
  %X = getelementptr inbounds %INC1_interface, %INC1_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %INC1_interface, %INC1_interface* %0, i32 0, i32 1
  %INC1 = alloca i16, align 2
  store i16 0, i16* %INC1, align 2
  %load_X = load i16, i16* %X, align 2
  %1 = sext i16 %load_X to i32
  %load_N = load i16, i16* %N, align 2
  %2 = sext i16 %load_N to i32
  %tmpVar = sub i32 %2, 1
  %tmpVar1 = icmp sge i32 %1, %tmpVar
  br i1 %tmpVar1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  store i16 0, i16* %INC1, align 2
  br label %continue

else:                                             ; preds = %entry
  %load_X2 = load i16, i16* %X, align 2
  %3 = sext i16 %load_X2 to i32
  %tmpVar3 = add i32 %3, 1
  %4 = trunc i32 %tmpVar3 to i16
  store i16 %4, i16* %INC1, align 2
  br label %continue

continue:                                         ; preds = %else, %condition_body
  %INC1_ret = load i16, i16* %INC1, align 2
  ret i16 %INC1_ret
}

define i16 @INC2(%INC2_interface* %0) {
entry:
  %X = getelementptr inbounds %INC2_interface, %INC2_interface* %0, i32 0, i32 0
  %D = getelementptr inbounds %INC2_interface, %INC2_interface* %0, i32 0, i32 1
  %L = getelementptr inbounds %INC2_interface, %INC2_interface* %0, i32 0, i32 2
  %U = getelementptr inbounds %INC2_interface, %INC2_interface* %0, i32 0, i32 3
  %tmp = getelementptr inbounds %INC2_interface, %INC2_interface* %0, i32 0, i32 4
  %INC2 = alloca i16, align 2
  store i16 0, i16* %tmp, align 2
  store i16 0, i16* %INC2, align 2
  %load_U = load i16, i16* %U, align 2
  %1 = sext i16 %load_U to i32
  %load_L = load i16, i16* %L, align 2
  %2 = sext i16 %load_L to i32
  %tmpVar = sub i32 %1, %2
  %tmpVar1 = add i32 %tmpVar, 1
  %3 = trunc i32 %tmpVar1 to i16
  store i16 %3, i16* %tmp, align 2
  %load_X = load i16, i16* %X, align 2
  %4 = sext i16 %load_X to i32
  %load_D = load i16, i16* %D, align 2
  %5 = sext i16 %load_D to i32
  %tmpVar2 = add i32 %4, %5
  %load_L3 = load i16, i16* %L, align 2
  %6 = sext i16 %load_L3 to i32
  %tmpVar4 = sub i32 %tmpVar2, %6
  %load_tmp = load i16, i16* %tmp, align 2
  %7 = sext i16 %load_tmp to i32
  %tmpVar5 = add i32 %tmpVar4, %7
  %load_tmp6 = load i16, i16* %tmp, align 2
  %8 = sext i16 %load_tmp6 to i32
  %tmpVar7 = srem i32 %tmpVar5, %8
  %load_L8 = load i16, i16* %L, align 2
  %9 = sext i16 %load_L8 to i32
  %tmpVar9 = add i32 %tmpVar7, %9
  %10 = trunc i32 %tmpVar9 to i16
  store i16 %10, i16* %INC2, align 2
  %INC2_ret = load i16, i16* %INC2, align 2
  ret i16 %INC2_ret
}

define float @INV(%INV_interface* %0) {
entry:
  %X = getelementptr inbounds %INV_interface, %INV_interface* %0, i32 0, i32 0
  %INV = alloca float, align 4
  store float 0.000000e+00, float* %INV, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp one float %load_X, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %load_X1 = load float, float* %X, align 4
  %tmpVar2 = fdiv float 1.000000e+00, %load_X1
  store float %tmpVar2, float* %INV, align 4
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  %INV_ret = load float, float* %INV, align 4
  ret float %INV_ret
}

define float @LAMBERT_W(%LAMBERT_W_interface* %0) {
entry:
  %X = getelementptr inbounds %LAMBERT_W_interface, %LAMBERT_W_interface* %0, i32 0, i32 0
  %w = getelementptr inbounds %LAMBERT_W_interface, %LAMBERT_W_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %LAMBERT_W_interface, %LAMBERT_W_interface* %0, i32 0, i32 2
  %we = getelementptr inbounds %LAMBERT_W_interface, %LAMBERT_W_interface* %0, i32 0, i32 3
  %w1e = getelementptr inbounds %LAMBERT_W_interface, %LAMBERT_W_interface* %0, i32 0, i32 4
  %last = getelementptr inbounds %LAMBERT_W_interface, %LAMBERT_W_interface* %0, i32 0, i32 5
  %ewx = getelementptr inbounds %LAMBERT_W_interface, %LAMBERT_W_interface* %0, i32 0, i32 6
  %LAMBERT_W = alloca float, align 4
  store float 0.000000e+00, float* %w, align 4
  store i16 0, i16* %i, align 2
  store float 0.000000e+00, float* %we, align 4
  store float 0.000000e+00, float* %w1e, align 4
  store i32 0, i32* %last, align 4
  store float 0.000000e+00, float* %ewx, align 4
  store float 0.000000e+00, float* %LAMBERT_W, align 4
  %load_x = load float, float* %X, align 4
  %tmpVar = fcmp olt float %load_x, 0xBFD78B5640000000
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store float -1.000000e+03, float* %LAMBERT_W, align 4
  %LAMBERT_W_ret = load float, float* %LAMBERT_W, align 4
  ret float %LAMBERT_W_ret

buffer_block:                                     ; No predecessors!
  br label %continue

branch:                                           ; preds = %entry
  %load_x3 = load float, float* %X, align 4
  %tmpVar4 = fcmp oeq float %load_x3, 0.000000e+00
  br i1 %tmpVar4, label %condition_body2, label %branch1

condition_body2:                                  ; preds = %branch
  %LAMBERT_W_ret5 = load float, float* %LAMBERT_W, align 4
  ret float %LAMBERT_W_ret5

buffer_block6:                                    ; No predecessors!
  br label %continue

branch1:                                          ; preds = %branch
  %load_x8 = load float, float* %X, align 4
  %tmpVar9 = fcmp ole float %load_x8, 5.000000e+02
  br i1 %tmpVar9, label %condition_body7, label %else

condition_body7:                                  ; preds = %branch1
  %LN_instance = alloca %LN_interface, align 8
  br label %input

else:                                             ; preds = %branch1
  %LN_instance20 = alloca %LN_interface, align 8
  br label %input21

continue:                                         ; preds = %continue41, %continue10, %buffer_block6, %buffer_block
  store i16 0, i16* %i, align 2
  br label %condition_check

input:                                            ; preds = %condition_body7
  %1 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %load_x11 = load float, float* %X, align 4
  %tmpVar12 = fadd float %load_x11, 1.000000e+00
  %2 = fptosi float %tmpVar12 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call13 = call double @LN(%LN_interface* %LN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue10

continue10:                                       ; preds = %output
  %3 = fptrunc double %call13 to float
  store float %3, float* %w, align 4
  %load_w = load float, float* %w, align 4
  %tmpVar14 = fmul float 0x3F93F7CEE0000000, %load_w
  %tmpVar15 = fadd float 1.000000e+00, %tmpVar14
  %tmpVar16 = fmul float 0x3FE547AE20000000, %tmpVar15
  %load_w17 = load float, float* %w, align 4
  %tmpVar18 = fmul float %tmpVar16, %load_w17
  %tmpVar19 = fadd float %tmpVar18, 0x3FA47AE140000000
  store float %tmpVar19, float* %w, align 4
  br label %continue

input21:                                          ; preds = %else
  %4 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance20, i32 0, i32 0
  %load_x25 = load float, float* %X, align 4
  %tmpVar26 = fsub float %load_x25, 4.000000e+00
  %5 = fptosi float %tmpVar26 to i32
  store i32 %5, i32* %4, align 4
  br label %call22

call22:                                           ; preds = %input21
  %call27 = call double @LN(%LN_interface* %LN_instance20)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %LN_instance28 = alloca %LN_interface, align 8
  br label %input29

input29:                                          ; preds = %continue24
  %6 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance28, i32 0, i32 0
  %load_x33 = load float, float* %X, align 4
  %7 = fptosi float %load_x33 to i32
  store i32 %7, i32* %6, align 4
  br label %call30

call30:                                           ; preds = %input29
  %call34 = call double @LN(%LN_interface* %LN_instance28)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  %tmpVar35 = fdiv double 1.000000e+00, %call34
  %tmpVar36 = fsub double 1.000000e+00, %tmpVar35
  %LN_instance37 = alloca %LN_interface, align 8
  br label %input38

input38:                                          ; preds = %continue32
  %8 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance37, i32 0, i32 0
  %LN_instance42 = alloca %LN_interface, align 8
  br label %input43

call39:                                           ; preds = %continue46
  %call49 = call double @LN(%LN_interface* %LN_instance37)
  br label %output40

output40:                                         ; preds = %call39
  br label %continue41

continue41:                                       ; preds = %output40
  %tmpVar50 = fmul double %tmpVar36, %call49
  %tmpVar51 = fsub double %call27, %tmpVar50
  %9 = fptrunc double %tmpVar51 to float
  store float %9, float* %w, align 4
  br label %continue

input43:                                          ; preds = %input38
  %10 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance42, i32 0, i32 0
  %load_x47 = load float, float* %X, align 4
  %11 = fptosi float %load_x47 to i32
  store i32 %11, i32* %10, align 4
  br label %call44

call44:                                           ; preds = %input43
  %call48 = call double @LN(%LN_interface* %LN_instance42)
  br label %output45

output45:                                         ; preds = %call44
  br label %continue46

continue46:                                       ; preds = %output45
  %12 = fptosi double %call48 to i32
  store i32 %12, i32* %8, align 4
  br label %call39

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i53 = load i16, i16* %i, align 2
  %tmpVar54 = icmp sle i16 %load_i53, 5
  %13 = icmp ne i1 %tmpVar54, false
  br i1 %13, label %18, label %19

for_body:                                         ; preds = %16
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input61

increment:                                        ; preds = %continue93
  %tmpVar104 = add i16 %load_i, 1
  store i16 %tmpVar104, i16* %i, align 2
  br label %condition_check

continue52:                                       ; preds = %condition_body94, %16
  %load_w105 = load float, float* %w, align 4
  store float %load_w105, float* %LAMBERT_W, align 4
  %LAMBERT_W_ret106 = load float, float* %LAMBERT_W, align 4
  ret float %LAMBERT_W_ret106

14:                                               ; preds = %19
  %load_i57 = load i16, i16* %i, align 2
  %tmpVar58 = icmp sge i16 %load_i57, 5
  %15 = icmp ne i1 %tmpVar58, false
  br i1 %15, label %22, label %23

16:                                               ; preds = %23, %19
  %17 = phi i1 [ %20, %19 ], [ %24, %23 ]
  br i1 %17, label %for_body, label %continue52

18:                                               ; preds = %condition_check
  %load_i55 = load i16, i16* %i, align 2
  %tmpVar56 = icmp sge i16 %load_i55, 0
  br label %19

19:                                               ; preds = %18, %condition_check
  %20 = phi i1 [ %tmpVar54, %condition_check ], [ %tmpVar56, %18 ]
  %21 = icmp ne i1 %20, false
  br i1 %21, label %16, label %14

22:                                               ; preds = %14
  %load_i59 = load i16, i16* %i, align 2
  %tmpVar60 = icmp sle i16 %load_i59, 0
  br label %23

23:                                               ; preds = %22, %14
  %24 = phi i1 [ %tmpVar58, %14 ], [ %tmpVar60, %22 ]
  br label %16

input61:                                          ; preds = %for_body
  %25 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %load_w65 = load float, float* %w, align 4
  %26 = fptosi float %load_w65 to i32
  store i32 %26, i32* %25, align 4
  br label %call62

call62:                                           ; preds = %input61
  %call66 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output63

output63:                                         ; preds = %call62
  br label %continue64

continue64:                                       ; preds = %output63
  %27 = fptrunc double %call66 to float
  store float %27, float* %ewx, align 4
  %load_w67 = load float, float* %w, align 4
  %load_ewx = load float, float* %ewx, align 4
  %tmpVar68 = fmul float %load_w67, %load_ewx
  %load_x69 = load float, float* %X, align 4
  %tmpVar70 = fsub float %tmpVar68, %load_x69
  store float %tmpVar70, float* %we, align 4
  %load_w71 = load float, float* %w, align 4
  %tmpVar72 = fadd float %load_w71, 1.000000e+00
  %load_ewx73 = load float, float* %ewx, align 4
  %tmpVar74 = fmul float %tmpVar72, %load_ewx73
  store float %tmpVar74, float* %w1e, align 4
  %REAL_TO_DW_instance = alloca %REAL_TO_DW_interface, align 8
  br label %input75

28:                                               ; preds = %continue78
  br label %29

29:                                               ; preds = %28, %continue78
  %30 = phi i64 [ %32, %continue78 ], [ 4294967292, %28 ]
  store i64 %30, i32* %last, align 4
  %load_w81 = load float, float* %w, align 4
  %load_we = load float, float* %we, align 4
  %load_w1e = load float, float* %w1e, align 4
  %load_w82 = load float, float* %w, align 4
  %tmpVar83 = fadd float %load_w82, 2.000000e+00
  %load_we84 = load float, float* %we, align 4
  %tmpVar85 = fmul float %tmpVar83, %load_we84
  %load_w86 = load float, float* %w, align 4
  %tmpVar87 = fmul float 2.000000e+00, %load_w86
  %tmpVar88 = fadd float %tmpVar87, 2.000000e+00
  %tmpVar89 = fdiv float %tmpVar85, %tmpVar88
  %tmpVar90 = fsub float %load_w1e, %tmpVar89
  %tmpVar91 = fdiv float %load_we, %tmpVar90
  %tmpVar92 = fsub float %load_w81, %tmpVar91
  store float %tmpVar92, float* %w, align 4
  %REAL_TO_DW_instance95 = alloca %REAL_TO_DW_interface, align 8
  br label %input96

input75:                                          ; preds = %continue64
  %31 = getelementptr inbounds %REAL_TO_DW_interface, %REAL_TO_DW_interface* %REAL_TO_DW_instance, i32 0, i32 0
  %load_w79 = load float, float* %w, align 4
  store float %load_w79, float* %31, align 4
  br label %call76

call76:                                           ; preds = %input75
  %call80 = call i32 @REAL_TO_DW(%REAL_TO_DW_interface* %REAL_TO_DW_instance)
  br label %output77

output77:                                         ; preds = %call76
  br label %continue78

continue78:                                       ; preds = %output77
  %32 = zext i32 %call80 to i64
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %28, label %29

condition_body94:                                 ; preds = %35
  br label %continue52

buffer_block103:                                  ; No predecessors!
  br label %continue93

continue93:                                       ; preds = %buffer_block103, %35
  br label %increment

34:                                               ; preds = %continue99
  br label %35

35:                                               ; preds = %34, %continue99
  %36 = phi i64 [ %38, %continue99 ], [ 4294967292, %34 ]
  %load_last = load i32, i32* %last, align 4
  %tmpVar102 = icmp eq i64 %36, i32 %load_last
  br i1 %tmpVar102, label %condition_body94, label %continue93

input96:                                          ; preds = %29
  %37 = getelementptr inbounds %REAL_TO_DW_interface, %REAL_TO_DW_interface* %REAL_TO_DW_instance95, i32 0, i32 0
  %load_w100 = load float, float* %w, align 4
  store float %load_w100, float* %37, align 4
  br label %call97

call97:                                           ; preds = %input96
  %call101 = call i32 @REAL_TO_DW(%REAL_TO_DW_interface* %REAL_TO_DW_instance95)
  br label %output98

output98:                                         ; preds = %call97
  br label %continue99

continue99:                                       ; preds = %output98
  %38 = zext i32 %call101 to i64
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %34, label %35
}

define float @LANGEVIN(%LANGEVIN_interface* %0) {
entry:
  %X = getelementptr inbounds %LANGEVIN_interface, %LANGEVIN_interface* %0, i32 0, i32 0
  %LANGEVIN = alloca float, align 4
  store float 0.000000e+00, float* %LANGEVIN, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp oeq float %load_X, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  store float 0.000000e+00, float* %LANGEVIN, align 4
  br label %continue

else:                                             ; preds = %entry
  %COTH_instance = alloca %COTH_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %condition_body
  %LANGEVIN_ret = load float, float* %LANGEVIN, align 4
  ret float %LANGEVIN_ret

input:                                            ; preds = %else
  %1 = getelementptr inbounds %COTH_interface, %COTH_interface* %COTH_instance, i32 0, i32 0
  %load_X2 = load float, float* %X, align 4
  store float %load_X2, float* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call3 = call float @COTH(%COTH_interface* %COTH_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %load_X4 = load float, float* %X, align 4
  %tmpVar5 = fdiv float 1.000000e+00, %load_X4
  %tmpVar6 = fsub float %call3, %tmpVar5
  store float %tmpVar6, float* %LANGEVIN, align 4
  br label %continue
}

define float @MAX3(%MAX3_interface* %0) {
entry:
  %in1 = getelementptr inbounds %MAX3_interface, %MAX3_interface* %0, i32 0, i32 0
  %in2 = getelementptr inbounds %MAX3_interface, %MAX3_interface* %0, i32 0, i32 1
  %in3 = getelementptr inbounds %MAX3_interface, %MAX3_interface* %0, i32 0, i32 2
  %MAX3 = alloca float, align 4
  store float 0.000000e+00, float* %MAX3, align 4
  %MAX_instance = alloca %MAX_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 0
  %MAX_instance1 = alloca %MAX_interface, align 8
  br label %input2

call:                                             ; preds = %continue5
  %call7 = call i64 @MAX(%MAX_interface* %MAX_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %2 = uitofp i64 %call7 to float
  store float %2, float* %MAX3, align 4
  %MAX3_ret = load float, float* %MAX3, align 4
  ret float %MAX3_ret

input2:                                           ; preds = %input
  %3 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance1, i32 0, i32 0
  %load_IN1 = load float, float* %in1, align 4
  %4 = fptoui float %load_IN1 to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance1, i32 0, i32 1
  %load_IN2 = load float, float* %in2, align 4
  %6 = fptoui float %load_IN2 to i64
  store i64 %6, i64* %5, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @MAX(%MAX_interface* %MAX_instance1)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i64 %call6, i64* %1, align 4
  %7 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 1
  %load_IN3 = load float, float* %in3, align 4
  %8 = fptoui float %load_IN3 to i64
  store i64 %8, i64* %7, align 4
  br label %call
}

define float @MID3(%MID3_interface* %0) {
entry:
  %IN1 = getelementptr inbounds %MID3_interface, %MID3_interface* %0, i32 0, i32 0
  %IN2 = getelementptr inbounds %MID3_interface, %MID3_interface* %0, i32 0, i32 1
  %IN3 = getelementptr inbounds %MID3_interface, %MID3_interface* %0, i32 0, i32 2
  %MID3 = alloca float, align 4
  store float 0.000000e+00, float* %MID3, align 4
  %load_IN1 = load float, float* %IN1, align 4
  %load_IN2 = load float, float* %IN2, align 4
  %tmpVar = fcmp ogt float %load_IN1, %load_IN2
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %load_IN11 = load float, float* %IN1, align 4
  store float %load_IN11, float* %MID3, align 4
  %load_IN22 = load float, float* %IN2, align 4
  store float %load_IN22, float* %IN1, align 4
  %load_MID3 = load float, float* %MID3, align 4
  store float %load_MID3, float* %IN2, align 4
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  %load_IN25 = load float, float* %IN2, align 4
  %load_IN3 = load float, float* %IN3, align 4
  %tmpVar6 = fcmp ogt float %load_IN25, %load_IN3
  br i1 %tmpVar6, label %condition_body4, label %continue3

condition_body4:                                  ; preds = %continue
  %load_IN37 = load float, float* %IN3, align 4
  store float %load_IN37, float* %IN2, align 4
  br label %continue3

continue3:                                        ; preds = %condition_body4, %continue
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input

input:                                            ; preds = %continue3
  %1 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %load_IN19 = load float, float* %IN1, align 4
  %load_IN210 = load float, float* %IN2, align 4
  %tmpVar11 = fcmp ogt float %load_IN19, %load_IN210
  %2 = zext i1 %tmpVar11 to i8
  store i8 %2, i8* %1, align 1
  %3 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  %load_IN212 = load float, float* %IN2, align 4
  %4 = fptoui float %load_IN212 to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  %load_IN113 = load float, float* %IN1, align 4
  %6 = fptoui float %load_IN113 to i64
  store i64 %6, i64* %5, align 4
  br label %call

call:                                             ; preds = %input
  %call14 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue8

continue8:                                        ; preds = %output
  %7 = uitofp i64 %call14 to float
  store float %7, float* %MID3, align 4
  %MID3_ret = load float, float* %MID3, align 4
  ret float %MID3_ret
}

define float @MIN3(%MIN3_interface* %0) {
entry:
  %in1 = getelementptr inbounds %MIN3_interface, %MIN3_interface* %0, i32 0, i32 0
  %in2 = getelementptr inbounds %MIN3_interface, %MIN3_interface* %0, i32 0, i32 1
  %in3 = getelementptr inbounds %MIN3_interface, %MIN3_interface* %0, i32 0, i32 2
  %MIN3 = alloca float, align 4
  store float 0.000000e+00, float* %MIN3, align 4
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %MIN_instance1 = alloca %MIN_interface, align 8
  br label %input2

call:                                             ; preds = %continue5
  %call7 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %2 = uitofp i64 %call7 to float
  store float %2, float* %MIN3, align 4
  %MIN3_ret = load float, float* %MIN3, align 4
  ret float %MIN3_ret

input2:                                           ; preds = %input
  %3 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance1, i32 0, i32 0
  %load_IN1 = load float, float* %in1, align 4
  %4 = fptoui float %load_IN1 to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance1, i32 0, i32 1
  %load_IN2 = load float, float* %in2, align 4
  %6 = fptoui float %load_IN2 to i64
  store i64 %6, i64* %5, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @MIN(%MIN_interface* %MIN_instance1)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i64 %call6, i64* %1, align 4
  %7 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_IN3 = load float, float* %in3, align 4
  %8 = fptoui float %load_IN3 to i64
  store i64 %8, i64* %7, align 4
  br label %call
}

define float @MODR(%MODR_interface* %0) {
entry:
  %IN = getelementptr inbounds %MODR_interface, %MODR_interface* %0, i32 0, i32 0
  %DIVI = getelementptr inbounds %MODR_interface, %MODR_interface* %0, i32 0, i32 1
  %MODR = alloca float, align 4
  store float 0.000000e+00, float* %MODR, align 4
  %load_divi = load float, float* %DIVI, align 4
  %tmpVar = fcmp oeq float %load_divi, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  store float 0.000000e+00, float* %MODR, align 4
  br label %continue

else:                                             ; preds = %entry
  %load_in = load float, float* %IN, align 4
  %DINT_TO_REAL_instance = alloca %DINT_TO_REAL_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %condition_body
  %MODR_ret = load float, float* %MODR, align 4
  ret float %MODR_ret

input:                                            ; preds = %else
  %1 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance, i32 0, i32 0
  %FLOOR2_instance = alloca %FLOOR2_interface, align 8
  br label %input2

call:                                             ; preds = %continue5
  %call10 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %load_divi11 = load float, float* %DIVI, align 4
  %tmpVar12 = fmul float %call10, %load_divi11
  %tmpVar13 = fsub float %load_in, %tmpVar12
  store float %tmpVar13, float* %MODR, align 4
  br label %continue

input2:                                           ; preds = %input
  %2 = getelementptr inbounds %FLOOR2_interface, %FLOOR2_interface* %FLOOR2_instance, i32 0, i32 0
  %load_in6 = load float, float* %IN, align 4
  %load_divi7 = load float, float* %DIVI, align 4
  %tmpVar8 = fdiv float %load_in6, %load_divi7
  store float %tmpVar8, float* %2, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call9 = call i32 @FLOOR2(%FLOOR2_interface* %FLOOR2_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i32 %call9, i32* %1, align 4
  br label %call
}

define float @MUL_ADD(%MUL_ADD_interface* %0) {
entry:
  %X = getelementptr inbounds %MUL_ADD_interface, %MUL_ADD_interface* %0, i32 0, i32 0
  %K = getelementptr inbounds %MUL_ADD_interface, %MUL_ADD_interface* %0, i32 0, i32 1
  %O = getelementptr inbounds %MUL_ADD_interface, %MUL_ADD_interface* %0, i32 0, i32 2
  %MUL_ADD = alloca float, align 4
  store float 0.000000e+00, float* %MUL_ADD, align 4
  %load_X = load float, float* %X, align 4
  %load_K = load float, float* %K, align 4
  %tmpVar = fmul float %load_X, %load_K
  %load_O = load float, float* %O, align 4
  %tmpVar1 = fadd float %tmpVar, %load_O
  store float %tmpVar1, float* %MUL_ADD, align 4
  %MUL_ADD_ret = load float, float* %MUL_ADD, align 4
  ret float %MUL_ADD_ret
}

define float @NEGX(%NEGX_interface* %0) {
entry:
  %X = getelementptr inbounds %NEGX_interface, %NEGX_interface* %0, i32 0, i32 0
  %NEGX = alloca float, align 4
  store float 0.000000e+00, float* %NEGX, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fneg float %load_X
  store float %tmpVar, float* %NEGX, align 4
  %NEGX_ret = load float, float* %NEGX, align 4
  ret float %NEGX_ret
}

define float @RAD(%RAD_interface* %0) {
entry:
  %DEG = getelementptr inbounds %RAD_interface, %RAD_interface* %0, i32 0, i32 0
  %RAD = alloca float, align 4
  store float 0.000000e+00, float* %RAD, align 4
  %MODR_instance = alloca %MODR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 0
  %load_DEG = load float, float* %DEG, align 4
  %tmpVar = fmul float 0x3F91DF46A0000000, %load_DEG
  store float %tmpVar, float* %1, align 4
  %2 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 1
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 1), align 4
  store float %load_, float* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call float @MODR(%MODR_interface* %MODR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call1, float* %RAD, align 4
  %RAD_ret = load float, float* %RAD, align 4
  ret float %RAD_ret
}

define float @RDM(%RDM_interface* %0) {
entry:
  %last = getelementptr inbounds %RDM_interface, %RDM_interface* %0, i32 0, i32 0
  %tn = getelementptr inbounds %RDM_interface, %RDM_interface* %0, i32 0, i32 1
  %tc = getelementptr inbounds %RDM_interface, %RDM_interface* %0, i32 0, i32 2
  %RDM = alloca float, align 4
  store i32 0, i32* %tn, align 4
  store i16 0, i16* %tc, align 2
  store float 0.000000e+00, float* %RDM, align 4
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %tn, align 4
  %BIT_COUNT_instance = alloca %BIT_COUNT_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %1 = getelementptr inbounds %BIT_COUNT_interface, %BIT_COUNT_interface* %BIT_COUNT_instance, i32 0, i32 0
  %load_tn = load i32, i32* %tn, align 4
  store i32 %load_tn, i32* %1, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i16 @BIT_COUNT(%BIT_COUNT_interface* %BIT_COUNT_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i16 %call6, i16* %tc, align 2
  %2 = load i32, i32* %tn, align 4
  %erase = and i32 %2, 2147483647
  %load_tn7 = load i32, i32* %tn, align 4
  %shift = lshr i32 %load_tn7, 2
  %3 = trunc i32 %shift to i8
  %4 = zext i8 %3 to i32
  %value = shl i32 %4, 31
  %or = or i32 %erase, %value
  store i32 %or, i32* %tn, align 4
  %5 = load i32, i32* %tn, align 4
  %erase8 = and i32 %5, -1073741825
  %load_tn9 = load i32, i32* %tn, align 4
  %shift10 = lshr i32 %load_tn9, 5
  %6 = trunc i32 %shift10 to i8
  %7 = zext i8 %6 to i32
  %value11 = shl i32 %7, 30
  %or12 = or i32 %erase8, %value11
  store i32 %or12, i32* %tn, align 4
  %8 = load i32, i32* %tn, align 4
  %erase13 = and i32 %8, -536870913
  %load_tn14 = load i32, i32* %tn, align 4
  %shift15 = lshr i32 %load_tn14, 4
  %9 = trunc i32 %shift15 to i8
  %10 = zext i8 %9 to i32
  %value16 = shl i32 %10, 29
  %or17 = or i32 %erase13, %value16
  store i32 %or17, i32* %tn, align 4
  %11 = load i32, i32* %tn, align 4
  %erase18 = and i32 %11, -268435457
  %load_tn19 = load i32, i32* %tn, align 4
  %shift20 = lshr i32 %load_tn19, 1
  %12 = trunc i32 %shift20 to i8
  %13 = zext i8 %12 to i32
  %value21 = shl i32 %13, 28
  %or22 = or i32 %erase18, %value21
  store i32 %or22, i32* %tn, align 4
  %14 = load i32, i32* %tn, align 4
  %erase23 = and i32 %14, -134217729
  %load_tn24 = load i32, i32* %tn, align 4
  %shift25 = lshr i32 %load_tn24, 0
  %15 = trunc i32 %shift25 to i8
  %16 = zext i8 %15 to i32
  %value26 = shl i32 %16, 27
  %or27 = or i32 %erase23, %value26
  store i32 %or27, i32* %tn, align 4
  %17 = load i32, i32* %tn, align 4
  %erase28 = and i32 %17, -67108865
  %load_tn29 = load i32, i32* %tn, align 4
  %shift30 = lshr i32 %load_tn29, 7
  %18 = trunc i32 %shift30 to i8
  %19 = zext i8 %18 to i32
  %value31 = shl i32 %19, 26
  %or32 = or i32 %erase28, %value31
  store i32 %or32, i32* %tn, align 4
  %20 = load i32, i32* %tn, align 4
  %erase33 = and i32 %20, -33554433
  %load_tn34 = load i32, i32* %tn, align 4
  %shift35 = lshr i32 %load_tn34, 6
  %21 = trunc i32 %shift35 to i8
  %22 = zext i8 %21 to i32
  %value36 = shl i32 %22, 25
  %or37 = or i32 %erase33, %value36
  store i32 %or37, i32* %tn, align 4
  %23 = load i32, i32* %tn, align 4
  %erase38 = and i32 %23, -16777217
  %load_tn39 = load i32, i32* %tn, align 4
  %shift40 = lshr i32 %load_tn39, 3
  %24 = trunc i32 %shift40 to i8
  %25 = zext i8 %24 to i32
  %value41 = shl i32 %25, 24
  %or42 = or i32 %erase38, %value41
  store i32 %or42, i32* %tn, align 4
  %ROL_instance = alloca %ROL_interface, align 8
  br label %input43

26:                                               ; preds = %continue46
  br label %27

27:                                               ; preds = %26, %continue46
  %28 = phi i64 [ %call55, %continue46 ], [ 2147483649, %26 ]
  store i64 %28, i32* %tn, align 4
  %load_tn56 = load i32, i32* %tn, align 4
  %tmpVar = srem i32 %load_tn56, 71474513
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input57

input43:                                          ; preds = %continue5
  %29 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 0
  %load_tn47 = load i32, i32* %tn, align 4
  %30 = zext i32 %load_tn47 to i64
  store i64 %30, i64* %29, align 4
  %31 = getelementptr inbounds %ROL_interface, %ROL_interface* %ROL_instance, i32 0, i32 1
  %BIT_COUNT_instance48 = alloca %BIT_COUNT_interface, align 8
  br label %input49

call44:                                           ; preds = %continue52
  %call55 = call i64 @ROL(%ROL_interface* %ROL_instance)
  br label %output45

output45:                                         ; preds = %call44
  br label %continue46

continue46:                                       ; preds = %output45
  %32 = icmp ne i64 %call55, 0
  br i1 %32, label %27, label %26

input49:                                          ; preds = %input43
  %33 = getelementptr inbounds %BIT_COUNT_interface, %BIT_COUNT_interface* %BIT_COUNT_instance48, i32 0, i32 0
  %load_tn53 = load i32, i32* %tn, align 4
  store i32 %load_tn53, i32* %33, align 4
  br label %call50

call50:                                           ; preds = %input49
  %call54 = call i16 @BIT_COUNT(%BIT_COUNT_interface* %BIT_COUNT_instance48)
  br label %output51

output51:                                         ; preds = %call50
  br label %continue52

continue52:                                       ; preds = %output51
  store i16 %call54, i16* %31, align 2
  br label %call44

input57:                                          ; preds = %27
  %34 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_tc = load i16, i16* %tc, align 2
  %35 = sext i16 %load_tc to i32
  %tmpVar61 = add i32 %35, 77
  %36 = trunc i32 %tmpVar61 to i16
  store i16 %36, i16* %34, align 2
  br label %call58

call58:                                           ; preds = %input57
  %call62 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output59

output59:                                         ; preds = %call58
  br label %continue60

continue60:                                       ; preds = %output59
  %tmpVar63 = add i32 %tmpVar, %call62
  store i32 %tmpVar63, i32* %tn, align 4
  %FRACT_instance = alloca %FRACT_interface, align 8
  br label %input64

input64:                                          ; preds = %continue60
  %37 = getelementptr inbounds %FRACT_interface, %FRACT_interface* %FRACT_instance, i32 0, i32 0
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input68

call65:                                           ; preds = %continue78
  %call82 = call float @FRACT(%FRACT_interface* %FRACT_instance)
  br label %output66

output66:                                         ; preds = %call65
  br label %continue67

continue67:                                       ; preds = %output66
  store float %call82, float* %RDM, align 4
  %RDM_ret = load float, float* %RDM, align 4
  ret float %RDM_ret

input68:                                          ; preds = %input64
  %38 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %load_tn72 = load i32, i32* %tn, align 4
  store i32 %load_tn72, i32* %38, align 4
  br label %call69

call69:                                           ; preds = %input68
  %call73 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output70

output70:                                         ; preds = %call69
  br label %continue71

continue71:                                       ; preds = %output70
  %tmpVar74 = fdiv float %call73, 1.000000e+07
  %39 = fpext float %tmpVar74 to double
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 6), align 4
  %40 = fpext float %load_ to double
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input75

input75:                                          ; preds = %continue71
  %41 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %41, align 4
  %42 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_last = load float, float* %last, align 4
  %43 = fptoui float %load_last to i64
  store i64 %43, i64* %42, align 4
  %44 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 1, i64* %44, align 4
  br label %call76

call76:                                           ; preds = %input75
  %call79 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output77

output77:                                         ; preds = %call76
  br label %continue78

continue78:                                       ; preds = %output77
  %45 = uitofp i64 %call79 to double
  %tmpVar80 = fsub double %40, %45
  %tmpVar81 = fmul double %39, %tmpVar80
  %46 = fptrunc double %tmpVar81 to float
  store float %46, float* %37, align 4
  br label %call65
}

define i16 @RDM2(%RDM2_interface* %0) {
entry:
  %last = getelementptr inbounds %RDM2_interface, %RDM2_interface* %0, i32 0, i32 0
  %low = getelementptr inbounds %RDM2_interface, %RDM2_interface* %0, i32 0, i32 1
  %high = getelementptr inbounds %RDM2_interface, %RDM2_interface* %0, i32 0, i32 2
  %RDM2 = alloca i16, align 2
  store i16 0, i16* %RDM2, align 2
  %TRUNC_instance = alloca %TRUNC_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %TRUNC_interface, %TRUNC_interface* %TRUNC_instance, i32 0, i32 0
  %RDM_instance = alloca %RDM_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call14 = call i16 @TRUNC(%TRUNC_interface* %TRUNC_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %2 = sext i16 %call14 to i32
  %load_low15 = load i16, i16* %low, align 2
  %3 = sext i16 %load_low15 to i32
  %tmpVar16 = add i32 %2, %3
  %4 = trunc i32 %tmpVar16 to i16
  store i16 %4, i16* %RDM2, align 2
  %RDM2_ret = load i16, i16* %RDM2, align 2
  ret i16 %RDM2_ret

input1:                                           ; preds = %input
  %5 = getelementptr inbounds %RDM_interface, %RDM_interface* %RDM_instance, i32 0, i32 0
  %FRACT_instance = alloca %FRACT_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  %call10 = call float @RDM(%RDM_interface* %RDM_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %load_high = load i16, i16* %high, align 2
  %6 = sext i16 %load_high to i32
  %load_low = load i16, i16* %low, align 2
  %7 = sext i16 %load_low to i32
  %tmpVar11 = sub i32 %6, %7
  %tmpVar12 = add i32 %tmpVar11, 1
  %8 = sitofp i32 %tmpVar12 to float
  %tmpVar13 = fmul float %call10, %8
  %9 = fpext float %tmpVar13 to double
  store double %9, double* %1, align 8
  br label %call

input5:                                           ; preds = %input1
  %10 = getelementptr inbounds %FRACT_interface, %FRACT_interface* %FRACT_instance, i32 0, i32 0
  %load_last = load i16, i16* %last, align 2
  %11 = sitofp i16 %load_last to float
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 0), align 4
  %tmpVar = fmul float %11, %load_
  store float %tmpVar, float* %10, align 4
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call float @FRACT(%FRACT_interface* %FRACT_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  store float %call9, float* %5, align 4
  br label %call2
}

define i32 @RDMDW(%RDMDW_interface* %0) {
entry:
  %last = getelementptr inbounds %RDMDW_interface, %RDMDW_interface* %0, i32 0, i32 0
  %RX = getelementptr inbounds %RDMDW_interface, %RDMDW_interface* %0, i32 0, i32 1
  %M = getelementptr inbounds %RDMDW_interface, %RDMDW_interface* %0, i32 0, i32 2
  %RDMDW = alloca i32, align 4
  store float 0.000000e+00, float* %RX, align 4
  store float 0.000000e+00, float* %M, align 4
  store i32 0, i32* %RDMDW, align 4
  %BIT_COUNT_instance = alloca %BIT_COUNT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %BIT_COUNT_interface, %BIT_COUNT_interface* %BIT_COUNT_instance, i32 0, i32 0
  %load_last = load i32, i32* %last, align 4
  store i32 %load_last, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @BIT_COUNT(%BIT_COUNT_interface* %BIT_COUNT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %2 = sitofp i16 %call1 to float
  store float %2, float* %M, align 4
  %RDM_instance = alloca %RDM_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %3 = getelementptr inbounds %RDM_interface, %RDM_interface* %RDM_instance, i32 0, i32 0
  %FRACT_instance = alloca %FRACT_interface, align 8
  br label %input6

call3:                                            ; preds = %continue9
  %call11 = call float @RDM(%RDM_interface* %RDM_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store float %call11, float* %RX, align 4
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input12

input6:                                           ; preds = %input2
  %4 = getelementptr inbounds %FRACT_interface, %FRACT_interface* %FRACT_instance, i32 0, i32 0
  %load_M = load float, float* %M, align 4
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 0), align 4
  %tmpVar = fmul float %load_M, %load_
  store float %tmpVar, float* %4, align 4
  br label %call7

call7:                                            ; preds = %input6
  %call10 = call float @FRACT(%FRACT_interface* %FRACT_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  store float %call10, float* %3, align 4
  br label %call3

input12:                                          ; preds = %continue5
  %5 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input16

call13:                                           ; preds = %continue19
  %call22 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %6 = trunc i64 %call22 to i32
  store i32 %6, i32* %RDMDW, align 4
  %RDM_instance23 = alloca %RDM_interface, align 8
  br label %input24

input16:                                          ; preds = %input12
  %7 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %load_rx = load float, float* %RX, align 4
  %tmpVar20 = fmul float %load_rx, 6.553500e+04
  store float %tmpVar20, float* %7, align 4
  br label %call17

call17:                                           ; preds = %input16
  %call21 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %8 = zext i32 %call21 to i64
  store i64 %8, i64* %5, align 4
  %9 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 16, i16* %9, align 2
  br label %call13

input24:                                          ; preds = %continue15
  %10 = getelementptr inbounds %RDM_interface, %RDM_interface* %RDM_instance23, i32 0, i32 0
  %FRACT_instance28 = alloca %FRACT_interface, align 8
  br label %input29

call25:                                           ; preds = %continue32
  %call37 = call float @RDM(%RDM_interface* %RDM_instance23)
  br label %output26

output26:                                         ; preds = %call25
  br label %continue27

continue27:                                       ; preds = %output26
  store float %call37, float* %RX, align 4
  %load_RDMDW = load i32, i32* %RDMDW, align 4
  %11 = icmp ne i32 %load_RDMDW, 0
  br i1 %11, label %14, label %13

input29:                                          ; preds = %input24
  %12 = getelementptr inbounds %FRACT_interface, %FRACT_interface* %FRACT_instance28, i32 0, i32 0
  %load_M33 = load float, float* %M, align 4
  %load_34 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 6), align 4
  %tmpVar35 = fmul float %load_M33, %load_34
  store float %tmpVar35, float* %12, align 4
  br label %call30

call30:                                           ; preds = %input29
  %call36 = call float @FRACT(%FRACT_interface* %FRACT_instance28)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  store float %call36, float* %10, align 4
  br label %call25

13:                                               ; preds = %continue27
  %REAL_TO_DWORD_instance38 = alloca %REAL_TO_DWORD_interface, align 8
  br label %input39

14:                                               ; preds = %17, %continue27
  %15 = phi i32 [ %load_RDMDW, %continue27 ], [ %18, %17 ]
  store i32 %15, i32* %RDMDW, align 4
  %RDMDW_ret = load i32, i32* %RDMDW, align 4
  ret i32 %RDMDW_ret

16:                                               ; preds = %continue42
  br label %17

17:                                               ; preds = %16, %continue42
  %18 = phi i32 [ %call45, %continue42 ], [ 65535, %16 ]
  br label %14

input39:                                          ; preds = %13
  %19 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance38, i32 0, i32 0
  %load_rx43 = load float, float* %RX, align 4
  %tmpVar44 = fmul float %load_rx43, 6.553500e+04
  store float %tmpVar44, float* %19, align 4
  br label %call40

call40:                                           ; preds = %input39
  %call45 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance38)
  br label %output41

output41:                                         ; preds = %call40
  br label %continue42

continue42:                                       ; preds = %output41
  %20 = icmp ne i32 %call45, 0
  br i1 %20, label %16, label %17
}

define %FRACTION @REAL_TO_FRAC(%REAL_TO_FRAC_interface* %0) {
entry:
  %X = getelementptr inbounds %REAL_TO_FRAC_interface, %REAL_TO_FRAC_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %REAL_TO_FRAC_interface, %REAL_TO_FRAC_interface* %0, i32 0, i32 1
  %temp = getelementptr inbounds %REAL_TO_FRAC_interface, %REAL_TO_FRAC_interface* %0, i32 0, i32 2
  %sign = getelementptr inbounds %REAL_TO_FRAC_interface, %REAL_TO_FRAC_interface* %0, i32 0, i32 3
  %X_gerundet = getelementptr inbounds %REAL_TO_FRAC_interface, %REAL_TO_FRAC_interface* %0, i32 0, i32 4
  %X_ohne_Nachkomma = getelementptr inbounds %REAL_TO_FRAC_interface, %REAL_TO_FRAC_interface* %0, i32 0, i32 5
  %Numerator = getelementptr inbounds %REAL_TO_FRAC_interface, %REAL_TO_FRAC_interface* %0, i32 0, i32 6
  %Denominator = getelementptr inbounds %REAL_TO_FRAC_interface, %REAL_TO_FRAC_interface* %0, i32 0, i32 7
  %Numerator_old = getelementptr inbounds %REAL_TO_FRAC_interface, %REAL_TO_FRAC_interface* %0, i32 0, i32 8
  %Denominator_old = getelementptr inbounds %REAL_TO_FRAC_interface, %REAL_TO_FRAC_interface* %0, i32 0, i32 9
  %REAL_TO_FRAC = alloca %FRACTION, align 8
  store i32 0, i32* %temp, align 4
  store i8 0, i8* %sign, align 1
  store i32 0, i32* %X_gerundet, align 4
  store float 0.000000e+00, float* %X_ohne_Nachkomma, align 4
  store i32 1, i32* %Numerator, align 4
  store i32 0, i32* %Denominator, align 4
  store i32 0, i32* %Numerator_old, align 4
  store i32 1, i32* %Denominator_old, align 4
  %1 = bitcast %FRACTION* %REAL_TO_FRAC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%FRACTION* @FRACTION__init to i8*), i64 mul nuw (i64 ptrtoint (i16* getelementptr (i16, i16* null, i32 1) to i64), i64 2), i1 false)
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp olt float %load_X, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  store i8 1, i8* %sign, align 1
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %entry
  br label %while_body

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_X2 = load float, float* %X, align 4
  %3 = fptoui float %load_X2 to i64
  store i64 %3, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call3 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %4 = uitofp i64 %call3 to float
  store float %4, float* %X, align 4
  br label %continue

condition_check:                                  ; preds = %continue32
  %ABS_instance5 = alloca %ABS_interface, align 8
  br label %input6

while_body:                                       ; preds = %continue, %continue9
  %REAL_TO_DINT_instance = alloca %REAL_TO_DINT_interface, align 8
  br label %input12

continue4:                                        ; preds = %continue36, %continue9
  %load_sign = load i8, i8* %sign, align 1
  %5 = icmp ne i8 %load_sign, 0
  br i1 %5, label %condition_body55, label %else53

input6:                                           ; preds = %condition_check
  %6 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance5, i32 0, i32 0
  %load_Denominator = load i32, i32* %Denominator, align 4
  %7 = sext i32 %load_Denominator to i64
  store i64 %7, i64* %6, align 4
  br label %call7

call7:                                            ; preds = %input6
  %call10 = call i64 @ABS(%ABS_interface* %ABS_instance5)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %load_N = load i16, i16* %N, align 2
  %8 = sext i16 %load_N to i64
  %tmpVar11 = icmp sgt i64 %call10, %8
  br i1 %tmpVar11, label %while_body, label %continue4

input12:                                          ; preds = %while_body
  %9 = getelementptr inbounds %REAL_TO_DINT_interface, %REAL_TO_DINT_interface* %REAL_TO_DINT_instance, i32 0, i32 0
  %load_X16 = load float, float* %X, align 4
  store float %load_X16, float* %9, align 4
  br label %call13

call13:                                           ; preds = %input12
  %call17 = call i32 @REAL_TO_DINT(%REAL_TO_DINT_interface* %REAL_TO_DINT_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  store i32 %call17, i32* %X_gerundet, align 4
  %load_numerator = load i32, i32* %Numerator, align 4
  %load_X_gerundet = load i32, i32* %X_gerundet, align 4
  %tmpVar18 = mul i32 %load_numerator, %load_X_gerundet
  %load_numerator_old = load i32, i32* %Numerator_old, align 4
  %tmpVar19 = add i32 %tmpVar18, %load_numerator_old
  store i32 %tmpVar19, i32* %temp, align 4
  %load_numerator20 = load i32, i32* %Numerator, align 4
  store i32 %load_numerator20, i32* %Numerator_old, align 4
  %load_temp = load i32, i32* %temp, align 4
  store i32 %load_temp, i32* %Numerator, align 4
  %load_denominator = load i32, i32* %Denominator, align 4
  %load_X_gerundet21 = load i32, i32* %X_gerundet, align 4
  %tmpVar22 = mul i32 %load_denominator, %load_X_gerundet21
  %load_denominator_old = load i32, i32* %Denominator_old, align 4
  %tmpVar23 = add i32 %tmpVar22, %load_denominator_old
  store i32 %tmpVar23, i32* %temp, align 4
  %load_denominator24 = load i32, i32* %Denominator, align 4
  store i32 %load_denominator24, i32* %Denominator_old, align 4
  %load_temp25 = load i32, i32* %temp, align 4
  store i32 %load_temp25, i32* %Denominator, align 4
  %DINT_TO_REAL_instance = alloca %DINT_TO_REAL_interface, align 8
  br label %input26

input26:                                          ; preds = %continue15
  %10 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance, i32 0, i32 0
  %load_X_gerundet30 = load i32, i32* %X_gerundet, align 4
  store i32 %load_X_gerundet30, i32* %10, align 4
  br label %call27

call27:                                           ; preds = %input26
  %call31 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  store float %call31, float* %X_ohne_Nachkomma, align 4
  %load_X34 = load float, float* %X, align 4
  %load_X_ohne_Nachkomma = load float, float* %X_ohne_Nachkomma, align 4
  %tmpVar35 = fcmp oeq float %load_X34, %load_X_ohne_Nachkomma
  br i1 %tmpVar35, label %condition_body33, label %else

condition_body33:                                 ; preds = %continue29
  %ABS_instance38 = alloca %ABS_interface, align 8
  br label %input39

else:                                             ; preds = %continue29
  %load_X49 = load float, float* %X, align 4
  %load_X_ohne_Nachkomma50 = load float, float* %X_ohne_Nachkomma, align 4
  %tmpVar51 = fsub float %load_X49, %load_X_ohne_Nachkomma50
  %tmpVar52 = fdiv float 1.000000e+00, %tmpVar51
  store float %tmpVar52, float* %X, align 4
  br label %continue32

continue32:                                       ; preds = %else, %buffer_block
  br label %condition_check

condition_body37:                                 ; preds = %continue42
  %load_numerator47 = load i32, i32* %Numerator, align 4
  store i32 %load_numerator47, i32* %Numerator_old, align 4
  %load_denominator48 = load i32, i32* %Denominator, align 4
  store i32 %load_denominator48, i32* %Denominator_old, align 4
  br label %continue36

continue36:                                       ; preds = %condition_body37, %continue42
  br label %continue4

buffer_block:                                     ; No predecessors!
  br label %continue32

input39:                                          ; preds = %condition_body33
  %11 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance38, i32 0, i32 0
  %load_denominator43 = load i32, i32* %Denominator, align 4
  %12 = sext i32 %load_denominator43 to i64
  store i64 %12, i64* %11, align 4
  br label %call40

call40:                                           ; preds = %input39
  %call44 = call i64 @ABS(%ABS_interface* %ABS_instance38)
  br label %output41

output41:                                         ; preds = %call40
  br label %continue42

continue42:                                       ; preds = %output41
  %load_N45 = load i16, i16* %N, align 2
  %13 = sext i16 %load_N45 to i64
  %tmpVar46 = icmp sle i64 %call44, %13
  br i1 %tmpVar46, label %condition_body37, label %continue36

condition_body55:                                 ; preds = %continue4
  %NUMERATOR = getelementptr inbounds %FRACTION, %FRACTION* %REAL_TO_FRAC, i32 0, i32 0
  %ABS_instance56 = alloca %ABS_interface, align 8
  br label %input57

else53:                                           ; preds = %continue4
  %NUMERATOR69 = getelementptr inbounds %FRACTION, %FRACTION* %REAL_TO_FRAC, i32 0, i32 0
  %ABS_instance70 = alloca %ABS_interface, align 8
  br label %input71

continue54:                                       ; preds = %continue74, %continue60
  %DENOMINATOR = getelementptr inbounds %FRACTION, %FRACTION* %REAL_TO_FRAC, i32 0, i32 1
  %ABS_instance83 = alloca %ABS_interface, align 8
  br label %input84

input57:                                          ; preds = %condition_body55
  %14 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance56, i32 0, i32 0
  %DINT_TO_INT_instance = alloca %DINT_TO_INT_interface, align 8
  br label %input61

call58:                                           ; preds = %continue64
  %call67 = call i64 @ABS(%ABS_interface* %ABS_instance56)
  br label %output59

output59:                                         ; preds = %call58
  br label %continue60

continue60:                                       ; preds = %output59
  %tmpVar68 = mul i64 -1, %call67
  %15 = trunc i64 %tmpVar68 to i16
  store i16 %15, i16* %NUMERATOR, align 2
  br label %continue54

input61:                                          ; preds = %input57
  %16 = getelementptr inbounds %DINT_TO_INT_interface, %DINT_TO_INT_interface* %DINT_TO_INT_instance, i32 0, i32 0
  %load_numerator_old65 = load i32, i32* %Numerator_old, align 4
  store i32 %load_numerator_old65, i32* %16, align 4
  br label %call62

call62:                                           ; preds = %input61
  %call66 = call i16 @DINT_TO_INT(%DINT_TO_INT_interface* %DINT_TO_INT_instance)
  br label %output63

output63:                                         ; preds = %call62
  br label %continue64

continue64:                                       ; preds = %output63
  %17 = sext i16 %call66 to i64
  store i64 %17, i64* %14, align 4
  br label %call58

input71:                                          ; preds = %else53
  %18 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance70, i32 0, i32 0
  %DINT_TO_INT_instance75 = alloca %DINT_TO_INT_interface, align 8
  br label %input76

call72:                                           ; preds = %continue79
  %call82 = call i64 @ABS(%ABS_interface* %ABS_instance70)
  br label %output73

output73:                                         ; preds = %call72
  br label %continue74

continue74:                                       ; preds = %output73
  %19 = trunc i64 %call82 to i16
  store i16 %19, i16* %NUMERATOR69, align 2
  br label %continue54

input76:                                          ; preds = %input71
  %20 = getelementptr inbounds %DINT_TO_INT_interface, %DINT_TO_INT_interface* %DINT_TO_INT_instance75, i32 0, i32 0
  %load_numerator_old80 = load i32, i32* %Numerator_old, align 4
  store i32 %load_numerator_old80, i32* %20, align 4
  br label %call77

call77:                                           ; preds = %input76
  %call81 = call i16 @DINT_TO_INT(%DINT_TO_INT_interface* %DINT_TO_INT_instance75)
  br label %output78

output78:                                         ; preds = %call77
  br label %continue79

continue79:                                       ; preds = %output78
  %21 = sext i16 %call81 to i64
  store i64 %21, i64* %18, align 4
  br label %call72

input84:                                          ; preds = %continue54
  %22 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance83, i32 0, i32 0
  %DINT_TO_INT_instance88 = alloca %DINT_TO_INT_interface, align 8
  br label %input89

call85:                                           ; preds = %continue92
  %call95 = call i64 @ABS(%ABS_interface* %ABS_instance83)
  br label %output86

output86:                                         ; preds = %call85
  br label %continue87

continue87:                                       ; preds = %output86
  %23 = trunc i64 %call95 to i16
  store i16 %23, i16* %DENOMINATOR, align 2
  %REAL_TO_FRAC_ret = load %FRACTION, %FRACTION* %REAL_TO_FRAC, align 2
  ret %FRACTION %REAL_TO_FRAC_ret

input89:                                          ; preds = %input84
  %24 = getelementptr inbounds %DINT_TO_INT_interface, %DINT_TO_INT_interface* %DINT_TO_INT_instance88, i32 0, i32 0
  %load_denominator_old93 = load i32, i32* %Denominator_old, align 4
  store i32 %load_denominator_old93, i32* %24, align 4
  br label %call90

call90:                                           ; preds = %input89
  %call94 = call i16 @DINT_TO_INT(%DINT_TO_INT_interface* %DINT_TO_INT_instance88)
  br label %output91

output91:                                         ; preds = %call90
  br label %continue92

continue92:                                       ; preds = %output91
  %25 = sext i16 %call94 to i64
  store i64 %25, i64* %22, align 4
  br label %call85
}

define float @RND(%RND_interface* %0) {
entry:
  %X = getelementptr inbounds %RND_interface, %RND_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %RND_interface, %RND_interface* %0, i32 0, i32 1
  %M = getelementptr inbounds %RND_interface, %RND_interface* %0, i32 0, i32 2
  %RND = alloca float, align 4
  store float 0.000000e+00, float* %M, align 4
  store float 0.000000e+00, float* %RND, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp oeq float %load_X, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  store float 0.000000e+00, float* %RND, align 4
  br label %continue

else:                                             ; preds = %entry
  %EXPN_instance = alloca %EXPN_interface, align 8
  br label %input

continue:                                         ; preds = %continue23, %condition_body
  %RND_ret = load float, float* %RND, align 4
  ret float %RND_ret

input:                                            ; preds = %else
  %1 = getelementptr inbounds %EXPN_interface, %EXPN_interface* %EXPN_instance, i32 0, i32 0
  store float 1.000000e+01, float* %1, align 4
  %2 = getelementptr inbounds %EXPN_interface, %EXPN_interface* %EXPN_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %3 = sext i16 %load_N to i32
  %CEIL_instance = alloca %CEIL_interface, align 8
  br label %input2

call:                                             ; preds = %continue5
  %call19 = call float @EXPN(%EXPN_interface* %EXPN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store float %call19, float* %M, align 4
  %DINT_TO_REAL_instance = alloca %DINT_TO_REAL_interface, align 8
  br label %input20

input2:                                           ; preds = %input
  %4 = getelementptr inbounds %CEIL_interface, %CEIL_interface* %CEIL_instance, i32 0, i32 0
  %LOG_instance = alloca %LOG_interface, align 8
  br label %input6

call3:                                            ; preds = %continue9
  %call17 = call i16 @CEIL(%CEIL_interface* %CEIL_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %5 = sext i16 %call17 to i32
  %tmpVar18 = sub i32 %3, %5
  %6 = trunc i32 %tmpVar18 to i16
  store i16 %6, i16* %2, align 2
  br label %call

input6:                                           ; preds = %input2
  %7 = getelementptr inbounds %LOG_interface, %LOG_interface* %LOG_instance, i32 0, i32 0
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input10

call7:                                            ; preds = %continue13
  %call16 = call i64 @LOG(%LOG_interface* %LOG_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %8 = uitofp i64 %call16 to float
  store float %8, float* %4, align 4
  br label %call3

input10:                                          ; preds = %input6
  %9 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_X14 = load float, float* %X, align 4
  %10 = fptoui float %load_X14 to i64
  store i64 %10, i64* %9, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call15 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  store i64 %call15, i64* %7, align 4
  br label %call7

input20:                                          ; preds = %continue1
  %11 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance, i32 0, i32 0
  %REAL_TO_DINT_instance = alloca %REAL_TO_DINT_interface, align 8
  br label %input24

call21:                                           ; preds = %continue27
  %call31 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance)
  br label %output22

output22:                                         ; preds = %call21
  br label %continue23

continue23:                                       ; preds = %output22
  %load_M32 = load float, float* %M, align 4
  %tmpVar33 = fdiv float %call31, %load_M32
  store float %tmpVar33, float* %RND, align 4
  br label %continue

input24:                                          ; preds = %input20
  %12 = getelementptr inbounds %REAL_TO_DINT_interface, %REAL_TO_DINT_interface* %REAL_TO_DINT_instance, i32 0, i32 0
  %load_X28 = load float, float* %X, align 4
  %load_M = load float, float* %M, align 4
  %tmpVar29 = fmul float %load_X28, %load_M
  store float %tmpVar29, float* %12, align 4
  br label %call25

call25:                                           ; preds = %input24
  %call30 = call i32 @REAL_TO_DINT(%REAL_TO_DINT_interface* %REAL_TO_DINT_instance)
  br label %output26

output26:                                         ; preds = %call25
  br label %continue27

continue27:                                       ; preds = %output26
  store i32 %call30, i32* %11, align 4
  br label %call21
}

define float @ROUND(%ROUND_interface* %0) {
entry:
  %in = getelementptr inbounds %ROUND_interface, %ROUND_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %ROUND_interface, %ROUND_interface* %0, i32 0, i32 1
  %X = getelementptr inbounds %ROUND_interface, %ROUND_interface* %0, i32 0, i32 2
  %ROUND = alloca float, align 4
  store float 0.000000e+00, float* %X, align 4
  store float 0.000000e+00, float* %ROUND, align 4
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %1, align 4
  %2 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %3 = sext i16 %load_N to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 8, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = trunc i64 %call1 to i32
  %tmpVar = mul i32 1, %5
  %tmpVar2 = add i32 %tmpVar, 0
  %tmpVar3 = getelementptr inbounds [9 x float], [9 x float]* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 3), i32 0, i32 %tmpVar2
  %load_ = load float, float* %tmpVar3, align 4
  store float %load_, float* %X, align 4
  %DINT_TO_REAL_instance = alloca %DINT_TO_REAL_interface, align 8
  br label %input4

input4:                                           ; preds = %continue
  %6 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance, i32 0, i32 0
  %REAL_TO_DINT_instance = alloca %REAL_TO_DINT_interface, align 8
  br label %input8

call5:                                            ; preds = %continue11
  %call14 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %load_X15 = load float, float* %X, align 4
  %tmpVar16 = fdiv float %call14, %load_X15
  store float %tmpVar16, float* %ROUND, align 4
  %ROUND_ret = load float, float* %ROUND, align 4
  ret float %ROUND_ret

input8:                                           ; preds = %input4
  %7 = getelementptr inbounds %REAL_TO_DINT_interface, %REAL_TO_DINT_interface* %REAL_TO_DINT_instance, i32 0, i32 0
  %load_in = load float, float* %in, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar12 = fmul float %load_in, %load_X
  store float %tmpVar12, float* %7, align 4
  br label %call9

call9:                                            ; preds = %input8
  %call13 = call i32 @REAL_TO_DINT(%REAL_TO_DINT_interface* %REAL_TO_DINT_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  store i32 %call13, i32* %6, align 4
  br label %call5
}

define i16 @SGN(%SGN_interface* %0) {
entry:
  %X = getelementptr inbounds %SGN_interface, %SGN_interface* %0, i32 0, i32 0
  %SGN = alloca i16, align 2
  store i16 0, i16* %SGN, align 2
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp ogt float %load_X, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store i16 1, i16* %SGN, align 2
  br label %continue

branch:                                           ; preds = %entry
  %load_X2 = load float, float* %X, align 4
  %tmpVar3 = fcmp olt float %load_X2, 0.000000e+00
  br i1 %tmpVar3, label %condition_body1, label %else

condition_body1:                                  ; preds = %branch
  store i16 -1, i16* %SGN, align 2
  br label %continue

else:                                             ; preds = %branch
  store i16 0, i16* %SGN, align 2
  br label %continue

continue:                                         ; preds = %else, %condition_body1, %condition_body
  %SGN_ret = load i16, i16* %SGN, align 2
  ret i16 %SGN_ret
}

define float @SIGMOID(%SIGMOID_interface* %0) {
entry:
  %X = getelementptr inbounds %SIGMOID_interface, %SIGMOID_interface* %0, i32 0, i32 0
  %SIGMOID = alloca float, align 4
  store float 0.000000e+00, float* %SIGMOID, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp ogt float %load_X, 2.000000e+01
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store float 1.000000e+00, float* %SIGMOID, align 4
  br label %continue

branch:                                           ; preds = %entry
  %load_x = load float, float* %X, align 4
  %tmpVar2 = fcmp olt float %load_x, -8.500000e+01
  br i1 %tmpVar2, label %condition_body1, label %else

condition_body1:                                  ; preds = %branch
  store float 0.000000e+00, float* %SIGMOID, align 4
  br label %continue

else:                                             ; preds = %branch
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input

continue:                                         ; preds = %continue3, %condition_body1, %condition_body
  %SIGMOID_ret = load float, float* %SIGMOID, align 4
  ret float %SIGMOID_ret

input:                                            ; preds = %else
  %1 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %load_X4 = load float, float* %X, align 4
  %tmpVar5 = fneg float %load_X4
  %2 = fptosi float %tmpVar5 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call6 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  %tmpVar7 = fadd double 1.000000e+00, %call6
  %tmpVar8 = fdiv double 1.000000e+00, %tmpVar7
  %3 = fptrunc double %tmpVar8 to float
  store float %3, float* %SIGMOID, align 4
  br label %continue
}

define i8 @SIGN_I(%SIGN_I_interface* %0) {
entry:
  %IN = getelementptr inbounds %SIGN_I_interface, %SIGN_I_interface* %0, i32 0, i32 0
  %SIGN_I = alloca i8, align 1
  store i8 0, i8* %SIGN_I, align 1
  %load_in = load i32, i32* %IN, align 4
  %shift = ashr i32 %load_in, 31
  %1 = trunc i32 %shift to i8
  store i8 %1, i8* %SIGN_I, align 1
  %SIGN_I_ret = load i8, i8* %SIGN_I, align 1
  ret i8 %SIGN_I_ret
}

define i8 @SIGN_R(%SIGN_R_interface* %0) {
entry:
  %in = getelementptr inbounds %SIGN_R_interface, %SIGN_R_interface* %0, i32 0, i32 0
  %SIGN_R = alloca i8, align 1
  store i8 0, i8* %SIGN_R, align 1
  %load_in = load float, float* %in, align 4
  %tmpVar = fcmp olt float %load_in, 0.000000e+00
  %1 = zext i1 %tmpVar to i8
  store i8 %1, i8* %SIGN_R, align 1
  %SIGN_R_ret = load i8, i8* %SIGN_R, align 1
  ret i8 %SIGN_R_ret
}

define float @SINC(%SINC_interface* %0) {
entry:
  %X = getelementptr inbounds %SINC_interface, %SINC_interface* %0, i32 0, i32 0
  %SINC = alloca float, align 4
  store float 0.000000e+00, float* %SINC, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp oeq float %load_X, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  store float 1.000000e+00, float* %SINC, align 4
  br label %continue

else:                                             ; preds = %entry
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %condition_body
  %SINC_ret = load float, float* %SINC, align 4
  ret float %SINC_ret

input:                                            ; preds = %else
  %1 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %2 = fptosi float %load_x to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %load_x3 = load float, float* %X, align 4
  %3 = fpext float %load_x3 to double
  %tmpVar4 = fdiv double %call2, %3
  %4 = fptrunc double %tmpVar4 to float
  store float %4, float* %SINC, align 4
  br label %continue
}

define float @SINH(%SINH_interface* %0) {
entry:
  %X = getelementptr inbounds %SINH_interface, %SINH_interface* %0, i32 0, i32 0
  %SINH = alloca float, align 4
  store float 0.000000e+00, float* %SINH, align 4
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input

condition_body:                                   ; preds = %continue1
  %load_X = load float, float* %X, align 4
  store float %load_X, float* %SINH, align 4
  br label %continue

else:                                             ; preds = %continue1
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input3

continue:                                         ; preds = %continue13, %condition_body
  %SINH_ret = load float, float* %SINH, align 4
  ret float %SINH_ret

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %2 = fptoui float %load_x to i64
  store i64 %2, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %3 = uitofp i64 %call2 to double
  %tmpVar = fcmp olt double %3, 2.000000e-03
  br i1 %tmpVar, label %condition_body, label %else

input3:                                           ; preds = %else
  %4 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %load_x7 = load float, float* %X, align 4
  %5 = fptosi float %load_x7 to i32
  store i32 %5, i32* %4, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %EXP_instance9 = alloca %EXP_interface, align 8
  br label %input10

input10:                                          ; preds = %continue6
  %6 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance9, i32 0, i32 0
  %load_x14 = load float, float* %X, align 4
  %tmpVar15 = fneg float %load_x14
  %7 = fptosi float %tmpVar15 to i32
  store i32 %7, i32* %6, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call16 = call double @EXP(%EXP_interface* %EXP_instance9)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %tmpVar17 = fsub double %call8, %call16
  %tmpVar18 = fmul double %tmpVar17, 5.000000e-01
  %8 = fptrunc double %tmpVar18 to float
  store float %8, float* %SINH, align 4
  br label %continue
}

define float @SQRTN(%SQRTN_interface* %0) {
entry:
  %X = getelementptr inbounds %SQRTN_interface, %SQRTN_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %SQRTN_interface, %SQRTN_interface* %0, i32 0, i32 1
  %SQRTN = alloca float, align 4
  store float 0.000000e+00, float* %SQRTN, align 4
  %load_N = load i16, i16* %N, align 2
  %1 = sext i16 %load_N to i32
  %tmpVar = icmp sgt i32 %1, 0
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input

else:                                             ; preds = %entry
  store float 0.000000e+00, float* %SQRTN, align 4
  br label %continue

continue:                                         ; preds = %else, %continue1
  %SQRTN_ret = load float, float* %SQRTN, align 4
  ret float %SQRTN_ret

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %LN_instance = alloca %LN_interface, align 8
  br label %input2

call:                                             ; preds = %continue10
  %call13 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %3 = fptrunc double %call13 to float
  store float %3, float* %SQRTN, align 4
  br label %continue

input2:                                           ; preds = %input
  %4 = getelementptr inbounds %LN_interface, %LN_interface* %LN_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %5 = fptosi float %load_x to i32
  store i32 %5, i32* %4, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call double @LN(%LN_interface* %LN_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %INT_TO_REAL_instance = alloca %INT_TO_REAL_interface, align 8
  br label %input7

input7:                                           ; preds = %continue5
  %6 = getelementptr inbounds %INT_TO_REAL_interface, %INT_TO_REAL_interface* %INT_TO_REAL_instance, i32 0, i32 0
  %load_n = load i16, i16* %N, align 2
  store i16 %load_n, i16* %6, align 2
  br label %call8

call8:                                            ; preds = %input7
  %call11 = call float @INT_TO_REAL(%INT_TO_REAL_interface* %INT_TO_REAL_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %7 = fpext float %call11 to double
  %tmpVar12 = fdiv double %call6, %7
  %8 = fptosi double %tmpVar12 to i32
  store i32 %8, i32* %2, align 4
  br label %call
}

define float @TANC(%TANC_interface* %0) {
entry:
  %X = getelementptr inbounds %TANC_interface, %TANC_interface* %0, i32 0, i32 0
  %TANC = alloca float, align 4
  store float 0.000000e+00, float* %TANC, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp oeq float %load_X, 0.000000e+00
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  store float 1.000000e+00, float* %TANC, align 4
  br label %continue

else:                                             ; preds = %entry
  %TAN_instance = alloca %TAN_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %condition_body
  %TANC_ret = load float, float* %TANC, align 4
  ret float %TANC_ret

input:                                            ; preds = %else
  %1 = getelementptr inbounds %TAN_interface, %TAN_interface* %TAN_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %2 = fptosi float %load_x to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call double @TAN(%TAN_interface* %TAN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %load_x3 = load float, float* %X, align 4
  %3 = fpext float %load_x3 to double
  %tmpVar4 = fdiv double %call2, %3
  %4 = fptrunc double %tmpVar4 to float
  store float %4, float* %TANC, align 4
  br label %continue
}

define float @TANH(%TANH_interface* %0) {
entry:
  %X = getelementptr inbounds %TANH_interface, %TANH_interface* %0, i32 0, i32 0
  %TANH = alloca float, align 4
  store float 0.000000e+00, float* %TANH, align 4
  %load_X = load float, float* %X, align 4
  %tmpVar = fcmp ogt float %load_X, 2.000000e+01
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  store float 1.000000e+00, float* %TANH, align 4
  br label %continue

branch:                                           ; preds = %entry
  %load_X2 = load float, float* %X, align 4
  %tmpVar3 = fcmp olt float %load_X2, -2.000000e+01
  br i1 %tmpVar3, label %condition_body1, label %else

condition_body1:                                  ; preds = %branch
  store float -1.000000e+00, float* %TANH, align 4
  br label %continue

else:                                             ; preds = %branch
  %EXP_instance = alloca %EXP_interface, align 8
  br label %input

continue:                                         ; preds = %continue4, %condition_body1, %condition_body
  %TANH_ret = load float, float* %TANH, align 4
  ret float %TANH_ret

input:                                            ; preds = %else
  %1 = getelementptr inbounds %EXP_interface, %EXP_interface* %EXP_instance, i32 0, i32 0
  %load_x = load float, float* %X, align 4
  %tmpVar5 = fmul float 2.000000e+00, %load_x
  %2 = fptosi float %tmpVar5 to i32
  store i32 %2, i32* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call6 = call double @EXP(%EXP_interface* %EXP_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue4

continue4:                                        ; preds = %output
  %tmpVar7 = fadd double %call6, 1.000000e+00
  %tmpVar8 = fdiv double 2.000000e+00, %tmpVar7
  %tmpVar9 = fsub double 1.000000e+00, %tmpVar8
  %3 = fptrunc double %tmpVar9 to float
  store float %3, float* %TANH, align 4
  br label %continue
}

define i8 @WINDOW(%WINDOW_interface* %0) {
entry:
  %low = getelementptr inbounds %WINDOW_interface, %WINDOW_interface* %0, i32 0, i32 0
  %in = getelementptr inbounds %WINDOW_interface, %WINDOW_interface* %0, i32 0, i32 1
  %high = getelementptr inbounds %WINDOW_interface, %WINDOW_interface* %0, i32 0, i32 2
  %WINDOW = alloca i8, align 1
  store i8 0, i8* %WINDOW, align 1
  %load_in = load float, float* %in, align 4
  %load_high = load float, float* %high, align 4
  %tmpVar = fcmp olt float %load_in, %load_high
  %1 = zext i1 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %3, label %5

3:                                                ; preds = %entry
  %load_in1 = load float, float* %in, align 4
  %load_low = load float, float* %low, align 4
  %tmpVar2 = fcmp ogt float %load_in1, %load_low
  %4 = zext i1 %tmpVar2 to i32
  br label %5

5:                                                ; preds = %3, %entry
  %6 = phi i32 [ %1, %entry ], [ %4, %3 ]
  store i32 %6, i8* %WINDOW, align 4
  %WINDOW_ret = load i8, i8* %WINDOW, align 1
  ret i8 %WINDOW_ret
}

define i8 @WINDOW2(%WINDOW2_interface* %0) {
entry:
  %LOW = getelementptr inbounds %WINDOW2_interface, %WINDOW2_interface* %0, i32 0, i32 0
  %IN = getelementptr inbounds %WINDOW2_interface, %WINDOW2_interface* %0, i32 0, i32 1
  %HIGH = getelementptr inbounds %WINDOW2_interface, %WINDOW2_interface* %0, i32 0, i32 2
  %WINDOW2 = alloca i8, align 1
  store i8 0, i8* %WINDOW2, align 1
  %load_IN = load float, float* %IN, align 4
  %load_LOW = load float, float* %LOW, align 4
  %tmpVar = fcmp oge float %load_IN, %load_LOW
  %1 = zext i1 %tmpVar to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %3, label %5

3:                                                ; preds = %entry
  %load_IN1 = load float, float* %IN, align 4
  %load_HIGH = load float, float* %HIGH, align 4
  %tmpVar2 = fcmp ole float %load_IN1, %load_HIGH
  %4 = zext i1 %tmpVar2 to i32
  br label %5

5:                                                ; preds = %3, %entry
  %6 = phi i32 [ %1, %entry ], [ %4, %3 ]
  store i32 %6, i8* %WINDOW2, align 4
  %WINDOW2_ret = load i8, i8* %WINDOW2, align 1
  ret i8 %WINDOW2_ret
}

define void @ESR_COLLECT(%ESR_COLLECT_interface* %0) {
entry:
  %ESR_0 = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 0
  %ESR_1 = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 1
  %ESR_2 = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 2
  %ESR_3 = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 3
  %ESR_4 = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 4
  %ESR_5 = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 5
  %ESR_6 = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 6
  %ESR_7 = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 7
  %rst = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 8
  %pos = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 9
  %ESR_OUT = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 10
  %max_in = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 11
  %max_out = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 12
  %cnt = getelementptr inbounds %ESR_COLLECT_interface, %ESR_COLLECT_interface* %0, i32 0, i32 13
  %load_rst = load i8, i8* %rst, align 1
  %1 = zext i8 %load_rst to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %6, label %3

condition_body:                                   ; preds = %6
  %deref = load i16*, i16** %pos, align 8
  store i16 -1, i16* %deref, align 2
  br label %continue

else:                                             ; preds = %6
  store i16 0, i16* %cnt, align 2
  br label %condition_check

continue:                                         ; preds = %continue1, %condition_body
  ret void

3:                                                ; preds = %entry
  %load_cnt = load i16, i16* %cnt, align 2
  %4 = sext i16 %load_cnt to i32
  %tmpVar = icmp slt i32 %4, 0
  %5 = zext i1 %tmpVar to i32
  br label %6

6:                                                ; preds = %3, %entry
  %7 = phi i32 [ %1, %entry ], [ %5, %3 ]
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %condition_body, label %else

condition_check:                                  ; preds = %increment, %else
  %load_cnt2 = load i16, i16* %cnt, align 2
  %load_cnt3 = load i16, i16* %cnt, align 2
  %load_max_in = load i16, i16* %max_in, align 2
  %tmpVar4 = icmp sle i16 %load_cnt3, %load_max_in
  %9 = icmp ne i1 %tmpVar4, false
  br i1 %9, label %16, label %17

for_body:                                         ; preds = %14
  %load_cnt14 = load i16, i16* %cnt, align 2
  %10 = sext i16 %load_cnt14 to i32
  %tmpVar15 = mul i32 1, %10
  %tmpVar16 = add i32 %tmpVar15, 0
  %tmpVar17 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_0, i32 0, i32 %tmpVar16
  %typ = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar17, i32 0, i32 0
  %load_ = load i8, i8* %typ, align 1
  %11 = zext i8 %load_ to i32
  %tmpVar18 = icmp sgt i32 %11, 0
  br i1 %tmpVar18, label %condition_body13, label %continue12

increment:                                        ; preds = %continue206
  %tmpVar235 = add i16 %load_cnt2, 1
  store i16 %tmpVar235, i16* %cnt, align 2
  br label %condition_check

continue1:                                        ; preds = %14
  br label %continue

12:                                               ; preds = %17
  %load_cnt7 = load i16, i16* %cnt, align 2
  %load_max_in8 = load i16, i16* %max_in, align 2
  %tmpVar9 = icmp sge i16 %load_cnt7, %load_max_in8
  %13 = icmp ne i1 %tmpVar9, false
  br i1 %13, label %20, label %21

14:                                               ; preds = %21, %17
  %15 = phi i1 [ %18, %17 ], [ %22, %21 ]
  br i1 %15, label %for_body, label %continue1

16:                                               ; preds = %condition_check
  %load_cnt5 = load i16, i16* %cnt, align 2
  %tmpVar6 = icmp sge i16 %load_cnt5, 0
  br label %17

17:                                               ; preds = %16, %condition_check
  %18 = phi i1 [ %tmpVar4, %condition_check ], [ %tmpVar6, %16 ]
  %19 = icmp ne i1 %18, false
  br i1 %19, label %14, label %12

20:                                               ; preds = %12
  %load_cnt10 = load i16, i16* %cnt, align 2
  %tmpVar11 = icmp sle i16 %load_cnt10, 0
  br label %21

21:                                               ; preds = %20, %12
  %22 = phi i1 [ %tmpVar9, %12 ], [ %tmpVar11, %20 ]
  br label %14

condition_body13:                                 ; preds = %for_body
  %deref19 = load i16*, i16** %pos, align 8
  %INC1_instance = alloca %INC1_interface, align 8
  br label %input

continue12:                                       ; preds = %continue20, %for_body
  %load_cnt34 = load i16, i16* %cnt, align 2
  %23 = sext i16 %load_cnt34 to i32
  %tmpVar35 = mul i32 1, %23
  %tmpVar36 = add i32 %tmpVar35, 0
  %tmpVar37 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_1, i32 0, i32 %tmpVar36
  %typ38 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar37, i32 0, i32 0
  %load_39 = load i8, i8* %typ38, align 1
  %24 = zext i8 %load_39 to i32
  %tmpVar40 = icmp sgt i32 %24, 0
  br i1 %tmpVar40, label %condition_body33, label %continue32

input:                                            ; preds = %condition_body13
  %25 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 0
  %deref21 = load i16*, i16** %pos, align 8
  %load_pos = load i16, i16* %deref21, align 2
  store i16 %load_pos, i16* %25, align 2
  %26 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 1
  %load_max_out = load i16, i16* %max_out, align 2
  store i16 %load_max_out, i16* %26, align 2
  br label %call

call:                                             ; preds = %input
  %call22 = call i16 @INC1(%INC1_interface* %INC1_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue20

continue20:                                       ; preds = %output
  store i16 %call22, i16* %deref19, align 2
  %deref23 = load i16*, i16** %pos, align 8
  %load_pos24 = load i16, i16* %deref23, align 2
  %27 = sext i16 %load_pos24 to i32
  %tmpVar25 = mul i32 1, %27
  %tmpVar26 = add i32 %tmpVar25, 0
  %tmpVar27 = getelementptr inbounds [32 x %ESR_DATA], [32 x %ESR_DATA]* %ESR_OUT, i32 0, i32 %tmpVar26
  %load_cnt28 = load i16, i16* %cnt, align 2
  %28 = sext i16 %load_cnt28 to i32
  %tmpVar29 = mul i32 1, %28
  %tmpVar30 = add i32 %tmpVar29, 0
  %tmpVar31 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_0, i32 0, i32 %tmpVar30
  %load_tmpVar = load %ESR_DATA, %ESR_DATA* %tmpVar31, align 4
  store %ESR_DATA %load_tmpVar, %ESR_DATA* %tmpVar27, align 4
  br label %continue12

condition_body33:                                 ; preds = %continue12
  %deref41 = load i16*, i16** %pos, align 8
  %INC1_instance42 = alloca %INC1_interface, align 8
  br label %input43

continue32:                                       ; preds = %continue46, %continue12
  %load_cnt63 = load i16, i16* %cnt, align 2
  %29 = sext i16 %load_cnt63 to i32
  %tmpVar64 = mul i32 1, %29
  %tmpVar65 = add i32 %tmpVar64, 0
  %tmpVar66 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_2, i32 0, i32 %tmpVar65
  %typ67 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar66, i32 0, i32 0
  %load_68 = load i8, i8* %typ67, align 1
  %30 = zext i8 %load_68 to i32
  %tmpVar69 = icmp sgt i32 %30, 0
  br i1 %tmpVar69, label %condition_body62, label %continue61

input43:                                          ; preds = %condition_body33
  %31 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance42, i32 0, i32 0
  %deref47 = load i16*, i16** %pos, align 8
  %load_pos48 = load i16, i16* %deref47, align 2
  store i16 %load_pos48, i16* %31, align 2
  %32 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance42, i32 0, i32 1
  %load_max_out49 = load i16, i16* %max_out, align 2
  store i16 %load_max_out49, i16* %32, align 2
  br label %call44

call44:                                           ; preds = %input43
  %call50 = call i16 @INC1(%INC1_interface* %INC1_instance42)
  br label %output45

output45:                                         ; preds = %call44
  br label %continue46

continue46:                                       ; preds = %output45
  store i16 %call50, i16* %deref41, align 2
  %deref51 = load i16*, i16** %pos, align 8
  %load_pos52 = load i16, i16* %deref51, align 2
  %33 = sext i16 %load_pos52 to i32
  %tmpVar53 = mul i32 1, %33
  %tmpVar54 = add i32 %tmpVar53, 0
  %tmpVar55 = getelementptr inbounds [32 x %ESR_DATA], [32 x %ESR_DATA]* %ESR_OUT, i32 0, i32 %tmpVar54
  %load_cnt56 = load i16, i16* %cnt, align 2
  %34 = sext i16 %load_cnt56 to i32
  %tmpVar57 = mul i32 1, %34
  %tmpVar58 = add i32 %tmpVar57, 0
  %tmpVar59 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_1, i32 0, i32 %tmpVar58
  %load_tmpVar60 = load %ESR_DATA, %ESR_DATA* %tmpVar59, align 4
  store %ESR_DATA %load_tmpVar60, %ESR_DATA* %tmpVar55, align 4
  br label %continue32

condition_body62:                                 ; preds = %continue32
  %deref70 = load i16*, i16** %pos, align 8
  %INC1_instance71 = alloca %INC1_interface, align 8
  br label %input72

continue61:                                       ; preds = %continue75, %continue32
  %load_cnt92 = load i16, i16* %cnt, align 2
  %35 = sext i16 %load_cnt92 to i32
  %tmpVar93 = mul i32 1, %35
  %tmpVar94 = add i32 %tmpVar93, 0
  %tmpVar95 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_3, i32 0, i32 %tmpVar94
  %typ96 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar95, i32 0, i32 0
  %load_97 = load i8, i8* %typ96, align 1
  %36 = zext i8 %load_97 to i32
  %tmpVar98 = icmp sgt i32 %36, 0
  br i1 %tmpVar98, label %condition_body91, label %continue90

input72:                                          ; preds = %condition_body62
  %37 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance71, i32 0, i32 0
  %deref76 = load i16*, i16** %pos, align 8
  %load_pos77 = load i16, i16* %deref76, align 2
  store i16 %load_pos77, i16* %37, align 2
  %38 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance71, i32 0, i32 1
  %load_max_out78 = load i16, i16* %max_out, align 2
  store i16 %load_max_out78, i16* %38, align 2
  br label %call73

call73:                                           ; preds = %input72
  %call79 = call i16 @INC1(%INC1_interface* %INC1_instance71)
  br label %output74

output74:                                         ; preds = %call73
  br label %continue75

continue75:                                       ; preds = %output74
  store i16 %call79, i16* %deref70, align 2
  %deref80 = load i16*, i16** %pos, align 8
  %load_pos81 = load i16, i16* %deref80, align 2
  %39 = sext i16 %load_pos81 to i32
  %tmpVar82 = mul i32 1, %39
  %tmpVar83 = add i32 %tmpVar82, 0
  %tmpVar84 = getelementptr inbounds [32 x %ESR_DATA], [32 x %ESR_DATA]* %ESR_OUT, i32 0, i32 %tmpVar83
  %load_cnt85 = load i16, i16* %cnt, align 2
  %40 = sext i16 %load_cnt85 to i32
  %tmpVar86 = mul i32 1, %40
  %tmpVar87 = add i32 %tmpVar86, 0
  %tmpVar88 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_2, i32 0, i32 %tmpVar87
  %load_tmpVar89 = load %ESR_DATA, %ESR_DATA* %tmpVar88, align 4
  store %ESR_DATA %load_tmpVar89, %ESR_DATA* %tmpVar84, align 4
  br label %continue61

condition_body91:                                 ; preds = %continue61
  %deref99 = load i16*, i16** %pos, align 8
  %INC1_instance100 = alloca %INC1_interface, align 8
  br label %input101

continue90:                                       ; preds = %continue104, %continue61
  %load_cnt121 = load i16, i16* %cnt, align 2
  %41 = sext i16 %load_cnt121 to i32
  %tmpVar122 = mul i32 1, %41
  %tmpVar123 = add i32 %tmpVar122, 0
  %tmpVar124 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_4, i32 0, i32 %tmpVar123
  %typ125 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar124, i32 0, i32 0
  %load_126 = load i8, i8* %typ125, align 1
  %42 = zext i8 %load_126 to i32
  %tmpVar127 = icmp sgt i32 %42, 0
  br i1 %tmpVar127, label %condition_body120, label %continue119

input101:                                         ; preds = %condition_body91
  %43 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance100, i32 0, i32 0
  %deref105 = load i16*, i16** %pos, align 8
  %load_pos106 = load i16, i16* %deref105, align 2
  store i16 %load_pos106, i16* %43, align 2
  %44 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance100, i32 0, i32 1
  %load_max_out107 = load i16, i16* %max_out, align 2
  store i16 %load_max_out107, i16* %44, align 2
  br label %call102

call102:                                          ; preds = %input101
  %call108 = call i16 @INC1(%INC1_interface* %INC1_instance100)
  br label %output103

output103:                                        ; preds = %call102
  br label %continue104

continue104:                                      ; preds = %output103
  store i16 %call108, i16* %deref99, align 2
  %deref109 = load i16*, i16** %pos, align 8
  %load_pos110 = load i16, i16* %deref109, align 2
  %45 = sext i16 %load_pos110 to i32
  %tmpVar111 = mul i32 1, %45
  %tmpVar112 = add i32 %tmpVar111, 0
  %tmpVar113 = getelementptr inbounds [32 x %ESR_DATA], [32 x %ESR_DATA]* %ESR_OUT, i32 0, i32 %tmpVar112
  %load_cnt114 = load i16, i16* %cnt, align 2
  %46 = sext i16 %load_cnt114 to i32
  %tmpVar115 = mul i32 1, %46
  %tmpVar116 = add i32 %tmpVar115, 0
  %tmpVar117 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_3, i32 0, i32 %tmpVar116
  %load_tmpVar118 = load %ESR_DATA, %ESR_DATA* %tmpVar117, align 4
  store %ESR_DATA %load_tmpVar118, %ESR_DATA* %tmpVar113, align 4
  br label %continue90

condition_body120:                                ; preds = %continue90
  %deref128 = load i16*, i16** %pos, align 8
  %INC1_instance129 = alloca %INC1_interface, align 8
  br label %input130

continue119:                                      ; preds = %continue133, %continue90
  %load_cnt150 = load i16, i16* %cnt, align 2
  %47 = sext i16 %load_cnt150 to i32
  %tmpVar151 = mul i32 1, %47
  %tmpVar152 = add i32 %tmpVar151, 0
  %tmpVar153 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_5, i32 0, i32 %tmpVar152
  %typ154 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar153, i32 0, i32 0
  %load_155 = load i8, i8* %typ154, align 1
  %48 = zext i8 %load_155 to i32
  %tmpVar156 = icmp sgt i32 %48, 0
  br i1 %tmpVar156, label %condition_body149, label %continue148

input130:                                         ; preds = %condition_body120
  %49 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance129, i32 0, i32 0
  %deref134 = load i16*, i16** %pos, align 8
  %load_pos135 = load i16, i16* %deref134, align 2
  store i16 %load_pos135, i16* %49, align 2
  %50 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance129, i32 0, i32 1
  %load_max_out136 = load i16, i16* %max_out, align 2
  store i16 %load_max_out136, i16* %50, align 2
  br label %call131

call131:                                          ; preds = %input130
  %call137 = call i16 @INC1(%INC1_interface* %INC1_instance129)
  br label %output132

output132:                                        ; preds = %call131
  br label %continue133

continue133:                                      ; preds = %output132
  store i16 %call137, i16* %deref128, align 2
  %deref138 = load i16*, i16** %pos, align 8
  %load_pos139 = load i16, i16* %deref138, align 2
  %51 = sext i16 %load_pos139 to i32
  %tmpVar140 = mul i32 1, %51
  %tmpVar141 = add i32 %tmpVar140, 0
  %tmpVar142 = getelementptr inbounds [32 x %ESR_DATA], [32 x %ESR_DATA]* %ESR_OUT, i32 0, i32 %tmpVar141
  %load_cnt143 = load i16, i16* %cnt, align 2
  %52 = sext i16 %load_cnt143 to i32
  %tmpVar144 = mul i32 1, %52
  %tmpVar145 = add i32 %tmpVar144, 0
  %tmpVar146 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_4, i32 0, i32 %tmpVar145
  %load_tmpVar147 = load %ESR_DATA, %ESR_DATA* %tmpVar146, align 4
  store %ESR_DATA %load_tmpVar147, %ESR_DATA* %tmpVar142, align 4
  br label %continue119

condition_body149:                                ; preds = %continue119
  %deref157 = load i16*, i16** %pos, align 8
  %INC1_instance158 = alloca %INC1_interface, align 8
  br label %input159

continue148:                                      ; preds = %continue162, %continue119
  %load_cnt179 = load i16, i16* %cnt, align 2
  %53 = sext i16 %load_cnt179 to i32
  %tmpVar180 = mul i32 1, %53
  %tmpVar181 = add i32 %tmpVar180, 0
  %tmpVar182 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_6, i32 0, i32 %tmpVar181
  %typ183 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar182, i32 0, i32 0
  %load_184 = load i8, i8* %typ183, align 1
  %54 = zext i8 %load_184 to i32
  %tmpVar185 = icmp sgt i32 %54, 0
  br i1 %tmpVar185, label %condition_body178, label %continue177

input159:                                         ; preds = %condition_body149
  %55 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance158, i32 0, i32 0
  %deref163 = load i16*, i16** %pos, align 8
  %load_pos164 = load i16, i16* %deref163, align 2
  store i16 %load_pos164, i16* %55, align 2
  %56 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance158, i32 0, i32 1
  %load_max_out165 = load i16, i16* %max_out, align 2
  store i16 %load_max_out165, i16* %56, align 2
  br label %call160

call160:                                          ; preds = %input159
  %call166 = call i16 @INC1(%INC1_interface* %INC1_instance158)
  br label %output161

output161:                                        ; preds = %call160
  br label %continue162

continue162:                                      ; preds = %output161
  store i16 %call166, i16* %deref157, align 2
  %deref167 = load i16*, i16** %pos, align 8
  %load_pos168 = load i16, i16* %deref167, align 2
  %57 = sext i16 %load_pos168 to i32
  %tmpVar169 = mul i32 1, %57
  %tmpVar170 = add i32 %tmpVar169, 0
  %tmpVar171 = getelementptr inbounds [32 x %ESR_DATA], [32 x %ESR_DATA]* %ESR_OUT, i32 0, i32 %tmpVar170
  %load_cnt172 = load i16, i16* %cnt, align 2
  %58 = sext i16 %load_cnt172 to i32
  %tmpVar173 = mul i32 1, %58
  %tmpVar174 = add i32 %tmpVar173, 0
  %tmpVar175 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_5, i32 0, i32 %tmpVar174
  %load_tmpVar176 = load %ESR_DATA, %ESR_DATA* %tmpVar175, align 4
  store %ESR_DATA %load_tmpVar176, %ESR_DATA* %tmpVar171, align 4
  br label %continue148

condition_body178:                                ; preds = %continue148
  %deref186 = load i16*, i16** %pos, align 8
  %INC1_instance187 = alloca %INC1_interface, align 8
  br label %input188

continue177:                                      ; preds = %continue191, %continue148
  %load_cnt208 = load i16, i16* %cnt, align 2
  %59 = sext i16 %load_cnt208 to i32
  %tmpVar209 = mul i32 1, %59
  %tmpVar210 = add i32 %tmpVar209, 0
  %tmpVar211 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_7, i32 0, i32 %tmpVar210
  %typ212 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar211, i32 0, i32 0
  %load_213 = load i8, i8* %typ212, align 1
  %60 = zext i8 %load_213 to i32
  %tmpVar214 = icmp sgt i32 %60, 0
  br i1 %tmpVar214, label %condition_body207, label %continue206

input188:                                         ; preds = %condition_body178
  %61 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance187, i32 0, i32 0
  %deref192 = load i16*, i16** %pos, align 8
  %load_pos193 = load i16, i16* %deref192, align 2
  store i16 %load_pos193, i16* %61, align 2
  %62 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance187, i32 0, i32 1
  %load_max_out194 = load i16, i16* %max_out, align 2
  store i16 %load_max_out194, i16* %62, align 2
  br label %call189

call189:                                          ; preds = %input188
  %call195 = call i16 @INC1(%INC1_interface* %INC1_instance187)
  br label %output190

output190:                                        ; preds = %call189
  br label %continue191

continue191:                                      ; preds = %output190
  store i16 %call195, i16* %deref186, align 2
  %deref196 = load i16*, i16** %pos, align 8
  %load_pos197 = load i16, i16* %deref196, align 2
  %63 = sext i16 %load_pos197 to i32
  %tmpVar198 = mul i32 1, %63
  %tmpVar199 = add i32 %tmpVar198, 0
  %tmpVar200 = getelementptr inbounds [32 x %ESR_DATA], [32 x %ESR_DATA]* %ESR_OUT, i32 0, i32 %tmpVar199
  %load_cnt201 = load i16, i16* %cnt, align 2
  %64 = sext i16 %load_cnt201 to i32
  %tmpVar202 = mul i32 1, %64
  %tmpVar203 = add i32 %tmpVar202, 0
  %tmpVar204 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_6, i32 0, i32 %tmpVar203
  %load_tmpVar205 = load %ESR_DATA, %ESR_DATA* %tmpVar204, align 4
  store %ESR_DATA %load_tmpVar205, %ESR_DATA* %tmpVar200, align 4
  br label %continue177

condition_body207:                                ; preds = %continue177
  %deref215 = load i16*, i16** %pos, align 8
  %INC1_instance216 = alloca %INC1_interface, align 8
  br label %input217

continue206:                                      ; preds = %continue220, %continue177
  br label %increment

input217:                                         ; preds = %condition_body207
  %65 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance216, i32 0, i32 0
  %deref221 = load i16*, i16** %pos, align 8
  %load_pos222 = load i16, i16* %deref221, align 2
  store i16 %load_pos222, i16* %65, align 2
  %66 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance216, i32 0, i32 1
  %load_max_out223 = load i16, i16* %max_out, align 2
  store i16 %load_max_out223, i16* %66, align 2
  br label %call218

call218:                                          ; preds = %input217
  %call224 = call i16 @INC1(%INC1_interface* %INC1_instance216)
  br label %output219

output219:                                        ; preds = %call218
  br label %continue220

continue220:                                      ; preds = %output219
  store i16 %call224, i16* %deref215, align 2
  %deref225 = load i16*, i16** %pos, align 8
  %load_pos226 = load i16, i16* %deref225, align 2
  %67 = sext i16 %load_pos226 to i32
  %tmpVar227 = mul i32 1, %67
  %tmpVar228 = add i32 %tmpVar227, 0
  %tmpVar229 = getelementptr inbounds [32 x %ESR_DATA], [32 x %ESR_DATA]* %ESR_OUT, i32 0, i32 %tmpVar228
  %load_cnt230 = load i16, i16* %cnt, align 2
  %68 = sext i16 %load_cnt230 to i32
  %tmpVar231 = mul i32 1, %68
  %tmpVar232 = add i32 %tmpVar231, 0
  %tmpVar233 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %ESR_7, i32 0, i32 %tmpVar232
  %load_tmpVar234 = load %ESR_DATA, %ESR_DATA* %tmpVar233, align 4
  store %ESR_DATA %load_tmpVar234, %ESR_DATA* %tmpVar229, align 4
  br label %continue206
}

define void @ESR_MON_B8(%ESR_MON_B8_interface* %0) {
entry:
  %s0 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 0
  %s1 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 1
  %s2 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 2
  %s3 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 3
  %s4 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 4
  %s5 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 5
  %s6 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 6
  %s7 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 7
  %DT_in = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 8
  %a0 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 9
  %a1 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 10
  %a2 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 11
  %a3 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 12
  %a4 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 13
  %a5 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 14
  %a6 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 15
  %a7 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 16
  %ESR_Flag = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 17
  %ESR_Out = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 18
  %x0 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 19
  %x1 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 20
  %x2 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 21
  %x3 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 22
  %x4 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 23
  %x5 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 24
  %x6 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 25
  %x7 = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 26
  %tx = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 27
  %cnt = getelementptr inbounds %ESR_MON_B8_interface, %ESR_MON_B8_interface* %0, i32 0, i32 28
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  store i8 0, i8* %ESR_Flag, align 1
  %deref = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref, i32 0, i32 3
  %typ = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar, i32 0, i32 0
  store i8 0, i8* %typ, align 1
  %deref7 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar8 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref7, i32 0, i32 2
  %typ9 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar8, i32 0, i32 0
  store i8 0, i8* %typ9, align 1
  %deref10 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar11 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref10, i32 0, i32 1
  %typ12 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar11, i32 0, i32 0
  store i8 0, i8* %typ12, align 1
  %deref13 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar14 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref13, i32 0, i32 0
  %typ15 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar14, i32 0, i32 0
  store i8 0, i8* %typ15, align 1
  store i16 0, i16* %cnt, align 2
  %load_s0 = load i8, i8* %s0, align 1
  %2 = zext i8 %load_s0 to i32
  %load_X0 = load i8, i8* %x0, align 1
  %3 = zext i8 %load_X0 to i32
  %tmpVar17 = icmp ne i32 %2, %3
  br i1 %tmpVar17, label %condition_body, label %continue16

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  %deref18 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt = load i16, i16* %cnt, align 2
  %4 = sext i16 %load_cnt to i32
  %tmpVar19 = mul i32 1, %4
  %tmpVar20 = add i32 %tmpVar19, 0
  %tmpVar21 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref18, i32 0, i32 %tmpVar20
  %typ22 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar21, i32 0, i32 0
  %BOOL_TO_BYTE_instance = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input23

continue16:                                       ; preds = %continue26, %continue
  %load_s1 = load i8, i8* %s1, align 1
  %5 = zext i8 %load_s1 to i32
  %load_X1 = load i8, i8* %x1, align 1
  %6 = zext i8 %load_X1 to i32
  %tmpVar49 = icmp ne i32 %5, %6
  br i1 %tmpVar49, label %condition_body48, label %continue47

input23:                                          ; preds = %condition_body
  %7 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance, i32 0, i32 0
  %load_s027 = load i8, i8* %s0, align 1
  store i8 %load_s027, i8* %7, align 1
  br label %call24

call24:                                           ; preds = %input23
  %call28 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %8 = zext i8 %call28 to i32
  %tmpVar29 = add i32 10, %8
  %9 = trunc i32 %tmpVar29 to i8
  store i8 %9, i8* %typ22, align 1
  %deref30 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt31 = load i16, i16* %cnt, align 2
  %10 = sext i16 %load_cnt31 to i32
  %tmpVar32 = mul i32 1, %10
  %tmpVar33 = add i32 %tmpVar32, 0
  %tmpVar34 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref30, i32 0, i32 %tmpVar33
  %adress = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar34, i32 0, i32 1
  %11 = bitcast [11 x i8]* %adress to i8*
  %12 = bitcast [11 x i8]* %a0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %11, i8* align 1 %12, i32 10, i1 false)
  %deref35 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt36 = load i16, i16* %cnt, align 2
  %13 = sext i16 %load_cnt36 to i32
  %tmpVar37 = mul i32 1, %13
  %tmpVar38 = add i32 %tmpVar37, 0
  %tmpVar39 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref35, i32 0, i32 %tmpVar38
  %DS = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar39, i32 0, i32 2
  %load_DT_in = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in, i64* %DS, align 4
  %deref40 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt41 = load i16, i16* %cnt, align 2
  %14 = sext i16 %load_cnt41 to i32
  %tmpVar42 = mul i32 1, %14
  %tmpVar43 = add i32 %tmpVar42, 0
  %tmpVar44 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref40, i32 0, i32 %tmpVar43
  %TS = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar44, i32 0, i32 3
  %load_TX = load i64, i64* %tx, align 4
  store i64 %load_TX, i64* %TS, align 4
  %load_S0 = load i8, i8* %s0, align 1
  store i8 %load_S0, i8* %x0, align 1
  %load_cnt45 = load i16, i16* %cnt, align 2
  %15 = sext i16 %load_cnt45 to i32
  %tmpVar46 = add i32 %15, 1
  %16 = trunc i32 %tmpVar46 to i16
  store i16 %16, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue16

condition_body48:                                 ; preds = %continue16
  %deref50 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt51 = load i16, i16* %cnt, align 2
  %17 = sext i16 %load_cnt51 to i32
  %tmpVar52 = mul i32 1, %17
  %tmpVar53 = add i32 %tmpVar52, 0
  %tmpVar54 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref50, i32 0, i32 %tmpVar53
  %typ55 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar54, i32 0, i32 0
  %BOOL_TO_BYTE_instance56 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input57

continue47:                                       ; preds = %continue60, %continue16
  %load_s2 = load i8, i8* %s2, align 1
  %18 = zext i8 %load_s2 to i32
  %load_X2 = load i8, i8* %x2, align 1
  %19 = zext i8 %load_X2 to i32
  %tmpVar88 = icmp ne i32 %18, %19
  br i1 %tmpVar88, label %condition_body87, label %continue86

input57:                                          ; preds = %condition_body48
  %20 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance56, i32 0, i32 0
  %load_s161 = load i8, i8* %s1, align 1
  store i8 %load_s161, i8* %20, align 1
  br label %call58

call58:                                           ; preds = %input57
  %call62 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance56)
  br label %output59

output59:                                         ; preds = %call58
  br label %continue60

continue60:                                       ; preds = %output59
  %21 = zext i8 %call62 to i32
  %tmpVar63 = add i32 10, %21
  %22 = trunc i32 %tmpVar63 to i8
  store i8 %22, i8* %typ55, align 1
  %deref64 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt65 = load i16, i16* %cnt, align 2
  %23 = sext i16 %load_cnt65 to i32
  %tmpVar66 = mul i32 1, %23
  %tmpVar67 = add i32 %tmpVar66, 0
  %tmpVar68 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref64, i32 0, i32 %tmpVar67
  %adress69 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar68, i32 0, i32 1
  %24 = bitcast [11 x i8]* %adress69 to i8*
  %25 = bitcast [11 x i8]* %a1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %24, i8* align 1 %25, i32 10, i1 false)
  %deref70 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt71 = load i16, i16* %cnt, align 2
  %26 = sext i16 %load_cnt71 to i32
  %tmpVar72 = mul i32 1, %26
  %tmpVar73 = add i32 %tmpVar72, 0
  %tmpVar74 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref70, i32 0, i32 %tmpVar73
  %DS75 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar74, i32 0, i32 2
  %load_DT_in76 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in76, i64* %DS75, align 4
  %deref77 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt78 = load i16, i16* %cnt, align 2
  %27 = sext i16 %load_cnt78 to i32
  %tmpVar79 = mul i32 1, %27
  %tmpVar80 = add i32 %tmpVar79, 0
  %tmpVar81 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref77, i32 0, i32 %tmpVar80
  %TS82 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar81, i32 0, i32 3
  %load_TX83 = load i64, i64* %tx, align 4
  store i64 %load_TX83, i64* %TS82, align 4
  %load_S1 = load i8, i8* %s1, align 1
  store i8 %load_S1, i8* %x1, align 1
  %load_cnt84 = load i16, i16* %cnt, align 2
  %28 = sext i16 %load_cnt84 to i32
  %tmpVar85 = add i32 %28, 1
  %29 = trunc i32 %tmpVar85 to i16
  store i16 %29, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue47

condition_body87:                                 ; preds = %continue47
  %deref89 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt90 = load i16, i16* %cnt, align 2
  %30 = sext i16 %load_cnt90 to i32
  %tmpVar91 = mul i32 1, %30
  %tmpVar92 = add i32 %tmpVar91, 0
  %tmpVar93 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref89, i32 0, i32 %tmpVar92
  %typ94 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar93, i32 0, i32 0
  %BOOL_TO_BYTE_instance95 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input96

continue86:                                       ; preds = %continue99, %continue47
  %load_s3 = load i8, i8* %s3, align 1
  %31 = zext i8 %load_s3 to i32
  %load_X3 = load i8, i8* %x3, align 1
  %32 = zext i8 %load_X3 to i32
  %tmpVar127 = icmp ne i32 %31, %32
  br i1 %tmpVar127, label %condition_body126, label %continue125

input96:                                          ; preds = %condition_body87
  %33 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance95, i32 0, i32 0
  %load_s2100 = load i8, i8* %s2, align 1
  store i8 %load_s2100, i8* %33, align 1
  br label %call97

call97:                                           ; preds = %input96
  %call101 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance95)
  br label %output98

output98:                                         ; preds = %call97
  br label %continue99

continue99:                                       ; preds = %output98
  %34 = zext i8 %call101 to i32
  %tmpVar102 = add i32 10, %34
  %35 = trunc i32 %tmpVar102 to i8
  store i8 %35, i8* %typ94, align 1
  %deref103 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt104 = load i16, i16* %cnt, align 2
  %36 = sext i16 %load_cnt104 to i32
  %tmpVar105 = mul i32 1, %36
  %tmpVar106 = add i32 %tmpVar105, 0
  %tmpVar107 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref103, i32 0, i32 %tmpVar106
  %adress108 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar107, i32 0, i32 1
  %37 = bitcast [11 x i8]* %adress108 to i8*
  %38 = bitcast [11 x i8]* %a2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %37, i8* align 1 %38, i32 10, i1 false)
  %deref109 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt110 = load i16, i16* %cnt, align 2
  %39 = sext i16 %load_cnt110 to i32
  %tmpVar111 = mul i32 1, %39
  %tmpVar112 = add i32 %tmpVar111, 0
  %tmpVar113 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref109, i32 0, i32 %tmpVar112
  %DS114 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar113, i32 0, i32 2
  %load_DT_in115 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in115, i64* %DS114, align 4
  %deref116 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt117 = load i16, i16* %cnt, align 2
  %40 = sext i16 %load_cnt117 to i32
  %tmpVar118 = mul i32 1, %40
  %tmpVar119 = add i32 %tmpVar118, 0
  %tmpVar120 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref116, i32 0, i32 %tmpVar119
  %TS121 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar120, i32 0, i32 3
  %load_TX122 = load i64, i64* %tx, align 4
  store i64 %load_TX122, i64* %TS121, align 4
  %load_S2 = load i8, i8* %s2, align 1
  store i8 %load_S2, i8* %x2, align 1
  %load_cnt123 = load i16, i16* %cnt, align 2
  %41 = sext i16 %load_cnt123 to i32
  %tmpVar124 = add i32 %41, 1
  %42 = trunc i32 %tmpVar124 to i16
  store i16 %42, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue86

condition_body126:                                ; preds = %continue86
  %deref128 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt129 = load i16, i16* %cnt, align 2
  %43 = sext i16 %load_cnt129 to i32
  %tmpVar130 = mul i32 1, %43
  %tmpVar131 = add i32 %tmpVar130, 0
  %tmpVar132 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref128, i32 0, i32 %tmpVar131
  %typ133 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar132, i32 0, i32 0
  %BOOL_TO_BYTE_instance134 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input135

continue125:                                      ; preds = %continue138, %continue86
  %load_s4 = load i8, i8* %s4, align 1
  %44 = zext i8 %load_s4 to i32
  %load_X4 = load i8, i8* %x4, align 1
  %45 = zext i8 %load_X4 to i32
  %tmpVar166 = icmp ne i32 %44, %45
  %46 = zext i1 %tmpVar166 to i32
  %47 = icmp ne i32 %46, 0
  br i1 %47, label %63, label %66

input135:                                         ; preds = %condition_body126
  %48 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance134, i32 0, i32 0
  %load_s3139 = load i8, i8* %s3, align 1
  store i8 %load_s3139, i8* %48, align 1
  br label %call136

call136:                                          ; preds = %input135
  %call140 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance134)
  br label %output137

output137:                                        ; preds = %call136
  br label %continue138

continue138:                                      ; preds = %output137
  %49 = zext i8 %call140 to i32
  %tmpVar141 = add i32 10, %49
  %50 = trunc i32 %tmpVar141 to i8
  store i8 %50, i8* %typ133, align 1
  %deref142 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt143 = load i16, i16* %cnt, align 2
  %51 = sext i16 %load_cnt143 to i32
  %tmpVar144 = mul i32 1, %51
  %tmpVar145 = add i32 %tmpVar144, 0
  %tmpVar146 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref142, i32 0, i32 %tmpVar145
  %adress147 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar146, i32 0, i32 1
  %52 = bitcast [11 x i8]* %adress147 to i8*
  %53 = bitcast [11 x i8]* %a3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %52, i8* align 1 %53, i32 10, i1 false)
  %deref148 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt149 = load i16, i16* %cnt, align 2
  %54 = sext i16 %load_cnt149 to i32
  %tmpVar150 = mul i32 1, %54
  %tmpVar151 = add i32 %tmpVar150, 0
  %tmpVar152 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref148, i32 0, i32 %tmpVar151
  %DS153 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar152, i32 0, i32 2
  %load_DT_in154 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in154, i64* %DS153, align 4
  %deref155 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt156 = load i16, i16* %cnt, align 2
  %55 = sext i16 %load_cnt156 to i32
  %tmpVar157 = mul i32 1, %55
  %tmpVar158 = add i32 %tmpVar157, 0
  %tmpVar159 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref155, i32 0, i32 %tmpVar158
  %TS160 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar159, i32 0, i32 3
  %load_TX161 = load i64, i64* %tx, align 4
  store i64 %load_TX161, i64* %TS160, align 4
  %load_S3 = load i8, i8* %s3, align 1
  store i8 %load_S3, i8* %x3, align 1
  %load_cnt162 = load i16, i16* %cnt, align 2
  %56 = sext i16 %load_cnt162 to i32
  %tmpVar163 = add i32 %56, 1
  %57 = trunc i32 %tmpVar163 to i16
  store i16 %57, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue125

condition_body165:                                ; preds = %66
  %deref169 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt170 = load i16, i16* %cnt, align 2
  %58 = sext i16 %load_cnt170 to i32
  %tmpVar171 = mul i32 1, %58
  %tmpVar172 = add i32 %tmpVar171, 0
  %tmpVar173 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref169, i32 0, i32 %tmpVar172
  %typ174 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar173, i32 0, i32 0
  %BOOL_TO_BYTE_instance175 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input176

continue164:                                      ; preds = %continue179, %66
  %load_s5 = load i8, i8* %s5, align 1
  %59 = zext i8 %load_s5 to i32
  %load_X5 = load i8, i8* %x5, align 1
  %60 = zext i8 %load_X5 to i32
  %tmpVar207 = icmp ne i32 %59, %60
  %61 = zext i1 %tmpVar207 to i32
  %62 = icmp ne i32 %61, 0
  br i1 %62, label %84, label %87

63:                                               ; preds = %continue125
  %load_cnt167 = load i16, i16* %cnt, align 2
  %64 = sext i16 %load_cnt167 to i32
  %tmpVar168 = icmp slt i32 %64, 4
  %65 = zext i1 %tmpVar168 to i32
  br label %66

66:                                               ; preds = %63, %continue125
  %67 = phi i32 [ %46, %continue125 ], [ %65, %63 ]
  %68 = icmp ne i32 %67, 0
  br i1 %68, label %condition_body165, label %continue164

input176:                                         ; preds = %condition_body165
  %69 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance175, i32 0, i32 0
  %load_s4180 = load i8, i8* %s4, align 1
  store i8 %load_s4180, i8* %69, align 1
  br label %call177

call177:                                          ; preds = %input176
  %call181 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance175)
  br label %output178

output178:                                        ; preds = %call177
  br label %continue179

continue179:                                      ; preds = %output178
  %70 = zext i8 %call181 to i32
  %tmpVar182 = add i32 10, %70
  %71 = trunc i32 %tmpVar182 to i8
  store i8 %71, i8* %typ174, align 1
  %deref183 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt184 = load i16, i16* %cnt, align 2
  %72 = sext i16 %load_cnt184 to i32
  %tmpVar185 = mul i32 1, %72
  %tmpVar186 = add i32 %tmpVar185, 0
  %tmpVar187 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref183, i32 0, i32 %tmpVar186
  %adress188 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar187, i32 0, i32 1
  %73 = bitcast [11 x i8]* %adress188 to i8*
  %74 = bitcast [11 x i8]* %a4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %73, i8* align 1 %74, i32 10, i1 false)
  %deref189 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt190 = load i16, i16* %cnt, align 2
  %75 = sext i16 %load_cnt190 to i32
  %tmpVar191 = mul i32 1, %75
  %tmpVar192 = add i32 %tmpVar191, 0
  %tmpVar193 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref189, i32 0, i32 %tmpVar192
  %DS194 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar193, i32 0, i32 2
  %load_DT_in195 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in195, i64* %DS194, align 4
  %deref196 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt197 = load i16, i16* %cnt, align 2
  %76 = sext i16 %load_cnt197 to i32
  %tmpVar198 = mul i32 1, %76
  %tmpVar199 = add i32 %tmpVar198, 0
  %tmpVar200 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref196, i32 0, i32 %tmpVar199
  %TS201 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar200, i32 0, i32 3
  %load_TX202 = load i64, i64* %tx, align 4
  store i64 %load_TX202, i64* %TS201, align 4
  %load_S4 = load i8, i8* %s4, align 1
  store i8 %load_S4, i8* %x4, align 1
  %load_cnt203 = load i16, i16* %cnt, align 2
  %77 = sext i16 %load_cnt203 to i32
  %tmpVar204 = add i32 %77, 1
  %78 = trunc i32 %tmpVar204 to i16
  store i16 %78, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue164

condition_body206:                                ; preds = %87
  %deref210 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt211 = load i16, i16* %cnt, align 2
  %79 = sext i16 %load_cnt211 to i32
  %tmpVar212 = mul i32 1, %79
  %tmpVar213 = add i32 %tmpVar212, 0
  %tmpVar214 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref210, i32 0, i32 %tmpVar213
  %typ215 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar214, i32 0, i32 0
  %BOOL_TO_BYTE_instance216 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input217

continue205:                                      ; preds = %continue220, %87
  %load_s6 = load i8, i8* %s6, align 1
  %80 = zext i8 %load_s6 to i32
  %load_X6 = load i8, i8* %x6, align 1
  %81 = zext i8 %load_X6 to i32
  %tmpVar248 = icmp ne i32 %80, %81
  %82 = zext i1 %tmpVar248 to i32
  %83 = icmp ne i32 %82, 0
  br i1 %83, label %105, label %108

84:                                               ; preds = %continue164
  %load_cnt208 = load i16, i16* %cnt, align 2
  %85 = sext i16 %load_cnt208 to i32
  %tmpVar209 = icmp slt i32 %85, 4
  %86 = zext i1 %tmpVar209 to i32
  br label %87

87:                                               ; preds = %84, %continue164
  %88 = phi i32 [ %61, %continue164 ], [ %86, %84 ]
  %89 = icmp ne i32 %88, 0
  br i1 %89, label %condition_body206, label %continue205

input217:                                         ; preds = %condition_body206
  %90 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance216, i32 0, i32 0
  %load_s5221 = load i8, i8* %s5, align 1
  store i8 %load_s5221, i8* %90, align 1
  br label %call218

call218:                                          ; preds = %input217
  %call222 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance216)
  br label %output219

output219:                                        ; preds = %call218
  br label %continue220

continue220:                                      ; preds = %output219
  %91 = zext i8 %call222 to i32
  %tmpVar223 = add i32 10, %91
  %92 = trunc i32 %tmpVar223 to i8
  store i8 %92, i8* %typ215, align 1
  %deref224 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt225 = load i16, i16* %cnt, align 2
  %93 = sext i16 %load_cnt225 to i32
  %tmpVar226 = mul i32 1, %93
  %tmpVar227 = add i32 %tmpVar226, 0
  %tmpVar228 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref224, i32 0, i32 %tmpVar227
  %adress229 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar228, i32 0, i32 1
  %94 = bitcast [11 x i8]* %adress229 to i8*
  %95 = bitcast [11 x i8]* %a5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %94, i8* align 1 %95, i32 10, i1 false)
  %deref230 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt231 = load i16, i16* %cnt, align 2
  %96 = sext i16 %load_cnt231 to i32
  %tmpVar232 = mul i32 1, %96
  %tmpVar233 = add i32 %tmpVar232, 0
  %tmpVar234 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref230, i32 0, i32 %tmpVar233
  %DS235 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar234, i32 0, i32 2
  %load_DT_in236 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in236, i64* %DS235, align 4
  %deref237 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt238 = load i16, i16* %cnt, align 2
  %97 = sext i16 %load_cnt238 to i32
  %tmpVar239 = mul i32 1, %97
  %tmpVar240 = add i32 %tmpVar239, 0
  %tmpVar241 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref237, i32 0, i32 %tmpVar240
  %TS242 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar241, i32 0, i32 3
  %load_TX243 = load i64, i64* %tx, align 4
  store i64 %load_TX243, i64* %TS242, align 4
  %load_S5 = load i8, i8* %s5, align 1
  store i8 %load_S5, i8* %x5, align 1
  %load_cnt244 = load i16, i16* %cnt, align 2
  %98 = sext i16 %load_cnt244 to i32
  %tmpVar245 = add i32 %98, 1
  %99 = trunc i32 %tmpVar245 to i16
  store i16 %99, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue205

condition_body247:                                ; preds = %108
  %deref251 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt252 = load i16, i16* %cnt, align 2
  %100 = sext i16 %load_cnt252 to i32
  %tmpVar253 = mul i32 1, %100
  %tmpVar254 = add i32 %tmpVar253, 0
  %tmpVar255 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref251, i32 0, i32 %tmpVar254
  %typ256 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar255, i32 0, i32 0
  %BOOL_TO_BYTE_instance257 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input258

continue246:                                      ; preds = %continue261, %108
  %load_s7 = load i8, i8* %s7, align 1
  %101 = zext i8 %load_s7 to i32
  %load_X7 = load i8, i8* %x7, align 1
  %102 = zext i8 %load_X7 to i32
  %tmpVar289 = icmp ne i32 %101, %102
  %103 = zext i1 %tmpVar289 to i32
  %104 = icmp ne i32 %103, 0
  br i1 %104, label %122, label %125

105:                                              ; preds = %continue205
  %load_cnt249 = load i16, i16* %cnt, align 2
  %106 = sext i16 %load_cnt249 to i32
  %tmpVar250 = icmp slt i32 %106, 4
  %107 = zext i1 %tmpVar250 to i32
  br label %108

108:                                              ; preds = %105, %continue205
  %109 = phi i32 [ %82, %continue205 ], [ %107, %105 ]
  %110 = icmp ne i32 %109, 0
  br i1 %110, label %condition_body247, label %continue246

input258:                                         ; preds = %condition_body247
  %111 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance257, i32 0, i32 0
  %load_s6262 = load i8, i8* %s6, align 1
  store i8 %load_s6262, i8* %111, align 1
  br label %call259

call259:                                          ; preds = %input258
  %call263 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance257)
  br label %output260

output260:                                        ; preds = %call259
  br label %continue261

continue261:                                      ; preds = %output260
  %112 = zext i8 %call263 to i32
  %tmpVar264 = add i32 10, %112
  %113 = trunc i32 %tmpVar264 to i8
  store i8 %113, i8* %typ256, align 1
  %deref265 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt266 = load i16, i16* %cnt, align 2
  %114 = sext i16 %load_cnt266 to i32
  %tmpVar267 = mul i32 1, %114
  %tmpVar268 = add i32 %tmpVar267, 0
  %tmpVar269 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref265, i32 0, i32 %tmpVar268
  %adress270 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar269, i32 0, i32 1
  %115 = bitcast [11 x i8]* %adress270 to i8*
  %116 = bitcast [11 x i8]* %a6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %115, i8* align 1 %116, i32 10, i1 false)
  %deref271 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt272 = load i16, i16* %cnt, align 2
  %117 = sext i16 %load_cnt272 to i32
  %tmpVar273 = mul i32 1, %117
  %tmpVar274 = add i32 %tmpVar273, 0
  %tmpVar275 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref271, i32 0, i32 %tmpVar274
  %DS276 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar275, i32 0, i32 2
  %load_DT_in277 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in277, i64* %DS276, align 4
  %deref278 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt279 = load i16, i16* %cnt, align 2
  %118 = sext i16 %load_cnt279 to i32
  %tmpVar280 = mul i32 1, %118
  %tmpVar281 = add i32 %tmpVar280, 0
  %tmpVar282 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref278, i32 0, i32 %tmpVar281
  %TS283 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar282, i32 0, i32 3
  %load_TX284 = load i64, i64* %tx, align 4
  store i64 %load_TX284, i64* %TS283, align 4
  %load_S6 = load i8, i8* %s6, align 1
  store i8 %load_S6, i8* %x6, align 1
  %load_cnt285 = load i16, i16* %cnt, align 2
  %119 = sext i16 %load_cnt285 to i32
  %tmpVar286 = add i32 %119, 1
  %120 = trunc i32 %tmpVar286 to i16
  store i16 %120, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue246

condition_body288:                                ; preds = %125
  %deref292 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt293 = load i16, i16* %cnt, align 2
  %121 = sext i16 %load_cnt293 to i32
  %tmpVar294 = mul i32 1, %121
  %tmpVar295 = add i32 %tmpVar294, 0
  %tmpVar296 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref292, i32 0, i32 %tmpVar295
  %typ297 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar296, i32 0, i32 0
  %BOOL_TO_BYTE_instance298 = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input299

continue287:                                      ; preds = %continue302, %125
  ret void

122:                                              ; preds = %continue246
  %load_cnt290 = load i16, i16* %cnt, align 2
  %123 = sext i16 %load_cnt290 to i32
  %tmpVar291 = icmp slt i32 %123, 4
  %124 = zext i1 %tmpVar291 to i32
  br label %125

125:                                              ; preds = %122, %continue246
  %126 = phi i32 [ %103, %continue246 ], [ %124, %122 ]
  %127 = icmp ne i32 %126, 0
  br i1 %127, label %condition_body288, label %continue287

input299:                                         ; preds = %condition_body288
  %128 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance298, i32 0, i32 0
  %load_s7303 = load i8, i8* %s7, align 1
  store i8 %load_s7303, i8* %128, align 1
  br label %call300

call300:                                          ; preds = %input299
  %call304 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance298)
  br label %output301

output301:                                        ; preds = %call300
  br label %continue302

continue302:                                      ; preds = %output301
  %129 = zext i8 %call304 to i32
  %tmpVar305 = add i32 10, %129
  %130 = trunc i32 %tmpVar305 to i8
  store i8 %130, i8* %typ297, align 1
  %deref306 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt307 = load i16, i16* %cnt, align 2
  %131 = sext i16 %load_cnt307 to i32
  %tmpVar308 = mul i32 1, %131
  %tmpVar309 = add i32 %tmpVar308, 0
  %tmpVar310 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref306, i32 0, i32 %tmpVar309
  %adress311 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar310, i32 0, i32 1
  %132 = bitcast [11 x i8]* %adress311 to i8*
  %133 = bitcast [11 x i8]* %a7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %132, i8* align 1 %133, i32 10, i1 false)
  %deref312 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt313 = load i16, i16* %cnt, align 2
  %134 = sext i16 %load_cnt313 to i32
  %tmpVar314 = mul i32 1, %134
  %tmpVar315 = add i32 %tmpVar314, 0
  %tmpVar316 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref312, i32 0, i32 %tmpVar315
  %DS317 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar316, i32 0, i32 2
  %load_DT_in318 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in318, i64* %DS317, align 4
  %deref319 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt320 = load i16, i16* %cnt, align 2
  %135 = sext i16 %load_cnt320 to i32
  %tmpVar321 = mul i32 1, %135
  %tmpVar322 = add i32 %tmpVar321, 0
  %tmpVar323 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref319, i32 0, i32 %tmpVar322
  %TS324 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar323, i32 0, i32 3
  %load_TX325 = load i64, i64* %tx, align 4
  store i64 %load_TX325, i64* %TS324, align 4
  %load_S7 = load i8, i8* %s7, align 1
  store i8 %load_S7, i8* %x7, align 1
  %load_cnt326 = load i16, i16* %cnt, align 2
  %136 = sext i16 %load_cnt326 to i32
  %tmpVar327 = add i32 %136, 1
  %137 = trunc i32 %tmpVar327 to i16
  store i16 %137, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue287
}

define void @ESR_MON_R4(%ESR_MON_R4_interface* %0) {
entry:
  %R0 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 0
  %R1 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 1
  %R2 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 2
  %R3 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 3
  %DT_in = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 4
  %a0 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 5
  %a1 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 6
  %a2 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 7
  %a3 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 8
  %s0 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 9
  %s1 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 10
  %s2 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 11
  %s3 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 12
  %ESR_Flag = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 13
  %ESR_Out = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 14
  %p0 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 15
  %p1 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 16
  %p2 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 17
  %p3 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 18
  %x0 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 19
  %x1 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 20
  %x2 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 21
  %x3 = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 22
  %tx = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 23
  %cnt = getelementptr inbounds %ESR_MON_R4_interface, %ESR_MON_R4_interface* %0, i32 0, i32 24
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  store float* %R0, i32** %p0, align 8
  store float* %R1, i32** %p1, align 8
  store float* %R2, i32** %p2, align 8
  store float* %R3, i32** %p3, align 8
  store i8 0, i8* %ESR_Flag, align 1
  %deref = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref, i32 0, i32 3
  %typ = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar, i32 0, i32 0
  store i8 0, i8* %typ, align 1
  %deref7 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar8 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref7, i32 0, i32 2
  %typ9 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar8, i32 0, i32 0
  store i8 0, i8* %typ9, align 1
  %deref10 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar11 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref10, i32 0, i32 1
  %typ12 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar11, i32 0, i32 0
  store i8 0, i8* %typ12, align 1
  %deref13 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar14 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref13, i32 0, i32 0
  %typ15 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar14, i32 0, i32 0
  store i8 0, i8* %typ15, align 1
  store i16 0, i16* %cnt, align 2
  %DIFFER_instance = alloca %DIFFER_interface, align 8
  br label %input17

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue20
  %deref22 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt = load i16, i16* %cnt, align 2
  %2 = sext i16 %load_cnt to i32
  %tmpVar23 = mul i32 1, %2
  %tmpVar24 = add i32 %tmpVar23, 0
  %tmpVar25 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref22, i32 0, i32 %tmpVar24
  %typ26 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar25, i32 0, i32 0
  store i8 20, i8* %typ26, align 1
  %deref27 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt28 = load i16, i16* %cnt, align 2
  %3 = sext i16 %load_cnt28 to i32
  %tmpVar29 = mul i32 1, %3
  %tmpVar30 = add i32 %tmpVar29, 0
  %tmpVar31 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref27, i32 0, i32 %tmpVar30
  %adress = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar31, i32 0, i32 1
  %4 = bitcast [11 x i8]* %adress to i8*
  %5 = bitcast [11 x i8]* %a0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %4, i8* align 1 %5, i32 10, i1 false)
  %deref32 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt33 = load i16, i16* %cnt, align 2
  %6 = sext i16 %load_cnt33 to i32
  %tmpVar34 = mul i32 1, %6
  %tmpVar35 = add i32 %tmpVar34, 0
  %tmpVar36 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref32, i32 0, i32 %tmpVar35
  %DS = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar36, i32 0, i32 2
  %load_DT_in = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in, i64* %DS, align 4
  %deref37 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt38 = load i16, i16* %cnt, align 2
  %7 = sext i16 %load_cnt38 to i32
  %tmpVar39 = mul i32 1, %7
  %tmpVar40 = add i32 %tmpVar39, 0
  %tmpVar41 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref37, i32 0, i32 %tmpVar40
  %TS = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar41, i32 0, i32 3
  %load_TX = load i64, i64* %tx, align 4
  store i64 %load_TX, i64* %TS, align 4
  %deref42 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt43 = load i16, i16* %cnt, align 2
  %8 = sext i16 %load_cnt43 to i32
  %tmpVar44 = mul i32 1, %8
  %tmpVar45 = add i32 %tmpVar44, 0
  %tmpVar46 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref42, i32 0, i32 %tmpVar45
  %data = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar46, i32 0, i32 4
  %tmpVar47 = getelementptr inbounds [8 x i8], [8 x i8]* %data, i32 0, i32 0
  %BYTE_OF_DWORD_instance = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input48

continue16:                                       ; preds = %continue95, %continue20
  %DIFFER_instance104 = alloca %DIFFER_interface, align 8
  br label %input105

input17:                                          ; preds = %continue
  %9 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance, i32 0, i32 0
  %load_R0 = load float, float* %R0, align 4
  store float %load_R0, float* %9, align 4
  %10 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance, i32 0, i32 1
  %load_X0 = load float, float* %x0, align 4
  store float %load_X0, float* %10, align 4
  %11 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance, i32 0, i32 2
  %load_S0 = load float, float* %s0, align 4
  store float %load_S0, float* %11, align 4
  br label %call18

call18:                                           ; preds = %input17
  %call21 = call i8 @DIFFER(%DIFFER_interface* %DIFFER_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %12 = icmp ne i8 %call21, 0
  br i1 %12, label %condition_body, label %continue16

input48:                                          ; preds = %condition_body
  %13 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance, i32 0, i32 0
  %deref52 = load i32*, i32** %p0, align 8
  %load_tmpVar = load i32, i32* %deref52, align 4
  store i32 %load_tmpVar, i32* %13, align 4
  %14 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance, i32 0, i32 1
  store i8 0, i8* %14, align 1
  br label %call49

call49:                                           ; preds = %input48
  %call53 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance)
  br label %output50

output50:                                         ; preds = %call49
  br label %continue51

continue51:                                       ; preds = %output50
  store i8 %call53, i8* %tmpVar47, align 1
  %deref54 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt55 = load i16, i16* %cnt, align 2
  %15 = sext i16 %load_cnt55 to i32
  %tmpVar56 = mul i32 1, %15
  %tmpVar57 = add i32 %tmpVar56, 0
  %tmpVar58 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref54, i32 0, i32 %tmpVar57
  %data59 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar58, i32 0, i32 4
  %tmpVar60 = getelementptr inbounds [8 x i8], [8 x i8]* %data59, i32 0, i32 1
  %BYTE_OF_DWORD_instance61 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input62

input62:                                          ; preds = %continue51
  %16 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance61, i32 0, i32 0
  %deref66 = load i32*, i32** %p0, align 8
  %load_tmpVar67 = load i32, i32* %deref66, align 4
  store i32 %load_tmpVar67, i32* %16, align 4
  %17 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance61, i32 0, i32 1
  store i8 1, i8* %17, align 1
  br label %call63

call63:                                           ; preds = %input62
  %call68 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance61)
  br label %output64

output64:                                         ; preds = %call63
  br label %continue65

continue65:                                       ; preds = %output64
  store i8 %call68, i8* %tmpVar60, align 1
  %deref69 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt70 = load i16, i16* %cnt, align 2
  %18 = sext i16 %load_cnt70 to i32
  %tmpVar71 = mul i32 1, %18
  %tmpVar72 = add i32 %tmpVar71, 0
  %tmpVar73 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref69, i32 0, i32 %tmpVar72
  %data74 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar73, i32 0, i32 4
  %tmpVar75 = getelementptr inbounds [8 x i8], [8 x i8]* %data74, i32 0, i32 2
  %BYTE_OF_DWORD_instance76 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input77

input77:                                          ; preds = %continue65
  %19 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance76, i32 0, i32 0
  %deref81 = load i32*, i32** %p0, align 8
  %load_tmpVar82 = load i32, i32* %deref81, align 4
  store i32 %load_tmpVar82, i32* %19, align 4
  %20 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance76, i32 0, i32 1
  store i8 2, i8* %20, align 1
  br label %call78

call78:                                           ; preds = %input77
  %call83 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance76)
  br label %output79

output79:                                         ; preds = %call78
  br label %continue80

continue80:                                       ; preds = %output79
  store i8 %call83, i8* %tmpVar75, align 1
  %deref84 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt85 = load i16, i16* %cnt, align 2
  %21 = sext i16 %load_cnt85 to i32
  %tmpVar86 = mul i32 1, %21
  %tmpVar87 = add i32 %tmpVar86, 0
  %tmpVar88 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref84, i32 0, i32 %tmpVar87
  %data89 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar88, i32 0, i32 4
  %tmpVar90 = getelementptr inbounds [8 x i8], [8 x i8]* %data89, i32 0, i32 3
  %BYTE_OF_DWORD_instance91 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input92

input92:                                          ; preds = %continue80
  %22 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance91, i32 0, i32 0
  %deref96 = load i32*, i32** %p0, align 8
  %load_tmpVar97 = load i32, i32* %deref96, align 4
  store i32 %load_tmpVar97, i32* %22, align 4
  %23 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance91, i32 0, i32 1
  store i8 3, i8* %23, align 1
  br label %call93

call93:                                           ; preds = %input92
  %call98 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance91)
  br label %output94

output94:                                         ; preds = %call93
  br label %continue95

continue95:                                       ; preds = %output94
  store i8 %call98, i8* %tmpVar90, align 1
  %load_R099 = load float, float* %R0, align 4
  store float %load_R099, float* %x0, align 4
  %load_cnt100 = load i16, i16* %cnt, align 2
  %24 = sext i16 %load_cnt100 to i32
  %tmpVar101 = add i32 %24, 1
  %25 = trunc i32 %tmpVar101 to i16
  store i16 %25, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue16

condition_body103:                                ; preds = %continue108
  %deref110 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt111 = load i16, i16* %cnt, align 2
  %26 = sext i16 %load_cnt111 to i32
  %tmpVar112 = mul i32 1, %26
  %tmpVar113 = add i32 %tmpVar112, 0
  %tmpVar114 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref110, i32 0, i32 %tmpVar113
  %typ115 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar114, i32 0, i32 0
  store i8 20, i8* %typ115, align 1
  %deref116 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt117 = load i16, i16* %cnt, align 2
  %27 = sext i16 %load_cnt117 to i32
  %tmpVar118 = mul i32 1, %27
  %tmpVar119 = add i32 %tmpVar118, 0
  %tmpVar120 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref116, i32 0, i32 %tmpVar119
  %adress121 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar120, i32 0, i32 1
  %28 = bitcast [11 x i8]* %adress121 to i8*
  %29 = bitcast [11 x i8]* %a1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %28, i8* align 1 %29, i32 10, i1 false)
  %deref122 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt123 = load i16, i16* %cnt, align 2
  %30 = sext i16 %load_cnt123 to i32
  %tmpVar124 = mul i32 1, %30
  %tmpVar125 = add i32 %tmpVar124, 0
  %tmpVar126 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref122, i32 0, i32 %tmpVar125
  %DS127 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar126, i32 0, i32 2
  %load_DT_in128 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in128, i64* %DS127, align 4
  %deref129 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt130 = load i16, i16* %cnt, align 2
  %31 = sext i16 %load_cnt130 to i32
  %tmpVar131 = mul i32 1, %31
  %tmpVar132 = add i32 %tmpVar131, 0
  %tmpVar133 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref129, i32 0, i32 %tmpVar132
  %TS134 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar133, i32 0, i32 3
  %load_TX135 = load i64, i64* %tx, align 4
  store i64 %load_TX135, i64* %TS134, align 4
  %deref136 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt137 = load i16, i16* %cnt, align 2
  %32 = sext i16 %load_cnt137 to i32
  %tmpVar138 = mul i32 1, %32
  %tmpVar139 = add i32 %tmpVar138, 0
  %tmpVar140 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref136, i32 0, i32 %tmpVar139
  %data141 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar140, i32 0, i32 4
  %tmpVar142 = getelementptr inbounds [8 x i8], [8 x i8]* %data141, i32 0, i32 0
  %BYTE_OF_DWORD_instance143 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input144

continue102:                                      ; preds = %continue192, %continue108
  %DIFFER_instance201 = alloca %DIFFER_interface, align 8
  br label %input202

input105:                                         ; preds = %continue16
  %33 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance104, i32 0, i32 0
  %load_R1 = load float, float* %R1, align 4
  store float %load_R1, float* %33, align 4
  %34 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance104, i32 0, i32 1
  %load_X1 = load float, float* %x1, align 4
  store float %load_X1, float* %34, align 4
  %35 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance104, i32 0, i32 2
  %load_S1 = load float, float* %s1, align 4
  store float %load_S1, float* %35, align 4
  br label %call106

call106:                                          ; preds = %input105
  %call109 = call i8 @DIFFER(%DIFFER_interface* %DIFFER_instance104)
  br label %output107

output107:                                        ; preds = %call106
  br label %continue108

continue108:                                      ; preds = %output107
  %36 = icmp ne i8 %call109, 0
  br i1 %36, label %condition_body103, label %continue102

input144:                                         ; preds = %condition_body103
  %37 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance143, i32 0, i32 0
  %deref148 = load i32*, i32** %p1, align 8
  %load_tmpVar149 = load i32, i32* %deref148, align 4
  store i32 %load_tmpVar149, i32* %37, align 4
  %38 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance143, i32 0, i32 1
  store i8 0, i8* %38, align 1
  br label %call145

call145:                                          ; preds = %input144
  %call150 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance143)
  br label %output146

output146:                                        ; preds = %call145
  br label %continue147

continue147:                                      ; preds = %output146
  store i8 %call150, i8* %tmpVar142, align 1
  %deref151 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt152 = load i16, i16* %cnt, align 2
  %39 = sext i16 %load_cnt152 to i32
  %tmpVar153 = mul i32 1, %39
  %tmpVar154 = add i32 %tmpVar153, 0
  %tmpVar155 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref151, i32 0, i32 %tmpVar154
  %data156 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar155, i32 0, i32 4
  %tmpVar157 = getelementptr inbounds [8 x i8], [8 x i8]* %data156, i32 0, i32 1
  %BYTE_OF_DWORD_instance158 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input159

input159:                                         ; preds = %continue147
  %40 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance158, i32 0, i32 0
  %deref163 = load i32*, i32** %p1, align 8
  %load_tmpVar164 = load i32, i32* %deref163, align 4
  store i32 %load_tmpVar164, i32* %40, align 4
  %41 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance158, i32 0, i32 1
  store i8 1, i8* %41, align 1
  br label %call160

call160:                                          ; preds = %input159
  %call165 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance158)
  br label %output161

output161:                                        ; preds = %call160
  br label %continue162

continue162:                                      ; preds = %output161
  store i8 %call165, i8* %tmpVar157, align 1
  %deref166 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt167 = load i16, i16* %cnt, align 2
  %42 = sext i16 %load_cnt167 to i32
  %tmpVar168 = mul i32 1, %42
  %tmpVar169 = add i32 %tmpVar168, 0
  %tmpVar170 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref166, i32 0, i32 %tmpVar169
  %data171 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar170, i32 0, i32 4
  %tmpVar172 = getelementptr inbounds [8 x i8], [8 x i8]* %data171, i32 0, i32 2
  %BYTE_OF_DWORD_instance173 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input174

input174:                                         ; preds = %continue162
  %43 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance173, i32 0, i32 0
  %deref178 = load i32*, i32** %p1, align 8
  %load_tmpVar179 = load i32, i32* %deref178, align 4
  store i32 %load_tmpVar179, i32* %43, align 4
  %44 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance173, i32 0, i32 1
  store i8 2, i8* %44, align 1
  br label %call175

call175:                                          ; preds = %input174
  %call180 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance173)
  br label %output176

output176:                                        ; preds = %call175
  br label %continue177

continue177:                                      ; preds = %output176
  store i8 %call180, i8* %tmpVar172, align 1
  %deref181 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt182 = load i16, i16* %cnt, align 2
  %45 = sext i16 %load_cnt182 to i32
  %tmpVar183 = mul i32 1, %45
  %tmpVar184 = add i32 %tmpVar183, 0
  %tmpVar185 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref181, i32 0, i32 %tmpVar184
  %data186 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar185, i32 0, i32 4
  %tmpVar187 = getelementptr inbounds [8 x i8], [8 x i8]* %data186, i32 0, i32 3
  %BYTE_OF_DWORD_instance188 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input189

input189:                                         ; preds = %continue177
  %46 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance188, i32 0, i32 0
  %deref193 = load i32*, i32** %p1, align 8
  %load_tmpVar194 = load i32, i32* %deref193, align 4
  store i32 %load_tmpVar194, i32* %46, align 4
  %47 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance188, i32 0, i32 1
  store i8 3, i8* %47, align 1
  br label %call190

call190:                                          ; preds = %input189
  %call195 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance188)
  br label %output191

output191:                                        ; preds = %call190
  br label %continue192

continue192:                                      ; preds = %output191
  store i8 %call195, i8* %tmpVar187, align 1
  %load_R1196 = load float, float* %R1, align 4
  store float %load_R1196, float* %x1, align 4
  %load_cnt197 = load i16, i16* %cnt, align 2
  %48 = sext i16 %load_cnt197 to i32
  %tmpVar198 = add i32 %48, 1
  %49 = trunc i32 %tmpVar198 to i16
  store i16 %49, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue102

condition_body200:                                ; preds = %continue205
  %deref207 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt208 = load i16, i16* %cnt, align 2
  %50 = sext i16 %load_cnt208 to i32
  %tmpVar209 = mul i32 1, %50
  %tmpVar210 = add i32 %tmpVar209, 0
  %tmpVar211 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref207, i32 0, i32 %tmpVar210
  %typ212 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar211, i32 0, i32 0
  store i8 20, i8* %typ212, align 1
  %deref213 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt214 = load i16, i16* %cnt, align 2
  %51 = sext i16 %load_cnt214 to i32
  %tmpVar215 = mul i32 1, %51
  %tmpVar216 = add i32 %tmpVar215, 0
  %tmpVar217 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref213, i32 0, i32 %tmpVar216
  %adress218 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar217, i32 0, i32 1
  %52 = bitcast [11 x i8]* %adress218 to i8*
  %53 = bitcast [11 x i8]* %a2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %52, i8* align 1 %53, i32 10, i1 false)
  %deref219 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt220 = load i16, i16* %cnt, align 2
  %54 = sext i16 %load_cnt220 to i32
  %tmpVar221 = mul i32 1, %54
  %tmpVar222 = add i32 %tmpVar221, 0
  %tmpVar223 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref219, i32 0, i32 %tmpVar222
  %DS224 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar223, i32 0, i32 2
  %load_DT_in225 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in225, i64* %DS224, align 4
  %deref226 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt227 = load i16, i16* %cnt, align 2
  %55 = sext i16 %load_cnt227 to i32
  %tmpVar228 = mul i32 1, %55
  %tmpVar229 = add i32 %tmpVar228, 0
  %tmpVar230 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref226, i32 0, i32 %tmpVar229
  %TS231 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar230, i32 0, i32 3
  %load_TX232 = load i64, i64* %tx, align 4
  store i64 %load_TX232, i64* %TS231, align 4
  %deref233 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt234 = load i16, i16* %cnt, align 2
  %56 = sext i16 %load_cnt234 to i32
  %tmpVar235 = mul i32 1, %56
  %tmpVar236 = add i32 %tmpVar235, 0
  %tmpVar237 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref233, i32 0, i32 %tmpVar236
  %data238 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar237, i32 0, i32 4
  %tmpVar239 = getelementptr inbounds [8 x i8], [8 x i8]* %data238, i32 0, i32 0
  %BYTE_OF_DWORD_instance240 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input241

continue199:                                      ; preds = %continue289, %continue205
  %DIFFER_instance298 = alloca %DIFFER_interface, align 8
  br label %input299

input202:                                         ; preds = %continue102
  %57 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance201, i32 0, i32 0
  %load_R2 = load float, float* %R2, align 4
  store float %load_R2, float* %57, align 4
  %58 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance201, i32 0, i32 1
  %load_X2 = load float, float* %x2, align 4
  store float %load_X2, float* %58, align 4
  %59 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance201, i32 0, i32 2
  %load_S2 = load float, float* %s2, align 4
  store float %load_S2, float* %59, align 4
  br label %call203

call203:                                          ; preds = %input202
  %call206 = call i8 @DIFFER(%DIFFER_interface* %DIFFER_instance201)
  br label %output204

output204:                                        ; preds = %call203
  br label %continue205

continue205:                                      ; preds = %output204
  %60 = icmp ne i8 %call206, 0
  br i1 %60, label %condition_body200, label %continue199

input241:                                         ; preds = %condition_body200
  %61 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance240, i32 0, i32 0
  %deref245 = load i32*, i32** %p2, align 8
  %load_tmpVar246 = load i32, i32* %deref245, align 4
  store i32 %load_tmpVar246, i32* %61, align 4
  %62 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance240, i32 0, i32 1
  store i8 0, i8* %62, align 1
  br label %call242

call242:                                          ; preds = %input241
  %call247 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance240)
  br label %output243

output243:                                        ; preds = %call242
  br label %continue244

continue244:                                      ; preds = %output243
  store i8 %call247, i8* %tmpVar239, align 1
  %deref248 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt249 = load i16, i16* %cnt, align 2
  %63 = sext i16 %load_cnt249 to i32
  %tmpVar250 = mul i32 1, %63
  %tmpVar251 = add i32 %tmpVar250, 0
  %tmpVar252 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref248, i32 0, i32 %tmpVar251
  %data253 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar252, i32 0, i32 4
  %tmpVar254 = getelementptr inbounds [8 x i8], [8 x i8]* %data253, i32 0, i32 1
  %BYTE_OF_DWORD_instance255 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input256

input256:                                         ; preds = %continue244
  %64 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance255, i32 0, i32 0
  %deref260 = load i32*, i32** %p2, align 8
  %load_tmpVar261 = load i32, i32* %deref260, align 4
  store i32 %load_tmpVar261, i32* %64, align 4
  %65 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance255, i32 0, i32 1
  store i8 1, i8* %65, align 1
  br label %call257

call257:                                          ; preds = %input256
  %call262 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance255)
  br label %output258

output258:                                        ; preds = %call257
  br label %continue259

continue259:                                      ; preds = %output258
  store i8 %call262, i8* %tmpVar254, align 1
  %deref263 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt264 = load i16, i16* %cnt, align 2
  %66 = sext i16 %load_cnt264 to i32
  %tmpVar265 = mul i32 1, %66
  %tmpVar266 = add i32 %tmpVar265, 0
  %tmpVar267 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref263, i32 0, i32 %tmpVar266
  %data268 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar267, i32 0, i32 4
  %tmpVar269 = getelementptr inbounds [8 x i8], [8 x i8]* %data268, i32 0, i32 2
  %BYTE_OF_DWORD_instance270 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input271

input271:                                         ; preds = %continue259
  %67 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance270, i32 0, i32 0
  %deref275 = load i32*, i32** %p2, align 8
  %load_tmpVar276 = load i32, i32* %deref275, align 4
  store i32 %load_tmpVar276, i32* %67, align 4
  %68 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance270, i32 0, i32 1
  store i8 2, i8* %68, align 1
  br label %call272

call272:                                          ; preds = %input271
  %call277 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance270)
  br label %output273

output273:                                        ; preds = %call272
  br label %continue274

continue274:                                      ; preds = %output273
  store i8 %call277, i8* %tmpVar269, align 1
  %deref278 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt279 = load i16, i16* %cnt, align 2
  %69 = sext i16 %load_cnt279 to i32
  %tmpVar280 = mul i32 1, %69
  %tmpVar281 = add i32 %tmpVar280, 0
  %tmpVar282 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref278, i32 0, i32 %tmpVar281
  %data283 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar282, i32 0, i32 4
  %tmpVar284 = getelementptr inbounds [8 x i8], [8 x i8]* %data283, i32 0, i32 3
  %BYTE_OF_DWORD_instance285 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input286

input286:                                         ; preds = %continue274
  %70 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance285, i32 0, i32 0
  %deref290 = load i32*, i32** %p2, align 8
  %load_tmpVar291 = load i32, i32* %deref290, align 4
  store i32 %load_tmpVar291, i32* %70, align 4
  %71 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance285, i32 0, i32 1
  store i8 3, i8* %71, align 1
  br label %call287

call287:                                          ; preds = %input286
  %call292 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance285)
  br label %output288

output288:                                        ; preds = %call287
  br label %continue289

continue289:                                      ; preds = %output288
  store i8 %call292, i8* %tmpVar284, align 1
  %load_R2293 = load float, float* %R2, align 4
  store float %load_R2293, float* %x2, align 4
  %load_cnt294 = load i16, i16* %cnt, align 2
  %72 = sext i16 %load_cnt294 to i32
  %tmpVar295 = add i32 %72, 1
  %73 = trunc i32 %tmpVar295 to i16
  store i16 %73, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue199

condition_body297:                                ; preds = %continue302
  %deref304 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt305 = load i16, i16* %cnt, align 2
  %74 = sext i16 %load_cnt305 to i32
  %tmpVar306 = mul i32 1, %74
  %tmpVar307 = add i32 %tmpVar306, 0
  %tmpVar308 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref304, i32 0, i32 %tmpVar307
  %typ309 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar308, i32 0, i32 0
  store i8 20, i8* %typ309, align 1
  %deref310 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt311 = load i16, i16* %cnt, align 2
  %75 = sext i16 %load_cnt311 to i32
  %tmpVar312 = mul i32 1, %75
  %tmpVar313 = add i32 %tmpVar312, 0
  %tmpVar314 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref310, i32 0, i32 %tmpVar313
  %adress315 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar314, i32 0, i32 1
  %76 = bitcast [11 x i8]* %adress315 to i8*
  %77 = bitcast [11 x i8]* %a3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %76, i8* align 1 %77, i32 10, i1 false)
  %deref316 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt317 = load i16, i16* %cnt, align 2
  %78 = sext i16 %load_cnt317 to i32
  %tmpVar318 = mul i32 1, %78
  %tmpVar319 = add i32 %tmpVar318, 0
  %tmpVar320 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref316, i32 0, i32 %tmpVar319
  %DS321 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar320, i32 0, i32 2
  %load_DT_in322 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in322, i64* %DS321, align 4
  %deref323 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt324 = load i16, i16* %cnt, align 2
  %79 = sext i16 %load_cnt324 to i32
  %tmpVar325 = mul i32 1, %79
  %tmpVar326 = add i32 %tmpVar325, 0
  %tmpVar327 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref323, i32 0, i32 %tmpVar326
  %TS328 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar327, i32 0, i32 3
  %load_TX329 = load i64, i64* %tx, align 4
  store i64 %load_TX329, i64* %TS328, align 4
  %deref330 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt331 = load i16, i16* %cnt, align 2
  %80 = sext i16 %load_cnt331 to i32
  %tmpVar332 = mul i32 1, %80
  %tmpVar333 = add i32 %tmpVar332, 0
  %tmpVar334 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref330, i32 0, i32 %tmpVar333
  %data335 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar334, i32 0, i32 4
  %tmpVar336 = getelementptr inbounds [8 x i8], [8 x i8]* %data335, i32 0, i32 0
  %BYTE_OF_DWORD_instance337 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input338

continue296:                                      ; preds = %continue386, %continue302
  ret void

input299:                                         ; preds = %continue199
  %81 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance298, i32 0, i32 0
  %load_R3 = load float, float* %R3, align 4
  store float %load_R3, float* %81, align 4
  %82 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance298, i32 0, i32 1
  %load_X3 = load float, float* %x3, align 4
  store float %load_X3, float* %82, align 4
  %83 = getelementptr inbounds %DIFFER_interface, %DIFFER_interface* %DIFFER_instance298, i32 0, i32 2
  %load_S3 = load float, float* %s3, align 4
  store float %load_S3, float* %83, align 4
  br label %call300

call300:                                          ; preds = %input299
  %call303 = call i8 @DIFFER(%DIFFER_interface* %DIFFER_instance298)
  br label %output301

output301:                                        ; preds = %call300
  br label %continue302

continue302:                                      ; preds = %output301
  %84 = icmp ne i8 %call303, 0
  br i1 %84, label %condition_body297, label %continue296

input338:                                         ; preds = %condition_body297
  %85 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance337, i32 0, i32 0
  %deref342 = load i32*, i32** %p3, align 8
  %load_tmpVar343 = load i32, i32* %deref342, align 4
  store i32 %load_tmpVar343, i32* %85, align 4
  %86 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance337, i32 0, i32 1
  store i8 0, i8* %86, align 1
  br label %call339

call339:                                          ; preds = %input338
  %call344 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance337)
  br label %output340

output340:                                        ; preds = %call339
  br label %continue341

continue341:                                      ; preds = %output340
  store i8 %call344, i8* %tmpVar336, align 1
  %deref345 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt346 = load i16, i16* %cnt, align 2
  %87 = sext i16 %load_cnt346 to i32
  %tmpVar347 = mul i32 1, %87
  %tmpVar348 = add i32 %tmpVar347, 0
  %tmpVar349 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref345, i32 0, i32 %tmpVar348
  %data350 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar349, i32 0, i32 4
  %tmpVar351 = getelementptr inbounds [8 x i8], [8 x i8]* %data350, i32 0, i32 1
  %BYTE_OF_DWORD_instance352 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input353

input353:                                         ; preds = %continue341
  %88 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance352, i32 0, i32 0
  %deref357 = load i32*, i32** %p3, align 8
  %load_tmpVar358 = load i32, i32* %deref357, align 4
  store i32 %load_tmpVar358, i32* %88, align 4
  %89 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance352, i32 0, i32 1
  store i8 1, i8* %89, align 1
  br label %call354

call354:                                          ; preds = %input353
  %call359 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance352)
  br label %output355

output355:                                        ; preds = %call354
  br label %continue356

continue356:                                      ; preds = %output355
  store i8 %call359, i8* %tmpVar351, align 1
  %deref360 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt361 = load i16, i16* %cnt, align 2
  %90 = sext i16 %load_cnt361 to i32
  %tmpVar362 = mul i32 1, %90
  %tmpVar363 = add i32 %tmpVar362, 0
  %tmpVar364 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref360, i32 0, i32 %tmpVar363
  %data365 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar364, i32 0, i32 4
  %tmpVar366 = getelementptr inbounds [8 x i8], [8 x i8]* %data365, i32 0, i32 2
  %BYTE_OF_DWORD_instance367 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input368

input368:                                         ; preds = %continue356
  %91 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance367, i32 0, i32 0
  %deref372 = load i32*, i32** %p3, align 8
  %load_tmpVar373 = load i32, i32* %deref372, align 4
  store i32 %load_tmpVar373, i32* %91, align 4
  %92 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance367, i32 0, i32 1
  store i8 2, i8* %92, align 1
  br label %call369

call369:                                          ; preds = %input368
  %call374 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance367)
  br label %output370

output370:                                        ; preds = %call369
  br label %continue371

continue371:                                      ; preds = %output370
  store i8 %call374, i8* %tmpVar366, align 1
  %deref375 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt376 = load i16, i16* %cnt, align 2
  %93 = sext i16 %load_cnt376 to i32
  %tmpVar377 = mul i32 1, %93
  %tmpVar378 = add i32 %tmpVar377, 0
  %tmpVar379 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref375, i32 0, i32 %tmpVar378
  %data380 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar379, i32 0, i32 4
  %tmpVar381 = getelementptr inbounds [8 x i8], [8 x i8]* %data380, i32 0, i32 3
  %BYTE_OF_DWORD_instance382 = alloca %BYTE_OF_DWORD_interface, align 8
  br label %input383

input383:                                         ; preds = %continue371
  %94 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance382, i32 0, i32 0
  %deref387 = load i32*, i32** %p3, align 8
  %load_tmpVar388 = load i32, i32* %deref387, align 4
  store i32 %load_tmpVar388, i32* %94, align 4
  %95 = getelementptr inbounds %BYTE_OF_DWORD_interface, %BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance382, i32 0, i32 1
  store i8 3, i8* %95, align 1
  br label %call384

call384:                                          ; preds = %input383
  %call389 = call i8 @BYTE_OF_DWORD(%BYTE_OF_DWORD_interface* %BYTE_OF_DWORD_instance382)
  br label %output385

output385:                                        ; preds = %call384
  br label %continue386

continue386:                                      ; preds = %output385
  store i8 %call389, i8* %tmpVar381, align 1
  %load_R3390 = load float, float* %R3, align 4
  store float %load_R3390, float* %x3, align 4
  %load_cnt391 = load i16, i16* %cnt, align 2
  %96 = sext i16 %load_cnt391 to i32
  %tmpVar392 = add i32 %96, 1
  %97 = trunc i32 %tmpVar392 to i16
  store i16 %97, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue296
}

define void @ESR_MON_X8(%ESR_MON_X8_interface* %0) {
entry:
  %s0 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 0
  %s1 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 1
  %s2 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 2
  %s3 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 3
  %s4 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 4
  %s5 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 5
  %s6 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 6
  %s7 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 7
  %DT_in = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 8
  %Mode = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 9
  %a0 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 10
  %a1 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 11
  %a2 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 12
  %a3 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 13
  %a4 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 14
  %a5 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 15
  %a6 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 16
  %a7 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 17
  %ESR_Flag = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 18
  %ESR_Out = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 19
  %x0 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 20
  %x1 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 21
  %x2 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 22
  %x3 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 23
  %x4 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 24
  %x5 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 25
  %x6 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 26
  %x7 = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 27
  %tx = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 28
  %cnt = getelementptr inbounds %ESR_MON_X8_interface, %ESR_MON_X8_interface* %0, i32 0, i32 29
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %tx, align 4
  store i8 0, i8* %ESR_Flag, align 1
  %deref = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref, i32 0, i32 3
  %typ = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar, i32 0, i32 0
  store i8 0, i8* %typ, align 1
  %deref7 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar8 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref7, i32 0, i32 2
  %typ9 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar8, i32 0, i32 0
  store i8 0, i8* %typ9, align 1
  %deref10 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar11 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref10, i32 0, i32 1
  %typ12 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar11, i32 0, i32 0
  store i8 0, i8* %typ12, align 1
  %deref13 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %tmpVar14 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref13, i32 0, i32 0
  %typ15 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %tmpVar14, i32 0, i32 0
  store i8 0, i8* %typ15, align 1
  store i16 0, i16* %cnt, align 2
  %load_s0 = load i8, i8* %s0, align 1
  %2 = zext i8 %load_s0 to i32
  %load_X0 = load i8, i8* %x0, align 1
  %3 = zext i8 %load_X0 to i32
  %tmpVar17 = icmp ne i32 %2, %3
  %4 = zext i1 %tmpVar17 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %11, label %15

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %15
  %deref28 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt = load i16, i16* %cnt, align 2
  %6 = sext i16 %load_cnt to i32
  %tmpVar29 = mul i32 1, %6
  %tmpVar30 = add i32 %tmpVar29, 0
  %tmpVar31 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref28, i32 0, i32 %tmpVar30
  %STATUS_TO_ESR_instance = alloca %STATUS_TO_ESR_interface, align 8
  br label %input32

continue16:                                       ; preds = %continue35, %15
  %load_s1 = load i8, i8* %s1, align 1
  %7 = zext i8 %load_s1 to i32
  %load_X1 = load i8, i8* %x1, align 1
  %8 = zext i8 %load_X1 to i32
  %tmpVar43 = icmp ne i32 %7, %8
  %9 = zext i1 %tmpVar43 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %60, label %64

11:                                               ; preds = %continue
  %load_s018 = load i8, i8* %s0, align 1
  %12 = zext i8 %load_s018 to i32
  %tmpVar19 = icmp slt i32 %12, 100
  %13 = zext i1 %tmpVar19 to i32
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %28, label %24

15:                                               ; preds = %22, %continue
  %16 = phi i32 [ %4, %continue ], [ %23, %22 ]
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %condition_body, label %continue16

18:                                               ; preds = %28
  %load_S024 = load i8, i8* %s0, align 1
  %19 = zext i8 %load_S024 to i32
  %tmpVar25 = icmp sgt i32 %19, 199
  %20 = zext i1 %tmpVar25 to i32
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %42, label %45

22:                                               ; preds = %45, %28
  %23 = phi i32 [ %29, %28 ], [ %46, %45 ]
  br label %15

24:                                               ; preds = %11
  %load_S0 = load i8, i8* %s0, align 1
  %25 = zext i8 %load_S0 to i32
  %tmpVar20 = icmp sgt i32 %25, 99
  %26 = zext i1 %tmpVar20 to i32
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %36, label %39

28:                                               ; preds = %34, %11
  %29 = phi i32 [ %13, %11 ], [ %35, %34 ]
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %22, label %18

31:                                               ; preds = %39
  %load_mode = load i8, i8* %Mode, align 1
  %32 = zext i8 %load_mode to i32
  %tmpVar23 = icmp sge i32 %32, 2
  %33 = zext i1 %tmpVar23 to i32
  br label %34

34:                                               ; preds = %31, %39
  %35 = phi i32 [ %40, %39 ], [ %33, %31 ]
  br label %28

36:                                               ; preds = %24
  %load_S021 = load i8, i8* %s0, align 1
  %37 = zext i8 %load_S021 to i32
  %tmpVar22 = icmp slt i32 %37, 200
  %38 = zext i1 %tmpVar22 to i32
  br label %39

39:                                               ; preds = %36, %24
  %40 = phi i32 [ %26, %24 ], [ %38, %36 ]
  %41 = icmp ne i32 %40, 0
  br i1 %41, label %31, label %34

42:                                               ; preds = %18
  %load_mode26 = load i8, i8* %Mode, align 1
  %43 = zext i8 %load_mode26 to i32
  %tmpVar27 = icmp eq i32 %43, 3
  %44 = zext i1 %tmpVar27 to i32
  br label %45

45:                                               ; preds = %42, %18
  %46 = phi i32 [ %20, %18 ], [ %44, %42 ]
  br label %22

input32:                                          ; preds = %condition_body
  %47 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance, i32 0, i32 0
  %load_s036 = load i8, i8* %s0, align 1
  store i8 %load_s036, i8* %47, align 1
  %48 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance, i32 0, i32 1
  %49 = bitcast [11 x i8]* %48 to i8*
  %50 = bitcast [11 x i8]* %a0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %49, i8* align 1 %50, i32 10, i1 false)
  %51 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance, i32 0, i32 2
  %load_DT_in = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in, i64* %51, align 4
  %52 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance, i32 0, i32 3
  %load_TX = load i64, i64* %tx, align 4
  store i64 %load_TX, i64* %52, align 4
  br label %call33

call33:                                           ; preds = %input32
  %call37 = call %ESR_DATA @STATUS_TO_ESR(%STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance)
  br label %output34

output34:                                         ; preds = %call33
  br label %continue35

continue35:                                       ; preds = %output34
  store %ESR_DATA %call37, %ESR_DATA* %tmpVar31, align 4
  %load_S038 = load i8, i8* %s0, align 1
  store i8 %load_S038, i8* %x0, align 1
  %load_cnt39 = load i16, i16* %cnt, align 2
  %53 = sext i16 %load_cnt39 to i32
  %tmpVar40 = add i32 %53, 1
  %54 = trunc i32 %tmpVar40 to i16
  store i16 %54, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue16

condition_body42:                                 ; preds = %64
  %deref55 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt56 = load i16, i16* %cnt, align 2
  %55 = sext i16 %load_cnt56 to i32
  %tmpVar57 = mul i32 1, %55
  %tmpVar58 = add i32 %tmpVar57, 0
  %tmpVar59 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref55, i32 0, i32 %tmpVar58
  %STATUS_TO_ESR_instance60 = alloca %STATUS_TO_ESR_interface, align 8
  br label %input61

continue41:                                       ; preds = %continue64, %64
  %load_s2 = load i8, i8* %s2, align 1
  %56 = zext i8 %load_s2 to i32
  %load_X2 = load i8, i8* %x2, align 1
  %57 = zext i8 %load_X2 to i32
  %tmpVar74 = icmp ne i32 %56, %57
  %58 = zext i1 %tmpVar74 to i32
  %59 = icmp ne i32 %58, 0
  br i1 %59, label %109, label %113

60:                                               ; preds = %continue16
  %load_s144 = load i8, i8* %s1, align 1
  %61 = zext i8 %load_s144 to i32
  %tmpVar45 = icmp slt i32 %61, 100
  %62 = zext i1 %tmpVar45 to i32
  %63 = icmp ne i32 %62, 0
  br i1 %63, label %77, label %73

64:                                               ; preds = %71, %continue16
  %65 = phi i32 [ %9, %continue16 ], [ %72, %71 ]
  %66 = icmp ne i32 %65, 0
  br i1 %66, label %condition_body42, label %continue41

67:                                               ; preds = %77
  %load_S151 = load i8, i8* %s1, align 1
  %68 = zext i8 %load_S151 to i32
  %tmpVar52 = icmp sgt i32 %68, 199
  %69 = zext i1 %tmpVar52 to i32
  %70 = icmp ne i32 %69, 0
  br i1 %70, label %91, label %94

71:                                               ; preds = %94, %77
  %72 = phi i32 [ %78, %77 ], [ %95, %94 ]
  br label %64

73:                                               ; preds = %60
  %load_S1 = load i8, i8* %s1, align 1
  %74 = zext i8 %load_S1 to i32
  %tmpVar46 = icmp sgt i32 %74, 99
  %75 = zext i1 %tmpVar46 to i32
  %76 = icmp ne i32 %75, 0
  br i1 %76, label %85, label %88

77:                                               ; preds = %83, %60
  %78 = phi i32 [ %62, %60 ], [ %84, %83 ]
  %79 = icmp ne i32 %78, 0
  br i1 %79, label %71, label %67

80:                                               ; preds = %88
  %load_mode49 = load i8, i8* %Mode, align 1
  %81 = zext i8 %load_mode49 to i32
  %tmpVar50 = icmp sge i32 %81, 2
  %82 = zext i1 %tmpVar50 to i32
  br label %83

83:                                               ; preds = %80, %88
  %84 = phi i32 [ %89, %88 ], [ %82, %80 ]
  br label %77

85:                                               ; preds = %73
  %load_S147 = load i8, i8* %s1, align 1
  %86 = zext i8 %load_S147 to i32
  %tmpVar48 = icmp slt i32 %86, 200
  %87 = zext i1 %tmpVar48 to i32
  br label %88

88:                                               ; preds = %85, %73
  %89 = phi i32 [ %75, %73 ], [ %87, %85 ]
  %90 = icmp ne i32 %89, 0
  br i1 %90, label %80, label %83

91:                                               ; preds = %67
  %load_mode53 = load i8, i8* %Mode, align 1
  %92 = zext i8 %load_mode53 to i32
  %tmpVar54 = icmp eq i32 %92, 3
  %93 = zext i1 %tmpVar54 to i32
  br label %94

94:                                               ; preds = %91, %67
  %95 = phi i32 [ %69, %67 ], [ %93, %91 ]
  br label %71

input61:                                          ; preds = %condition_body42
  %96 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance60, i32 0, i32 0
  %load_s165 = load i8, i8* %s1, align 1
  store i8 %load_s165, i8* %96, align 1
  %97 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance60, i32 0, i32 1
  %98 = bitcast [11 x i8]* %97 to i8*
  %99 = bitcast [11 x i8]* %a1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %98, i8* align 1 %99, i32 10, i1 false)
  %100 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance60, i32 0, i32 2
  %load_DT_in66 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in66, i64* %100, align 4
  %101 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance60, i32 0, i32 3
  %load_TX67 = load i64, i64* %tx, align 4
  store i64 %load_TX67, i64* %101, align 4
  br label %call62

call62:                                           ; preds = %input61
  %call68 = call %ESR_DATA @STATUS_TO_ESR(%STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance60)
  br label %output63

output63:                                         ; preds = %call62
  br label %continue64

continue64:                                       ; preds = %output63
  store %ESR_DATA %call68, %ESR_DATA* %tmpVar59, align 4
  %load_S169 = load i8, i8* %s1, align 1
  store i8 %load_S169, i8* %x1, align 1
  %load_cnt70 = load i16, i16* %cnt, align 2
  %102 = sext i16 %load_cnt70 to i32
  %tmpVar71 = add i32 %102, 1
  %103 = trunc i32 %tmpVar71 to i16
  store i16 %103, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue41

condition_body73:                                 ; preds = %113
  %deref86 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt87 = load i16, i16* %cnt, align 2
  %104 = sext i16 %load_cnt87 to i32
  %tmpVar88 = mul i32 1, %104
  %tmpVar89 = add i32 %tmpVar88, 0
  %tmpVar90 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref86, i32 0, i32 %tmpVar89
  %STATUS_TO_ESR_instance91 = alloca %STATUS_TO_ESR_interface, align 8
  br label %input92

continue72:                                       ; preds = %continue95, %113
  %load_s3 = load i8, i8* %s3, align 1
  %105 = zext i8 %load_s3 to i32
  %load_X3 = load i8, i8* %x3, align 1
  %106 = zext i8 %load_X3 to i32
  %tmpVar105 = icmp ne i32 %105, %106
  %107 = zext i1 %tmpVar105 to i32
  %108 = icmp ne i32 %107, 0
  br i1 %108, label %157, label %161

109:                                              ; preds = %continue41
  %load_s275 = load i8, i8* %s2, align 1
  %110 = zext i8 %load_s275 to i32
  %tmpVar76 = icmp slt i32 %110, 100
  %111 = zext i1 %tmpVar76 to i32
  %112 = icmp ne i32 %111, 0
  br i1 %112, label %126, label %122

113:                                              ; preds = %120, %continue41
  %114 = phi i32 [ %58, %continue41 ], [ %121, %120 ]
  %115 = icmp ne i32 %114, 0
  br i1 %115, label %condition_body73, label %continue72

116:                                              ; preds = %126
  %load_S282 = load i8, i8* %s2, align 1
  %117 = zext i8 %load_S282 to i32
  %tmpVar83 = icmp sgt i32 %117, 199
  %118 = zext i1 %tmpVar83 to i32
  %119 = icmp ne i32 %118, 0
  br i1 %119, label %140, label %143

120:                                              ; preds = %143, %126
  %121 = phi i32 [ %127, %126 ], [ %144, %143 ]
  br label %113

122:                                              ; preds = %109
  %load_S2 = load i8, i8* %s2, align 1
  %123 = zext i8 %load_S2 to i32
  %tmpVar77 = icmp sgt i32 %123, 99
  %124 = zext i1 %tmpVar77 to i32
  %125 = icmp ne i32 %124, 0
  br i1 %125, label %134, label %137

126:                                              ; preds = %132, %109
  %127 = phi i32 [ %111, %109 ], [ %133, %132 ]
  %128 = icmp ne i32 %127, 0
  br i1 %128, label %120, label %116

129:                                              ; preds = %137
  %load_mode80 = load i8, i8* %Mode, align 1
  %130 = zext i8 %load_mode80 to i32
  %tmpVar81 = icmp sge i32 %130, 2
  %131 = zext i1 %tmpVar81 to i32
  br label %132

132:                                              ; preds = %129, %137
  %133 = phi i32 [ %138, %137 ], [ %131, %129 ]
  br label %126

134:                                              ; preds = %122
  %load_S278 = load i8, i8* %s2, align 1
  %135 = zext i8 %load_S278 to i32
  %tmpVar79 = icmp slt i32 %135, 200
  %136 = zext i1 %tmpVar79 to i32
  br label %137

137:                                              ; preds = %134, %122
  %138 = phi i32 [ %124, %122 ], [ %136, %134 ]
  %139 = icmp ne i32 %138, 0
  br i1 %139, label %129, label %132

140:                                              ; preds = %116
  %load_mode84 = load i8, i8* %Mode, align 1
  %141 = zext i8 %load_mode84 to i32
  %tmpVar85 = icmp eq i32 %141, 3
  %142 = zext i1 %tmpVar85 to i32
  br label %143

143:                                              ; preds = %140, %116
  %144 = phi i32 [ %118, %116 ], [ %142, %140 ]
  br label %120

input92:                                          ; preds = %condition_body73
  %145 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance91, i32 0, i32 0
  %load_s296 = load i8, i8* %s2, align 1
  store i8 %load_s296, i8* %145, align 1
  %146 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance91, i32 0, i32 1
  %147 = bitcast [11 x i8]* %146 to i8*
  %148 = bitcast [11 x i8]* %a2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %147, i8* align 1 %148, i32 10, i1 false)
  %149 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance91, i32 0, i32 2
  %load_DT_in97 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in97, i64* %149, align 4
  %150 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance91, i32 0, i32 3
  %load_TX98 = load i64, i64* %tx, align 4
  store i64 %load_TX98, i64* %150, align 4
  br label %call93

call93:                                           ; preds = %input92
  %call99 = call %ESR_DATA @STATUS_TO_ESR(%STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance91)
  br label %output94

output94:                                         ; preds = %call93
  br label %continue95

continue95:                                       ; preds = %output94
  store %ESR_DATA %call99, %ESR_DATA* %tmpVar90, align 4
  %load_S2100 = load i8, i8* %s2, align 1
  store i8 %load_S2100, i8* %x2, align 1
  %load_cnt101 = load i16, i16* %cnt, align 2
  %151 = sext i16 %load_cnt101 to i32
  %tmpVar102 = add i32 %151, 1
  %152 = trunc i32 %tmpVar102 to i16
  store i16 %152, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue72

condition_body104:                                ; preds = %161
  %deref117 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt118 = load i16, i16* %cnt, align 2
  %153 = sext i16 %load_cnt118 to i32
  %tmpVar119 = mul i32 1, %153
  %tmpVar120 = add i32 %tmpVar119, 0
  %tmpVar121 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref117, i32 0, i32 %tmpVar120
  %STATUS_TO_ESR_instance122 = alloca %STATUS_TO_ESR_interface, align 8
  br label %input123

continue103:                                      ; preds = %continue126, %161
  %load_cnt136 = load i16, i16* %cnt, align 2
  %154 = sext i16 %load_cnt136 to i32
  %tmpVar137 = icmp slt i32 %154, 4
  %155 = zext i1 %tmpVar137 to i32
  %156 = icmp ne i32 %155, 0
  br i1 %156, label %212, label %216

157:                                              ; preds = %continue72
  %load_s3106 = load i8, i8* %s3, align 1
  %158 = zext i8 %load_s3106 to i32
  %tmpVar107 = icmp slt i32 %158, 100
  %159 = zext i1 %tmpVar107 to i32
  %160 = icmp ne i32 %159, 0
  br i1 %160, label %174, label %170

161:                                              ; preds = %168, %continue72
  %162 = phi i32 [ %107, %continue72 ], [ %169, %168 ]
  %163 = icmp ne i32 %162, 0
  br i1 %163, label %condition_body104, label %continue103

164:                                              ; preds = %174
  %load_S3113 = load i8, i8* %s3, align 1
  %165 = zext i8 %load_S3113 to i32
  %tmpVar114 = icmp sgt i32 %165, 199
  %166 = zext i1 %tmpVar114 to i32
  %167 = icmp ne i32 %166, 0
  br i1 %167, label %188, label %191

168:                                              ; preds = %191, %174
  %169 = phi i32 [ %175, %174 ], [ %192, %191 ]
  br label %161

170:                                              ; preds = %157
  %load_S3 = load i8, i8* %s3, align 1
  %171 = zext i8 %load_S3 to i32
  %tmpVar108 = icmp sgt i32 %171, 99
  %172 = zext i1 %tmpVar108 to i32
  %173 = icmp ne i32 %172, 0
  br i1 %173, label %182, label %185

174:                                              ; preds = %180, %157
  %175 = phi i32 [ %159, %157 ], [ %181, %180 ]
  %176 = icmp ne i32 %175, 0
  br i1 %176, label %168, label %164

177:                                              ; preds = %185
  %load_mode111 = load i8, i8* %Mode, align 1
  %178 = zext i8 %load_mode111 to i32
  %tmpVar112 = icmp sge i32 %178, 2
  %179 = zext i1 %tmpVar112 to i32
  br label %180

180:                                              ; preds = %177, %185
  %181 = phi i32 [ %186, %185 ], [ %179, %177 ]
  br label %174

182:                                              ; preds = %170
  %load_S3109 = load i8, i8* %s3, align 1
  %183 = zext i8 %load_S3109 to i32
  %tmpVar110 = icmp slt i32 %183, 200
  %184 = zext i1 %tmpVar110 to i32
  br label %185

185:                                              ; preds = %182, %170
  %186 = phi i32 [ %172, %170 ], [ %184, %182 ]
  %187 = icmp ne i32 %186, 0
  br i1 %187, label %177, label %180

188:                                              ; preds = %164
  %load_mode115 = load i8, i8* %Mode, align 1
  %189 = zext i8 %load_mode115 to i32
  %tmpVar116 = icmp eq i32 %189, 3
  %190 = zext i1 %tmpVar116 to i32
  br label %191

191:                                              ; preds = %188, %164
  %192 = phi i32 [ %166, %164 ], [ %190, %188 ]
  br label %168

input123:                                         ; preds = %condition_body104
  %193 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance122, i32 0, i32 0
  %load_s3127 = load i8, i8* %s3, align 1
  store i8 %load_s3127, i8* %193, align 1
  %194 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance122, i32 0, i32 1
  %195 = bitcast [11 x i8]* %194 to i8*
  %196 = bitcast [11 x i8]* %a3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %195, i8* align 1 %196, i32 10, i1 false)
  %197 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance122, i32 0, i32 2
  %load_DT_in128 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in128, i64* %197, align 4
  %198 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance122, i32 0, i32 3
  %load_TX129 = load i64, i64* %tx, align 4
  store i64 %load_TX129, i64* %198, align 4
  br label %call124

call124:                                          ; preds = %input123
  %call130 = call %ESR_DATA @STATUS_TO_ESR(%STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance122)
  br label %output125

output125:                                        ; preds = %call124
  br label %continue126

continue126:                                      ; preds = %output125
  store %ESR_DATA %call130, %ESR_DATA* %tmpVar121, align 4
  %load_S3131 = load i8, i8* %s3, align 1
  store i8 %load_S3131, i8* %x3, align 1
  %load_cnt132 = load i16, i16* %cnt, align 2
  %199 = sext i16 %load_cnt132 to i32
  %tmpVar133 = add i32 %199, 1
  %200 = trunc i32 %tmpVar133 to i16
  store i16 %200, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue103

condition_body135:                                ; preds = %209
  %deref150 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt151 = load i16, i16* %cnt, align 2
  %201 = sext i16 %load_cnt151 to i32
  %tmpVar152 = mul i32 1, %201
  %tmpVar153 = add i32 %tmpVar152, 0
  %tmpVar154 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref150, i32 0, i32 %tmpVar153
  %STATUS_TO_ESR_instance155 = alloca %STATUS_TO_ESR_interface, align 8
  br label %input156

continue134:                                      ; preds = %continue159, %209
  %load_cnt169 = load i16, i16* %cnt, align 2
  %202 = sext i16 %load_cnt169 to i32
  %tmpVar170 = icmp slt i32 %202, 4
  %203 = zext i1 %tmpVar170 to i32
  %204 = icmp ne i32 %203, 0
  br i1 %204, label %267, label %271

205:                                              ; preds = %216
  %load_s4139 = load i8, i8* %s4, align 1
  %206 = zext i8 %load_s4139 to i32
  %tmpVar140 = icmp slt i32 %206, 100
  %207 = zext i1 %tmpVar140 to i32
  %208 = icmp ne i32 %207, 0
  br i1 %208, label %229, label %225

209:                                              ; preds = %223, %216
  %210 = phi i32 [ %217, %216 ], [ %224, %223 ]
  %211 = icmp ne i32 %210, 0
  br i1 %211, label %condition_body135, label %continue134

212:                                              ; preds = %continue103
  %load_s4 = load i8, i8* %s4, align 1
  %213 = zext i8 %load_s4 to i32
  %load_X4 = load i8, i8* %x4, align 1
  %214 = zext i8 %load_X4 to i32
  %tmpVar138 = icmp ne i32 %213, %214
  %215 = zext i1 %tmpVar138 to i32
  br label %216

216:                                              ; preds = %212, %continue103
  %217 = phi i32 [ %155, %continue103 ], [ %215, %212 ]
  %218 = icmp ne i32 %217, 0
  br i1 %218, label %205, label %209

219:                                              ; preds = %229
  %load_S4146 = load i8, i8* %s4, align 1
  %220 = zext i8 %load_S4146 to i32
  %tmpVar147 = icmp sgt i32 %220, 199
  %221 = zext i1 %tmpVar147 to i32
  %222 = icmp ne i32 %221, 0
  br i1 %222, label %243, label %246

223:                                              ; preds = %246, %229
  %224 = phi i32 [ %230, %229 ], [ %247, %246 ]
  br label %209

225:                                              ; preds = %205
  %load_S4 = load i8, i8* %s4, align 1
  %226 = zext i8 %load_S4 to i32
  %tmpVar141 = icmp sgt i32 %226, 99
  %227 = zext i1 %tmpVar141 to i32
  %228 = icmp ne i32 %227, 0
  br i1 %228, label %237, label %240

229:                                              ; preds = %235, %205
  %230 = phi i32 [ %207, %205 ], [ %236, %235 ]
  %231 = icmp ne i32 %230, 0
  br i1 %231, label %223, label %219

232:                                              ; preds = %240
  %load_mode144 = load i8, i8* %Mode, align 1
  %233 = zext i8 %load_mode144 to i32
  %tmpVar145 = icmp sge i32 %233, 2
  %234 = zext i1 %tmpVar145 to i32
  br label %235

235:                                              ; preds = %232, %240
  %236 = phi i32 [ %241, %240 ], [ %234, %232 ]
  br label %229

237:                                              ; preds = %225
  %load_S4142 = load i8, i8* %s4, align 1
  %238 = zext i8 %load_S4142 to i32
  %tmpVar143 = icmp slt i32 %238, 200
  %239 = zext i1 %tmpVar143 to i32
  br label %240

240:                                              ; preds = %237, %225
  %241 = phi i32 [ %227, %225 ], [ %239, %237 ]
  %242 = icmp ne i32 %241, 0
  br i1 %242, label %232, label %235

243:                                              ; preds = %219
  %load_mode148 = load i8, i8* %Mode, align 1
  %244 = zext i8 %load_mode148 to i32
  %tmpVar149 = icmp eq i32 %244, 3
  %245 = zext i1 %tmpVar149 to i32
  br label %246

246:                                              ; preds = %243, %219
  %247 = phi i32 [ %221, %219 ], [ %245, %243 ]
  br label %223

input156:                                         ; preds = %condition_body135
  %248 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance155, i32 0, i32 0
  %load_s4160 = load i8, i8* %s4, align 1
  store i8 %load_s4160, i8* %248, align 1
  %249 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance155, i32 0, i32 1
  %250 = bitcast [11 x i8]* %249 to i8*
  %251 = bitcast [11 x i8]* %a4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %250, i8* align 1 %251, i32 10, i1 false)
  %252 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance155, i32 0, i32 2
  %load_DT_in161 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in161, i64* %252, align 4
  %253 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance155, i32 0, i32 3
  %load_TX162 = load i64, i64* %tx, align 4
  store i64 %load_TX162, i64* %253, align 4
  br label %call157

call157:                                          ; preds = %input156
  %call163 = call %ESR_DATA @STATUS_TO_ESR(%STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance155)
  br label %output158

output158:                                        ; preds = %call157
  br label %continue159

continue159:                                      ; preds = %output158
  store %ESR_DATA %call163, %ESR_DATA* %tmpVar154, align 4
  %load_S4164 = load i8, i8* %s4, align 1
  store i8 %load_S4164, i8* %x4, align 1
  %load_cnt165 = load i16, i16* %cnt, align 2
  %254 = sext i16 %load_cnt165 to i32
  %tmpVar166 = add i32 %254, 1
  %255 = trunc i32 %tmpVar166 to i16
  store i16 %255, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue134

condition_body168:                                ; preds = %264
  %deref183 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt184 = load i16, i16* %cnt, align 2
  %256 = sext i16 %load_cnt184 to i32
  %tmpVar185 = mul i32 1, %256
  %tmpVar186 = add i32 %tmpVar185, 0
  %tmpVar187 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref183, i32 0, i32 %tmpVar186
  %STATUS_TO_ESR_instance188 = alloca %STATUS_TO_ESR_interface, align 8
  br label %input189

continue167:                                      ; preds = %continue192, %264
  %load_cnt202 = load i16, i16* %cnt, align 2
  %257 = sext i16 %load_cnt202 to i32
  %tmpVar203 = icmp slt i32 %257, 4
  %258 = zext i1 %tmpVar203 to i32
  %259 = icmp ne i32 %258, 0
  br i1 %259, label %322, label %326

260:                                              ; preds = %271
  %load_s5172 = load i8, i8* %s5, align 1
  %261 = zext i8 %load_s5172 to i32
  %tmpVar173 = icmp slt i32 %261, 100
  %262 = zext i1 %tmpVar173 to i32
  %263 = icmp ne i32 %262, 0
  br i1 %263, label %284, label %280

264:                                              ; preds = %278, %271
  %265 = phi i32 [ %272, %271 ], [ %279, %278 ]
  %266 = icmp ne i32 %265, 0
  br i1 %266, label %condition_body168, label %continue167

267:                                              ; preds = %continue134
  %load_s5 = load i8, i8* %s5, align 1
  %268 = zext i8 %load_s5 to i32
  %load_X5 = load i8, i8* %x5, align 1
  %269 = zext i8 %load_X5 to i32
  %tmpVar171 = icmp ne i32 %268, %269
  %270 = zext i1 %tmpVar171 to i32
  br label %271

271:                                              ; preds = %267, %continue134
  %272 = phi i32 [ %203, %continue134 ], [ %270, %267 ]
  %273 = icmp ne i32 %272, 0
  br i1 %273, label %260, label %264

274:                                              ; preds = %284
  %load_S5179 = load i8, i8* %s5, align 1
  %275 = zext i8 %load_S5179 to i32
  %tmpVar180 = icmp sgt i32 %275, 199
  %276 = zext i1 %tmpVar180 to i32
  %277 = icmp ne i32 %276, 0
  br i1 %277, label %298, label %301

278:                                              ; preds = %301, %284
  %279 = phi i32 [ %285, %284 ], [ %302, %301 ]
  br label %264

280:                                              ; preds = %260
  %load_S5 = load i8, i8* %s5, align 1
  %281 = zext i8 %load_S5 to i32
  %tmpVar174 = icmp sgt i32 %281, 99
  %282 = zext i1 %tmpVar174 to i32
  %283 = icmp ne i32 %282, 0
  br i1 %283, label %292, label %295

284:                                              ; preds = %290, %260
  %285 = phi i32 [ %262, %260 ], [ %291, %290 ]
  %286 = icmp ne i32 %285, 0
  br i1 %286, label %278, label %274

287:                                              ; preds = %295
  %load_mode177 = load i8, i8* %Mode, align 1
  %288 = zext i8 %load_mode177 to i32
  %tmpVar178 = icmp sge i32 %288, 2
  %289 = zext i1 %tmpVar178 to i32
  br label %290

290:                                              ; preds = %287, %295
  %291 = phi i32 [ %296, %295 ], [ %289, %287 ]
  br label %284

292:                                              ; preds = %280
  %load_S5175 = load i8, i8* %s5, align 1
  %293 = zext i8 %load_S5175 to i32
  %tmpVar176 = icmp slt i32 %293, 200
  %294 = zext i1 %tmpVar176 to i32
  br label %295

295:                                              ; preds = %292, %280
  %296 = phi i32 [ %282, %280 ], [ %294, %292 ]
  %297 = icmp ne i32 %296, 0
  br i1 %297, label %287, label %290

298:                                              ; preds = %274
  %load_mode181 = load i8, i8* %Mode, align 1
  %299 = zext i8 %load_mode181 to i32
  %tmpVar182 = icmp eq i32 %299, 3
  %300 = zext i1 %tmpVar182 to i32
  br label %301

301:                                              ; preds = %298, %274
  %302 = phi i32 [ %276, %274 ], [ %300, %298 ]
  br label %278

input189:                                         ; preds = %condition_body168
  %303 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance188, i32 0, i32 0
  %load_s5193 = load i8, i8* %s5, align 1
  store i8 %load_s5193, i8* %303, align 1
  %304 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance188, i32 0, i32 1
  %305 = bitcast [11 x i8]* %304 to i8*
  %306 = bitcast [11 x i8]* %a5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %305, i8* align 1 %306, i32 10, i1 false)
  %307 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance188, i32 0, i32 2
  %load_DT_in194 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in194, i64* %307, align 4
  %308 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance188, i32 0, i32 3
  %load_TX195 = load i64, i64* %tx, align 4
  store i64 %load_TX195, i64* %308, align 4
  br label %call190

call190:                                          ; preds = %input189
  %call196 = call %ESR_DATA @STATUS_TO_ESR(%STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance188)
  br label %output191

output191:                                        ; preds = %call190
  br label %continue192

continue192:                                      ; preds = %output191
  store %ESR_DATA %call196, %ESR_DATA* %tmpVar187, align 4
  %load_S5197 = load i8, i8* %s5, align 1
  store i8 %load_S5197, i8* %x5, align 1
  %load_cnt198 = load i16, i16* %cnt, align 2
  %309 = sext i16 %load_cnt198 to i32
  %tmpVar199 = add i32 %309, 1
  %310 = trunc i32 %tmpVar199 to i16
  store i16 %310, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue167

condition_body201:                                ; preds = %319
  %deref216 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt217 = load i16, i16* %cnt, align 2
  %311 = sext i16 %load_cnt217 to i32
  %tmpVar218 = mul i32 1, %311
  %tmpVar219 = add i32 %tmpVar218, 0
  %tmpVar220 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref216, i32 0, i32 %tmpVar219
  %STATUS_TO_ESR_instance221 = alloca %STATUS_TO_ESR_interface, align 8
  br label %input222

continue200:                                      ; preds = %continue225, %319
  %load_cnt235 = load i16, i16* %cnt, align 2
  %312 = sext i16 %load_cnt235 to i32
  %tmpVar236 = icmp slt i32 %312, 4
  %313 = zext i1 %tmpVar236 to i32
  %314 = icmp ne i32 %313, 0
  br i1 %314, label %374, label %378

315:                                              ; preds = %326
  %load_s6205 = load i8, i8* %s6, align 1
  %316 = zext i8 %load_s6205 to i32
  %tmpVar206 = icmp slt i32 %316, 100
  %317 = zext i1 %tmpVar206 to i32
  %318 = icmp ne i32 %317, 0
  br i1 %318, label %339, label %335

319:                                              ; preds = %333, %326
  %320 = phi i32 [ %327, %326 ], [ %334, %333 ]
  %321 = icmp ne i32 %320, 0
  br i1 %321, label %condition_body201, label %continue200

322:                                              ; preds = %continue167
  %load_s6 = load i8, i8* %s6, align 1
  %323 = zext i8 %load_s6 to i32
  %load_X6 = load i8, i8* %x6, align 1
  %324 = zext i8 %load_X6 to i32
  %tmpVar204 = icmp ne i32 %323, %324
  %325 = zext i1 %tmpVar204 to i32
  br label %326

326:                                              ; preds = %322, %continue167
  %327 = phi i32 [ %258, %continue167 ], [ %325, %322 ]
  %328 = icmp ne i32 %327, 0
  br i1 %328, label %315, label %319

329:                                              ; preds = %339
  %load_S6212 = load i8, i8* %s6, align 1
  %330 = zext i8 %load_S6212 to i32
  %tmpVar213 = icmp sgt i32 %330, 199
  %331 = zext i1 %tmpVar213 to i32
  %332 = icmp ne i32 %331, 0
  br i1 %332, label %353, label %356

333:                                              ; preds = %356, %339
  %334 = phi i32 [ %340, %339 ], [ %357, %356 ]
  br label %319

335:                                              ; preds = %315
  %load_S6 = load i8, i8* %s6, align 1
  %336 = zext i8 %load_S6 to i32
  %tmpVar207 = icmp sgt i32 %336, 99
  %337 = zext i1 %tmpVar207 to i32
  %338 = icmp ne i32 %337, 0
  br i1 %338, label %347, label %350

339:                                              ; preds = %345, %315
  %340 = phi i32 [ %317, %315 ], [ %346, %345 ]
  %341 = icmp ne i32 %340, 0
  br i1 %341, label %333, label %329

342:                                              ; preds = %350
  %load_mode210 = load i8, i8* %Mode, align 1
  %343 = zext i8 %load_mode210 to i32
  %tmpVar211 = icmp sge i32 %343, 2
  %344 = zext i1 %tmpVar211 to i32
  br label %345

345:                                              ; preds = %342, %350
  %346 = phi i32 [ %351, %350 ], [ %344, %342 ]
  br label %339

347:                                              ; preds = %335
  %load_S6208 = load i8, i8* %s6, align 1
  %348 = zext i8 %load_S6208 to i32
  %tmpVar209 = icmp slt i32 %348, 200
  %349 = zext i1 %tmpVar209 to i32
  br label %350

350:                                              ; preds = %347, %335
  %351 = phi i32 [ %337, %335 ], [ %349, %347 ]
  %352 = icmp ne i32 %351, 0
  br i1 %352, label %342, label %345

353:                                              ; preds = %329
  %load_mode214 = load i8, i8* %Mode, align 1
  %354 = zext i8 %load_mode214 to i32
  %tmpVar215 = icmp eq i32 %354, 3
  %355 = zext i1 %tmpVar215 to i32
  br label %356

356:                                              ; preds = %353, %329
  %357 = phi i32 [ %331, %329 ], [ %355, %353 ]
  br label %333

input222:                                         ; preds = %condition_body201
  %358 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance221, i32 0, i32 0
  %load_s6226 = load i8, i8* %s6, align 1
  store i8 %load_s6226, i8* %358, align 1
  %359 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance221, i32 0, i32 1
  %360 = bitcast [11 x i8]* %359 to i8*
  %361 = bitcast [11 x i8]* %a6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %360, i8* align 1 %361, i32 10, i1 false)
  %362 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance221, i32 0, i32 2
  %load_DT_in227 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in227, i64* %362, align 4
  %363 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance221, i32 0, i32 3
  %load_TX228 = load i64, i64* %tx, align 4
  store i64 %load_TX228, i64* %363, align 4
  br label %call223

call223:                                          ; preds = %input222
  %call229 = call %ESR_DATA @STATUS_TO_ESR(%STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance221)
  br label %output224

output224:                                        ; preds = %call223
  br label %continue225

continue225:                                      ; preds = %output224
  store %ESR_DATA %call229, %ESR_DATA* %tmpVar220, align 4
  %load_S6230 = load i8, i8* %s6, align 1
  store i8 %load_S6230, i8* %x6, align 1
  %load_cnt231 = load i16, i16* %cnt, align 2
  %364 = sext i16 %load_cnt231 to i32
  %tmpVar232 = add i32 %364, 1
  %365 = trunc i32 %tmpVar232 to i16
  store i16 %365, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue200

condition_body234:                                ; preds = %371
  %deref249 = load [4 x %ESR_DATA]*, [4 x %ESR_DATA]** %ESR_Out, align 8
  %load_cnt250 = load i16, i16* %cnt, align 2
  %366 = sext i16 %load_cnt250 to i32
  %tmpVar251 = mul i32 1, %366
  %tmpVar252 = add i32 %tmpVar251, 0
  %tmpVar253 = getelementptr inbounds [4 x %ESR_DATA], [4 x %ESR_DATA]* %deref249, i32 0, i32 %tmpVar252
  %STATUS_TO_ESR_instance254 = alloca %STATUS_TO_ESR_interface, align 8
  br label %input255

continue233:                                      ; preds = %continue258, %371
  ret void

367:                                              ; preds = %378
  %load_s7238 = load i8, i8* %s7, align 1
  %368 = zext i8 %load_s7238 to i32
  %tmpVar239 = icmp slt i32 %368, 100
  %369 = zext i1 %tmpVar239 to i32
  %370 = icmp ne i32 %369, 0
  br i1 %370, label %391, label %387

371:                                              ; preds = %385, %378
  %372 = phi i32 [ %379, %378 ], [ %386, %385 ]
  %373 = icmp ne i32 %372, 0
  br i1 %373, label %condition_body234, label %continue233

374:                                              ; preds = %continue200
  %load_s7 = load i8, i8* %s7, align 1
  %375 = zext i8 %load_s7 to i32
  %load_X7 = load i8, i8* %x7, align 1
  %376 = zext i8 %load_X7 to i32
  %tmpVar237 = icmp ne i32 %375, %376
  %377 = zext i1 %tmpVar237 to i32
  br label %378

378:                                              ; preds = %374, %continue200
  %379 = phi i32 [ %313, %continue200 ], [ %377, %374 ]
  %380 = icmp ne i32 %379, 0
  br i1 %380, label %367, label %371

381:                                              ; preds = %391
  %load_S7245 = load i8, i8* %s7, align 1
  %382 = zext i8 %load_S7245 to i32
  %tmpVar246 = icmp sgt i32 %382, 199
  %383 = zext i1 %tmpVar246 to i32
  %384 = icmp ne i32 %383, 0
  br i1 %384, label %405, label %408

385:                                              ; preds = %408, %391
  %386 = phi i32 [ %392, %391 ], [ %409, %408 ]
  br label %371

387:                                              ; preds = %367
  %load_S7 = load i8, i8* %s7, align 1
  %388 = zext i8 %load_S7 to i32
  %tmpVar240 = icmp sgt i32 %388, 99
  %389 = zext i1 %tmpVar240 to i32
  %390 = icmp ne i32 %389, 0
  br i1 %390, label %399, label %402

391:                                              ; preds = %397, %367
  %392 = phi i32 [ %369, %367 ], [ %398, %397 ]
  %393 = icmp ne i32 %392, 0
  br i1 %393, label %385, label %381

394:                                              ; preds = %402
  %load_mode243 = load i8, i8* %Mode, align 1
  %395 = zext i8 %load_mode243 to i32
  %tmpVar244 = icmp sge i32 %395, 2
  %396 = zext i1 %tmpVar244 to i32
  br label %397

397:                                              ; preds = %394, %402
  %398 = phi i32 [ %403, %402 ], [ %396, %394 ]
  br label %391

399:                                              ; preds = %387
  %load_S7241 = load i8, i8* %s7, align 1
  %400 = zext i8 %load_S7241 to i32
  %tmpVar242 = icmp slt i32 %400, 200
  %401 = zext i1 %tmpVar242 to i32
  br label %402

402:                                              ; preds = %399, %387
  %403 = phi i32 [ %389, %387 ], [ %401, %399 ]
  %404 = icmp ne i32 %403, 0
  br i1 %404, label %394, label %397

405:                                              ; preds = %381
  %load_mode247 = load i8, i8* %Mode, align 1
  %406 = zext i8 %load_mode247 to i32
  %tmpVar248 = icmp eq i32 %406, 3
  %407 = zext i1 %tmpVar248 to i32
  br label %408

408:                                              ; preds = %405, %381
  %409 = phi i32 [ %383, %381 ], [ %407, %405 ]
  br label %385

input255:                                         ; preds = %condition_body234
  %410 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance254, i32 0, i32 0
  %load_s7259 = load i8, i8* %s7, align 1
  store i8 %load_s7259, i8* %410, align 1
  %411 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance254, i32 0, i32 1
  %412 = bitcast [11 x i8]* %411 to i8*
  %413 = bitcast [11 x i8]* %a7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %412, i8* align 1 %413, i32 10, i1 false)
  %414 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance254, i32 0, i32 2
  %load_DT_in260 = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in260, i64* %414, align 4
  %415 = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance254, i32 0, i32 3
  %load_TX261 = load i64, i64* %tx, align 4
  store i64 %load_TX261, i64* %415, align 4
  br label %call256

call256:                                          ; preds = %input255
  %call262 = call %ESR_DATA @STATUS_TO_ESR(%STATUS_TO_ESR_interface* %STATUS_TO_ESR_instance254)
  br label %output257

output257:                                        ; preds = %call256
  br label %continue258

continue258:                                      ; preds = %output257
  store %ESR_DATA %call262, %ESR_DATA* %tmpVar253, align 4
  %load_S7263 = load i8, i8* %s7, align 1
  store i8 %load_S7263, i8* %x7, align 1
  %load_cnt264 = load i16, i16* %cnt, align 2
  %416 = sext i16 %load_cnt264 to i32
  %tmpVar265 = add i32 %416, 1
  %417 = trunc i32 %tmpVar265 to i16
  store i16 %417, i16* %cnt, align 2
  store i8 1, i8* %ESR_Flag, align 1
  br label %continue233
}

define i32 @OSCAT_VERSION(%OSCAT_VERSION_interface* %0) {
entry:
  %IN = getelementptr inbounds %OSCAT_VERSION_interface, %OSCAT_VERSION_interface* %0, i32 0, i32 0
  %OSCAT_VERSION = alloca i32, align 4
  store i32 0, i32* %OSCAT_VERSION, align 4
  %load_in = load i8, i8* %IN, align 1
  %1 = icmp ne i8 %load_in, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %DATE_TO_DWORD_instance = alloca %DATE_TO_DWORD_interface, align 8
  br label %input

else:                                             ; preds = %entry
  store i32 333, i32* %OSCAT_VERSION, align 4
  br label %continue

continue:                                         ; preds = %else, %continue1
  %OSCAT_VERSION_ret = load i32, i32* %OSCAT_VERSION, align 4
  ret i32 %OSCAT_VERSION_ret

input:                                            ; preds = %condition_body
  %2 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance, i32 0, i32 0
  store i64 1325462400000, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store i32 %call2, i32* %OSCAT_VERSION, align 4
  br label %continue
}

define %ESR_DATA @STATUS_TO_ESR(%STATUS_TO_ESR_interface* %0) {
entry:
  %status = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %0, i32 0, i32 0
  %adress = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %0, i32 0, i32 1
  %DT_in = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %0, i32 0, i32 2
  %TS = getelementptr inbounds %STATUS_TO_ESR_interface, %STATUS_TO_ESR_interface* %0, i32 0, i32 3
  %STATUS_TO_ESR = alloca %ESR_DATA, align 8
  %1 = bitcast %ESR_DATA* %STATUS_TO_ESR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 getelementptr inbounds (%ESR_DATA, %ESR_DATA* @ESR_DATA__init, i32 0, i32 0), i64 ptrtoint (%ESR_DATA* getelementptr (%ESR_DATA, %ESR_DATA* null, i32 1) to i64), i1 false)
  %load_status = load i8, i8* %status, align 1
  %2 = zext i8 %load_status to i32
  %tmpVar = icmp slt i32 %2, 100
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  %typ = getelementptr inbounds %ESR_DATA, %ESR_DATA* %STATUS_TO_ESR, i32 0, i32 0
  store i8 1, i8* %typ, align 1
  br label %continue

branch:                                           ; preds = %entry
  %load_status2 = load i8, i8* %status, align 1
  %3 = zext i8 %load_status2 to i32
  %tmpVar3 = icmp slt i32 %3, 200
  br i1 %tmpVar3, label %condition_body1, label %else

condition_body1:                                  ; preds = %branch
  %typ4 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %STATUS_TO_ESR, i32 0, i32 0
  store i8 2, i8* %typ4, align 1
  br label %continue

else:                                             ; preds = %branch
  %typ5 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %STATUS_TO_ESR, i32 0, i32 0
  store i8 3, i8* %typ5, align 1
  br label %continue

continue:                                         ; preds = %else, %condition_body1, %condition_body
  %adress6 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %STATUS_TO_ESR, i32 0, i32 1
  %4 = bitcast [11 x i8]* %adress6 to i8*
  %5 = bitcast [11 x i8]* %adress to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %4, i8* align 1 %5, i32 10, i1 false)
  %DS = getelementptr inbounds %ESR_DATA, %ESR_DATA* %STATUS_TO_ESR, i32 0, i32 2
  %load_DT_in = load i64, i64* %DT_in, align 4
  store i64 %load_DT_in, i64* %DS, align 4
  %TS7 = getelementptr inbounds %ESR_DATA, %ESR_DATA* %STATUS_TO_ESR, i32 0, i32 3
  %load_TS = load i64, i64* %TS, align 4
  store i64 %load_TS, i64* %TS7, align 4
  %data = getelementptr inbounds %ESR_DATA, %ESR_DATA* %STATUS_TO_ESR, i32 0, i32 4
  %tmpVar8 = getelementptr inbounds [8 x i8], [8 x i8]* %data, i32 0, i32 0
  %load_status9 = load i8, i8* %status, align 1
  store i8 %load_status9, i8* %tmpVar8, align 1
  %STATUS_TO_ESR_ret = load %ESR_DATA, %ESR_DATA* %STATUS_TO_ESR, align 4
  ret %ESR_DATA %STATUS_TO_ESR_ret
}

define i8 @BIN_TO_BYTE(%BIN_TO_BYTE_interface* %0) {
entry:
  %BIN = getelementptr inbounds %BIN_TO_BYTE_interface, %BIN_TO_BYTE_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %BIN_TO_BYTE_interface, %BIN_TO_BYTE_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %BIN_TO_BYTE_interface, %BIN_TO_BYTE_interface* %0, i32 0, i32 2
  %X = getelementptr inbounds %BIN_TO_BYTE_interface, %BIN_TO_BYTE_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %BIN_TO_BYTE_interface, %BIN_TO_BYTE_interface* %0, i32 0, i32 4
  %BIN_TO_BYTE = alloca i8, align 1
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %i, align 2
  store i8 0, i8* %X, align 1
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %BIN_TO_BYTE, align 1
  store [13 x i8]* %BIN, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [13 x i8]* %BIN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 13, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_I = load i16, i16* %i, align 2
  %load_I3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_I3, %load_stop
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %10, label %11

for_body:                                         ; preds = %8
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %5 = zext i8 %load_X to i32
  %tmpVar12 = icmp eq i32 %5, 48
  br i1 %tmpVar12, label %condition_body, label %branch

increment:                                        ; preds = %continue11
  %tmpVar28 = add i16 %load_I, 1
  store i16 %tmpVar28, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %8
  %BIN_TO_BYTE_ret = load i8, i8* %BIN_TO_BYTE, align 1
  ret i8 %BIN_TO_BYTE_ret

6:                                                ; preds = %11
  %load_I6 = load i16, i16* %i, align 2
  %load_stop7 = load i16, i16* %stop, align 2
  %tmpVar8 = icmp sge i16 %load_I6, %load_stop7
  %7 = icmp ne i1 %tmpVar8, false
  br i1 %7, label %14, label %15

8:                                                ; preds = %15, %11
  %9 = phi i1 [ %12, %11 ], [ %16, %15 ]
  br i1 %9, label %for_body, label %continue2

10:                                               ; preds = %condition_check
  %load_I4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_I4, 1
  br label %11

11:                                               ; preds = %10, %condition_check
  %12 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %10 ]
  %13 = icmp ne i1 %12, false
  br i1 %13, label %8, label %6

14:                                               ; preds = %6
  %load_I9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sle i16 %load_I9, 1
  br label %15

15:                                               ; preds = %14, %6
  %16 = phi i1 [ %tmpVar8, %6 ], [ %tmpVar10, %14 ]
  br label %8

condition_body:                                   ; preds = %for_body
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input13

branch:                                           ; preds = %for_body
  %load_X19 = load i8, i8* %X, align 1
  %17 = zext i8 %load_X19 to i32
  %tmpVar20 = icmp eq i32 %17, 49
  br i1 %tmpVar20, label %condition_body18, label %continue11

condition_body18:                                 ; preds = %branch
  %SHL_instance21 = alloca %SHL_interface, align 8
  br label %input22

continue11:                                       ; preds = %23, %branch, %continue16
  %load_pt = load i8*, i8** %pt, align 8
  %access___BIN_TO_BYTE_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___BIN_TO_BYTE_pt, i8** %pt, align 8
  br label %increment

input13:                                          ; preds = %condition_body
  %18 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_BIN_TO_BYTE = load i8, i8* %BIN_TO_BYTE, align 1
  %19 = zext i8 %load_BIN_TO_BYTE to i64
  store i64 %19, i64* %18, align 4
  %20 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 1, i16* %20, align 2
  br label %call14

call14:                                           ; preds = %input13
  %call17 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %21 = trunc i64 %call17 to i8
  store i8 %21, i8* %BIN_TO_BYTE, align 1
  br label %continue11

22:                                               ; preds = %continue25
  br label %23

23:                                               ; preds = %22, %continue25
  %24 = phi i64 [ %call27, %continue25 ], [ 1, %22 ]
  store i64 %24, i8* %BIN_TO_BYTE, align 4
  br label %continue11

input22:                                          ; preds = %condition_body18
  %25 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance21, i32 0, i32 0
  %load_BIN_TO_BYTE26 = load i8, i8* %BIN_TO_BYTE, align 1
  %26 = zext i8 %load_BIN_TO_BYTE26 to i64
  store i64 %26, i64* %25, align 4
  %27 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance21, i32 0, i32 1
  store i16 1, i16* %27, align 2
  br label %call23

call23:                                           ; preds = %input22
  %call27 = call i64 @SHL(%SHL_interface* %SHL_instance21)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %28 = icmp ne i64 %call27, 0
  br i1 %28, label %23, label %22
}

define i32 @BIN_TO_DWORD(%BIN_TO_DWORD_interface* %0) {
entry:
  %BIN = getelementptr inbounds %BIN_TO_DWORD_interface, %BIN_TO_DWORD_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %BIN_TO_DWORD_interface, %BIN_TO_DWORD_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %BIN_TO_DWORD_interface, %BIN_TO_DWORD_interface* %0, i32 0, i32 2
  %X = getelementptr inbounds %BIN_TO_DWORD_interface, %BIN_TO_DWORD_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %BIN_TO_DWORD_interface, %BIN_TO_DWORD_interface* %0, i32 0, i32 4
  %BIN_TO_DWORD = alloca i32, align 4
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %i, align 2
  store i8 0, i8* %X, align 1
  store i16 0, i16* %stop, align 2
  store i32 0, i32* %BIN_TO_DWORD, align 4
  store [41 x i8]* %BIN, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [41 x i8]* %BIN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 41, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_I = load i16, i16* %i, align 2
  %load_I3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_I3, %load_stop
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %10, label %11

for_body:                                         ; preds = %8
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %5 = zext i8 %load_X to i32
  %tmpVar12 = icmp eq i32 %5, 48
  br i1 %tmpVar12, label %condition_body, label %branch

increment:                                        ; preds = %continue11
  %tmpVar28 = add i16 %load_I, 1
  store i16 %tmpVar28, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %8
  %BIN_TO_DWORD_ret = load i32, i32* %BIN_TO_DWORD, align 4
  ret i32 %BIN_TO_DWORD_ret

6:                                                ; preds = %11
  %load_I6 = load i16, i16* %i, align 2
  %load_stop7 = load i16, i16* %stop, align 2
  %tmpVar8 = icmp sge i16 %load_I6, %load_stop7
  %7 = icmp ne i1 %tmpVar8, false
  br i1 %7, label %14, label %15

8:                                                ; preds = %15, %11
  %9 = phi i1 [ %12, %11 ], [ %16, %15 ]
  br i1 %9, label %for_body, label %continue2

10:                                               ; preds = %condition_check
  %load_I4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_I4, 1
  br label %11

11:                                               ; preds = %10, %condition_check
  %12 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %10 ]
  %13 = icmp ne i1 %12, false
  br i1 %13, label %8, label %6

14:                                               ; preds = %6
  %load_I9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sle i16 %load_I9, 1
  br label %15

15:                                               ; preds = %14, %6
  %16 = phi i1 [ %tmpVar8, %6 ], [ %tmpVar10, %14 ]
  br label %8

condition_body:                                   ; preds = %for_body
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input13

branch:                                           ; preds = %for_body
  %load_X19 = load i8, i8* %X, align 1
  %17 = zext i8 %load_X19 to i32
  %tmpVar20 = icmp eq i32 %17, 49
  br i1 %tmpVar20, label %condition_body18, label %continue11

condition_body18:                                 ; preds = %branch
  %SHL_instance21 = alloca %SHL_interface, align 8
  br label %input22

continue11:                                       ; preds = %23, %branch, %continue16
  %load_pt = load i8*, i8** %pt, align 8
  %access___BIN_TO_DWORD_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___BIN_TO_DWORD_pt, i8** %pt, align 8
  br label %increment

input13:                                          ; preds = %condition_body
  %18 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_BIN_TO_DWORD = load i32, i32* %BIN_TO_DWORD, align 4
  %19 = zext i32 %load_BIN_TO_DWORD to i64
  store i64 %19, i64* %18, align 4
  %20 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 1, i16* %20, align 2
  br label %call14

call14:                                           ; preds = %input13
  %call17 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %21 = trunc i64 %call17 to i32
  store i32 %21, i32* %BIN_TO_DWORD, align 4
  br label %continue11

22:                                               ; preds = %continue25
  br label %23

23:                                               ; preds = %22, %continue25
  %24 = phi i64 [ %call27, %continue25 ], [ 1, %22 ]
  store i64 %24, i32* %BIN_TO_DWORD, align 4
  br label %continue11

input22:                                          ; preds = %condition_body18
  %25 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance21, i32 0, i32 0
  %load_BIN_TO_DWORD26 = load i32, i32* %BIN_TO_DWORD, align 4
  %26 = zext i32 %load_BIN_TO_DWORD26 to i64
  store i64 %26, i64* %25, align 4
  %27 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance21, i32 0, i32 1
  store i16 1, i16* %27, align 2
  br label %call23

call23:                                           ; preds = %input22
  %call27 = call i64 @SHL(%SHL_interface* %SHL_instance21)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %28 = icmp ne i64 %call27, 0
  br i1 %28, label %23, label %22
}

define [9 x i8] @BYTE_TO_STRB(%BYTE_TO_STRB_interface* %0) {
entry:
  %IN = getelementptr inbounds %BYTE_TO_STRB_interface, %BYTE_TO_STRB_interface* %0, i32 0, i32 0
  %i = getelementptr inbounds %BYTE_TO_STRB_interface, %BYTE_TO_STRB_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %BYTE_TO_STRB_interface, %BYTE_TO_STRB_interface* %0, i32 0, i32 2
  %BYTE_TO_STRB = alloca [9 x i8], align 1
  store i16 0, i16* %i, align 2
  store i8* null, i8** %pt, align 8
  %1 = bitcast [9 x i8]* %BYTE_TO_STRB to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 9), i1 false)
  store [9 x i8]* %BYTE_TO_STRB, i8** %pt, align 8
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %entry
  %load_i = load i16, i16* %i, align 2
  %load_i1 = load i16, i16* %i, align 2
  %tmpVar = icmp sle i16 %load_i1, 8
  %2 = icmp ne i1 %tmpVar, false
  br i1 %2, label %7, label %8

for_body:                                         ; preds = %5
  %deref = load i8*, i8** %pt, align 8
  %BOOL_TO_BYTE_instance = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input

increment:                                        ; preds = %continue14
  %tmpVar17 = add i16 %load_i, 1
  store i16 %tmpVar17, i16* %i, align 2
  br label %condition_check

continue:                                         ; preds = %5
  %deref18 = load i8*, i8** %pt, align 8
  store i8 0, i8* %deref18, align 1
  %BYTE_TO_STRB_ret = load [9 x i8], [9 x i8]* %BYTE_TO_STRB, align 1
  ret [9 x i8] %BYTE_TO_STRB_ret

3:                                                ; preds = %8
  %load_i4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_i4, 8
  %4 = icmp ne i1 %tmpVar5, false
  br i1 %4, label %11, label %12

5:                                                ; preds = %12, %8
  %6 = phi i1 [ %9, %8 ], [ %13, %12 ]
  br i1 %6, label %for_body, label %continue

7:                                                ; preds = %condition_check
  %load_i2 = load i16, i16* %i, align 2
  %tmpVar3 = icmp sge i16 %load_i2, 1
  br label %8

8:                                                ; preds = %7, %condition_check
  %9 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar3, %7 ]
  %10 = icmp ne i1 %9, false
  br i1 %10, label %5, label %3

11:                                               ; preds = %3
  %load_i6 = load i16, i16* %i, align 2
  %tmpVar7 = icmp sle i16 %load_i6, 1
  br label %12

12:                                               ; preds = %11, %3
  %13 = phi i1 [ %tmpVar5, %3 ], [ %tmpVar7, %11 ]
  br label %5

input:                                            ; preds = %for_body
  %14 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance, i32 0, i32 0
  %load_in = load i8, i8* %IN, align 1
  %shift = lshr i8 %load_in, 7
  store i8 %shift, i8* %14, align 1
  br label %call

call:                                             ; preds = %input
  %call9 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue8

continue8:                                        ; preds = %output
  %15 = zext i8 %call9 to i32
  %tmpVar10 = add i32 %15, 48
  %16 = trunc i32 %tmpVar10 to i8
  store i8 %16, i8* %deref, align 1
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input11

input11:                                          ; preds = %continue8
  %17 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_in15 = load i8, i8* %IN, align 1
  %18 = zext i8 %load_in15 to i64
  store i64 %18, i64* %17, align 4
  %19 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 1, i16* %19, align 2
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %20 = trunc i64 %call16 to i8
  store i8 %20, i8* %IN, align 1
  %load_pt = load i8*, i8** %pt, align 8
  %access___BYTE_TO_STRB_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___BYTE_TO_STRB_pt, i8** %pt, align 8
  br label %increment
}

define [3 x i8] @BYTE_TO_STRH(%BYTE_TO_STRH_interface* %0) {
entry:
  %IN = getelementptr inbounds %BYTE_TO_STRH_interface, %BYTE_TO_STRH_interface* %0, i32 0, i32 0
  %temp = getelementptr inbounds %BYTE_TO_STRH_interface, %BYTE_TO_STRH_interface* %0, i32 0, i32 1
  %PT = getelementptr inbounds %BYTE_TO_STRH_interface, %BYTE_TO_STRH_interface* %0, i32 0, i32 2
  %BYTE_TO_STRH = alloca [3 x i8], align 1
  store i8 0, i8* %temp, align 1
  store i8* null, i8** %PT, align 8
  %1 = bitcast [3 x i8]* %BYTE_TO_STRH to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 3), i1 false)
  store [3 x i8]* %BYTE_TO_STRH, i8** %PT, align 8
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in = load i8, i8* %IN, align 1
  %3 = zext i8 %load_in to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 4, i16* %4, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = trunc i64 %call1 to i8
  store i8 %5, i8* %temp, align 1
  %load_temp = load i8, i8* %temp, align 1
  %6 = zext i8 %load_temp to i32
  %tmpVar = icmp sle i32 %6, 9
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %continue
  %load_temp3 = load i8, i8* %temp, align 1
  %7 = zext i8 %load_temp3 to i32
  %tmpVar4 = add i32 %7, 48
  %8 = trunc i32 %tmpVar4 to i8
  store i8 %8, i8* %temp, align 1
  br label %continue2

else:                                             ; preds = %continue
  %load_temp5 = load i8, i8* %temp, align 1
  %9 = zext i8 %load_temp5 to i32
  %tmpVar6 = add i32 %9, 55
  %10 = trunc i32 %tmpVar6 to i8
  store i8 %10, i8* %temp, align 1
  br label %continue2

continue2:                                        ; preds = %else, %condition_body
  %deref = load i8*, i8** %PT, align 8
  %load_temp7 = load i8, i8* %temp, align 1
  store i8 %load_temp7, i8* %deref, align 1
  %load_in8 = load i8, i8* %IN, align 1
  %11 = zext i8 %load_in8 to i32
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %13, label %14

13:                                               ; preds = %continue2
  br label %14

14:                                               ; preds = %13, %continue2
  %15 = phi i32 [ %11, %continue2 ], [ 15, %13 ]
  store i32 %15, i8* %temp, align 4
  %load_temp12 = load i8, i8* %temp, align 1
  %16 = zext i8 %load_temp12 to i32
  %tmpVar13 = icmp sle i32 %16, 9
  br i1 %tmpVar13, label %condition_body11, label %else9

condition_body11:                                 ; preds = %14
  %load_temp14 = load i8, i8* %temp, align 1
  %17 = zext i8 %load_temp14 to i32
  %tmpVar15 = add i32 %17, 48
  %18 = trunc i32 %tmpVar15 to i8
  store i8 %18, i8* %temp, align 1
  br label %continue10

else9:                                            ; preds = %14
  %load_temp16 = load i8, i8* %temp, align 1
  %19 = zext i8 %load_temp16 to i32
  %tmpVar17 = add i32 %19, 55
  %20 = trunc i32 %tmpVar17 to i8
  store i8 %20, i8* %temp, align 1
  br label %continue10

continue10:                                       ; preds = %else9, %condition_body11
  %load_pt = load i8*, i8** %PT, align 8
  %access___BYTE_TO_STRH_PT = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___BYTE_TO_STRH_PT, i8** %PT, align 8
  %deref18 = load i8*, i8** %PT, align 8
  %load_temp19 = load i8, i8* %temp, align 1
  store i8 %load_temp19, i8* %deref18, align 1
  %load_pt20 = load i8*, i8** %PT, align 8
  %access___BYTE_TO_STRH_PT21 = getelementptr inbounds i8, i8* %load_pt20, i32 1
  store i8* %access___BYTE_TO_STRH_PT21, i8** %PT, align 8
  %deref22 = load i8*, i8** %PT, align 8
  store i8 0, i8* %deref22, align 1
  %BYTE_TO_STRH_ret = load [3 x i8], [3 x i8]* %BYTE_TO_STRH, align 1
  ret [3 x i8] %BYTE_TO_STRH_ret
}

define [251 x i8] @CAPITALIZE(%CAPITALIZE_interface* %0) {
entry:
  %str = getelementptr inbounds %CAPITALIZE_interface, %CAPITALIZE_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %CAPITALIZE_interface, %CAPITALIZE_interface* %0, i32 0, i32 1
  %pos = getelementptr inbounds %CAPITALIZE_interface, %CAPITALIZE_interface* %0, i32 0, i32 2
  %L = getelementptr inbounds %CAPITALIZE_interface, %CAPITALIZE_interface* %0, i32 0, i32 3
  %first = getelementptr inbounds %CAPITALIZE_interface, %CAPITALIZE_interface* %0, i32 0, i32 4
  %CAPITALIZE = alloca [251 x i8], align 1
  store i8* null, i8** %PT, align 8
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %L, align 2
  store i8 1, i8* %first, align 1
  %1 = bitcast [251 x i8]* %CAPITALIZE to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  store [251 x i8]* %CAPITALIZE, i8** %PT, align 8
  %2 = bitcast [251 x i8]* %CAPITALIZE to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 250, i1 false)
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %5 = bitcast [1024 x i8]* %4 to i8*
  %6 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %L, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_l = load i16, i16* %L, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_l
  %7 = icmp ne i1 %tmpVar, false
  br i1 %7, label %13, label %14

for_body:                                         ; preds = %11
  %load_first = load i8, i8* %first, align 1
  %8 = icmp ne i8 %load_first, 0
  br i1 %8, label %condition_body, label %continue11

increment:                                        ; preds = %continue11
  %tmpVar21 = add i16 %load_pos, 1
  store i16 %tmpVar21, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %11
  %CAPITALIZE_ret = load [251 x i8], [251 x i8]* %CAPITALIZE, align 1
  ret [251 x i8] %CAPITALIZE_ret

9:                                                ; preds = %14
  %load_pos6 = load i16, i16* %pos, align 2
  %load_l7 = load i16, i16* %L, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_l7
  %10 = icmp ne i1 %tmpVar8, false
  br i1 %10, label %17, label %18

11:                                               ; preds = %18, %14
  %12 = phi i1 [ %15, %14 ], [ %19, %18 ]
  br i1 %12, label %for_body, label %continue2

13:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %14

14:                                               ; preds = %13, %condition_check
  %15 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %13 ]
  %16 = icmp ne i1 %15, false
  br i1 %16, label %11, label %9

17:                                               ; preds = %9
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %18

18:                                               ; preds = %17, %9
  %19 = phi i1 [ %tmpVar8, %9 ], [ %tmpVar10, %17 ]
  br label %11

condition_body:                                   ; preds = %for_body
  %deref = load i8*, i8** %PT, align 8
  %TO_UPPER_instance = alloca %TO_UPPER_interface, align 8
  br label %input12

continue11:                                       ; preds = %continue15, %for_body
  %deref18 = load i8*, i8** %PT, align 8
  %load_tmpVar19 = load i8, i8* %deref18, align 1
  %20 = zext i8 %load_tmpVar19 to i32
  %tmpVar20 = icmp eq i32 %20, 32
  %21 = zext i1 %tmpVar20 to i8
  store i8 %21, i8* %first, align 1
  %load_pt = load i8*, i8** %PT, align 8
  %access___CAPITALIZE_PT = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___CAPITALIZE_PT, i8** %PT, align 8
  br label %increment

input12:                                          ; preds = %condition_body
  %22 = getelementptr inbounds %TO_UPPER_interface, %TO_UPPER_interface* %TO_UPPER_instance, i32 0, i32 0
  %deref16 = load i8*, i8** %PT, align 8
  %load_tmpVar = load i8, i8* %deref16, align 1
  store i8 %load_tmpVar, i8* %22, align 1
  br label %call13

call13:                                           ; preds = %input12
  %call17 = call i8 @TO_UPPER(%TO_UPPER_interface* %TO_UPPER_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  store i8 %call17, i8* %deref, align 1
  br label %continue11
}

define i8 @CHARCODE(%CHARCODE_interface* %0) {
entry:
  %STR = getelementptr inbounds %CHARCODE_interface, %CHARCODE_interface* %0, i32 0, i32 0
  %found = getelementptr inbounds %CHARCODE_interface, %CHARCODE_interface* %0, i32 0, i32 1
  %search = getelementptr inbounds %CHARCODE_interface, %CHARCODE_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %CHARCODE_interface, %CHARCODE_interface* %0, i32 0, i32 3
  %i = getelementptr inbounds %CHARCODE_interface, %CHARCODE_interface* %0, i32 0, i32 4
  %CHARCODE = alloca i8, align 1
  %1 = bitcast [2 x i8]* %found to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 2), i1 false)
  %2 = bitcast [11 x i8]* %search to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %2, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 11), i1 false)
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %i, align 2
  store i8 0, i8* %CHARCODE, align 1
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

condition_body:                                   ; preds = %continue1
  %CODE_instance = alloca %CODE_interface, align 8
  br label %input3

branch:                                           ; preds = %continue1
  %STRING_EQUAL_instance = alloca %STRING_EQUAL_interface, align 8
  br label %input9

condition_body8:                                  ; preds = %continue12
  %CONCAT_instance = alloca %CONCAT_interface, align 8
  br label %input15

continue:                                         ; preds = %continue55, %continue12, %continue6
  %CHARCODE_ret = load i8, i8* %CHARCODE, align 1
  ret i8 %CHARCODE_ret

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %4 = bitcast [1024 x i8]* %3 to i8*
  %5 = bitcast [11 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %4, i8* align 1 %5, i32 11, i1 false)
  br label %call

call:                                             ; preds = %input
  %call2 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %6 = sext i16 %call2 to i32
  %tmpVar = icmp eq i32 %6, 1
  br i1 %tmpVar, label %condition_body, label %branch

input3:                                           ; preds = %condition_body
  %7 = getelementptr inbounds %CODE_interface, %CODE_interface* %CODE_instance, i32 0, i32 0
  %8 = bitcast [251 x i8]* %7 to i8*
  %9 = bitcast [11 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %8, i8* align 1 %9, i32 11, i1 false)
  %10 = getelementptr inbounds %CODE_interface, %CODE_interface* %CODE_instance, i32 0, i32 1
  store i16 1, i16* %10, align 2
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i8 @CODE(%CODE_interface* %CODE_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  store i8 %call7, i8* %CHARCODE, align 1
  br label %continue

input9:                                           ; preds = %branch
  %11 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 0
  %12 = bitcast [1025 x i8]* %11 to i8*
  %13 = bitcast [11 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %12, i8* align 1 %13, i32 11, i1 false)
  %14 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 1
  %15 = bitcast [1025 x i8]* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %15, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  br label %call10

call10:                                           ; preds = %input9
  %call13 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  %tmpVar14 = xor i8 %call13, -1
  %16 = icmp ne i8 %tmpVar14, 0
  br i1 %16, label %condition_body8, label %continue

input15:                                          ; preds = %condition_body8
  %17 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 0
  %18 = bitcast [1024 x i8]* %17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %18, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_4, i32 0, i32 0), i32 2, i1 false)
  %19 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 1
  %20 = bitcast [1024 x i8]* %19 to i8*
  %21 = bitcast [11 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 11, i1 false)
  br label %call16

call16:                                           ; preds = %input15
  %call19 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %22 = alloca [1024 x i8], align 1
  store [1024 x i8] %call19, [1024 x i8]* %22, align 1
  %23 = bitcast [11 x i8]* %search to i8*
  %24 = bitcast [1024 x i8]* %22 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %23, i8* align 1 %24, i32 10, i1 false)
  %CONCAT_instance20 = alloca %CONCAT_interface, align 8
  br label %input21

input21:                                          ; preds = %continue18
  %25 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance20, i32 0, i32 0
  %26 = bitcast [1024 x i8]* %25 to i8*
  %27 = bitcast [11 x i8]* %search to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %26, i8* align 1 %27, i32 11, i1 false)
  %28 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance20, i32 0, i32 1
  %29 = bitcast [1024 x i8]* %28 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %29, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_18, i32 0, i32 0), i32 2, i1 false)
  br label %call22

call22:                                           ; preds = %input21
  %call25 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance20)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %30 = alloca [1024 x i8], align 1
  store [1024 x i8] %call25, [1024 x i8]* %30, align 1
  %31 = bitcast [11 x i8]* %search to i8*
  %32 = bitcast [1024 x i8]* %30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %31, i8* align 1 %32, i32 10, i1 false)
  br label %condition_check

condition_check:                                  ; preds = %continue24, %continue34
  %load_pos = load i16, i16* %pos, align 2
  %33 = sext i16 %load_pos to i32
  %tmpVar27 = icmp eq i32 %33, 0
  %34 = zext i1 %tmpVar27 to i32
  %35 = icmp ne i32 %34, 0
  br i1 %35, label %38, label %41

while_body:                                       ; preds = %41
  %load_i29 = load i16, i16* %i, align 2
  %36 = sext i16 %load_i29 to i32
  %tmpVar30 = add i32 %36, 1
  %37 = trunc i32 %tmpVar30 to i16
  store i16 %37, i16* %i, align 2
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input31

continue26:                                       ; preds = %41
  %MID_instance = alloca %MID_interface, align 8
  br label %input40

38:                                               ; preds = %condition_check
  %load_i = load i16, i16* %i, align 2
  %39 = sext i16 %load_i to i32
  %tmpVar28 = icmp slt i32 %39, 4
  %40 = zext i1 %tmpVar28 to i32
  br label %41

41:                                               ; preds = %38, %condition_check
  %42 = phi i32 [ %34, %condition_check ], [ %40, %38 ]
  br i32 %42, label %while_body, label %continue26

input31:                                          ; preds = %while_body
  %43 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %load_i35 = load i16, i16* %i, align 2
  %44 = sub i16 %load_i35, 1
  %45 = sext i16 %44 to i32
  %tmpVar36 = mul i32 1, %45
  %tmpVar37 = add i32 %tmpVar36, 0
  %tmpVar38 = getelementptr inbounds [4 x [254 x i8]], [4 x [254 x i8]]* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 1), i32 0, i32 %tmpVar37
  %46 = bitcast [1024 x i8]* %43 to i8*
  %47 = bitcast [254 x i8]* %tmpVar38 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %46, i8* align 1 %47, i32 254, i1 false)
  %48 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %49 = bitcast [1024 x i8]* %48 to i8*
  %50 = bitcast [11 x i8]* %search to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %49, i8* align 1 %50, i32 11, i1 false)
  br label %call32

call32:                                           ; preds = %input31
  %call39 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  store i16 %call39, i16* %pos, align 2
  br label %condition_check

input40:                                          ; preds = %continue26
  %51 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %load_i44 = load i16, i16* %i, align 2
  %52 = sub i16 %load_i44, 1
  %53 = sext i16 %52 to i32
  %tmpVar45 = mul i32 1, %53
  %tmpVar46 = add i32 %tmpVar45, 0
  %tmpVar47 = getelementptr inbounds [4 x [254 x i8]], [4 x [254 x i8]]* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 1), i32 0, i32 %tmpVar46
  %54 = bitcast [1024 x i8]* %51 to i8*
  %55 = bitcast [254 x i8]* %tmpVar47 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %54, i8* align 1 %55, i32 254, i1 false)
  %56 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  store i16 1, i16* %56, align 2
  %57 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  %load_pos48 = load i16, i16* %pos, align 2
  %58 = sext i16 %load_pos48 to i32
  %tmpVar49 = sub i32 %58, 1
  %59 = trunc i32 %tmpVar49 to i16
  store i16 %59, i16* %57, align 2
  br label %call41

call41:                                           ; preds = %input40
  %call50 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output42

output42:                                         ; preds = %call41
  br label %continue43

continue43:                                       ; preds = %output42
  %60 = alloca [1024 x i8], align 1
  store [1024 x i8] %call50, [1024 x i8]* %60, align 1
  %61 = bitcast [2 x i8]* %found to i8*
  %62 = bitcast [1024 x i8]* %60 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %61, i8* align 1 %62, i32 1, i1 false)
  %CODE_instance51 = alloca %CODE_interface, align 8
  br label %input52

input52:                                          ; preds = %continue43
  %63 = getelementptr inbounds %CODE_interface, %CODE_interface* %CODE_instance51, i32 0, i32 0
  %64 = bitcast [251 x i8]* %63 to i8*
  %65 = bitcast [2 x i8]* %found to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %64, i8* align 1 %65, i32 2, i1 false)
  %66 = getelementptr inbounds %CODE_interface, %CODE_interface* %CODE_instance51, i32 0, i32 1
  store i16 1, i16* %66, align 2
  br label %call53

call53:                                           ; preds = %input52
  %call56 = call i8 @CODE(%CODE_interface* %CODE_instance51)
  br label %output54

output54:                                         ; preds = %call53
  br label %continue55

continue55:                                       ; preds = %output54
  store i8 %call56, i8* %CHARCODE, align 1
  br label %continue
}

define [11 x i8] @CHARNAME(%CHARNAME_interface* %0) {
entry:
  %C = getelementptr inbounds %CHARNAME_interface, %CHARNAME_interface* %0, i32 0, i32 0
  %pos = getelementptr inbounds %CHARNAME_interface, %CHARNAME_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %CHARNAME_interface, %CHARNAME_interface* %0, i32 0, i32 2
  %CHARNAME = alloca [11 x i8], align 1
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %i, align 2
  %1 = bitcast [11 x i8]* %CHARNAME to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 11), i1 false)
  %load_C = load i8, i8* %C, align 1
  %2 = zext i8 %load_C to i32
  %tmpVar = icmp ne i32 %2, 0
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %CHR_TO_STRING_instance = alloca %CHR_TO_STRING_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %3 = bitcast [11 x i8]* %CHARNAME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %3, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  br label %continue

continue:                                         ; preds = %else, %continue30
  %CHARNAME_ret = load [11 x i8], [11 x i8]* %CHARNAME, align 1
  ret [11 x i8] %CHARNAME_ret

input:                                            ; preds = %condition_body
  %4 = getelementptr inbounds %CHR_TO_STRING_interface, %CHR_TO_STRING_interface* %CHR_TO_STRING_instance, i32 0, i32 0
  %load_C2 = load i8, i8* %C, align 1
  store i8 %load_C2, i8* %4, align 1
  br label %call

call:                                             ; preds = %input
  %call3 = call [2 x i8] @CHR_TO_STRING(%CHR_TO_STRING_interface* %CHR_TO_STRING_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %5 = alloca [2 x i8], align 1
  store [2 x i8] %call3, [2 x i8]* %5, align 1
  %6 = bitcast [11 x i8]* %CHARNAME to i8*
  %7 = bitcast [2 x i8]* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %6, i8* align 1 %7, i32 2, i1 false)
  %CONCAT_instance = alloca %CONCAT_interface, align 8
  br label %input4

input4:                                           ; preds = %continue1
  %8 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 0
  %9 = bitcast [1024 x i8]* %8 to i8*
  %10 = bitcast [11 x i8]* %CHARNAME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %9, i8* align 1 %10, i32 11, i1 false)
  %11 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 1
  %12 = bitcast [1024 x i8]* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %12, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_4, i32 0, i32 0), i32 2, i1 false)
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %13 = alloca [1024 x i8], align 1
  store [1024 x i8] %call8, [1024 x i8]* %13, align 1
  %14 = bitcast [11 x i8]* %CHARNAME to i8*
  %15 = bitcast [1024 x i8]* %13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %14, i8* align 1 %15, i32 10, i1 false)
  %CONCAT_instance9 = alloca %CONCAT_interface, align 8
  br label %input10

input10:                                          ; preds = %continue7
  %16 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance9, i32 0, i32 0
  %17 = bitcast [1024 x i8]* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %17, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_18, i32 0, i32 0), i32 2, i1 false)
  %18 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance9, i32 0, i32 1
  %19 = bitcast [1024 x i8]* %18 to i8*
  %20 = bitcast [11 x i8]* %CHARNAME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %19, i8* align 1 %20, i32 11, i1 false)
  br label %call11

call11:                                           ; preds = %input10
  %call14 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance9)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %21 = alloca [1024 x i8], align 1
  store [1024 x i8] %call14, [1024 x i8]* %21, align 1
  %22 = bitcast [11 x i8]* %CHARNAME to i8*
  %23 = bitcast [1024 x i8]* %21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %22, i8* align 1 %23, i32 10, i1 false)
  br label %condition_check

condition_check:                                  ; preds = %continue13, %continue23
  %load_pos = load i16, i16* %pos, align 2
  %24 = sext i16 %load_pos to i32
  %tmpVar16 = icmp eq i32 %24, 0
  %25 = zext i1 %tmpVar16 to i32
  %26 = icmp ne i32 %25, 0
  br i1 %26, label %30, label %33

while_body:                                       ; preds = %33
  %load_i18 = load i16, i16* %i, align 2
  %27 = sext i16 %load_i18 to i32
  %tmpVar19 = add i32 %27, 1
  %28 = trunc i32 %tmpVar19 to i16
  store i16 %28, i16* %i, align 2
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input20

continue15:                                       ; preds = %33
  %load_pos32 = load i16, i16* %pos, align 2
  %29 = sext i16 %load_pos32 to i32
  %tmpVar33 = icmp sgt i32 %29, 0
  br i1 %tmpVar33, label %condition_body31, label %else29

30:                                               ; preds = %condition_check
  %load_i = load i16, i16* %i, align 2
  %31 = sext i16 %load_i to i32
  %tmpVar17 = icmp slt i32 %31, 4
  %32 = zext i1 %tmpVar17 to i32
  br label %33

33:                                               ; preds = %30, %condition_check
  %34 = phi i32 [ %25, %condition_check ], [ %32, %30 ]
  br i32 %34, label %while_body, label %continue15

input20:                                          ; preds = %while_body
  %35 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %load_i24 = load i16, i16* %i, align 2
  %36 = sub i16 %load_i24, 1
  %37 = sext i16 %36 to i32
  %tmpVar25 = mul i32 1, %37
  %tmpVar26 = add i32 %tmpVar25, 0
  %tmpVar27 = getelementptr inbounds [4 x [254 x i8]], [4 x [254 x i8]]* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 1), i32 0, i32 %tmpVar26
  %38 = bitcast [1024 x i8]* %35 to i8*
  %39 = bitcast [254 x i8]* %tmpVar27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %38, i8* align 1 %39, i32 254, i1 false)
  %40 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %41 = bitcast [1024 x i8]* %40 to i8*
  %42 = bitcast [11 x i8]* %CHARNAME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %41, i8* align 1 %42, i32 11, i1 false)
  br label %call21

call21:                                           ; preds = %input20
  %call28 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output22

output22:                                         ; preds = %call21
  br label %continue23

continue23:                                       ; preds = %output22
  store i16 %call28, i16* %pos, align 2
  br label %condition_check

condition_body31:                                 ; preds = %continue15
  %MID_instance = alloca %MID_interface, align 8
  br label %input34

else29:                                           ; preds = %continue15
  %CHR_TO_STRING_instance58 = alloca %CHR_TO_STRING_interface, align 8
  br label %input59

continue30:                                       ; preds = %continue62, %continue54
  br label %continue

input34:                                          ; preds = %condition_body31
  %43 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %load_i38 = load i16, i16* %i, align 2
  %44 = sub i16 %load_i38, 1
  %45 = sext i16 %44 to i32
  %tmpVar39 = mul i32 1, %45
  %tmpVar40 = add i32 %tmpVar39, 0
  %tmpVar41 = getelementptr inbounds [4 x [254 x i8]], [4 x [254 x i8]]* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 1), i32 0, i32 %tmpVar40
  %46 = bitcast [1024 x i8]* %43 to i8*
  %47 = bitcast [254 x i8]* %tmpVar41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %46, i8* align 1 %47, i32 254, i1 false)
  %48 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  store i16 10, i16* %48, align 2
  %49 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  %load_pos42 = load i16, i16* %pos, align 2
  %50 = sext i16 %load_pos42 to i32
  %tmpVar43 = add i32 %50, 3
  %51 = trunc i32 %tmpVar43 to i16
  store i16 %51, i16* %49, align 2
  br label %call35

call35:                                           ; preds = %input34
  %call44 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output36

output36:                                         ; preds = %call35
  br label %continue37

continue37:                                       ; preds = %output36
  %52 = alloca [1024 x i8], align 1
  store [1024 x i8] %call44, [1024 x i8]* %52, align 1
  %53 = bitcast [11 x i8]* %CHARNAME to i8*
  %54 = bitcast [1024 x i8]* %52 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %53, i8* align 1 %54, i32 10, i1 false)
  %FIND_instance45 = alloca %FIND_interface, align 8
  br label %input46

input46:                                          ; preds = %continue37
  %55 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance45, i32 0, i32 0
  %56 = bitcast [1024 x i8]* %55 to i8*
  %57 = bitcast [11 x i8]* %CHARNAME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %56, i8* align 1 %57, i32 11, i1 false)
  %58 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance45, i32 0, i32 1
  %59 = bitcast [1024 x i8]* %58 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %59, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_18, i32 0, i32 0), i32 2, i1 false)
  br label %call47

call47:                                           ; preds = %input46
  %call50 = call i16 @FIND(%FIND_interface* %FIND_instance45)
  br label %output48

output48:                                         ; preds = %call47
  br label %continue49

continue49:                                       ; preds = %output48
  store i16 %call50, i16* %pos, align 2
  %LEFT_instance = alloca %LEFT_interface, align 8
  br label %input51

input51:                                          ; preds = %continue49
  %60 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 0
  %61 = bitcast [1024 x i8]* %60 to i8*
  %62 = bitcast [11 x i8]* %CHARNAME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %61, i8* align 1 %62, i32 11, i1 false)
  %63 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 1
  %load_pos55 = load i16, i16* %pos, align 2
  %64 = sext i16 %load_pos55 to i32
  %tmpVar56 = sub i32 %64, 1
  %65 = trunc i32 %tmpVar56 to i16
  store i16 %65, i16* %63, align 2
  br label %call52

call52:                                           ; preds = %input51
  %call57 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance)
  br label %output53

output53:                                         ; preds = %call52
  br label %continue54

continue54:                                       ; preds = %output53
  %66 = alloca [1024 x i8], align 1
  store [1024 x i8] %call57, [1024 x i8]* %66, align 1
  %67 = bitcast [11 x i8]* %CHARNAME to i8*
  %68 = bitcast [1024 x i8]* %66 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %67, i8* align 1 %68, i32 10, i1 false)
  br label %continue30

input59:                                          ; preds = %else29
  %69 = getelementptr inbounds %CHR_TO_STRING_interface, %CHR_TO_STRING_interface* %CHR_TO_STRING_instance58, i32 0, i32 0
  %load_C63 = load i8, i8* %C, align 1
  store i8 %load_C63, i8* %69, align 1
  br label %call60

call60:                                           ; preds = %input59
  %call64 = call [2 x i8] @CHR_TO_STRING(%CHR_TO_STRING_interface* %CHR_TO_STRING_instance58)
  br label %output61

output61:                                         ; preds = %call60
  br label %continue62

continue62:                                       ; preds = %output61
  %70 = alloca [2 x i8], align 1
  store [2 x i8] %call64, [2 x i8]* %70, align 1
  %71 = bitcast [11 x i8]* %CHARNAME to i8*
  %72 = bitcast [2 x i8]* %70 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %71, i8* align 1 %72, i32 2, i1 false)
  br label %continue30
}

define [2 x i8] @CHR_TO_STRING(%CHR_TO_STRING_interface* %0) {
entry:
  %C = getelementptr inbounds %CHR_TO_STRING_interface, %CHR_TO_STRING_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %CHR_TO_STRING_interface, %CHR_TO_STRING_interface* %0, i32 0, i32 1
  %CHR_TO_STRING = alloca [2 x i8], align 1
  store i8* null, i8** %PT, align 8
  %1 = bitcast [2 x i8]* %CHR_TO_STRING to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 2), i1 false)
  store [2 x i8]* %CHR_TO_STRING, i8** %PT, align 8
  %deref = load i8*, i8** %PT, align 8
  %load_C = load i8, i8* %C, align 1
  store i8 %load_C, i8* %deref, align 1
  %load_pt = load i8*, i8** %PT, align 8
  %access___CHR_TO_STRING_PT = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___CHR_TO_STRING_PT, i8** %PT, align 8
  %deref1 = load i8*, i8** %PT, align 8
  store i8 0, i8* %deref1, align 1
  %CHR_TO_STRING_ret = load [2 x i8], [2 x i8]* %CHR_TO_STRING, align 1
  ret [2 x i8] %CHR_TO_STRING_ret
}

define [251 x i8] @CLEAN(%CLEAN_interface* %0) {
entry:
  %IN = getelementptr inbounds %CLEAN_interface, %CLEAN_interface* %0, i32 0, i32 0
  %CX = getelementptr inbounds %CLEAN_interface, %CLEAN_interface* %0, i32 0, i32 1
  %pos = getelementptr inbounds %CLEAN_interface, %CLEAN_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %CLEAN_interface, %CLEAN_interface* %0, i32 0, i32 3
  %CLEAN = alloca [251 x i8], align 1
  store i16 1, i16* %pos, align 2
  store i16 0, i16* %stop, align 2
  %1 = bitcast [251 x i8]* %CLEAN to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %2 = bitcast [251 x i8]* %CLEAN to i8*
  %3 = bitcast [251 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 250, i1 false)
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %5 = bitcast [1024 x i8]* %4 to i8*
  %6 = bitcast [251 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  br label %condition_check

condition_check:                                  ; preds = %continue, %continue3
  %load_pos = load i16, i16* %pos, align 2
  %7 = sext i16 %load_pos to i32
  %load_stop = load i16, i16* %stop, align 2
  %8 = sext i16 %load_stop to i32
  %tmpVar = icmp sle i32 %7, %8
  br i1 %tmpVar, label %while_body, label %continue2

while_body:                                       ; preds = %condition_check
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input4

continue2:                                        ; preds = %condition_check
  %CLEAN_ret = load [251 x i8], [251 x i8]* %CLEAN, align 1
  ret [251 x i8] %CLEAN_ret

condition_body:                                   ; preds = %continue7
  %load_pos16 = load i16, i16* %pos, align 2
  %9 = sext i16 %load_pos16 to i32
  %tmpVar17 = add i32 %9, 1
  %10 = trunc i32 %tmpVar17 to i16
  store i16 %10, i16* %pos, align 2
  br label %continue3

else:                                             ; preds = %continue7
  %DELETE_instance = alloca %DELETE_interface, align 8
  br label %input18

continue3:                                        ; preds = %continue21, %condition_body
  br label %condition_check

input4:                                           ; preds = %while_body
  %11 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %12 = bitcast [1024 x i8]* %11 to i8*
  %13 = bitcast [81 x i8]* %CX to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %12, i8* align 1 %13, i32 81, i1 false)
  %14 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %MID_instance = alloca %MID_interface, align 8
  br label %input8

call5:                                            ; preds = %continue11
  %call14 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %15 = sext i16 %call14 to i32
  %tmpVar15 = icmp sgt i32 %15, 0
  br i1 %tmpVar15, label %condition_body, label %else

input8:                                           ; preds = %input4
  %16 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %17 = bitcast [1024 x i8]* %16 to i8*
  %18 = bitcast [251 x i8]* %CLEAN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %17, i8* align 1 %18, i32 251, i1 false)
  %19 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  store i16 1, i16* %19, align 2
  %20 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  %load_pos12 = load i16, i16* %pos, align 2
  store i16 %load_pos12, i16* %20, align 2
  br label %call9

call9:                                            ; preds = %input8
  %call13 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %21 = alloca [1024 x i8], align 1
  store [1024 x i8] %call13, [1024 x i8]* %21, align 1
  %22 = bitcast [1024 x i8]* %14 to i8*
  %23 = bitcast [1024 x i8]* %21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %22, i8* align 1 %23, i32 1023, i1 false)
  br label %call5

input18:                                          ; preds = %else
  %24 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 0
  %25 = bitcast [1024 x i8]* %24 to i8*
  %26 = bitcast [251 x i8]* %CLEAN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %25, i8* align 1 %26, i32 251, i1 false)
  %27 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 1
  store i16 1, i16* %27, align 2
  %28 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 2
  %load_pos22 = load i16, i16* %pos, align 2
  store i16 %load_pos22, i16* %28, align 2
  br label %call19

call19:                                           ; preds = %input18
  %call23 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %29 = alloca [1024 x i8], align 1
  store [1024 x i8] %call23, [1024 x i8]* %29, align 1
  %30 = bitcast [251 x i8]* %CLEAN to i8*
  %31 = bitcast [1024 x i8]* %29 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %30, i8* align 1 %31, i32 250, i1 false)
  %load_stop24 = load i16, i16* %stop, align 2
  %32 = sext i16 %load_stop24 to i32
  %tmpVar25 = sub i32 %32, 1
  %33 = trunc i32 %tmpVar25 to i16
  store i16 %33, i16* %stop, align 2
  br label %continue3
}

define i8 @CODE(%CODE_interface* %0) {
entry:
  %STR = getelementptr inbounds %CODE_interface, %CODE_interface* %0, i32 0, i32 0
  %POS = getelementptr inbounds %CODE_interface, %CODE_interface* %0, i32 0, i32 1
  %PT = getelementptr inbounds %CODE_interface, %CODE_interface* %0, i32 0, i32 2
  %CODE = alloca i8, align 1
  store i8* null, i8** %PT, align 8
  store i8 0, i8* %CODE, align 1
  %load_pos = load i16, i16* %POS, align 2
  %1 = sext i16 %load_pos to i32
  %tmpVar = icmp slt i32 %1, 1
  %2 = zext i1 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %6, label %4

condition_body:                                   ; preds = %6
  store i8 0, i8* %CODE, align 1
  %CODE_ret = load i8, i8* %CODE, align 1
  ret i8 %CODE_ret

buffer_block:                                     ; No predecessors!
  br label %continue

else:                                             ; preds = %6
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input5

continue:                                         ; preds = %continue8, %buffer_block
  %CODE_ret12 = load i8, i8* %CODE, align 1
  ret i8 %CODE_ret12

4:                                                ; preds = %entry
  %load_pos1 = load i16, i16* %POS, align 2
  %5 = sext i16 %load_pos1 to i32
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

6:                                                ; preds = %continue2, %entry
  %7 = phi i32 [ %2, %entry ], [ %13, %continue2 ]
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %condition_body, label %else

input:                                            ; preds = %4
  %9 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %10 = bitcast [1024 x i8]* %9 to i8*
  %11 = bitcast [251 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %10, i8* align 1 %11, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call3 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue2

continue2:                                        ; preds = %output
  %12 = sext i16 %call3 to i32
  %tmpVar4 = icmp sgt i32 %5, %12
  %13 = zext i1 %tmpVar4 to i32
  br label %6

input5:                                           ; preds = %else
  %14 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_pos9 = load i16, i16* %POS, align 2
  %15 = sext i16 %load_pos9 to i32
  %tmpVar10 = sub i32 %15, 1
  %16 = trunc i32 %tmpVar10 to i16
  store i16 %16, i16* %14, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call11 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %access_POINTER_TO_STRING = getelementptr inbounds [251 x i8], [251 x i8]* %STR, i32 %call11
  store [251 x i8]* %access_POINTER_TO_STRING, i8** %PT, align 8
  %deref = load i8*, i8** %PT, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %CODE, align 1
  br label %continue
}

define i16 @COUNT_CHAR(%COUNT_CHAR_interface* %0) {
entry:
  %str = getelementptr inbounds %COUNT_CHAR_interface, %COUNT_CHAR_interface* %0, i32 0, i32 0
  %chr = getelementptr inbounds %COUNT_CHAR_interface, %COUNT_CHAR_interface* %0, i32 0, i32 1
  %l = getelementptr inbounds %COUNT_CHAR_interface, %COUNT_CHAR_interface* %0, i32 0, i32 2
  %pt = getelementptr inbounds %COUNT_CHAR_interface, %COUNT_CHAR_interface* %0, i32 0, i32 3
  %pos = getelementptr inbounds %COUNT_CHAR_interface, %COUNT_CHAR_interface* %0, i32 0, i32 4
  %COUNT_CHAR = alloca i16, align 2
  store i16 0, i16* %l, align 2
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %COUNT_CHAR, align 2
  store [251 x i8]* %str, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %l, align 2
  store i16 0, i16* %COUNT_CHAR, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_l = load i16, i16* %l, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_l
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %11, label %12

for_body:                                         ; preds = %9
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  %5 = zext i8 %load_tmpVar to i32
  %load_CHR = load i8, i8* %chr, align 1
  %6 = zext i8 %load_CHR to i32
  %tmpVar12 = icmp eq i32 %5, %6
  br i1 %tmpVar12, label %condition_body, label %continue11

increment:                                        ; preds = %continue11
  %tmpVar14 = add i16 %load_pos, 1
  store i16 %tmpVar14, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  %COUNT_CHAR_ret = load i16, i16* %COUNT_CHAR, align 2
  ret i16 %COUNT_CHAR_ret

7:                                                ; preds = %12
  %load_pos6 = load i16, i16* %pos, align 2
  %load_l7 = load i16, i16* %l, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_l7
  %8 = icmp ne i1 %tmpVar8, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar8, %7 ], [ %tmpVar10, %15 ]
  br label %9

condition_body:                                   ; preds = %for_body
  %load_COUNT_CHAR = load i16, i16* %COUNT_CHAR, align 2
  %18 = sext i16 %load_COUNT_CHAR to i32
  %tmpVar13 = add i32 %18, 1
  %19 = trunc i32 %tmpVar13 to i16
  store i16 %19, i16* %COUNT_CHAR, align 2
  br label %continue11

continue11:                                       ; preds = %condition_body, %for_body
  %load_PT = load i8*, i8** %pt, align 8
  %access___COUNT_CHAR_pt = getelementptr inbounds i8, i8* %load_PT, i32 1
  store i8* %access___COUNT_CHAR_pt, i8** %pt, align 8
  br label %increment
}

define i16 @COUNT_SUBSTRING(%COUNT_SUBSTRING_interface* %0) {
entry:
  %SEARCH = getelementptr inbounds %COUNT_SUBSTRING_interface, %COUNT_SUBSTRING_interface* %0, i32 0, i32 0
  %STR = getelementptr inbounds %COUNT_SUBSTRING_interface, %COUNT_SUBSTRING_interface* %0, i32 0, i32 1
  %pos = getelementptr inbounds %COUNT_SUBSTRING_interface, %COUNT_SUBSTRING_interface* %0, i32 0, i32 2
  %size = getelementptr inbounds %COUNT_SUBSTRING_interface, %COUNT_SUBSTRING_interface* %0, i32 0, i32 3
  %COUNT_SUBSTRING = alloca i16, align 2
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %size, align 2
  store i16 0, i16* %COUNT_SUBSTRING, align 2
  store i16 0, i16* %COUNT_SUBSTRING, align 2
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [81 x i8]* %SEARCH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 81, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %size, align 2
  br label %while_body

condition_check:                                  ; preds = %continue8
  %load_pos = load i16, i16* %pos, align 2
  %4 = sext i16 %load_pos to i32
  %tmpVar = icmp eq i32 %4, 0
  br i1 %tmpVar, label %while_body, label %continue2

while_body:                                       ; preds = %continue, %condition_check
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input3

continue2:                                        ; preds = %condition_check
  %COUNT_SUBSTRING_ret = load i16, i16* %COUNT_SUBSTRING, align 2
  ret i16 %COUNT_SUBSTRING_ret

input3:                                           ; preds = %while_body
  %5 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %6 = bitcast [1024 x i8]* %5 to i8*
  %7 = bitcast [81 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %6, i8* align 1 %7, i32 81, i1 false)
  %8 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %9 = bitcast [1024 x i8]* %8 to i8*
  %10 = bitcast [81 x i8]* %SEARCH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %9, i8* align 1 %10, i32 81, i1 false)
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  store i16 %call7, i16* %pos, align 2
  %load_pos9 = load i16, i16* %pos, align 2
  %11 = sext i16 %load_pos9 to i32
  %tmpVar10 = icmp sgt i32 %11, 0
  br i1 %tmpVar10, label %condition_body, label %continue8

condition_body:                                   ; preds = %continue6
  %REPLACE_instance = alloca %REPLACE_interface, align 8
  br label %input11

continue8:                                        ; preds = %continue14, %continue6
  br label %condition_check

input11:                                          ; preds = %condition_body
  %12 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 0
  %13 = bitcast [1024 x i8]* %12 to i8*
  %14 = bitcast [81 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %13, i8* align 1 %14, i32 81, i1 false)
  %15 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 1
  %16 = bitcast [1024 x i8]* %15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %16, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  %17 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 2
  %load_size = load i16, i16* %size, align 2
  store i16 %load_size, i16* %17, align 2
  %18 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 3
  %load_pos15 = load i16, i16* %pos, align 2
  store i16 %load_pos15, i16* %18, align 2
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call [1024 x i8] @REPLACE(%REPLACE_interface* %REPLACE_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %19 = alloca [1024 x i8], align 1
  store [1024 x i8] %call16, [1024 x i8]* %19, align 1
  %20 = bitcast [81 x i8]* %STR to i8*
  %21 = bitcast [1024 x i8]* %19 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 80, i1 false)
  %load_COUNT_SUBSTRING = load i16, i16* %COUNT_SUBSTRING, align 2
  %22 = sext i16 %load_COUNT_SUBSTRING to i32
  %tmpVar17 = add i32 %22, 1
  %23 = trunc i32 %tmpVar17 to i16
  store i16 %23, i16* %COUNT_SUBSTRING, align 2
  br label %continue8
}

define i8 @DEC_TO_BYTE(%DEC_TO_BYTE_interface* %0) {
entry:
  %DEC = getelementptr inbounds %DEC_TO_BYTE_interface, %DEC_TO_BYTE_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %DEC_TO_BYTE_interface, %DEC_TO_BYTE_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %DEC_TO_BYTE_interface, %DEC_TO_BYTE_interface* %0, i32 0, i32 2
  %X = getelementptr inbounds %DEC_TO_BYTE_interface, %DEC_TO_BYTE_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %DEC_TO_BYTE_interface, %DEC_TO_BYTE_interface* %0, i32 0, i32 4
  %DEC_TO_BYTE = alloca i8, align 1
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %i, align 2
  store i8 0, i8* %X, align 1
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %DEC_TO_BYTE, align 1
  store [11 x i8]* %DEC, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [11 x i8]* %DEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 11, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_I = load i16, i16* %i, align 2
  %load_I3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_I3, %load_stop
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %12, label %13

for_body:                                         ; preds = %10
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %5 = zext i8 %load_X to i32
  %tmpVar12 = icmp sgt i32 %5, 47
  %6 = zext i1 %tmpVar12 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %22, label %25

increment:                                        ; preds = %continue11
  %tmpVar18 = add i16 %load_I, 1
  store i16 %tmpVar18, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  %DEC_TO_BYTE_ret = load i8, i8* %DEC_TO_BYTE, align 1
  ret i8 %DEC_TO_BYTE_ret

8:                                                ; preds = %13
  %load_I6 = load i16, i16* %i, align 2
  %load_stop7 = load i16, i16* %stop, align 2
  %tmpVar8 = icmp sge i16 %load_I6, %load_stop7
  %9 = icmp ne i1 %tmpVar8, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_I4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_I4, 1
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_I9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sle i16 %load_I9, 1
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar8, %8 ], [ %tmpVar10, %16 ]
  br label %10

condition_body:                                   ; preds = %25
  %load_DEC_TO_BYTE = load i8, i8* %DEC_TO_BYTE, align 1
  %19 = zext i8 %load_DEC_TO_BYTE to i32
  %tmpVar14 = mul i32 %19, 10
  %load_X15 = load i8, i8* %X, align 1
  %20 = zext i8 %load_X15 to i32
  %tmpVar16 = add i32 %tmpVar14, %20
  %tmpVar17 = sub i32 %tmpVar16, 48
  %21 = trunc i32 %tmpVar17 to i8
  store i8 %21, i8* %DEC_TO_BYTE, align 1
  br label %continue11

continue11:                                       ; preds = %condition_body, %25
  %load_pt = load i8*, i8** %pt, align 8
  %access___DEC_TO_BYTE_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___DEC_TO_BYTE_pt, i8** %pt, align 8
  br label %increment

22:                                               ; preds = %for_body
  %load_x = load i8, i8* %X, align 1
  %23 = zext i8 %load_x to i32
  %tmpVar13 = icmp slt i32 %23, 58
  %24 = zext i1 %tmpVar13 to i32
  br label %25

25:                                               ; preds = %22, %for_body
  %26 = phi i32 [ %6, %for_body ], [ %24, %22 ]
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %condition_body, label %continue11
}

define i32 @DEC_TO_DWORD(%DEC_TO_DWORD_interface* %0) {
entry:
  %DEC = getelementptr inbounds %DEC_TO_DWORD_interface, %DEC_TO_DWORD_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %DEC_TO_DWORD_interface, %DEC_TO_DWORD_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %DEC_TO_DWORD_interface, %DEC_TO_DWORD_interface* %0, i32 0, i32 2
  %X = getelementptr inbounds %DEC_TO_DWORD_interface, %DEC_TO_DWORD_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %DEC_TO_DWORD_interface, %DEC_TO_DWORD_interface* %0, i32 0, i32 4
  %DEC_TO_DWORD = alloca i32, align 4
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %i, align 2
  store i8 0, i8* %X, align 1
  store i16 0, i16* %stop, align 2
  store i32 0, i32* %DEC_TO_DWORD, align 4
  store [21 x i8]* %DEC, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [21 x i8]* %DEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 21, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_I = load i16, i16* %i, align 2
  %load_I3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_I3, %load_stop
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %12, label %13

for_body:                                         ; preds = %10
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %5 = zext i8 %load_X to i32
  %tmpVar12 = icmp sgt i32 %5, 47
  %6 = zext i1 %tmpVar12 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %20, label %23

increment:                                        ; preds = %continue11
  %tmpVar18 = add i16 %load_I, 1
  store i16 %tmpVar18, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  %DEC_TO_DWORD_ret = load i32, i32* %DEC_TO_DWORD, align 4
  ret i32 %DEC_TO_DWORD_ret

8:                                                ; preds = %13
  %load_I6 = load i16, i16* %i, align 2
  %load_stop7 = load i16, i16* %stop, align 2
  %tmpVar8 = icmp sge i16 %load_I6, %load_stop7
  %9 = icmp ne i1 %tmpVar8, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_I4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_I4, 1
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_I9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sle i16 %load_I9, 1
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar8, %8 ], [ %tmpVar10, %16 ]
  br label %10

condition_body:                                   ; preds = %23
  %load_DEC_TO_DWORD = load i32, i32* %DEC_TO_DWORD, align 4
  %tmpVar14 = mul i32 %load_DEC_TO_DWORD, 10
  %load_X15 = load i8, i8* %X, align 1
  %19 = zext i8 %load_X15 to i32
  %tmpVar16 = add i32 %tmpVar14, %19
  %tmpVar17 = sub i32 %tmpVar16, 48
  store i32 %tmpVar17, i32* %DEC_TO_DWORD, align 4
  br label %continue11

continue11:                                       ; preds = %condition_body, %23
  %load_pt = load i8*, i8** %pt, align 8
  %access___DEC_TO_DWORD_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___DEC_TO_DWORD_pt, i8** %pt, align 8
  br label %increment

20:                                               ; preds = %for_body
  %load_x = load i8, i8* %X, align 1
  %21 = zext i8 %load_x to i32
  %tmpVar13 = icmp slt i32 %21, 58
  %22 = zext i1 %tmpVar13 to i32
  br label %23

23:                                               ; preds = %20, %for_body
  %24 = phi i32 [ %6, %for_body ], [ %22, %20 ]
  %25 = icmp ne i32 %24, 0
  br i1 %25, label %condition_body, label %continue11
}

define i16 @DEC_TO_INT(%DEC_TO_INT_interface* %0) {
entry:
  %DEC = getelementptr inbounds %DEC_TO_INT_interface, %DEC_TO_INT_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %DEC_TO_INT_interface, %DEC_TO_INT_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %DEC_TO_INT_interface, %DEC_TO_INT_interface* %0, i32 0, i32 2
  %X = getelementptr inbounds %DEC_TO_INT_interface, %DEC_TO_INT_interface* %0, i32 0, i32 3
  %sign = getelementptr inbounds %DEC_TO_INT_interface, %DEC_TO_INT_interface* %0, i32 0, i32 4
  %stop = getelementptr inbounds %DEC_TO_INT_interface, %DEC_TO_INT_interface* %0, i32 0, i32 5
  %DEC_TO_INT = alloca i16, align 2
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %i, align 2
  store i8 0, i8* %X, align 1
  store i8 0, i8* %sign, align 1
  store i16 0, i16* %stop, align 2
  store i16 0, i16* %DEC_TO_INT, align 2
  store [11 x i8]* %DEC, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [11 x i8]* %DEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 11, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_I = load i16, i16* %i, align 2
  %load_I3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_I3, %load_stop
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %13, label %14

for_body:                                         ; preds = %11
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %5 = zext i8 %load_X to i32
  %tmpVar12 = icmp sgt i32 %5, 47
  %6 = zext i1 %tmpVar12 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %26, label %29

increment:                                        ; preds = %continue11
  %tmpVar23 = add i16 %load_I, 1
  store i16 %tmpVar23, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %11
  %load_sign = load i8, i8* %sign, align 1
  %8 = icmp ne i8 %load_sign, 0
  br i1 %8, label %condition_body25, label %continue24

9:                                                ; preds = %14
  %load_I6 = load i16, i16* %i, align 2
  %load_stop7 = load i16, i16* %stop, align 2
  %tmpVar8 = icmp sge i16 %load_I6, %load_stop7
  %10 = icmp ne i1 %tmpVar8, false
  br i1 %10, label %17, label %18

11:                                               ; preds = %18, %14
  %12 = phi i1 [ %15, %14 ], [ %19, %18 ]
  br i1 %12, label %for_body, label %continue2

13:                                               ; preds = %condition_check
  %load_I4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_I4, 1
  br label %14

14:                                               ; preds = %13, %condition_check
  %15 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %13 ]
  %16 = icmp ne i1 %15, false
  br i1 %16, label %11, label %9

17:                                               ; preds = %9
  %load_I9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sle i16 %load_I9, 1
  br label %18

18:                                               ; preds = %17, %9
  %19 = phi i1 [ %tmpVar8, %9 ], [ %tmpVar10, %17 ]
  br label %11

condition_body:                                   ; preds = %29
  %load_DEC_TO_INT = load i16, i16* %DEC_TO_INT, align 2
  %20 = sext i16 %load_DEC_TO_INT to i32
  %tmpVar14 = mul i32 %20, 10
  %load_X15 = load i8, i8* %X, align 1
  %21 = zext i8 %load_X15 to i32
  %tmpVar16 = add i32 %tmpVar14, %21
  %tmpVar17 = sub i32 %tmpVar16, 48
  %22 = trunc i32 %tmpVar17 to i16
  store i16 %22, i16* %DEC_TO_INT, align 2
  br label %continue11

branch:                                           ; preds = %29
  %load_X19 = load i8, i8* %X, align 1
  %23 = zext i8 %load_X19 to i32
  %tmpVar20 = icmp eq i32 %23, 45
  %24 = zext i1 %tmpVar20 to i32
  %25 = icmp ne i32 %24, 0
  br i1 %25, label %32, label %35

condition_body18:                                 ; preds = %35
  store i8 1, i8* %sign, align 1
  br label %continue11

continue11:                                       ; preds = %condition_body18, %35, %condition_body
  %load_pt = load i8*, i8** %pt, align 8
  %access___DEC_TO_INT_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___DEC_TO_INT_pt, i8** %pt, align 8
  br label %increment

26:                                               ; preds = %for_body
  %load_x = load i8, i8* %X, align 1
  %27 = zext i8 %load_x to i32
  %tmpVar13 = icmp slt i32 %27, 58
  %28 = zext i1 %tmpVar13 to i32
  br label %29

29:                                               ; preds = %26, %for_body
  %30 = phi i32 [ %6, %for_body ], [ %28, %26 ]
  %31 = icmp ne i32 %30, 0
  br i1 %31, label %condition_body, label %branch

32:                                               ; preds = %branch
  %load_DEC_TO_INT21 = load i16, i16* %DEC_TO_INT, align 2
  %33 = sext i16 %load_DEC_TO_INT21 to i32
  %tmpVar22 = icmp eq i32 %33, 0
  %34 = zext i1 %tmpVar22 to i32
  br label %35

35:                                               ; preds = %32, %branch
  %36 = phi i32 [ %24, %branch ], [ %34, %32 ]
  %37 = icmp ne i32 %36, 0
  br i1 %37, label %condition_body18, label %continue11

condition_body25:                                 ; preds = %continue2
  %load_DEC_TO_INT26 = load i16, i16* %DEC_TO_INT, align 2
  %tmpVar27 = sub i16 0, %load_DEC_TO_INT26
  store i16 %tmpVar27, i16* %DEC_TO_INT, align 2
  br label %continue24

continue24:                                       ; preds = %condition_body25, %continue2
  %DEC_TO_INT_ret = load i16, i16* %DEC_TO_INT, align 2
  ret i16 %DEC_TO_INT_ret
}

define [251 x i8] @DEL_CHARS(%DEL_CHARS_interface* %0) {
entry:
  %IN = getelementptr inbounds %DEL_CHARS_interface, %DEL_CHARS_interface* %0, i32 0, i32 0
  %CX = getelementptr inbounds %DEL_CHARS_interface, %DEL_CHARS_interface* %0, i32 0, i32 1
  %pos = getelementptr inbounds %DEL_CHARS_interface, %DEL_CHARS_interface* %0, i32 0, i32 2
  %stop = getelementptr inbounds %DEL_CHARS_interface, %DEL_CHARS_interface* %0, i32 0, i32 3
  %DEL_CHARS = alloca [251 x i8], align 1
  store i16 1, i16* %pos, align 2
  store i16 0, i16* %stop, align 2
  %1 = bitcast [251 x i8]* %DEL_CHARS to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %2 = bitcast [251 x i8]* %DEL_CHARS to i8*
  %3 = bitcast [251 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 250, i1 false)
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %5 = bitcast [1024 x i8]* %4 to i8*
  %6 = bitcast [251 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  br label %condition_check

condition_check:                                  ; preds = %continue, %continue3
  %load_pos = load i16, i16* %pos, align 2
  %7 = sext i16 %load_pos to i32
  %load_stop = load i16, i16* %stop, align 2
  %8 = sext i16 %load_stop to i32
  %tmpVar = icmp sle i32 %7, %8
  br i1 %tmpVar, label %while_body, label %continue2

while_body:                                       ; preds = %condition_check
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input4

continue2:                                        ; preds = %condition_check
  %DEL_CHARS_ret = load [251 x i8], [251 x i8]* %DEL_CHARS, align 1
  ret [251 x i8] %DEL_CHARS_ret

condition_body:                                   ; preds = %continue7
  %DELETE_instance = alloca %DELETE_interface, align 8
  br label %input16

else:                                             ; preds = %continue7
  %load_pos24 = load i16, i16* %pos, align 2
  %9 = sext i16 %load_pos24 to i32
  %tmpVar25 = add i32 %9, 1
  %10 = trunc i32 %tmpVar25 to i16
  store i16 %10, i16* %pos, align 2
  br label %continue3

continue3:                                        ; preds = %else, %continue19
  br label %condition_check

input4:                                           ; preds = %while_body
  %11 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %12 = bitcast [1024 x i8]* %11 to i8*
  %13 = bitcast [81 x i8]* %CX to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %12, i8* align 1 %13, i32 81, i1 false)
  %14 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %MID_instance = alloca %MID_interface, align 8
  br label %input8

call5:                                            ; preds = %continue11
  %call14 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %15 = sext i16 %call14 to i32
  %tmpVar15 = icmp sgt i32 %15, 0
  br i1 %tmpVar15, label %condition_body, label %else

input8:                                           ; preds = %input4
  %16 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %17 = bitcast [1024 x i8]* %16 to i8*
  %18 = bitcast [251 x i8]* %DEL_CHARS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %17, i8* align 1 %18, i32 251, i1 false)
  %19 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  store i16 1, i16* %19, align 2
  %20 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  %load_pos12 = load i16, i16* %pos, align 2
  store i16 %load_pos12, i16* %20, align 2
  br label %call9

call9:                                            ; preds = %input8
  %call13 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %21 = alloca [1024 x i8], align 1
  store [1024 x i8] %call13, [1024 x i8]* %21, align 1
  %22 = bitcast [1024 x i8]* %14 to i8*
  %23 = bitcast [1024 x i8]* %21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %22, i8* align 1 %23, i32 1023, i1 false)
  br label %call5

input16:                                          ; preds = %condition_body
  %24 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 0
  %25 = bitcast [1024 x i8]* %24 to i8*
  %26 = bitcast [251 x i8]* %DEL_CHARS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %25, i8* align 1 %26, i32 251, i1 false)
  %27 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 1
  store i16 1, i16* %27, align 2
  %28 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 2
  %load_pos20 = load i16, i16* %pos, align 2
  store i16 %load_pos20, i16* %28, align 2
  br label %call17

call17:                                           ; preds = %input16
  %call21 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %29 = alloca [1024 x i8], align 1
  store [1024 x i8] %call21, [1024 x i8]* %29, align 1
  %30 = bitcast [251 x i8]* %DEL_CHARS to i8*
  %31 = bitcast [1024 x i8]* %29 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %30, i8* align 1 %31, i32 250, i1 false)
  %load_stop22 = load i16, i16* %stop, align 2
  %32 = sext i16 %load_stop22 to i32
  %tmpVar23 = sub i32 %32, 1
  %33 = trunc i32 %tmpVar23 to i16
  store i16 %33, i16* %stop, align 2
  br label %continue3
}

define [81 x i8] @DT_TO_STRF(%DT_TO_STRF_interface* %0) {
entry:
  %DTI = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 0
  %MS = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 1
  %FMT = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 2
  %LANG = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 3
  %FILL = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 4
  %BLANK = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 5
  %ly = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 6
  %dx = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 7
  %fs = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 8
  %td = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 9
  %tmp = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 10
  %pos = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 11
  %f = getelementptr inbounds %DT_TO_STRF_interface, %DT_TO_STRF_interface* %0, i32 0, i32 12
  %DT_TO_STRF = alloca [81 x i8], align 1
  %1 = bitcast [2 x i8]* %FILL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @DT_TO_STRF.FILL__init, i32 0, i32 0), i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 2), i1 false)
  %2 = bitcast [2 x i8]* %BLANK to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %2, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @DT_TO_STRF.BLANK__init, i32 0, i32 0), i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 2), i1 false)
  store i16 0, i16* %ly, align 2
  store i64 0, i64* %dx, align 4
  %3 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %3, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 11), i1 false)
  store i64 0, i64* %td, align 4
  store i16 0, i16* %tmp, align 2
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %f, align 2
  %4 = bitcast [81 x i8]* %DT_TO_STRF to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %4, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 81), i1 false)
  %load_LANG = load i16, i16* %LANG, align 2
  %5 = sext i16 %load_LANG to i32
  %tmpVar = icmp slt i32 %5, 1
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_ = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 0), align 2
  store i16 %load_, i16* %ly, align 2
  br label %continue

else:                                             ; preds = %entry
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %condition_body
  %DT_TO_DATE_instance = alloca %DT_TO_DATE_interface, align 8
  br label %input5

input:                                            ; preds = %else
  %6 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_2 = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 1), align 2
  %7 = sext i16 %load_2 to i64
  store i64 %7, i64* %6, align 4
  %8 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_LANG3 = load i16, i16* %LANG, align 2
  %9 = sext i16 %load_LANG3 to i64
  store i64 %9, i64* %8, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %10 = trunc i64 %call4 to i16
  store i16 %10, i16* %ly, align 2
  br label %continue

input5:                                           ; preds = %continue
  %11 = getelementptr inbounds %DT_TO_DATE_interface, %DT_TO_DATE_interface* %DT_TO_DATE_instance, i32 0, i32 0
  %load_DTI = load i64, i64* %DTI, align 4
  store i64 %load_DTI, i64* %11, align 4
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i64 @DT_TO_DATE(%DT_TO_DATE_interface* %DT_TO_DATE_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  store i64 %call9, i64* %dx, align 4
  %DT_TO_TOD_instance = alloca %DT_TO_TOD_interface, align 8
  br label %input10

input10:                                          ; preds = %continue8
  %12 = getelementptr inbounds %DT_TO_TOD_interface, %DT_TO_TOD_interface* %DT_TO_TOD_instance, i32 0, i32 0
  %load_DTI14 = load i64, i64* %DTI, align 4
  store i64 %load_DTI14, i64* %12, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call15 = call i64 @DT_TO_TOD(%DT_TO_TOD_interface* %DT_TO_TOD_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  store i64 %call15, i64* %td, align 4
  %13 = bitcast [81 x i8]* %DT_TO_STRF to i8*
  %14 = bitcast [81 x i8]* %FMT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %13, i8* align 1 %14, i32 80, i1 false)
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input16

input16:                                          ; preds = %continue13
  %15 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %16 = bitcast [1024 x i8]* %15 to i8*
  %17 = bitcast [81 x i8]* %DT_TO_STRF to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %16, i8* align 1 %17, i32 81, i1 false)
  %18 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %19 = bitcast [1024 x i8]* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %19, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_3, i32 0, i32 0), i32 2, i1 false)
  br label %call17

call17:                                           ; preds = %input16
  %call20 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  store i16 %call20, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %continue19, %continue504
  %load_pos = load i16, i16* %pos, align 2
  %20 = sext i16 %load_pos to i32
  %tmpVar22 = icmp sgt i32 %20, 0
  br i1 %tmpVar22, label %while_body, label %continue21

while_body:                                       ; preds = %condition_check
  %CODE_instance = alloca %CODE_interface, align 8
  br label %input23

continue21:                                       ; preds = %condition_check
  %DT_TO_STRF_ret = load [81 x i8], [81 x i8]* %DT_TO_STRF, align 1
  ret [81 x i8] %DT_TO_STRF_ret

input23:                                          ; preds = %while_body
  %21 = getelementptr inbounds %CODE_interface, %CODE_interface* %CODE_instance, i32 0, i32 0
  %22 = bitcast [251 x i8]* %21 to i8*
  %23 = bitcast [81 x i8]* %DT_TO_STRF to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %22, i8* align 1 %23, i32 81, i1 false)
  %24 = getelementptr inbounds %CODE_interface, %CODE_interface* %CODE_instance, i32 0, i32 1
  %load_pos27 = load i16, i16* %pos, align 2
  %25 = sext i16 %load_pos27 to i32
  %tmpVar28 = add i32 %25, 1
  %26 = trunc i32 %tmpVar28 to i16
  store i16 %26, i16* %24, align 2
  br label %call24

call24:                                           ; preds = %input23
  %call29 = call i8 @CODE(%CODE_interface* %CODE_instance)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %27 = zext i8 %call29 to i16
  store i16 %27, i16* %f, align 2
  %28 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %28, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  %load_f = load i16, i16* %f, align 2
  switch i16 %load_f, label %else31 [
    i16 65, label %case
    i16 66, label %case42
    i16 67, label %case61
    i16 68, label %case74
    i16 69, label %case101
    i16 70, label %case114
    i16 71, label %case129
    i16 72, label %case142
    i16 73, label %case171
    i16 74, label %case184
    i16 75, label %case198
    i16 76, label %case213
    i16 77, label %case218
    i16 78, label %case231
    i16 79, label %case260
    i16 80, label %case279
    i16 81, label %case314
    i16 82, label %case327
    i16 83, label %case356
    i16 84, label %case374
    i16 85, label %case409
    i16 86, label %case416
    i16 87, label %case436
    i16 88, label %case465
  ]

case:                                             ; preds = %continue26
  %INT_TO_STRING_instance = alloca %INT_TO_STRING_interface, align 8
  br label %input32

case42:                                           ; preds = %continue26
  %RIGHT_instance = alloca %RIGHT_interface, align 8
  br label %input43

case61:                                           ; preds = %continue26
  %INT_TO_STRING_instance62 = alloca %INT_TO_STRING_interface, align 8
  br label %input63

case74:                                           ; preds = %continue26
  %INT_TO_STRING_instance75 = alloca %INT_TO_STRING_interface, align 8
  br label %input76

case101:                                          ; preds = %continue26
  %MONTH_TO_STRING_instance = alloca %MONTH_TO_STRING_interface, align 8
  br label %input102

case114:                                          ; preds = %continue26
  %MONTH_TO_STRING_instance115 = alloca %MONTH_TO_STRING_interface, align 8
  br label %input116

case129:                                          ; preds = %continue26
  %INT_TO_STRING_instance130 = alloca %INT_TO_STRING_interface, align 8
  br label %input131

case142:                                          ; preds = %continue26
  %INT_TO_STRING_instance143 = alloca %INT_TO_STRING_interface, align 8
  br label %input144

case171:                                          ; preds = %continue26
  %INT_TO_STRING_instance172 = alloca %INT_TO_STRING_interface, align 8
  br label %input173

case184:                                          ; preds = %continue26
  %WEEKDAY_TO_STRING_instance = alloca %WEEKDAY_TO_STRING_interface, align 8
  br label %input185

case198:                                          ; preds = %continue26
  %WEEKDAY_TO_STRING_instance199 = alloca %WEEKDAY_TO_STRING_interface, align 8
  br label %input200

case213:                                          ; preds = %continue26
  %load_td = load i64, i64* %td, align 4
  %tmpVar217 = icmp sge i64 %load_td, 43200000
  br i1 %tmpVar217, label %condition_body216, label %else214

case218:                                          ; preds = %continue26
  %INT_TO_STRING_instance219 = alloca %INT_TO_STRING_interface, align 8
  br label %input220

case231:                                          ; preds = %continue26
  %INT_TO_STRING_instance232 = alloca %INT_TO_STRING_interface, align 8
  br label %input233

case260:                                          ; preds = %continue26
  %HOUR_instance261 = alloca %HOUR_interface, align 8
  br label %input262

case279:                                          ; preds = %continue26
  %HOUR_instance280 = alloca %HOUR_interface, align 8
  br label %input281

case314:                                          ; preds = %continue26
  %INT_TO_STRING_instance315 = alloca %INT_TO_STRING_interface, align 8
  br label %input316

case327:                                          ; preds = %continue26
  %INT_TO_STRING_instance328 = alloca %INT_TO_STRING_interface, align 8
  br label %input329

case356:                                          ; preds = %continue26
  %INT_TO_STRING_instance357 = alloca %INT_TO_STRING_interface, align 8
  br label %input358

case374:                                          ; preds = %continue26
  %INT_TO_STRING_instance375 = alloca %INT_TO_STRING_interface, align 8
  br label %input376

case409:                                          ; preds = %continue26
  %INT_TO_STRING_instance410 = alloca %INT_TO_STRING_interface, align 8
  br label %input411

case416:                                          ; preds = %continue26
  %INT_TO_STRING_instance417 = alloca %INT_TO_STRING_interface, align 8
  br label %input418

case436:                                          ; preds = %continue26
  %INT_TO_STRING_instance437 = alloca %INT_TO_STRING_interface, align 8
  br label %input438

case465:                                          ; preds = %continue26
  %INT_TO_STRING_instance466 = alloca %INT_TO_STRING_interface, align 8
  br label %input467

else31:                                           ; preds = %continue26
  br label %continue30

continue30:                                       ; preds = %else31, %continue479, %continue450, %continue434, %continue414, %continue394, %continue361, %continue341, %continue319, %continue299, %continue276, %continue245, %continue223, %continue215, %continue203, %continue188, %continue176, %continue156, %continue134, %continue119, %continue105, %continue88, %continue66, %continue46, %continue35
  %REPLACE_instance = alloca %REPLACE_interface, align 8
  br label %input494

input32:                                          ; preds = %case
  %29 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance, i32 0, i32 0
  %YEAR_OF_DATE_instance = alloca %YEAR_OF_DATE_interface, align 8
  br label %input36

call33:                                           ; preds = %continue39
  %call41 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance)
  br label %output34

output34:                                         ; preds = %call33
  br label %continue35

continue35:                                       ; preds = %output34
  %30 = alloca [81 x i8], align 1
  store [81 x i8] %call41, [81 x i8]* %30, align 1
  %31 = bitcast [11 x i8]* %fs to i8*
  %32 = bitcast [81 x i8]* %30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %31, i8* align 1 %32, i32 10, i1 false)
  br label %continue30

input36:                                          ; preds = %input32
  %33 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance, i32 0, i32 0
  %load_dx = load i64, i64* %dx, align 4
  store i64 %load_dx, i64* %33, align 4
  br label %call37

call37:                                           ; preds = %input36
  %call40 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance)
  br label %output38

output38:                                         ; preds = %call37
  br label %continue39

continue39:                                       ; preds = %output38
  store i16 %call40, i16* %29, align 2
  br label %call33

input43:                                          ; preds = %case42
  %34 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 0
  %INT_TO_STRING_instance47 = alloca %INT_TO_STRING_interface, align 8
  br label %input48

call44:                                           ; preds = %continue51
  %call60 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance)
  br label %output45

output45:                                         ; preds = %call44
  br label %continue46

continue46:                                       ; preds = %output45
  %35 = alloca [1024 x i8], align 1
  store [1024 x i8] %call60, [1024 x i8]* %35, align 1
  %36 = bitcast [11 x i8]* %fs to i8*
  %37 = bitcast [1024 x i8]* %35 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %36, i8* align 1 %37, i32 10, i1 false)
  br label %continue30

input48:                                          ; preds = %input43
  %38 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance47, i32 0, i32 0
  %YEAR_OF_DATE_instance52 = alloca %YEAR_OF_DATE_interface, align 8
  br label %input53

call49:                                           ; preds = %continue56
  %call59 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance47)
  br label %output50

output50:                                         ; preds = %call49
  br label %continue51

continue51:                                       ; preds = %output50
  %39 = alloca [81 x i8], align 1
  store [81 x i8] %call59, [81 x i8]* %39, align 1
  %40 = bitcast [1024 x i8]* %34 to i8*
  %41 = bitcast [81 x i8]* %39 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %40, i8* align 1 %41, i32 81, i1 false)
  %42 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 1
  store i16 2, i16* %42, align 2
  br label %call44

input53:                                          ; preds = %input48
  %43 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance52, i32 0, i32 0
  %load_dx57 = load i64, i64* %dx, align 4
  store i64 %load_dx57, i64* %43, align 4
  br label %call54

call54:                                           ; preds = %input53
  %call58 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance52)
  br label %output55

output55:                                         ; preds = %call54
  br label %continue56

continue56:                                       ; preds = %output55
  store i16 %call58, i16* %38, align 2
  br label %call49

input63:                                          ; preds = %case61
  %44 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance62, i32 0, i32 0
  %MONTH_OF_DATE_instance = alloca %MONTH_OF_DATE_interface, align 8
  br label %input67

call64:                                           ; preds = %continue70
  %call73 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance62)
  br label %output65

output65:                                         ; preds = %call64
  br label %continue66

continue66:                                       ; preds = %output65
  %45 = alloca [81 x i8], align 1
  store [81 x i8] %call73, [81 x i8]* %45, align 1
  %46 = bitcast [11 x i8]* %fs to i8*
  %47 = bitcast [81 x i8]* %45 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %46, i8* align 1 %47, i32 10, i1 false)
  br label %continue30

input67:                                          ; preds = %input63
  %48 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance, i32 0, i32 0
  %load_dx71 = load i64, i64* %dx, align 4
  store i64 %load_dx71, i64* %48, align 4
  br label %call68

call68:                                           ; preds = %input67
  %call72 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance)
  br label %output69

output69:                                         ; preds = %call68
  br label %continue70

continue70:                                       ; preds = %output69
  store i16 %call72, i16* %44, align 2
  br label %call64

input76:                                          ; preds = %case74
  %49 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance75, i32 0, i32 0
  %MONTH_OF_DATE_instance80 = alloca %MONTH_OF_DATE_interface, align 8
  br label %input81

call77:                                           ; preds = %continue84
  %call87 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance75)
  br label %output78

output78:                                         ; preds = %call77
  br label %continue79

continue79:                                       ; preds = %output78
  %50 = alloca [81 x i8], align 1
  store [81 x i8] %call87, [81 x i8]* %50, align 1
  %51 = bitcast [11 x i8]* %fs to i8*
  %52 = bitcast [81 x i8]* %50 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %51, i8* align 1 %52, i32 10, i1 false)
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input90

input81:                                          ; preds = %input76
  %53 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance80, i32 0, i32 0
  %load_dx85 = load i64, i64* %dx, align 4
  store i64 %load_dx85, i64* %53, align 4
  br label %call82

call82:                                           ; preds = %input81
  %call86 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance80)
  br label %output83

output83:                                         ; preds = %call82
  br label %continue84

continue84:                                       ; preds = %output83
  store i16 %call86, i16* %49, align 2
  br label %call77

condition_body89:                                 ; preds = %continue93
  %CONCAT_instance = alloca %CONCAT_interface, align 8
  br label %input96

continue88:                                       ; preds = %continue99, %continue93
  br label %continue30

input90:                                          ; preds = %continue79
  %54 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %55 = bitcast [1024 x i8]* %54 to i8*
  %56 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %55, i8* align 1 %56, i32 11, i1 false)
  br label %call91

call91:                                           ; preds = %input90
  %call94 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output92

output92:                                         ; preds = %call91
  br label %continue93

continue93:                                       ; preds = %output92
  %57 = sext i16 %call94 to i32
  %tmpVar95 = icmp slt i32 %57, 2
  br i1 %tmpVar95, label %condition_body89, label %continue88

input96:                                          ; preds = %condition_body89
  %58 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 0
  %59 = bitcast [1024 x i8]* %58 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %59, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_12, i32 0, i32 0), i32 2, i1 false)
  %60 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 1
  %61 = bitcast [1024 x i8]* %60 to i8*
  %62 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %61, i8* align 1 %62, i32 11, i1 false)
  br label %call97

call97:                                           ; preds = %input96
  %call100 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance)
  br label %output98

output98:                                         ; preds = %call97
  br label %continue99

continue99:                                       ; preds = %output98
  %63 = alloca [1024 x i8], align 1
  store [1024 x i8] %call100, [1024 x i8]* %63, align 1
  %64 = bitcast [11 x i8]* %fs to i8*
  %65 = bitcast [1024 x i8]* %63 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %64, i8* align 1 %65, i32 10, i1 false)
  br label %continue88

input102:                                         ; preds = %case101
  %66 = getelementptr inbounds %MONTH_TO_STRING_interface, %MONTH_TO_STRING_interface* %MONTH_TO_STRING_instance, i32 0, i32 0
  %MONTH_OF_DATE_instance106 = alloca %MONTH_OF_DATE_interface, align 8
  br label %input107

call103:                                          ; preds = %continue110
  %call113 = call [11 x i8] @MONTH_TO_STRING(%MONTH_TO_STRING_interface* %MONTH_TO_STRING_instance)
  br label %output104

output104:                                        ; preds = %call103
  br label %continue105

continue105:                                      ; preds = %output104
  %67 = alloca [11 x i8], align 1
  store [11 x i8] %call113, [11 x i8]* %67, align 1
  %68 = bitcast [11 x i8]* %fs to i8*
  %69 = bitcast [11 x i8]* %67 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %68, i8* align 1 %69, i32 10, i1 false)
  br label %continue30

input107:                                         ; preds = %input102
  %70 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance106, i32 0, i32 0
  %load_dx111 = load i64, i64* %dx, align 4
  store i64 %load_dx111, i64* %70, align 4
  br label %call108

call108:                                          ; preds = %input107
  %call112 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance106)
  br label %output109

output109:                                        ; preds = %call108
  br label %continue110

continue110:                                      ; preds = %output109
  store i16 %call112, i16* %66, align 2
  %71 = getelementptr inbounds %MONTH_TO_STRING_interface, %MONTH_TO_STRING_interface* %MONTH_TO_STRING_instance, i32 0, i32 1
  %load_ly = load i16, i16* %ly, align 2
  store i16 %load_ly, i16* %71, align 2
  %72 = getelementptr inbounds %MONTH_TO_STRING_interface, %MONTH_TO_STRING_interface* %MONTH_TO_STRING_instance, i32 0, i32 2
  store i16 3, i16* %72, align 2
  br label %call103

input116:                                         ; preds = %case114
  %73 = getelementptr inbounds %MONTH_TO_STRING_interface, %MONTH_TO_STRING_interface* %MONTH_TO_STRING_instance115, i32 0, i32 0
  %MONTH_OF_DATE_instance120 = alloca %MONTH_OF_DATE_interface, align 8
  br label %input121

call117:                                          ; preds = %continue124
  %call128 = call [11 x i8] @MONTH_TO_STRING(%MONTH_TO_STRING_interface* %MONTH_TO_STRING_instance115)
  br label %output118

output118:                                        ; preds = %call117
  br label %continue119

continue119:                                      ; preds = %output118
  %74 = alloca [11 x i8], align 1
  store [11 x i8] %call128, [11 x i8]* %74, align 1
  %75 = bitcast [11 x i8]* %fs to i8*
  %76 = bitcast [11 x i8]* %74 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %75, i8* align 1 %76, i32 10, i1 false)
  br label %continue30

input121:                                         ; preds = %input116
  %77 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance120, i32 0, i32 0
  %load_dx125 = load i64, i64* %dx, align 4
  store i64 %load_dx125, i64* %77, align 4
  br label %call122

call122:                                          ; preds = %input121
  %call126 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance120)
  br label %output123

output123:                                        ; preds = %call122
  br label %continue124

continue124:                                      ; preds = %output123
  store i16 %call126, i16* %73, align 2
  %78 = getelementptr inbounds %MONTH_TO_STRING_interface, %MONTH_TO_STRING_interface* %MONTH_TO_STRING_instance115, i32 0, i32 1
  %load_ly127 = load i16, i16* %ly, align 2
  store i16 %load_ly127, i16* %78, align 2
  %79 = getelementptr inbounds %MONTH_TO_STRING_interface, %MONTH_TO_STRING_interface* %MONTH_TO_STRING_instance115, i32 0, i32 2
  store i16 0, i16* %79, align 2
  br label %call117

input131:                                         ; preds = %case129
  %80 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance130, i32 0, i32 0
  %DAY_OF_MONTH_instance = alloca %DAY_OF_MONTH_interface, align 8
  br label %input135

call132:                                          ; preds = %continue138
  %call141 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance130)
  br label %output133

output133:                                        ; preds = %call132
  br label %continue134

continue134:                                      ; preds = %output133
  %81 = alloca [81 x i8], align 1
  store [81 x i8] %call141, [81 x i8]* %81, align 1
  %82 = bitcast [11 x i8]* %fs to i8*
  %83 = bitcast [81 x i8]* %81 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %82, i8* align 1 %83, i32 10, i1 false)
  br label %continue30

input135:                                         ; preds = %input131
  %84 = getelementptr inbounds %DAY_OF_MONTH_interface, %DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance, i32 0, i32 0
  %load_dx139 = load i64, i64* %dx, align 4
  store i64 %load_dx139, i64* %84, align 4
  br label %call136

call136:                                          ; preds = %input135
  %call140 = call i16 @DAY_OF_MONTH(%DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance)
  br label %output137

output137:                                        ; preds = %call136
  br label %continue138

continue138:                                      ; preds = %output137
  store i16 %call140, i16* %80, align 2
  br label %call132

input144:                                         ; preds = %case142
  %85 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance143, i32 0, i32 0
  %DAY_OF_MONTH_instance148 = alloca %DAY_OF_MONTH_interface, align 8
  br label %input149

call145:                                          ; preds = %continue152
  %call155 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance143)
  br label %output146

output146:                                        ; preds = %call145
  br label %continue147

continue147:                                      ; preds = %output146
  %86 = alloca [81 x i8], align 1
  store [81 x i8] %call155, [81 x i8]* %86, align 1
  %87 = bitcast [11 x i8]* %fs to i8*
  %88 = bitcast [81 x i8]* %86 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %87, i8* align 1 %88, i32 10, i1 false)
  %LEN_instance158 = alloca %LEN_interface, align 8
  br label %input159

input149:                                         ; preds = %input144
  %89 = getelementptr inbounds %DAY_OF_MONTH_interface, %DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance148, i32 0, i32 0
  %load_dx153 = load i64, i64* %dx, align 4
  store i64 %load_dx153, i64* %89, align 4
  br label %call150

call150:                                          ; preds = %input149
  %call154 = call i16 @DAY_OF_MONTH(%DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance148)
  br label %output151

output151:                                        ; preds = %call150
  br label %continue152

continue152:                                      ; preds = %output151
  store i16 %call154, i16* %85, align 2
  br label %call145

condition_body157:                                ; preds = %continue162
  %CONCAT_instance165 = alloca %CONCAT_interface, align 8
  br label %input166

continue156:                                      ; preds = %continue169, %continue162
  br label %continue30

input159:                                         ; preds = %continue147
  %90 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance158, i32 0, i32 0
  %91 = bitcast [1024 x i8]* %90 to i8*
  %92 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %91, i8* align 1 %92, i32 11, i1 false)
  br label %call160

call160:                                          ; preds = %input159
  %call163 = call i16 @LEN(%LEN_interface* %LEN_instance158)
  br label %output161

output161:                                        ; preds = %call160
  br label %continue162

continue162:                                      ; preds = %output161
  %93 = sext i16 %call163 to i32
  %tmpVar164 = icmp slt i32 %93, 2
  br i1 %tmpVar164, label %condition_body157, label %continue156

input166:                                         ; preds = %condition_body157
  %94 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance165, i32 0, i32 0
  %95 = bitcast [1024 x i8]* %94 to i8*
  %96 = bitcast [2 x i8]* %FILL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %95, i8* align 1 %96, i32 2, i1 false)
  %97 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance165, i32 0, i32 1
  %98 = bitcast [1024 x i8]* %97 to i8*
  %99 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %98, i8* align 1 %99, i32 11, i1 false)
  br label %call167

call167:                                          ; preds = %input166
  %call170 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance165)
  br label %output168

output168:                                        ; preds = %call167
  br label %continue169

continue169:                                      ; preds = %output168
  %100 = alloca [1024 x i8], align 1
  store [1024 x i8] %call170, [1024 x i8]* %100, align 1
  %101 = bitcast [11 x i8]* %fs to i8*
  %102 = bitcast [1024 x i8]* %100 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %101, i8* align 1 %102, i32 10, i1 false)
  br label %continue156

input173:                                         ; preds = %case171
  %103 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance172, i32 0, i32 0
  %DAY_OF_WEEK_instance = alloca %DAY_OF_WEEK_interface, align 8
  br label %input177

call174:                                          ; preds = %continue180
  %call183 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance172)
  br label %output175

output175:                                        ; preds = %call174
  br label %continue176

continue176:                                      ; preds = %output175
  %104 = alloca [81 x i8], align 1
  store [81 x i8] %call183, [81 x i8]* %104, align 1
  %105 = bitcast [11 x i8]* %fs to i8*
  %106 = bitcast [81 x i8]* %104 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %105, i8* align 1 %106, i32 10, i1 false)
  br label %continue30

input177:                                         ; preds = %input173
  %107 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance, i32 0, i32 0
  %load_dx181 = load i64, i64* %dx, align 4
  store i64 %load_dx181, i64* %107, align 4
  br label %call178

call178:                                          ; preds = %input177
  %call182 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance)
  br label %output179

output179:                                        ; preds = %call178
  br label %continue180

continue180:                                      ; preds = %output179
  store i16 %call182, i16* %103, align 2
  br label %call174

input185:                                         ; preds = %case184
  %108 = getelementptr inbounds %WEEKDAY_TO_STRING_interface, %WEEKDAY_TO_STRING_interface* %WEEKDAY_TO_STRING_instance, i32 0, i32 0
  %DAY_OF_WEEK_instance189 = alloca %DAY_OF_WEEK_interface, align 8
  br label %input190

call186:                                          ; preds = %continue193
  %call197 = call [11 x i8] @WEEKDAY_TO_STRING(%WEEKDAY_TO_STRING_interface* %WEEKDAY_TO_STRING_instance)
  br label %output187

output187:                                        ; preds = %call186
  br label %continue188

continue188:                                      ; preds = %output187
  %109 = alloca [11 x i8], align 1
  store [11 x i8] %call197, [11 x i8]* %109, align 1
  %110 = bitcast [11 x i8]* %fs to i8*
  %111 = bitcast [11 x i8]* %109 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %110, i8* align 1 %111, i32 10, i1 false)
  br label %continue30

input190:                                         ; preds = %input185
  %112 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance189, i32 0, i32 0
  %load_dx194 = load i64, i64* %dx, align 4
  store i64 %load_dx194, i64* %112, align 4
  br label %call191

call191:                                          ; preds = %input190
  %call195 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance189)
  br label %output192

output192:                                        ; preds = %call191
  br label %continue193

continue193:                                      ; preds = %output192
  store i16 %call195, i16* %108, align 2
  %113 = getelementptr inbounds %WEEKDAY_TO_STRING_interface, %WEEKDAY_TO_STRING_interface* %WEEKDAY_TO_STRING_instance, i32 0, i32 1
  %load_ly196 = load i16, i16* %ly, align 2
  store i16 %load_ly196, i16* %113, align 2
  %114 = getelementptr inbounds %WEEKDAY_TO_STRING_interface, %WEEKDAY_TO_STRING_interface* %WEEKDAY_TO_STRING_instance, i32 0, i32 2
  store i16 2, i16* %114, align 2
  br label %call186

input200:                                         ; preds = %case198
  %115 = getelementptr inbounds %WEEKDAY_TO_STRING_interface, %WEEKDAY_TO_STRING_interface* %WEEKDAY_TO_STRING_instance199, i32 0, i32 0
  %DAY_OF_WEEK_instance204 = alloca %DAY_OF_WEEK_interface, align 8
  br label %input205

call201:                                          ; preds = %continue208
  %call212 = call [11 x i8] @WEEKDAY_TO_STRING(%WEEKDAY_TO_STRING_interface* %WEEKDAY_TO_STRING_instance199)
  br label %output202

output202:                                        ; preds = %call201
  br label %continue203

continue203:                                      ; preds = %output202
  %116 = alloca [11 x i8], align 1
  store [11 x i8] %call212, [11 x i8]* %116, align 1
  %117 = bitcast [11 x i8]* %fs to i8*
  %118 = bitcast [11 x i8]* %116 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %117, i8* align 1 %118, i32 10, i1 false)
  br label %continue30

input205:                                         ; preds = %input200
  %119 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance204, i32 0, i32 0
  %load_dx209 = load i64, i64* %dx, align 4
  store i64 %load_dx209, i64* %119, align 4
  br label %call206

call206:                                          ; preds = %input205
  %call210 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance204)
  br label %output207

output207:                                        ; preds = %call206
  br label %continue208

continue208:                                      ; preds = %output207
  store i16 %call210, i16* %115, align 2
  %120 = getelementptr inbounds %WEEKDAY_TO_STRING_interface, %WEEKDAY_TO_STRING_interface* %WEEKDAY_TO_STRING_instance199, i32 0, i32 1
  %load_ly211 = load i16, i16* %ly, align 2
  store i16 %load_ly211, i16* %120, align 2
  %121 = getelementptr inbounds %WEEKDAY_TO_STRING_interface, %WEEKDAY_TO_STRING_interface* %WEEKDAY_TO_STRING_instance199, i32 0, i32 2
  store i16 0, i16* %121, align 2
  br label %call201

condition_body216:                                ; preds = %case213
  %122 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %122, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_27, i32 0, i32 0), i32 3, i1 false)
  br label %continue215

else214:                                          ; preds = %case213
  %123 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %123, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_19, i32 0, i32 0), i32 3, i1 false)
  br label %continue215

continue215:                                      ; preds = %else214, %condition_body216
  br label %continue30

input220:                                         ; preds = %case218
  %124 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance219, i32 0, i32 0
  %HOUR_instance = alloca %HOUR_interface, align 8
  br label %input224

call221:                                          ; preds = %continue227
  %call230 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance219)
  br label %output222

output222:                                        ; preds = %call221
  br label %continue223

continue223:                                      ; preds = %output222
  %125 = alloca [81 x i8], align 1
  store [81 x i8] %call230, [81 x i8]* %125, align 1
  %126 = bitcast [11 x i8]* %fs to i8*
  %127 = bitcast [81 x i8]* %125 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %126, i8* align 1 %127, i32 10, i1 false)
  br label %continue30

input224:                                         ; preds = %input220
  %128 = getelementptr inbounds %HOUR_interface, %HOUR_interface* %HOUR_instance, i32 0, i32 0
  %load_td228 = load i64, i64* %td, align 4
  store i64 %load_td228, i64* %128, align 4
  br label %call225

call225:                                          ; preds = %input224
  %call229 = call i16 @HOUR(%HOUR_interface* %HOUR_instance)
  br label %output226

output226:                                        ; preds = %call225
  br label %continue227

continue227:                                      ; preds = %output226
  store i16 %call229, i16* %124, align 2
  br label %call221

input233:                                         ; preds = %case231
  %129 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance232, i32 0, i32 0
  %HOUR_instance237 = alloca %HOUR_interface, align 8
  br label %input238

call234:                                          ; preds = %continue241
  %call244 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance232)
  br label %output235

output235:                                        ; preds = %call234
  br label %continue236

continue236:                                      ; preds = %output235
  %130 = alloca [81 x i8], align 1
  store [81 x i8] %call244, [81 x i8]* %130, align 1
  %131 = bitcast [11 x i8]* %fs to i8*
  %132 = bitcast [81 x i8]* %130 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %131, i8* align 1 %132, i32 10, i1 false)
  %LEN_instance247 = alloca %LEN_interface, align 8
  br label %input248

input238:                                         ; preds = %input233
  %133 = getelementptr inbounds %HOUR_interface, %HOUR_interface* %HOUR_instance237, i32 0, i32 0
  %load_td242 = load i64, i64* %td, align 4
  store i64 %load_td242, i64* %133, align 4
  br label %call239

call239:                                          ; preds = %input238
  %call243 = call i16 @HOUR(%HOUR_interface* %HOUR_instance237)
  br label %output240

output240:                                        ; preds = %call239
  br label %continue241

continue241:                                      ; preds = %output240
  store i16 %call243, i16* %129, align 2
  br label %call234

condition_body246:                                ; preds = %continue251
  %CONCAT_instance254 = alloca %CONCAT_interface, align 8
  br label %input255

continue245:                                      ; preds = %continue258, %continue251
  br label %continue30

input248:                                         ; preds = %continue236
  %134 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance247, i32 0, i32 0
  %135 = bitcast [1024 x i8]* %134 to i8*
  %136 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %135, i8* align 1 %136, i32 11, i1 false)
  br label %call249

call249:                                          ; preds = %input248
  %call252 = call i16 @LEN(%LEN_interface* %LEN_instance247)
  br label %output250

output250:                                        ; preds = %call249
  br label %continue251

continue251:                                      ; preds = %output250
  %137 = sext i16 %call252 to i32
  %tmpVar253 = icmp slt i32 %137, 2
  br i1 %tmpVar253, label %condition_body246, label %continue245

input255:                                         ; preds = %condition_body246
  %138 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance254, i32 0, i32 0
  %139 = bitcast [1024 x i8]* %138 to i8*
  %140 = bitcast [2 x i8]* %FILL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %139, i8* align 1 %140, i32 2, i1 false)
  %141 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance254, i32 0, i32 1
  %142 = bitcast [1024 x i8]* %141 to i8*
  %143 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %142, i8* align 1 %143, i32 11, i1 false)
  br label %call256

call256:                                          ; preds = %input255
  %call259 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance254)
  br label %output257

output257:                                        ; preds = %call256
  br label %continue258

continue258:                                      ; preds = %output257
  %144 = alloca [1024 x i8], align 1
  store [1024 x i8] %call259, [1024 x i8]* %144, align 1
  %145 = bitcast [11 x i8]* %fs to i8*
  %146 = bitcast [1024 x i8]* %144 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %145, i8* align 1 %146, i32 10, i1 false)
  br label %continue245

input262:                                         ; preds = %case260
  %147 = getelementptr inbounds %HOUR_interface, %HOUR_interface* %HOUR_instance261, i32 0, i32 0
  %load_td266 = load i64, i64* %td, align 4
  store i64 %load_td266, i64* %147, align 4
  br label %call263

call263:                                          ; preds = %input262
  %call267 = call i16 @HOUR(%HOUR_interface* %HOUR_instance261)
  br label %output264

output264:                                        ; preds = %call263
  br label %continue265

continue265:                                      ; preds = %output264
  %148 = sext i16 %call267 to i32
  %tmpVar268 = srem i32 %148, 12
  %149 = trunc i32 %tmpVar268 to i16
  store i16 %149, i16* %tmp, align 2
  %load_tmp = load i16, i16* %tmp, align 2
  %150 = sext i16 %load_tmp to i32
  %tmpVar271 = icmp eq i32 %150, 0
  br i1 %tmpVar271, label %condition_body270, label %continue269

condition_body270:                                ; preds = %continue265
  store i16 12, i16* %tmp, align 2
  br label %continue269

continue269:                                      ; preds = %condition_body270, %continue265
  %INT_TO_STRING_instance272 = alloca %INT_TO_STRING_interface, align 8
  br label %input273

input273:                                         ; preds = %continue269
  %151 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance272, i32 0, i32 0
  %load_tmp277 = load i16, i16* %tmp, align 2
  store i16 %load_tmp277, i16* %151, align 2
  br label %call274

call274:                                          ; preds = %input273
  %call278 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance272)
  br label %output275

output275:                                        ; preds = %call274
  br label %continue276

continue276:                                      ; preds = %output275
  %152 = alloca [81 x i8], align 1
  store [81 x i8] %call278, [81 x i8]* %152, align 1
  %153 = bitcast [11 x i8]* %fs to i8*
  %154 = bitcast [81 x i8]* %152 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %153, i8* align 1 %154, i32 10, i1 false)
  br label %continue30

input281:                                         ; preds = %case279
  %155 = getelementptr inbounds %HOUR_interface, %HOUR_interface* %HOUR_instance280, i32 0, i32 0
  %load_td285 = load i64, i64* %td, align 4
  store i64 %load_td285, i64* %155, align 4
  br label %call282

call282:                                          ; preds = %input281
  %call286 = call i16 @HOUR(%HOUR_interface* %HOUR_instance280)
  br label %output283

output283:                                        ; preds = %call282
  br label %continue284

continue284:                                      ; preds = %output283
  %156 = sext i16 %call286 to i32
  %tmpVar287 = srem i32 %156, 12
  %157 = trunc i32 %tmpVar287 to i16
  store i16 %157, i16* %tmp, align 2
  %load_tmp290 = load i16, i16* %tmp, align 2
  %158 = sext i16 %load_tmp290 to i32
  %tmpVar291 = icmp eq i32 %158, 0
  br i1 %tmpVar291, label %condition_body289, label %continue288

condition_body289:                                ; preds = %continue284
  store i16 12, i16* %tmp, align 2
  br label %continue288

continue288:                                      ; preds = %condition_body289, %continue284
  %INT_TO_STRING_instance292 = alloca %INT_TO_STRING_interface, align 8
  br label %input293

input293:                                         ; preds = %continue288
  %159 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance292, i32 0, i32 0
  %load_tmp297 = load i16, i16* %tmp, align 2
  store i16 %load_tmp297, i16* %159, align 2
  br label %call294

call294:                                          ; preds = %input293
  %call298 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance292)
  br label %output295

output295:                                        ; preds = %call294
  br label %continue296

continue296:                                      ; preds = %output295
  %160 = alloca [81 x i8], align 1
  store [81 x i8] %call298, [81 x i8]* %160, align 1
  %161 = bitcast [11 x i8]* %fs to i8*
  %162 = bitcast [81 x i8]* %160 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %161, i8* align 1 %162, i32 10, i1 false)
  %LEN_instance301 = alloca %LEN_interface, align 8
  br label %input302

condition_body300:                                ; preds = %continue305
  %CONCAT_instance308 = alloca %CONCAT_interface, align 8
  br label %input309

continue299:                                      ; preds = %continue312, %continue305
  br label %continue30

input302:                                         ; preds = %continue296
  %163 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance301, i32 0, i32 0
  %164 = bitcast [1024 x i8]* %163 to i8*
  %165 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %164, i8* align 1 %165, i32 11, i1 false)
  br label %call303

call303:                                          ; preds = %input302
  %call306 = call i16 @LEN(%LEN_interface* %LEN_instance301)
  br label %output304

output304:                                        ; preds = %call303
  br label %continue305

continue305:                                      ; preds = %output304
  %166 = sext i16 %call306 to i32
  %tmpVar307 = icmp slt i32 %166, 2
  br i1 %tmpVar307, label %condition_body300, label %continue299

input309:                                         ; preds = %condition_body300
  %167 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance308, i32 0, i32 0
  %168 = bitcast [1024 x i8]* %167 to i8*
  %169 = bitcast [2 x i8]* %FILL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %168, i8* align 1 %169, i32 2, i1 false)
  %170 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance308, i32 0, i32 1
  %171 = bitcast [1024 x i8]* %170 to i8*
  %172 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %171, i8* align 1 %172, i32 11, i1 false)
  br label %call310

call310:                                          ; preds = %input309
  %call313 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance308)
  br label %output311

output311:                                        ; preds = %call310
  br label %continue312

continue312:                                      ; preds = %output311
  %173 = alloca [1024 x i8], align 1
  store [1024 x i8] %call313, [1024 x i8]* %173, align 1
  %174 = bitcast [11 x i8]* %fs to i8*
  %175 = bitcast [1024 x i8]* %173 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %174, i8* align 1 %175, i32 10, i1 false)
  br label %continue299

input316:                                         ; preds = %case314
  %176 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance315, i32 0, i32 0
  %MINUTE_instance = alloca %MINUTE_interface, align 8
  br label %input320

call317:                                          ; preds = %continue323
  %call326 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance315)
  br label %output318

output318:                                        ; preds = %call317
  br label %continue319

continue319:                                      ; preds = %output318
  %177 = alloca [81 x i8], align 1
  store [81 x i8] %call326, [81 x i8]* %177, align 1
  %178 = bitcast [11 x i8]* %fs to i8*
  %179 = bitcast [81 x i8]* %177 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %178, i8* align 1 %179, i32 10, i1 false)
  br label %continue30

input320:                                         ; preds = %input316
  %180 = getelementptr inbounds %MINUTE_interface, %MINUTE_interface* %MINUTE_instance, i32 0, i32 0
  %load_td324 = load i64, i64* %td, align 4
  store i64 %load_td324, i64* %180, align 4
  br label %call321

call321:                                          ; preds = %input320
  %call325 = call i16 @MINUTE(%MINUTE_interface* %MINUTE_instance)
  br label %output322

output322:                                        ; preds = %call321
  br label %continue323

continue323:                                      ; preds = %output322
  store i16 %call325, i16* %176, align 2
  br label %call317

input329:                                         ; preds = %case327
  %181 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance328, i32 0, i32 0
  %MINUTE_instance333 = alloca %MINUTE_interface, align 8
  br label %input334

call330:                                          ; preds = %continue337
  %call340 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance328)
  br label %output331

output331:                                        ; preds = %call330
  br label %continue332

continue332:                                      ; preds = %output331
  %182 = alloca [81 x i8], align 1
  store [81 x i8] %call340, [81 x i8]* %182, align 1
  %183 = bitcast [11 x i8]* %fs to i8*
  %184 = bitcast [81 x i8]* %182 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %183, i8* align 1 %184, i32 10, i1 false)
  %LEN_instance343 = alloca %LEN_interface, align 8
  br label %input344

input334:                                         ; preds = %input329
  %185 = getelementptr inbounds %MINUTE_interface, %MINUTE_interface* %MINUTE_instance333, i32 0, i32 0
  %load_td338 = load i64, i64* %td, align 4
  store i64 %load_td338, i64* %185, align 4
  br label %call335

call335:                                          ; preds = %input334
  %call339 = call i16 @MINUTE(%MINUTE_interface* %MINUTE_instance333)
  br label %output336

output336:                                        ; preds = %call335
  br label %continue337

continue337:                                      ; preds = %output336
  store i16 %call339, i16* %181, align 2
  br label %call330

condition_body342:                                ; preds = %continue347
  %CONCAT_instance350 = alloca %CONCAT_interface, align 8
  br label %input351

continue341:                                      ; preds = %continue354, %continue347
  br label %continue30

input344:                                         ; preds = %continue332
  %186 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance343, i32 0, i32 0
  %187 = bitcast [1024 x i8]* %186 to i8*
  %188 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %187, i8* align 1 %188, i32 11, i1 false)
  br label %call345

call345:                                          ; preds = %input344
  %call348 = call i16 @LEN(%LEN_interface* %LEN_instance343)
  br label %output346

output346:                                        ; preds = %call345
  br label %continue347

continue347:                                      ; preds = %output346
  %189 = sext i16 %call348 to i32
  %tmpVar349 = icmp slt i32 %189, 2
  br i1 %tmpVar349, label %condition_body342, label %continue341

input351:                                         ; preds = %condition_body342
  %190 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance350, i32 0, i32 0
  %191 = bitcast [1024 x i8]* %190 to i8*
  %192 = bitcast [2 x i8]* %FILL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %191, i8* align 1 %192, i32 2, i1 false)
  %193 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance350, i32 0, i32 1
  %194 = bitcast [1024 x i8]* %193 to i8*
  %195 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %194, i8* align 1 %195, i32 11, i1 false)
  br label %call352

call352:                                          ; preds = %input351
  %call355 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance350)
  br label %output353

output353:                                        ; preds = %call352
  br label %continue354

continue354:                                      ; preds = %output353
  %196 = alloca [1024 x i8], align 1
  store [1024 x i8] %call355, [1024 x i8]* %196, align 1
  %197 = bitcast [11 x i8]* %fs to i8*
  %198 = bitcast [1024 x i8]* %196 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %197, i8* align 1 %198, i32 10, i1 false)
  br label %continue341

input358:                                         ; preds = %case356
  %199 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance357, i32 0, i32 0
  %REAL_TO_INT_instance = alloca %REAL_TO_INT_interface, align 8
  br label %input362

call359:                                          ; preds = %continue365
  %call373 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance357)
  br label %output360

output360:                                        ; preds = %call359
  br label %continue361

continue361:                                      ; preds = %output360
  %200 = alloca [81 x i8], align 1
  store [81 x i8] %call373, [81 x i8]* %200, align 1
  %201 = bitcast [11 x i8]* %fs to i8*
  %202 = bitcast [81 x i8]* %200 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %201, i8* align 1 %202, i32 10, i1 false)
  br label %continue30

input362:                                         ; preds = %input358
  %203 = getelementptr inbounds %REAL_TO_INT_interface, %REAL_TO_INT_interface* %REAL_TO_INT_instance, i32 0, i32 0
  %SECOND_instance = alloca %SECOND_interface, align 8
  br label %input366

call363:                                          ; preds = %continue369
  %call372 = call i16 @REAL_TO_INT(%REAL_TO_INT_interface* %REAL_TO_INT_instance)
  br label %output364

output364:                                        ; preds = %call363
  br label %continue365

continue365:                                      ; preds = %output364
  store i16 %call372, i16* %199, align 2
  br label %call359

input366:                                         ; preds = %input362
  %204 = getelementptr inbounds %SECOND_interface, %SECOND_interface* %SECOND_instance, i32 0, i32 0
  %load_td370 = load i64, i64* %td, align 4
  store i64 %load_td370, i64* %204, align 4
  br label %call367

call367:                                          ; preds = %input366
  %call371 = call float @SECOND(%SECOND_interface* %SECOND_instance)
  br label %output368

output368:                                        ; preds = %call367
  br label %continue369

continue369:                                      ; preds = %output368
  store float %call371, float* %203, align 4
  br label %call363

input376:                                         ; preds = %case374
  %205 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance375, i32 0, i32 0
  %REAL_TO_INT_instance380 = alloca %REAL_TO_INT_interface, align 8
  br label %input381

call377:                                          ; preds = %continue384
  %call393 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance375)
  br label %output378

output378:                                        ; preds = %call377
  br label %continue379

continue379:                                      ; preds = %output378
  %206 = alloca [81 x i8], align 1
  store [81 x i8] %call393, [81 x i8]* %206, align 1
  %207 = bitcast [11 x i8]* %fs to i8*
  %208 = bitcast [81 x i8]* %206 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %207, i8* align 1 %208, i32 10, i1 false)
  %LEN_instance396 = alloca %LEN_interface, align 8
  br label %input397

input381:                                         ; preds = %input376
  %209 = getelementptr inbounds %REAL_TO_INT_interface, %REAL_TO_INT_interface* %REAL_TO_INT_instance380, i32 0, i32 0
  %SECOND_instance385 = alloca %SECOND_interface, align 8
  br label %input386

call382:                                          ; preds = %continue389
  %call392 = call i16 @REAL_TO_INT(%REAL_TO_INT_interface* %REAL_TO_INT_instance380)
  br label %output383

output383:                                        ; preds = %call382
  br label %continue384

continue384:                                      ; preds = %output383
  store i16 %call392, i16* %205, align 2
  br label %call377

input386:                                         ; preds = %input381
  %210 = getelementptr inbounds %SECOND_interface, %SECOND_interface* %SECOND_instance385, i32 0, i32 0
  %load_td390 = load i64, i64* %td, align 4
  store i64 %load_td390, i64* %210, align 4
  br label %call387

call387:                                          ; preds = %input386
  %call391 = call float @SECOND(%SECOND_interface* %SECOND_instance385)
  br label %output388

output388:                                        ; preds = %call387
  br label %continue389

continue389:                                      ; preds = %output388
  store float %call391, float* %209, align 4
  br label %call382

condition_body395:                                ; preds = %continue400
  %CONCAT_instance403 = alloca %CONCAT_interface, align 8
  br label %input404

continue394:                                      ; preds = %continue407, %continue400
  br label %continue30

input397:                                         ; preds = %continue379
  %211 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance396, i32 0, i32 0
  %212 = bitcast [1024 x i8]* %211 to i8*
  %213 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %212, i8* align 1 %213, i32 11, i1 false)
  br label %call398

call398:                                          ; preds = %input397
  %call401 = call i16 @LEN(%LEN_interface* %LEN_instance396)
  br label %output399

output399:                                        ; preds = %call398
  br label %continue400

continue400:                                      ; preds = %output399
  %214 = sext i16 %call401 to i32
  %tmpVar402 = icmp slt i32 %214, 2
  br i1 %tmpVar402, label %condition_body395, label %continue394

input404:                                         ; preds = %condition_body395
  %215 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance403, i32 0, i32 0
  %216 = bitcast [1024 x i8]* %215 to i8*
  %217 = bitcast [2 x i8]* %FILL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %216, i8* align 1 %217, i32 2, i1 false)
  %218 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance403, i32 0, i32 1
  %219 = bitcast [1024 x i8]* %218 to i8*
  %220 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %219, i8* align 1 %220, i32 11, i1 false)
  br label %call405

call405:                                          ; preds = %input404
  %call408 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance403)
  br label %output406

output406:                                        ; preds = %call405
  br label %continue407

continue407:                                      ; preds = %output406
  %221 = alloca [1024 x i8], align 1
  store [1024 x i8] %call408, [1024 x i8]* %221, align 1
  %222 = bitcast [11 x i8]* %fs to i8*
  %223 = bitcast [1024 x i8]* %221 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %222, i8* align 1 %223, i32 10, i1 false)
  br label %continue394

input411:                                         ; preds = %case409
  %224 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance410, i32 0, i32 0
  %load_MS = load i16, i16* %MS, align 2
  store i16 %load_MS, i16* %224, align 2
  br label %call412

call412:                                          ; preds = %input411
  %call415 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance410)
  br label %output413

output413:                                        ; preds = %call412
  br label %continue414

continue414:                                      ; preds = %output413
  %225 = alloca [81 x i8], align 1
  store [81 x i8] %call415, [81 x i8]* %225, align 1
  %226 = bitcast [11 x i8]* %fs to i8*
  %227 = bitcast [81 x i8]* %225 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %226, i8* align 1 %227, i32 10, i1 false)
  br label %continue30

input418:                                         ; preds = %case416
  %228 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance417, i32 0, i32 0
  %load_MS422 = load i16, i16* %MS, align 2
  store i16 %load_MS422, i16* %228, align 2
  br label %call419

call419:                                          ; preds = %input418
  %call423 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance417)
  br label %output420

output420:                                        ; preds = %call419
  br label %continue421

continue421:                                      ; preds = %output420
  %229 = alloca [81 x i8], align 1
  store [81 x i8] %call423, [81 x i8]* %229, align 1
  %230 = bitcast [11 x i8]* %fs to i8*
  %231 = bitcast [81 x i8]* %229 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %230, i8* align 1 %231, i32 10, i1 false)
  %CONCAT_instance424 = alloca %CONCAT_interface, align 8
  br label %input425

input425:                                         ; preds = %continue421
  %232 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance424, i32 0, i32 0
  %233 = bitcast [1024 x i8]* %232 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %233, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_13, i32 0, i32 0), i32 3, i1 false)
  %234 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance424, i32 0, i32 1
  %235 = bitcast [1024 x i8]* %234 to i8*
  %236 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %235, i8* align 1 %236, i32 11, i1 false)
  br label %call426

call426:                                          ; preds = %input425
  %call429 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance424)
  br label %output427

output427:                                        ; preds = %call426
  br label %continue428

continue428:                                      ; preds = %output427
  %237 = alloca [1024 x i8], align 1
  store [1024 x i8] %call429, [1024 x i8]* %237, align 1
  %238 = bitcast [11 x i8]* %fs to i8*
  %239 = bitcast [1024 x i8]* %237 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %238, i8* align 1 %239, i32 10, i1 false)
  %RIGHT_instance430 = alloca %RIGHT_interface, align 8
  br label %input431

input431:                                         ; preds = %continue428
  %240 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance430, i32 0, i32 0
  %241 = bitcast [1024 x i8]* %240 to i8*
  %242 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %241, i8* align 1 %242, i32 11, i1 false)
  %243 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance430, i32 0, i32 1
  store i16 3, i16* %243, align 2
  br label %call432

call432:                                          ; preds = %input431
  %call435 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance430)
  br label %output433

output433:                                        ; preds = %call432
  br label %continue434

continue434:                                      ; preds = %output433
  %244 = alloca [1024 x i8], align 1
  store [1024 x i8] %call435, [1024 x i8]* %244, align 1
  %245 = bitcast [11 x i8]* %fs to i8*
  %246 = bitcast [1024 x i8]* %244 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %245, i8* align 1 %246, i32 10, i1 false)
  br label %continue30

input438:                                         ; preds = %case436
  %247 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance437, i32 0, i32 0
  %DAY_OF_MONTH_instance442 = alloca %DAY_OF_MONTH_interface, align 8
  br label %input443

call439:                                          ; preds = %continue446
  %call449 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance437)
  br label %output440

output440:                                        ; preds = %call439
  br label %continue441

continue441:                                      ; preds = %output440
  %248 = alloca [81 x i8], align 1
  store [81 x i8] %call449, [81 x i8]* %248, align 1
  %249 = bitcast [11 x i8]* %fs to i8*
  %250 = bitcast [81 x i8]* %248 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %249, i8* align 1 %250, i32 10, i1 false)
  %LEN_instance452 = alloca %LEN_interface, align 8
  br label %input453

input443:                                         ; preds = %input438
  %251 = getelementptr inbounds %DAY_OF_MONTH_interface, %DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance442, i32 0, i32 0
  %load_dx447 = load i64, i64* %dx, align 4
  store i64 %load_dx447, i64* %251, align 4
  br label %call444

call444:                                          ; preds = %input443
  %call448 = call i16 @DAY_OF_MONTH(%DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance442)
  br label %output445

output445:                                        ; preds = %call444
  br label %continue446

continue446:                                      ; preds = %output445
  store i16 %call448, i16* %247, align 2
  br label %call439

condition_body451:                                ; preds = %continue456
  %CONCAT_instance459 = alloca %CONCAT_interface, align 8
  br label %input460

continue450:                                      ; preds = %continue463, %continue456
  br label %continue30

input453:                                         ; preds = %continue441
  %252 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance452, i32 0, i32 0
  %253 = bitcast [1024 x i8]* %252 to i8*
  %254 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %253, i8* align 1 %254, i32 11, i1 false)
  br label %call454

call454:                                          ; preds = %input453
  %call457 = call i16 @LEN(%LEN_interface* %LEN_instance452)
  br label %output455

output455:                                        ; preds = %call454
  br label %continue456

continue456:                                      ; preds = %output455
  %255 = sext i16 %call457 to i32
  %tmpVar458 = icmp slt i32 %255, 2
  br i1 %tmpVar458, label %condition_body451, label %continue450

input460:                                         ; preds = %condition_body451
  %256 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance459, i32 0, i32 0
  %257 = bitcast [1024 x i8]* %256 to i8*
  %258 = bitcast [2 x i8]* %BLANK to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %257, i8* align 1 %258, i32 2, i1 false)
  %259 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance459, i32 0, i32 1
  %260 = bitcast [1024 x i8]* %259 to i8*
  %261 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %260, i8* align 1 %261, i32 11, i1 false)
  br label %call461

call461:                                          ; preds = %input460
  %call464 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance459)
  br label %output462

output462:                                        ; preds = %call461
  br label %continue463

continue463:                                      ; preds = %output462
  %262 = alloca [1024 x i8], align 1
  store [1024 x i8] %call464, [1024 x i8]* %262, align 1
  %263 = bitcast [11 x i8]* %fs to i8*
  %264 = bitcast [1024 x i8]* %262 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %263, i8* align 1 %264, i32 10, i1 false)
  br label %continue450

input467:                                         ; preds = %case465
  %265 = getelementptr inbounds %INT_TO_STRING_interface, %INT_TO_STRING_interface* %INT_TO_STRING_instance466, i32 0, i32 0
  %MONTH_OF_DATE_instance471 = alloca %MONTH_OF_DATE_interface, align 8
  br label %input472

call468:                                          ; preds = %continue475
  %call478 = call [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface* %INT_TO_STRING_instance466)
  br label %output469

output469:                                        ; preds = %call468
  br label %continue470

continue470:                                      ; preds = %output469
  %266 = alloca [81 x i8], align 1
  store [81 x i8] %call478, [81 x i8]* %266, align 1
  %267 = bitcast [11 x i8]* %fs to i8*
  %268 = bitcast [81 x i8]* %266 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %267, i8* align 1 %268, i32 10, i1 false)
  %LEN_instance481 = alloca %LEN_interface, align 8
  br label %input482

input472:                                         ; preds = %input467
  %269 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance471, i32 0, i32 0
  %load_dx476 = load i64, i64* %dx, align 4
  store i64 %load_dx476, i64* %269, align 4
  br label %call473

call473:                                          ; preds = %input472
  %call477 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance471)
  br label %output474

output474:                                        ; preds = %call473
  br label %continue475

continue475:                                      ; preds = %output474
  store i16 %call477, i16* %265, align 2
  br label %call468

condition_body480:                                ; preds = %continue485
  %CONCAT_instance488 = alloca %CONCAT_interface, align 8
  br label %input489

continue479:                                      ; preds = %continue492, %continue485
  br label %continue30

input482:                                         ; preds = %continue470
  %270 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance481, i32 0, i32 0
  %271 = bitcast [1024 x i8]* %270 to i8*
  %272 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %271, i8* align 1 %272, i32 11, i1 false)
  br label %call483

call483:                                          ; preds = %input482
  %call486 = call i16 @LEN(%LEN_interface* %LEN_instance481)
  br label %output484

output484:                                        ; preds = %call483
  br label %continue485

continue485:                                      ; preds = %output484
  %273 = sext i16 %call486 to i32
  %tmpVar487 = icmp slt i32 %273, 2
  br i1 %tmpVar487, label %condition_body480, label %continue479

input489:                                         ; preds = %condition_body480
  %274 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance488, i32 0, i32 0
  %275 = bitcast [1024 x i8]* %274 to i8*
  %276 = bitcast [2 x i8]* %BLANK to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %275, i8* align 1 %276, i32 2, i1 false)
  %277 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance488, i32 0, i32 1
  %278 = bitcast [1024 x i8]* %277 to i8*
  %279 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %278, i8* align 1 %279, i32 11, i1 false)
  br label %call490

call490:                                          ; preds = %input489
  %call493 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance488)
  br label %output491

output491:                                        ; preds = %call490
  br label %continue492

continue492:                                      ; preds = %output491
  %280 = alloca [1024 x i8], align 1
  store [1024 x i8] %call493, [1024 x i8]* %280, align 1
  %281 = bitcast [11 x i8]* %fs to i8*
  %282 = bitcast [1024 x i8]* %280 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %281, i8* align 1 %282, i32 10, i1 false)
  br label %continue479

input494:                                         ; preds = %continue30
  %283 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 0
  %284 = bitcast [1024 x i8]* %283 to i8*
  %285 = bitcast [81 x i8]* %DT_TO_STRF to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %284, i8* align 1 %285, i32 81, i1 false)
  %286 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 1
  %287 = bitcast [1024 x i8]* %286 to i8*
  %288 = bitcast [11 x i8]* %fs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %287, i8* align 1 %288, i32 11, i1 false)
  %289 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 2
  store i16 2, i16* %289, align 2
  %290 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 3
  %load_pos498 = load i16, i16* %pos, align 2
  store i16 %load_pos498, i16* %290, align 2
  br label %call495

call495:                                          ; preds = %input494
  %call499 = call [1024 x i8] @REPLACE(%REPLACE_interface* %REPLACE_instance)
  br label %output496

output496:                                        ; preds = %call495
  br label %continue497

continue497:                                      ; preds = %output496
  %291 = alloca [1024 x i8], align 1
  store [1024 x i8] %call499, [1024 x i8]* %291, align 1
  %292 = bitcast [81 x i8]* %DT_TO_STRF to i8*
  %293 = bitcast [1024 x i8]* %291 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %292, i8* align 1 %293, i32 80, i1 false)
  %FIND_instance500 = alloca %FIND_interface, align 8
  br label %input501

input501:                                         ; preds = %continue497
  %294 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance500, i32 0, i32 0
  %295 = bitcast [1024 x i8]* %294 to i8*
  %296 = bitcast [81 x i8]* %DT_TO_STRF to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %295, i8* align 1 %296, i32 81, i1 false)
  %297 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance500, i32 0, i32 1
  %298 = bitcast [1024 x i8]* %297 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %298, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_3, i32 0, i32 0), i32 2, i1 false)
  br label %call502

call502:                                          ; preds = %input501
  %call505 = call i16 @FIND(%FIND_interface* %FIND_instance500)
  br label %output503

output503:                                        ; preds = %call502
  br label %continue504

continue504:                                      ; preds = %output503
  store i16 %call505, i16* %pos, align 2
  br label %condition_check
}

define [33 x i8] @DWORD_TO_STRB(%DWORD_TO_STRB_interface* %0) {
entry:
  %IN = getelementptr inbounds %DWORD_TO_STRB_interface, %DWORD_TO_STRB_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %DWORD_TO_STRB_interface, %DWORD_TO_STRB_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %DWORD_TO_STRB_interface, %DWORD_TO_STRB_interface* %0, i32 0, i32 2
  %DWORD_TO_STRB = alloca [33 x i8], align 1
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %i, align 2
  %1 = bitcast [33 x i8]* %DWORD_TO_STRB to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 33), i1 false)
  store [33 x i8]* %DWORD_TO_STRB, i8** %pt, align 8
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %entry
  %load_i = load i16, i16* %i, align 2
  %load_i1 = load i16, i16* %i, align 2
  %tmpVar = icmp sle i16 %load_i1, 32
  %2 = icmp ne i1 %tmpVar, false
  br i1 %2, label %7, label %8

for_body:                                         ; preds = %5
  %deref = load i8*, i8** %pt, align 8
  %BOOL_TO_BYTE_instance = alloca %BOOL_TO_BYTE_interface, align 8
  br label %input

increment:                                        ; preds = %continue14
  %tmpVar17 = add i16 %load_i, 1
  store i16 %tmpVar17, i16* %i, align 2
  br label %condition_check

continue:                                         ; preds = %5
  %deref18 = load i8*, i8** %pt, align 8
  store i8 0, i8* %deref18, align 1
  %DWORD_TO_STRB_ret = load [33 x i8], [33 x i8]* %DWORD_TO_STRB, align 1
  ret [33 x i8] %DWORD_TO_STRB_ret

3:                                                ; preds = %8
  %load_i4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_i4, 32
  %4 = icmp ne i1 %tmpVar5, false
  br i1 %4, label %11, label %12

5:                                                ; preds = %12, %8
  %6 = phi i1 [ %9, %8 ], [ %13, %12 ]
  br i1 %6, label %for_body, label %continue

7:                                                ; preds = %condition_check
  %load_i2 = load i16, i16* %i, align 2
  %tmpVar3 = icmp sge i16 %load_i2, 1
  br label %8

8:                                                ; preds = %7, %condition_check
  %9 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar3, %7 ]
  %10 = icmp ne i1 %9, false
  br i1 %10, label %5, label %3

11:                                               ; preds = %3
  %load_i6 = load i16, i16* %i, align 2
  %tmpVar7 = icmp sle i16 %load_i6, 1
  br label %12

12:                                               ; preds = %11, %3
  %13 = phi i1 [ %tmpVar5, %3 ], [ %tmpVar7, %11 ]
  br label %5

input:                                            ; preds = %for_body
  %14 = getelementptr inbounds %BOOL_TO_BYTE_interface, %BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance, i32 0, i32 0
  %load_in = load i32, i32* %IN, align 4
  %shift = lshr i32 %load_in, 31
  %15 = trunc i32 %shift to i8
  store i8 %15, i8* %14, align 1
  br label %call

call:                                             ; preds = %input
  %call9 = call i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface* %BOOL_TO_BYTE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue8

continue8:                                        ; preds = %output
  %16 = zext i8 %call9 to i32
  %tmpVar10 = add i32 %16, 48
  %17 = trunc i32 %tmpVar10 to i8
  store i8 %17, i8* %deref, align 1
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input11

input11:                                          ; preds = %continue8
  %18 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_in15 = load i32, i32* %IN, align 4
  %19 = zext i32 %load_in15 to i64
  store i64 %19, i64* %18, align 4
  %20 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 1, i16* %20, align 2
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %21 = trunc i64 %call16 to i32
  store i32 %21, i32* %IN, align 4
  %load_pt = load i8*, i8** %pt, align 8
  %access___DWORD_TO_STRB_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___DWORD_TO_STRB_pt, i8** %pt, align 8
  br label %increment
}

define [21 x i8] @DWORD_TO_STRF(%DWORD_TO_STRF_interface* %0) {
entry:
  %IN = getelementptr inbounds %DWORD_TO_STRF_interface, %DWORD_TO_STRF_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %DWORD_TO_STRF_interface, %DWORD_TO_STRF_interface* %0, i32 0, i32 1
  %DWORD_TO_STRF = alloca [21 x i8], align 1
  %1 = bitcast [21 x i8]* %DWORD_TO_STRF to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 21), i1 false)
  %FIX_instance = alloca %FIX_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %FIX_interface, %FIX_interface* %FIX_instance, i32 0, i32 0
  %DWORD_TO_STRING_instance = alloca %DWORD_TO_STRING_interface, align 8
  br label %input1

call:                                             ; preds = %continue9
  %call11 = call [251 x i8] @FIX(%FIX_interface* %FIX_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %3 = alloca [251 x i8], align 1
  store [251 x i8] %call11, [251 x i8]* %3, align 1
  %4 = bitcast [21 x i8]* %DWORD_TO_STRF to i8*
  %5 = bitcast [251 x i8]* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %4, i8* align 1 %5, i32 20, i1 false)
  %DWORD_TO_STRF_ret = load [21 x i8], [21 x i8]* %DWORD_TO_STRF, align 1
  ret [21 x i8] %DWORD_TO_STRF_ret

input1:                                           ; preds = %input
  %6 = getelementptr inbounds %DWORD_TO_STRING_interface, %DWORD_TO_STRING_interface* %DWORD_TO_STRING_instance, i32 0, i32 0
  %load_in = load i32, i32* %IN, align 4
  store i32 %load_in, i32* %6, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call [81 x i8] @DWORD_TO_STRING(%DWORD_TO_STRING_interface* %DWORD_TO_STRING_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %7 = alloca [81 x i8], align 1
  store [81 x i8] %call5, [81 x i8]* %7, align 1
  %8 = bitcast [251 x i8]* %2 to i8*
  %9 = bitcast [81 x i8]* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %8, i8* align 1 %9, i32 81, i1 false)
  %10 = getelementptr inbounds %FIX_interface, %FIX_interface* %FIX_instance, i32 0, i32 1
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input6

input6:                                           ; preds = %continue4
  %11 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %11, align 4
  %12 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %13 = sext i16 %load_N to i64
  store i64 %13, i64* %12, align 4
  %14 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 20, i64* %14, align 4
  br label %call7

call7:                                            ; preds = %input6
  %call10 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %15 = trunc i64 %call10 to i16
  store i16 %15, i16* %10, align 2
  %16 = getelementptr inbounds %FIX_interface, %FIX_interface* %FIX_instance, i32 0, i32 2
  store i8 48, i8* %16, align 1
  %17 = getelementptr inbounds %FIX_interface, %FIX_interface* %FIX_instance, i32 0, i32 3
  store i16 1, i16* %17, align 2
  br label %call
}

define [9 x i8] @DWORD_TO_STRH(%DWORD_TO_STRH_interface* %0) {
entry:
  %IN = getelementptr inbounds %DWORD_TO_STRH_interface, %DWORD_TO_STRH_interface* %0, i32 0, i32 0
  %i = getelementptr inbounds %DWORD_TO_STRH_interface, %DWORD_TO_STRH_interface* %0, i32 0, i32 1
  %temp = getelementptr inbounds %DWORD_TO_STRH_interface, %DWORD_TO_STRH_interface* %0, i32 0, i32 2
  %pt = getelementptr inbounds %DWORD_TO_STRH_interface, %DWORD_TO_STRH_interface* %0, i32 0, i32 3
  %DWORD_TO_STRH = alloca [9 x i8], align 1
  store i16 0, i16* %i, align 2
  store i8 0, i8* %temp, align 1
  store i8* null, i8** %pt, align 8
  %1 = bitcast [9 x i8]* %DWORD_TO_STRH to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 9), i1 false)
  %access_POINTER_TO_STRING = getelementptr inbounds [9 x i8], [9 x i8]* %DWORD_TO_STRH, i32 8
  store [9 x i8]* %access_POINTER_TO_STRING, i8** %pt, align 8
  %deref = load i8*, i8** %pt, align 8
  store i8 0, i8* %deref, align 1
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %entry
  %load_i = load i16, i16* %i, align 2
  %load_i1 = load i16, i16* %i, align 2
  %tmpVar = icmp sle i16 %load_i1, 8
  %2 = icmp ne i1 %tmpVar, false
  br i1 %2, label %7, label %8

for_body:                                         ; preds = %5
  %load_pt = load i8*, i8** %pt, align 8
  %access___DWORD_TO_STRH_pt = getelementptr inbounds i8, i8* %load_pt, i32 -1
  store i8* %access___DWORD_TO_STRH_pt, i8** %pt, align 8
  %DWORD_TO_BYTE_instance = alloca %DWORD_TO_BYTE_interface, align 8
  br label %input

increment:                                        ; preds = %continue21
  %tmpVar24 = add i16 %load_i, 1
  store i16 %tmpVar24, i16* %i, align 2
  br label %condition_check

continue:                                         ; preds = %5
  %DWORD_TO_STRH_ret = load [9 x i8], [9 x i8]* %DWORD_TO_STRH, align 1
  ret [9 x i8] %DWORD_TO_STRH_ret

3:                                                ; preds = %8
  %load_i4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_i4, 8
  %4 = icmp ne i1 %tmpVar5, false
  br i1 %4, label %11, label %12

5:                                                ; preds = %12, %8
  %6 = phi i1 [ %9, %8 ], [ %13, %12 ]
  br i1 %6, label %for_body, label %continue

7:                                                ; preds = %condition_check
  %load_i2 = load i16, i16* %i, align 2
  %tmpVar3 = icmp sge i16 %load_i2, 1
  br label %8

8:                                                ; preds = %7, %condition_check
  %9 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar3, %7 ]
  %10 = icmp ne i1 %9, false
  br i1 %10, label %5, label %3

11:                                               ; preds = %3
  %load_i6 = load i16, i16* %i, align 2
  %tmpVar7 = icmp sle i16 %load_i6, 1
  br label %12

12:                                               ; preds = %11, %3
  %13 = phi i1 [ %tmpVar5, %3 ], [ %tmpVar7, %11 ]
  br label %5

input:                                            ; preds = %for_body
  %14 = getelementptr inbounds %DWORD_TO_BYTE_interface, %DWORD_TO_BYTE_interface* %DWORD_TO_BYTE_instance, i32 0, i32 0
  %load_in = load i32, i32* %IN, align 4
  %15 = icmp ne i32 %load_in, 0
  br i1 %15, label %17, label %18

call:                                             ; preds = %18
  %call9 = call i8 @DWORD_TO_BYTE(%DWORD_TO_BYTE_interface* %DWORD_TO_BYTE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue8

continue8:                                        ; preds = %output
  store i8 %call9, i8* %temp, align 1
  %load_temp = load i8, i8* %temp, align 1
  %16 = zext i8 %load_temp to i32
  %tmpVar11 = icmp sle i32 %16, 9
  br i1 %tmpVar11, label %condition_body, label %else

17:                                               ; preds = %input
  br label %18

18:                                               ; preds = %17, %input
  %19 = phi i32 [ %load_in, %input ], [ 15, %17 ]
  store i32 %19, i32* %14, align 4
  br label %call

condition_body:                                   ; preds = %continue8
  %load_temp12 = load i8, i8* %temp, align 1
  %20 = zext i8 %load_temp12 to i32
  %tmpVar13 = add i32 %20, 48
  %21 = trunc i32 %tmpVar13 to i8
  store i8 %21, i8* %temp, align 1
  br label %continue10

else:                                             ; preds = %continue8
  %load_temp14 = load i8, i8* %temp, align 1
  %22 = zext i8 %load_temp14 to i32
  %tmpVar15 = add i32 %22, 55
  %23 = trunc i32 %tmpVar15 to i8
  store i8 %23, i8* %temp, align 1
  br label %continue10

continue10:                                       ; preds = %else, %condition_body
  %deref16 = load i8*, i8** %pt, align 8
  %load_temp17 = load i8, i8* %temp, align 1
  store i8 %load_temp17, i8* %deref16, align 1
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input18

input18:                                          ; preds = %continue10
  %24 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_in22 = load i32, i32* %IN, align 4
  %25 = zext i32 %load_in22 to i64
  store i64 %25, i64* %24, align 4
  %26 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 4, i16* %26, align 2
  br label %call19

call19:                                           ; preds = %input18
  %call23 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %27 = trunc i64 %call23 to i32
  store i32 %27, i32* %IN, align 4
  br label %increment
}

define [251 x i8] @EXEC(%EXEC_interface* %0) {
entry:
  %str = getelementptr inbounds %EXEC_interface, %EXEC_interface* %0, i32 0, i32 0
  %pos = getelementptr inbounds %EXEC_interface, %EXEC_interface* %0, i32 0, i32 1
  %R1 = getelementptr inbounds %EXEC_interface, %EXEC_interface* %0, i32 0, i32 2
  %R2 = getelementptr inbounds %EXEC_interface, %EXEC_interface* %0, i32 0, i32 3
  %operator = getelementptr inbounds %EXEC_interface, %EXEC_interface* %0, i32 0, i32 4
  %EXEC = alloca [251 x i8], align 1
  store i16 0, i16* %pos, align 2
  store float 0.000000e+00, float* %R1, align 4
  store float 0.000000e+00, float* %R2, align 4
  %1 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 11), i1 false)
  %2 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %2, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %UPPERCASE_instance = alloca %UPPERCASE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %UPPERCASE_interface, %UPPERCASE_interface* %UPPERCASE_instance, i32 0, i32 0
  %TRIM_instance = alloca %TRIM_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call [251 x i8] @UPPERCASE(%UPPERCASE_interface* %UPPERCASE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = alloca [251 x i8], align 1
  store [251 x i8] %call6, [251 x i8]* %4, align 1
  %5 = bitcast [251 x i8]* %EXEC to i8*
  %6 = bitcast [251 x i8]* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 250, i1 false)
  %FINDB_NONUM_instance = alloca %FINDB_NONUM_interface, align 8
  br label %input7

input1:                                           ; preds = %input
  %7 = getelementptr inbounds %TRIM_interface, %TRIM_interface* %TRIM_instance, i32 0, i32 0
  %8 = bitcast [251 x i8]* %7 to i8*
  %9 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %8, i8* align 1 %9, i32 250, i1 false)
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call [251 x i8] @TRIM(%TRIM_interface* %TRIM_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %10 = alloca [251 x i8], align 1
  store [251 x i8] %call5, [251 x i8]* %10, align 1
  %11 = bitcast [251 x i8]* %3 to i8*
  %12 = bitcast [251 x i8]* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %11, i8* align 1 %12, i32 250, i1 false)
  br label %call

input7:                                           ; preds = %continue
  %13 = getelementptr inbounds %FINDB_NONUM_interface, %FINDB_NONUM_interface* %FINDB_NONUM_instance, i32 0, i32 0
  %14 = bitcast [251 x i8]* %13 to i8*
  %15 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %14, i8* align 1 %15, i32 250, i1 false)
  br label %call8

call8:                                            ; preds = %input7
  %call11 = call i16 @FINDB_NONUM(%FINDB_NONUM_interface* %FINDB_NONUM_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  store i16 %call11, i16* %pos, align 2
  %load_pos = load i16, i16* %pos, align 2
  %16 = sext i16 %load_pos to i32
  %tmpVar = icmp sgt i32 %16, 1
  br i1 %tmpVar, label %condition_body, label %continue12

condition_body:                                   ; preds = %continue10
  %STRING_TO_REAL_instance = alloca %STRING_TO_REAL_interface, align 8
  br label %input13

continue12:                                       ; preds = %continue16, %continue10
  %STRING_TO_REAL_instance25 = alloca %STRING_TO_REAL_interface, align 8
  br label %input26

input13:                                          ; preds = %condition_body
  %17 = getelementptr inbounds %STRING_TO_REAL_interface, %STRING_TO_REAL_interface* %STRING_TO_REAL_instance, i32 0, i32 0
  %LEFT_instance = alloca %LEFT_interface, align 8
  br label %input17

call14:                                           ; preds = %continue20
  %call24 = call float @STRING_TO_REAL(%STRING_TO_REAL_interface* %STRING_TO_REAL_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  store float %call24, float* %R1, align 4
  br label %continue12

input17:                                          ; preds = %input13
  %18 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 0
  %19 = bitcast [1024 x i8]* %18 to i8*
  %20 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %19, i8* align 1 %20, i32 251, i1 false)
  %21 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 1
  %load_pos21 = load i16, i16* %pos, align 2
  %22 = sext i16 %load_pos21 to i32
  %tmpVar22 = sub i32 %22, 1
  %23 = trunc i32 %tmpVar22 to i16
  store i16 %23, i16* %21, align 2
  br label %call18

call18:                                           ; preds = %input17
  %call23 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %24 = alloca [1024 x i8], align 1
  store [1024 x i8] %call23, [1024 x i8]* %24, align 1
  %25 = bitcast [81 x i8]* %17 to i8*
  %26 = bitcast [1024 x i8]* %24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %25, i8* align 1 %26, i32 80, i1 false)
  br label %call14

input26:                                          ; preds = %continue12
  %27 = getelementptr inbounds %STRING_TO_REAL_interface, %STRING_TO_REAL_interface* %STRING_TO_REAL_instance25, i32 0, i32 0
  %RIGHT_instance = alloca %RIGHT_interface, align 8
  br label %input30

call27:                                           ; preds = %continue33
  %call42 = call float @STRING_TO_REAL(%STRING_TO_REAL_interface* %STRING_TO_REAL_instance25)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  store float %call42, float* %R2, align 4
  %LEFT_instance43 = alloca %LEFT_interface, align 8
  br label %input44

input30:                                          ; preds = %input26
  %28 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 0
  %29 = bitcast [1024 x i8]* %28 to i8*
  %30 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %29, i8* align 1 %30, i32 251, i1 false)
  %31 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 1
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input34

call31:                                           ; preds = %continue37
  %call41 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance)
  br label %output32

output32:                                         ; preds = %call31
  br label %continue33

continue33:                                       ; preds = %output32
  %32 = alloca [1024 x i8], align 1
  store [1024 x i8] %call41, [1024 x i8]* %32, align 1
  %33 = bitcast [81 x i8]* %27 to i8*
  %34 = bitcast [1024 x i8]* %32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %33, i8* align 1 %34, i32 80, i1 false)
  br label %call27

input34:                                          ; preds = %input30
  %35 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %36 = bitcast [1024 x i8]* %35 to i8*
  %37 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %36, i8* align 1 %37, i32 251, i1 false)
  br label %call35

call35:                                           ; preds = %input34
  %call38 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output36

output36:                                         ; preds = %call35
  br label %continue37

continue37:                                       ; preds = %output36
  %38 = sext i16 %call38 to i32
  %load_pos39 = load i16, i16* %pos, align 2
  %39 = sext i16 %load_pos39 to i32
  %tmpVar40 = sub i32 %38, %39
  %40 = trunc i32 %tmpVar40 to i16
  store i16 %40, i16* %31, align 2
  br label %call31

input44:                                          ; preds = %continue29
  %41 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance43, i32 0, i32 0
  %42 = bitcast [1024 x i8]* %41 to i8*
  %43 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %42, i8* align 1 %43, i32 251, i1 false)
  %44 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance43, i32 0, i32 1
  %load_pos48 = load i16, i16* %pos, align 2
  store i16 %load_pos48, i16* %44, align 2
  br label %call45

call45:                                           ; preds = %input44
  %call49 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance43)
  br label %output46

output46:                                         ; preds = %call45
  br label %continue47

continue47:                                       ; preds = %output46
  %45 = alloca [1024 x i8], align 1
  store [1024 x i8] %call49, [1024 x i8]* %45, align 1
  %46 = bitcast [251 x i8]* %EXEC to i8*
  %47 = bitcast [1024 x i8]* %45 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %46, i8* align 1 %47, i32 250, i1 false)
  %FINDB_NUM_instance = alloca %FINDB_NUM_interface, align 8
  br label %input50

input50:                                          ; preds = %continue47
  %48 = getelementptr inbounds %FINDB_NUM_interface, %FINDB_NUM_interface* %FINDB_NUM_instance, i32 0, i32 0
  %49 = bitcast [251 x i8]* %48 to i8*
  %50 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %49, i8* align 1 %50, i32 250, i1 false)
  br label %call51

call51:                                           ; preds = %input50
  %call54 = call i16 @FINDB_NUM(%FINDB_NUM_interface* %FINDB_NUM_instance)
  br label %output52

output52:                                         ; preds = %call51
  br label %continue53

continue53:                                       ; preds = %output52
  store i16 %call54, i16* %pos, align 2
  %RIGHT_instance55 = alloca %RIGHT_interface, align 8
  br label %input56

input56:                                          ; preds = %continue53
  %51 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance55, i32 0, i32 0
  %52 = bitcast [1024 x i8]* %51 to i8*
  %53 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %52, i8* align 1 %53, i32 251, i1 false)
  %54 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance55, i32 0, i32 1
  %LEN_instance60 = alloca %LEN_interface, align 8
  br label %input61

call57:                                           ; preds = %continue64
  %call68 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance55)
  br label %output58

output58:                                         ; preds = %call57
  br label %continue59

continue59:                                       ; preds = %output58
  %55 = alloca [1024 x i8], align 1
  store [1024 x i8] %call68, [1024 x i8]* %55, align 1
  %56 = bitcast [11 x i8]* %operator to i8*
  %57 = bitcast [1024 x i8]* %55 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %56, i8* align 1 %57, i32 10, i1 false)
  %STRING_EQUAL_instance = alloca %STRING_EQUAL_interface, align 8
  br label %input71

input61:                                          ; preds = %input56
  %58 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance60, i32 0, i32 0
  %59 = bitcast [1024 x i8]* %58 to i8*
  %60 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %59, i8* align 1 %60, i32 251, i1 false)
  br label %call62

call62:                                           ; preds = %input61
  %call65 = call i16 @LEN(%LEN_interface* %LEN_instance60)
  br label %output63

output63:                                         ; preds = %call62
  br label %continue64

continue64:                                       ; preds = %output63
  %61 = sext i16 %call65 to i32
  %load_pos66 = load i16, i16* %pos, align 2
  %62 = sext i16 %load_pos66 to i32
  %tmpVar67 = sub i32 %61, %62
  %63 = trunc i32 %tmpVar67 to i16
  store i16 %63, i16* %54, align 2
  br label %call57

condition_body70:                                 ; preds = %68
  %64 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %64, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  %EXEC_ret = load [251 x i8], [251 x i8]* %EXEC, align 1
  ret [251 x i8] %EXEC_ret

buffer_block:                                     ; No predecessors!
  br label %continue69

branch:                                           ; preds = %68
  %STRING_EQUAL_instance84 = alloca %STRING_EQUAL_interface, align 8
  br label %input85

condition_body83:                                 ; preds = %continue88
  %65 = bitcast [251 x i8]* %EXEC to i8*
  %66 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %65, i8* align 1 %66, i32 250, i1 false)
  %EXEC_ret90 = load [251 x i8], [251 x i8]* %EXEC, align 1
  ret [251 x i8] %EXEC_ret90

buffer_block91:                                   ; No predecessors!
  br label %continue69

continue69:                                       ; preds = %buffer_block91, %continue88, %buffer_block
  %STRING_EQUAL_instance102 = alloca %STRING_EQUAL_interface, align 8
  br label %input103

67:                                               ; preds = %continue74
  %LEN_instance76 = alloca %LEN_interface, align 8
  br label %input77

68:                                               ; preds = %continue80, %continue74
  %69 = phi i32 [ %76, %continue74 ], [ %82, %continue80 ]
  %70 = icmp ne i32 %69, 0
  br i1 %70, label %condition_body70, label %branch

input71:                                          ; preds = %continue59
  %71 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 0
  %72 = bitcast [1025 x i8]* %71 to i8*
  %73 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %72, i8* align 1 %73, i32 11, i1 false)
  %74 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 1
  %75 = bitcast [1025 x i8]* %74 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %75, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  br label %call72

call72:                                           ; preds = %input71
  %call75 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance)
  br label %output73

output73:                                         ; preds = %call72
  br label %continue74

continue74:                                       ; preds = %output73
  %76 = zext i8 %call75 to i32
  %77 = icmp ne i32 %76, 0
  br i1 %77, label %67, label %68

input77:                                          ; preds = %67
  %78 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance76, i32 0, i32 0
  %79 = bitcast [1024 x i8]* %78 to i8*
  %80 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %79, i8* align 1 %80, i32 251, i1 false)
  br label %call78

call78:                                           ; preds = %input77
  %call81 = call i16 @LEN(%LEN_interface* %LEN_instance76)
  br label %output79

output79:                                         ; preds = %call78
  br label %continue80

continue80:                                       ; preds = %output79
  %81 = sext i16 %call81 to i32
  %tmpVar82 = icmp eq i32 %81, 0
  %82 = zext i1 %tmpVar82 to i32
  br label %68

input85:                                          ; preds = %branch
  %83 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance84, i32 0, i32 0
  %84 = bitcast [1025 x i8]* %83 to i8*
  %85 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %84, i8* align 1 %85, i32 11, i1 false)
  %86 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance84, i32 0, i32 1
  %87 = bitcast [1025 x i8]* %86 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %87, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  br label %call86

call86:                                           ; preds = %input85
  %call89 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance84)
  br label %output87

output87:                                         ; preds = %call86
  br label %continue88

continue88:                                       ; preds = %output87
  %88 = icmp ne i8 %call89, 0
  br i1 %88, label %condition_body83, label %continue69

condition_body101:                                ; preds = %continue106
  %REAL_TO_STRING_instance = alloca %REAL_TO_STRING_interface, align 8
  br label %input108

branch92:                                         ; preds = %continue106
  %STRING_EQUAL_instance119 = alloca %STRING_EQUAL_interface, align 8
  br label %input120

condition_body118:                                ; preds = %continue123
  %REAL_TO_STRING_instance125 = alloca %REAL_TO_STRING_interface, align 8
  br label %input126

branch93:                                         ; preds = %continue123
  %STRING_EQUAL_instance138 = alloca %STRING_EQUAL_interface, align 8
  br label %input139

condition_body137:                                ; preds = %continue142
  %REAL_TO_STRING_instance144 = alloca %REAL_TO_STRING_interface, align 8
  br label %input145

branch94:                                         ; preds = %continue142
  %STRING_EQUAL_instance156 = alloca %STRING_EQUAL_interface, align 8
  br label %input157

condition_body155:                                ; preds = %continue160
  %REAL_TO_STRING_instance162 = alloca %REAL_TO_STRING_interface, align 8
  br label %input163

branch95:                                         ; preds = %continue160
  %STRING_EQUAL_instance175 = alloca %STRING_EQUAL_interface, align 8
  br label %input176

condition_body174:                                ; preds = %continue179
  %REAL_TO_STRING_instance181 = alloca %REAL_TO_STRING_interface, align 8
  br label %input182

branch96:                                         ; preds = %continue179
  %STRING_EQUAL_instance194 = alloca %STRING_EQUAL_interface, align 8
  br label %input195

condition_body193:                                ; preds = %continue198
  %REAL_TO_STRING_instance200 = alloca %REAL_TO_STRING_interface, align 8
  br label %input201

branch97:                                         ; preds = %continue198
  %STRING_EQUAL_instance210 = alloca %STRING_EQUAL_interface, align 8
  br label %input211

condition_body209:                                ; preds = %continue214
  %load_R2219 = load float, float* %R2, align 4
  %tmpVar220 = fcmp one float %load_R2219, 0.000000e+00
  br i1 %tmpVar220, label %condition_body218, label %else216

branch98:                                         ; preds = %continue214
  %STRING_EQUAL_instance231 = alloca %STRING_EQUAL_interface, align 8
  br label %input232

condition_body230:                                ; preds = %continue235
  %REAL_TO_STRING_instance237 = alloca %REAL_TO_STRING_interface, align 8
  br label %input238

branch99:                                         ; preds = %continue235
  %STRING_EQUAL_instance246 = alloca %STRING_EQUAL_interface, align 8
  br label %input247

condition_body245:                                ; preds = %continue250
  %REAL_TO_STRING_instance252 = alloca %REAL_TO_STRING_interface, align 8
  br label %input253

else:                                             ; preds = %continue250
  %89 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %89, i8* align 1 getelementptr inbounds ([6 x i8], [6 x i8]* @utf08_literal_23, i32 0, i32 0), i32 6, i1 false)
  br label %continue100

continue100:                                      ; preds = %else, %continue256, %continue241, %continue217, %continue204, %continue185, %continue166, %continue148, %continue129, %continue111
  %STRING_EQUAL_instance265 = alloca %STRING_EQUAL_interface, align 8
  br label %input266

input103:                                         ; preds = %continue69
  %90 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance102, i32 0, i32 0
  %91 = bitcast [1025 x i8]* %90 to i8*
  %92 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %91, i8* align 1 %92, i32 11, i1 false)
  %93 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance102, i32 0, i32 1
  %94 = bitcast [1025 x i8]* %93 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %94, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_33, i32 0, i32 0), i32 2, i1 false)
  br label %call104

call104:                                          ; preds = %input103
  %call107 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance102)
  br label %output105

output105:                                        ; preds = %call104
  br label %continue106

continue106:                                      ; preds = %output105
  %95 = icmp ne i8 %call107, 0
  br i1 %95, label %condition_body101, label %branch92

input108:                                         ; preds = %condition_body101
  %96 = getelementptr inbounds %REAL_TO_STRING_interface, %REAL_TO_STRING_interface* %REAL_TO_STRING_instance, i32 0, i32 0
  %EXPT_instance = alloca %EXPT_interface, align 8
  br label %input112

call109:                                          ; preds = %continue115
  %call117 = call [81 x i8] @REAL_TO_STRING(%REAL_TO_STRING_interface* %REAL_TO_STRING_instance)
  br label %output110

output110:                                        ; preds = %call109
  br label %continue111

continue111:                                      ; preds = %output110
  %97 = alloca [81 x i8], align 1
  store [81 x i8] %call117, [81 x i8]* %97, align 1
  %98 = bitcast [251 x i8]* %EXEC to i8*
  %99 = bitcast [81 x i8]* %97 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %98, i8* align 1 %99, i32 81, i1 false)
  br label %continue100

input112:                                         ; preds = %input108
  %100 = getelementptr inbounds %EXPT_interface, %EXPT_interface* %EXPT_instance, i32 0, i32 0
  %load_R1 = load float, float* %R1, align 4
  %101 = fptosi float %load_R1 to i32
  store i32 %101, i32* %100, align 4
  %102 = getelementptr inbounds %EXPT_interface, %EXPT_interface* %EXPT_instance, i32 0, i32 1
  %load_R2 = load float, float* %R2, align 4
  %103 = fptosi float %load_R2 to i32
  store i32 %103, i32* %102, align 4
  br label %call113

call113:                                          ; preds = %input112
  %call116 = call double @EXPT(%EXPT_interface* %EXPT_instance)
  br label %output114

output114:                                        ; preds = %call113
  br label %continue115

continue115:                                      ; preds = %output114
  %104 = fptrunc double %call116 to float
  store float %104, float* %96, align 4
  br label %call109

input120:                                         ; preds = %branch92
  %105 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance119, i32 0, i32 0
  %106 = bitcast [1025 x i8]* %105 to i8*
  %107 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %106, i8* align 1 %107, i32 11, i1 false)
  %108 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance119, i32 0, i32 1
  %109 = bitcast [1025 x i8]* %108 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %109, i8* align 1 getelementptr inbounds ([5 x i8], [5 x i8]* @utf08_literal_29, i32 0, i32 0), i32 5, i1 false)
  br label %call121

call121:                                          ; preds = %input120
  %call124 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance119)
  br label %output122

output122:                                        ; preds = %call121
  br label %continue123

continue123:                                      ; preds = %output122
  %110 = icmp ne i8 %call124, 0
  br i1 %110, label %condition_body118, label %branch93

input126:                                         ; preds = %condition_body118
  %111 = getelementptr inbounds %REAL_TO_STRING_interface, %REAL_TO_STRING_interface* %REAL_TO_STRING_instance125, i32 0, i32 0
  %SQRT_instance = alloca %SQRT_interface, align 8
  br label %input130

call127:                                          ; preds = %continue133
  %call136 = call [81 x i8] @REAL_TO_STRING(%REAL_TO_STRING_interface* %REAL_TO_STRING_instance125)
  br label %output128

output128:                                        ; preds = %call127
  br label %continue129

continue129:                                      ; preds = %output128
  %112 = alloca [81 x i8], align 1
  store [81 x i8] %call136, [81 x i8]* %112, align 1
  %113 = bitcast [251 x i8]* %EXEC to i8*
  %114 = bitcast [81 x i8]* %112 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %113, i8* align 1 %114, i32 81, i1 false)
  br label %continue100

input130:                                         ; preds = %input126
  %115 = getelementptr inbounds %SQRT_interface, %SQRT_interface* %SQRT_instance, i32 0, i32 0
  %load_R2134 = load float, float* %R2, align 4
  %116 = fptosi float %load_R2134 to i32
  store i32 %116, i32* %115, align 4
  br label %call131

call131:                                          ; preds = %input130
  %call135 = call double @SQRT(%SQRT_interface* %SQRT_instance)
  br label %output132

output132:                                        ; preds = %call131
  br label %continue133

continue133:                                      ; preds = %output132
  %117 = fptrunc double %call135 to float
  store float %117, float* %111, align 4
  br label %call127

input139:                                         ; preds = %branch93
  %118 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance138, i32 0, i32 0
  %119 = bitcast [1025 x i8]* %118 to i8*
  %120 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %119, i8* align 1 %120, i32 11, i1 false)
  %121 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance138, i32 0, i32 1
  %122 = bitcast [1025 x i8]* %121 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %122, i8* align 1 getelementptr inbounds ([4 x i8], [4 x i8]* @utf08_literal_28, i32 0, i32 0), i32 4, i1 false)
  br label %call140

call140:                                          ; preds = %input139
  %call143 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance138)
  br label %output141

output141:                                        ; preds = %call140
  br label %continue142

continue142:                                      ; preds = %output141
  %123 = icmp ne i8 %call143, 0
  br i1 %123, label %condition_body137, label %branch94

input145:                                         ; preds = %condition_body137
  %124 = getelementptr inbounds %REAL_TO_STRING_interface, %REAL_TO_STRING_interface* %REAL_TO_STRING_instance144, i32 0, i32 0
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input149

call146:                                          ; preds = %continue152
  %call154 = call [81 x i8] @REAL_TO_STRING(%REAL_TO_STRING_interface* %REAL_TO_STRING_instance144)
  br label %output147

output147:                                        ; preds = %call146
  br label %continue148

continue148:                                      ; preds = %output147
  %125 = alloca [81 x i8], align 1
  store [81 x i8] %call154, [81 x i8]* %125, align 1
  %126 = bitcast [251 x i8]* %EXEC to i8*
  %127 = bitcast [81 x i8]* %125 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %126, i8* align 1 %127, i32 81, i1 false)
  br label %continue100

input149:                                         ; preds = %input145
  %128 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %load_r2 = load float, float* %R2, align 4
  %129 = fptosi float %load_r2 to i32
  store i32 %129, i32* %128, align 4
  br label %call150

call150:                                          ; preds = %input149
  %call153 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output151

output151:                                        ; preds = %call150
  br label %continue152

continue152:                                      ; preds = %output151
  %130 = fptrunc double %call153 to float
  store float %130, float* %124, align 4
  br label %call146

input157:                                         ; preds = %branch94
  %131 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance156, i32 0, i32 0
  %132 = bitcast [1025 x i8]* %131 to i8*
  %133 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %132, i8* align 1 %133, i32 11, i1 false)
  %134 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance156, i32 0, i32 1
  %135 = bitcast [1025 x i8]* %134 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %135, i8* align 1 getelementptr inbounds ([4 x i8], [4 x i8]* @utf08_literal_21, i32 0, i32 0), i32 4, i1 false)
  br label %call158

call158:                                          ; preds = %input157
  %call161 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance156)
  br label %output159

output159:                                        ; preds = %call158
  br label %continue160

continue160:                                      ; preds = %output159
  %136 = icmp ne i8 %call161, 0
  br i1 %136, label %condition_body155, label %branch95

input163:                                         ; preds = %condition_body155
  %137 = getelementptr inbounds %REAL_TO_STRING_interface, %REAL_TO_STRING_interface* %REAL_TO_STRING_instance162, i32 0, i32 0
  %COS_instance = alloca %COS_interface, align 8
  br label %input167

call164:                                          ; preds = %continue170
  %call173 = call [81 x i8] @REAL_TO_STRING(%REAL_TO_STRING_interface* %REAL_TO_STRING_instance162)
  br label %output165

output165:                                        ; preds = %call164
  br label %continue166

continue166:                                      ; preds = %output165
  %138 = alloca [81 x i8], align 1
  store [81 x i8] %call173, [81 x i8]* %138, align 1
  %139 = bitcast [251 x i8]* %EXEC to i8*
  %140 = bitcast [81 x i8]* %138 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %139, i8* align 1 %140, i32 81, i1 false)
  br label %continue100

input167:                                         ; preds = %input163
  %141 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance, i32 0, i32 0
  %load_r2171 = load float, float* %R2, align 4
  %142 = fptosi float %load_r2171 to i32
  store i32 %142, i32* %141, align 4
  br label %call168

call168:                                          ; preds = %input167
  %call172 = call double @COS(%COS_interface* %COS_instance)
  br label %output169

output169:                                        ; preds = %call168
  br label %continue170

continue170:                                      ; preds = %output169
  %143 = fptrunc double %call172 to float
  store float %143, float* %137, align 4
  br label %call164

input176:                                         ; preds = %branch95
  %144 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance175, i32 0, i32 0
  %145 = bitcast [1025 x i8]* %144 to i8*
  %146 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %145, i8* align 1 %146, i32 11, i1 false)
  %147 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance175, i32 0, i32 1
  %148 = bitcast [1025 x i8]* %147 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %148, i8* align 1 getelementptr inbounds ([4 x i8], [4 x i8]* @utf08_literal_30, i32 0, i32 0), i32 4, i1 false)
  br label %call177

call177:                                          ; preds = %input176
  %call180 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance175)
  br label %output178

output178:                                        ; preds = %call177
  br label %continue179

continue179:                                      ; preds = %output178
  %149 = icmp ne i8 %call180, 0
  br i1 %149, label %condition_body174, label %branch96

input182:                                         ; preds = %condition_body174
  %150 = getelementptr inbounds %REAL_TO_STRING_interface, %REAL_TO_STRING_interface* %REAL_TO_STRING_instance181, i32 0, i32 0
  %TAN_instance = alloca %TAN_interface, align 8
  br label %input186

call183:                                          ; preds = %continue189
  %call192 = call [81 x i8] @REAL_TO_STRING(%REAL_TO_STRING_interface* %REAL_TO_STRING_instance181)
  br label %output184

output184:                                        ; preds = %call183
  br label %continue185

continue185:                                      ; preds = %output184
  %151 = alloca [81 x i8], align 1
  store [81 x i8] %call192, [81 x i8]* %151, align 1
  %152 = bitcast [251 x i8]* %EXEC to i8*
  %153 = bitcast [81 x i8]* %151 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %152, i8* align 1 %153, i32 81, i1 false)
  br label %continue100

input186:                                         ; preds = %input182
  %154 = getelementptr inbounds %TAN_interface, %TAN_interface* %TAN_instance, i32 0, i32 0
  %load_R2190 = load float, float* %R2, align 4
  %155 = fptosi float %load_R2190 to i32
  store i32 %155, i32* %154, align 4
  br label %call187

call187:                                          ; preds = %input186
  %call191 = call double @TAN(%TAN_interface* %TAN_instance)
  br label %output188

output188:                                        ; preds = %call187
  br label %continue189

continue189:                                      ; preds = %output188
  %156 = fptrunc double %call191 to float
  store float %156, float* %150, align 4
  br label %call183

input195:                                         ; preds = %branch96
  %157 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance194, i32 0, i32 0
  %158 = bitcast [1025 x i8]* %157 to i8*
  %159 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %158, i8* align 1 %159, i32 11, i1 false)
  %160 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance194, i32 0, i32 1
  %161 = bitcast [1025 x i8]* %160 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %161, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_5, i32 0, i32 0), i32 2, i1 false)
  br label %call196

call196:                                          ; preds = %input195
  %call199 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance194)
  br label %output197

output197:                                        ; preds = %call196
  br label %continue198

continue198:                                      ; preds = %output197
  %162 = icmp ne i8 %call199, 0
  br i1 %162, label %condition_body193, label %branch97

input201:                                         ; preds = %condition_body193
  %163 = getelementptr inbounds %REAL_TO_STRING_interface, %REAL_TO_STRING_interface* %REAL_TO_STRING_instance200, i32 0, i32 0
  %load_R1205 = load float, float* %R1, align 4
  %load_R2206 = load float, float* %R2, align 4
  %tmpVar207 = fmul float %load_R1205, %load_R2206
  store float %tmpVar207, float* %163, align 4
  br label %call202

call202:                                          ; preds = %input201
  %call208 = call [81 x i8] @REAL_TO_STRING(%REAL_TO_STRING_interface* %REAL_TO_STRING_instance200)
  br label %output203

output203:                                        ; preds = %call202
  br label %continue204

continue204:                                      ; preds = %output203
  %164 = alloca [81 x i8], align 1
  store [81 x i8] %call208, [81 x i8]* %164, align 1
  %165 = bitcast [251 x i8]* %EXEC to i8*
  %166 = bitcast [81 x i8]* %164 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %165, i8* align 1 %166, i32 81, i1 false)
  br label %continue100

input211:                                         ; preds = %branch97
  %167 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance210, i32 0, i32 0
  %168 = bitcast [1025 x i8]* %167 to i8*
  %169 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %168, i8* align 1 %169, i32 11, i1 false)
  %170 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance210, i32 0, i32 1
  %171 = bitcast [1025 x i8]* %170 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %171, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_11, i32 0, i32 0), i32 2, i1 false)
  br label %call212

call212:                                          ; preds = %input211
  %call215 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance210)
  br label %output213

output213:                                        ; preds = %call212
  br label %continue214

continue214:                                      ; preds = %output213
  %172 = icmp ne i8 %call215, 0
  br i1 %172, label %condition_body209, label %branch98

condition_body218:                                ; preds = %condition_body209
  %REAL_TO_STRING_instance221 = alloca %REAL_TO_STRING_interface, align 8
  br label %input222

else216:                                          ; preds = %condition_body209
  %173 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %173, i8* align 1 getelementptr inbounds ([6 x i8], [6 x i8]* @utf08_literal_23, i32 0, i32 0), i32 6, i1 false)
  br label %continue217

continue217:                                      ; preds = %else216, %continue225
  br label %continue100

input222:                                         ; preds = %condition_body218
  %174 = getelementptr inbounds %REAL_TO_STRING_interface, %REAL_TO_STRING_interface* %REAL_TO_STRING_instance221, i32 0, i32 0
  %load_R1226 = load float, float* %R1, align 4
  %load_R2227 = load float, float* %R2, align 4
  %tmpVar228 = fdiv float %load_R1226, %load_R2227
  store float %tmpVar228, float* %174, align 4
  br label %call223

call223:                                          ; preds = %input222
  %call229 = call [81 x i8] @REAL_TO_STRING(%REAL_TO_STRING_interface* %REAL_TO_STRING_instance221)
  br label %output224

output224:                                        ; preds = %call223
  br label %continue225

continue225:                                      ; preds = %output224
  %175 = alloca [81 x i8], align 1
  store [81 x i8] %call229, [81 x i8]* %175, align 1
  %176 = bitcast [251 x i8]* %EXEC to i8*
  %177 = bitcast [81 x i8]* %175 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %176, i8* align 1 %177, i32 81, i1 false)
  br label %continue217

input232:                                         ; preds = %branch98
  %178 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance231, i32 0, i32 0
  %179 = bitcast [1025 x i8]* %178 to i8*
  %180 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %179, i8* align 1 %180, i32 11, i1 false)
  %181 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance231, i32 0, i32 1
  %182 = bitcast [1025 x i8]* %181 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %182, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_6, i32 0, i32 0), i32 2, i1 false)
  br label %call233

call233:                                          ; preds = %input232
  %call236 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance231)
  br label %output234

output234:                                        ; preds = %call233
  br label %continue235

continue235:                                      ; preds = %output234
  %183 = icmp ne i8 %call236, 0
  br i1 %183, label %condition_body230, label %branch99

input238:                                         ; preds = %condition_body230
  %184 = getelementptr inbounds %REAL_TO_STRING_interface, %REAL_TO_STRING_interface* %REAL_TO_STRING_instance237, i32 0, i32 0
  %load_r1 = load float, float* %R1, align 4
  %load_r2242 = load float, float* %R2, align 4
  %tmpVar243 = fadd float %load_r1, %load_r2242
  store float %tmpVar243, float* %184, align 4
  br label %call239

call239:                                          ; preds = %input238
  %call244 = call [81 x i8] @REAL_TO_STRING(%REAL_TO_STRING_interface* %REAL_TO_STRING_instance237)
  br label %output240

output240:                                        ; preds = %call239
  br label %continue241

continue241:                                      ; preds = %output240
  %185 = alloca [81 x i8], align 1
  store [81 x i8] %call244, [81 x i8]* %185, align 1
  %186 = bitcast [251 x i8]* %EXEC to i8*
  %187 = bitcast [81 x i8]* %185 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %186, i8* align 1 %187, i32 81, i1 false)
  br label %continue100

input247:                                         ; preds = %branch99
  %188 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance246, i32 0, i32 0
  %189 = bitcast [1025 x i8]* %188 to i8*
  %190 = bitcast [11 x i8]* %operator to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %189, i8* align 1 %190, i32 11, i1 false)
  %191 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance246, i32 0, i32 1
  %192 = bitcast [1025 x i8]* %191 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %192, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_8, i32 0, i32 0), i32 2, i1 false)
  br label %call248

call248:                                          ; preds = %input247
  %call251 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance246)
  br label %output249

output249:                                        ; preds = %call248
  br label %continue250

continue250:                                      ; preds = %output249
  %193 = icmp ne i8 %call251, 0
  br i1 %193, label %condition_body245, label %else

input253:                                         ; preds = %condition_body245
  %194 = getelementptr inbounds %REAL_TO_STRING_interface, %REAL_TO_STRING_interface* %REAL_TO_STRING_instance252, i32 0, i32 0
  %load_r1257 = load float, float* %R1, align 4
  %load_r2258 = load float, float* %R2, align 4
  %tmpVar259 = fsub float %load_r1257, %load_r2258
  store float %tmpVar259, float* %194, align 4
  br label %call254

call254:                                          ; preds = %input253
  %call260 = call [81 x i8] @REAL_TO_STRING(%REAL_TO_STRING_interface* %REAL_TO_STRING_instance252)
  br label %output255

output255:                                        ; preds = %call254
  br label %continue256

continue256:                                      ; preds = %output255
  %195 = alloca [81 x i8], align 1
  store [81 x i8] %call260, [81 x i8]* %195, align 1
  %196 = bitcast [251 x i8]* %EXEC to i8*
  %197 = bitcast [81 x i8]* %195 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %196, i8* align 1 %197, i32 81, i1 false)
  br label %continue100

condition_body264:                                ; preds = %continue269
  %EXEC_ret271 = load [251 x i8], [251 x i8]* %EXEC, align 1
  ret [251 x i8] %EXEC_ret271

buffer_block272:                                  ; No predecessors!
  br label %continue263

branch261:                                        ; preds = %continue269
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input274

condition_body273:                                ; preds = %continue277
  %CONCAT_instance = alloca %CONCAT_interface, align 8
  br label %input280

branch262:                                        ; preds = %continue277
  %STRING_EQUAL_instance286 = alloca %STRING_EQUAL_interface, align 8
  br label %input287

condition_body285:                                ; preds = %continue290
  %CONCAT_instance298 = alloca %CONCAT_interface, align 8
  br label %input299

continue263:                                      ; preds = %continue302, %continue290, %continue283, %buffer_block272
  %EXEC_ret304 = load [251 x i8], [251 x i8]* %EXEC, align 1
  ret [251 x i8] %EXEC_ret304

input266:                                         ; preds = %continue100
  %198 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance265, i32 0, i32 0
  %199 = bitcast [1025 x i8]* %198 to i8*
  %200 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %199, i8* align 1 %200, i32 251, i1 false)
  %201 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance265, i32 0, i32 1
  %202 = bitcast [1025 x i8]* %201 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %202, i8* align 1 getelementptr inbounds ([6 x i8], [6 x i8]* @utf08_literal_23, i32 0, i32 0), i32 6, i1 false)
  br label %call267

call267:                                          ; preds = %input266
  %call270 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance265)
  br label %output268

output268:                                        ; preds = %call267
  br label %continue269

continue269:                                      ; preds = %output268
  %203 = icmp ne i8 %call270, 0
  br i1 %203, label %condition_body264, label %branch261

input274:                                         ; preds = %branch261
  %204 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %205 = bitcast [1024 x i8]* %204 to i8*
  %206 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %205, i8* align 1 %206, i32 251, i1 false)
  %207 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %208 = bitcast [1024 x i8]* %207 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %208, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_9, i32 0, i32 0), i32 2, i1 false)
  br label %call275

call275:                                          ; preds = %input274
  %call278 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output276

output276:                                        ; preds = %call275
  br label %continue277

continue277:                                      ; preds = %output276
  %209 = sext i16 %call278 to i32
  %tmpVar279 = icmp eq i32 %209, 0
  br i1 %tmpVar279, label %condition_body273, label %branch262

input280:                                         ; preds = %condition_body273
  %210 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 0
  %211 = bitcast [1024 x i8]* %210 to i8*
  %212 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %211, i8* align 1 %212, i32 251, i1 false)
  %213 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 1
  %214 = bitcast [1024 x i8]* %213 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %214, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_10, i32 0, i32 0), i32 3, i1 false)
  br label %call281

call281:                                          ; preds = %input280
  %call284 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance)
  br label %output282

output282:                                        ; preds = %call281
  br label %continue283

continue283:                                      ; preds = %output282
  %215 = alloca [1024 x i8], align 1
  store [1024 x i8] %call284, [1024 x i8]* %215, align 1
  %216 = bitcast [251 x i8]* %EXEC to i8*
  %217 = bitcast [1024 x i8]* %215 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %216, i8* align 1 %217, i32 250, i1 false)
  br label %continue263

input287:                                         ; preds = %branch262
  %218 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance286, i32 0, i32 0
  %RIGHT_instance291 = alloca %RIGHT_interface, align 8
  br label %input292

call288:                                          ; preds = %continue295
  %call297 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance286)
  br label %output289

output289:                                        ; preds = %call288
  br label %continue290

continue290:                                      ; preds = %output289
  %219 = icmp ne i8 %call297, 0
  br i1 %219, label %condition_body285, label %continue263

input292:                                         ; preds = %input287
  %220 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance291, i32 0, i32 0
  %221 = bitcast [1024 x i8]* %220 to i8*
  %222 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %221, i8* align 1 %222, i32 251, i1 false)
  %223 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance291, i32 0, i32 1
  store i16 1, i16* %223, align 2
  br label %call293

call293:                                          ; preds = %input292
  %call296 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance291)
  br label %output294

output294:                                        ; preds = %call293
  br label %continue295

continue295:                                      ; preds = %output294
  %224 = alloca [1024 x i8], align 1
  store [1024 x i8] %call296, [1024 x i8]* %224, align 1
  %225 = bitcast [1025 x i8]* %218 to i8*
  %226 = bitcast [1024 x i8]* %224 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %225, i8* align 1 %226, i32 1024, i1 false)
  %227 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance286, i32 0, i32 1
  %228 = bitcast [1025 x i8]* %227 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %228, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_9, i32 0, i32 0), i32 2, i1 false)
  br label %call288

input299:                                         ; preds = %condition_body285
  %229 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance298, i32 0, i32 0
  %230 = bitcast [1024 x i8]* %229 to i8*
  %231 = bitcast [251 x i8]* %EXEC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %230, i8* align 1 %231, i32 251, i1 false)
  %232 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance298, i32 0, i32 1
  %233 = bitcast [1024 x i8]* %232 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %233, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_12, i32 0, i32 0), i32 2, i1 false)
  br label %call300

call300:                                          ; preds = %input299
  %call303 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance298)
  br label %output301

output301:                                        ; preds = %call300
  br label %continue302

continue302:                                      ; preds = %output301
  %234 = alloca [1024 x i8], align 1
  store [1024 x i8] %call303, [1024 x i8]* %234, align 1
  %235 = bitcast [251 x i8]* %EXEC to i8*
  %236 = bitcast [1024 x i8]* %234 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %235, i8* align 1 %236, i32 250, i1 false)
  br label %continue263
}

define [251 x i8] @FILL(%FILL_interface* %0) {
entry:
  %C = getelementptr inbounds %FILL_interface, %FILL_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %FILL_interface, %FILL_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %FILL_interface, %FILL_interface* %0, i32 0, i32 2
  %sx = getelementptr inbounds %FILL_interface, %FILL_interface* %0, i32 0, i32 3
  %FILL = alloca [251 x i8], align 1
  store i16 0, i16* %i, align 2
  %1 = bitcast [2 x i8]* %sx to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 2), i1 false)
  %2 = bitcast [251 x i8]* %FILL to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %2, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %CHR_TO_STRING_instance = alloca %CHR_TO_STRING_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %CHR_TO_STRING_interface, %CHR_TO_STRING_interface* %CHR_TO_STRING_instance, i32 0, i32 0
  %load_c = load i8, i8* %C, align 1
  store i8 %load_c, i8* %3, align 1
  br label %call

call:                                             ; preds = %input
  %call1 = call [2 x i8] @CHR_TO_STRING(%CHR_TO_STRING_interface* %CHR_TO_STRING_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %4 = alloca [2 x i8], align 1
  store [2 x i8] %call1, [2 x i8]* %4, align 1
  %5 = bitcast [2 x i8]* %sx to i8*
  %6 = bitcast [2 x i8]* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 1, i1 false)
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %7 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %7, align 4
  %8 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_L = load i16, i16* %L, align 2
  %9 = sext i16 %load_L to i64
  store i64 %9, i64* %8, align 4
  %10 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_STRING_LENGTH = load i16, i16* @STRING_LENGTH, align 2
  %11 = sext i16 %load_STRING_LENGTH to i64
  store i64 %11, i64* %10, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %12 = trunc i64 %call6 to i16
  store i16 %12, i16* %L, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue5
  %load_i = load i16, i16* %i, align 2
  %load_i8 = load i16, i16* %i, align 2
  %tmpVar = icmp sle i16 %load_i8, 8
  %13 = icmp ne i1 %tmpVar, false
  br i1 %13, label %18, label %19

for_body:                                         ; preds = %16
  %CONCAT_instance = alloca %CONCAT_interface, align 8
  br label %input15

increment:                                        ; preds = %continue31
  %tmpVar34 = add i16 %load_i, 1
  store i16 %tmpVar34, i16* %i, align 2
  br label %condition_check

continue7:                                        ; preds = %16
  %FILL_ret = load [251 x i8], [251 x i8]* %FILL, align 1
  ret [251 x i8] %FILL_ret

14:                                               ; preds = %19
  %load_i11 = load i16, i16* %i, align 2
  %tmpVar12 = icmp sge i16 %load_i11, 8
  %15 = icmp ne i1 %tmpVar12, false
  br i1 %15, label %22, label %23

16:                                               ; preds = %23, %19
  %17 = phi i1 [ %20, %19 ], [ %24, %23 ]
  br i1 %17, label %for_body, label %continue7

18:                                               ; preds = %condition_check
  %load_i9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sge i16 %load_i9, 1
  br label %19

19:                                               ; preds = %18, %condition_check
  %20 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar10, %18 ]
  %21 = icmp ne i1 %20, false
  br i1 %21, label %16, label %14

22:                                               ; preds = %14
  %load_i13 = load i16, i16* %i, align 2
  %tmpVar14 = icmp sle i16 %load_i13, 1
  br label %23

23:                                               ; preds = %22, %14
  %24 = phi i1 [ %tmpVar12, %14 ], [ %tmpVar14, %22 ]
  br label %16

input15:                                          ; preds = %for_body
  %25 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 0
  %26 = bitcast [1024 x i8]* %25 to i8*
  %27 = bitcast [251 x i8]* %FILL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %26, i8* align 1 %27, i32 251, i1 false)
  %28 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 1
  %29 = bitcast [1024 x i8]* %28 to i8*
  %30 = bitcast [251 x i8]* %FILL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %29, i8* align 1 %30, i32 251, i1 false)
  br label %call16

call16:                                           ; preds = %input15
  %call19 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %31 = alloca [1024 x i8], align 1
  store [1024 x i8] %call19, [1024 x i8]* %31, align 1
  %32 = bitcast [251 x i8]* %FILL to i8*
  %33 = bitcast [1024 x i8]* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %32, i8* align 1 %33, i32 250, i1 false)
  %load_L21 = load i16, i16* %L, align 2
  %shift = ashr i16 %load_L21, 7
  %34 = trunc i16 %shift to i8
  %35 = icmp ne i8 %34, 0
  br i1 %35, label %condition_body, label %continue20

condition_body:                                   ; preds = %continue18
  %CONCAT_instance22 = alloca %CONCAT_interface, align 8
  br label %input23

continue20:                                       ; preds = %continue26, %continue18
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input28

input23:                                          ; preds = %condition_body
  %36 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance22, i32 0, i32 0
  %37 = bitcast [1024 x i8]* %36 to i8*
  %38 = bitcast [251 x i8]* %FILL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %37, i8* align 1 %38, i32 251, i1 false)
  %39 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance22, i32 0, i32 1
  %40 = bitcast [1024 x i8]* %39 to i8*
  %41 = bitcast [2 x i8]* %sx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %40, i8* align 1 %41, i32 2, i1 false)
  br label %call24

call24:                                           ; preds = %input23
  %call27 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance22)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %42 = alloca [1024 x i8], align 1
  store [1024 x i8] %call27, [1024 x i8]* %42, align 1
  %43 = bitcast [251 x i8]* %FILL to i8*
  %44 = bitcast [1024 x i8]* %42 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %43, i8* align 1 %44, i32 250, i1 false)
  br label %continue20

input28:                                          ; preds = %continue20
  %45 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_L32 = load i16, i16* %L, align 2
  %46 = sext i16 %load_L32 to i64
  store i64 %46, i64* %45, align 4
  %47 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 1, i16* %47, align 2
  br label %call29

call29:                                           ; preds = %input28
  %call33 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output30

output30:                                         ; preds = %call29
  br label %continue31

continue31:                                       ; preds = %output30
  %48 = trunc i64 %call33 to i16
  store i16 %48, i16* %L, align 2
  br label %increment
}

define i16 @FIND_CHAR(%FIND_CHAR_interface* %0) {
entry:
  %str = getelementptr inbounds %FIND_CHAR_interface, %FIND_CHAR_interface* %0, i32 0, i32 0
  %pos = getelementptr inbounds %FIND_CHAR_interface, %FIND_CHAR_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %FIND_CHAR_interface, %FIND_CHAR_interface* %0, i32 0, i32 2
  %pt = getelementptr inbounds %FIND_CHAR_interface, %FIND_CHAR_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %FIND_CHAR_interface, %FIND_CHAR_interface* %0, i32 0, i32 4
  %X = getelementptr inbounds %FIND_CHAR_interface, %FIND_CHAR_interface* %0, i32 0, i32 5
  %FIND_CHAR = alloca i16, align 2
  store i16 0, i16* %i, align 2
  store [255 x i8]* null, [255 x i8]** %pt, align 8
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %X, align 1
  store i16 0, i16* %FIND_CHAR, align 2
  store [251 x i8]* %str, [255 x i8]** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  %MAX_instance = alloca %MAX_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %4 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 0
  %load_pos = load i16, i16* %pos, align 2
  %5 = sext i16 %load_pos to i64
  store i64 %5, i64* %4, align 4
  %6 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 1
  store i64 1, i64* %6, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @MAX(%MAX_interface* %MAX_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %7 = trunc i64 %call6 to i16
  store i16 %7, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue5
  %load_i = load i16, i16* %i, align 2
  %load_i8 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_i8, %load_stop
  %8 = icmp ne i1 %tmpVar, false
  br i1 %8, label %18, label %19

for_body:                                         ; preds = %16
  %deref = load [255 x i8]*, [255 x i8]** %pt, align 8
  %load_i30 = load i16, i16* %i, align 2
  %9 = sub i16 %load_i30, 1
  %10 = sext i16 %9 to i32
  %tmpVar31 = mul i32 1, %10
  %tmpVar32 = add i32 %tmpVar31, 0
  %tmpVar33 = getelementptr inbounds [255 x i8], [255 x i8]* %deref, i32 0, i32 %tmpVar32
  %load_tmpVar = load i8, i8* %tmpVar33, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %11 = zext i8 %load_X to i32
  %tmpVar35 = icmp sgt i32 %11, 31
  %12 = zext i1 %tmpVar35 to i32
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %33, label %36

increment:                                        ; preds = %continue34
  %tmpVar43 = add i16 %load_i, 1
  store i16 %tmpVar43, i16* %i, align 2
  br label %condition_check

continue7:                                        ; preds = %16
  store i16 0, i16* %FIND_CHAR, align 2
  %FIND_CHAR_ret44 = load i16, i16* %FIND_CHAR, align 2
  ret i16 %FIND_CHAR_ret44

14:                                               ; preds = %19
  %load_i18 = load i16, i16* %i, align 2
  %load_stop19 = load i16, i16* %stop, align 2
  %tmpVar20 = icmp sge i16 %load_i18, %load_stop19
  %15 = icmp ne i1 %tmpVar20, false
  br i1 %15, label %26, label %27

16:                                               ; preds = %27, %19
  %17 = phi i1 [ %20, %19 ], [ %28, %27 ]
  br i1 %17, label %for_body, label %continue7

18:                                               ; preds = %condition_check
  %load_i9 = load i16, i16* %i, align 2
  %MAX_instance10 = alloca %MAX_interface, align 8
  br label %input11

19:                                               ; preds = %continue14, %condition_check
  %20 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar17, %continue14 ]
  %21 = icmp ne i1 %20, false
  br i1 %21, label %16, label %14

input11:                                          ; preds = %18
  %22 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance10, i32 0, i32 0
  %load_pos15 = load i16, i16* %pos, align 2
  %23 = sext i16 %load_pos15 to i64
  store i64 %23, i64* %22, align 4
  %24 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance10, i32 0, i32 1
  store i64 1, i64* %24, align 4
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call i64 @MAX(%MAX_interface* %MAX_instance10)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %25 = trunc i64 %call16 to i16
  %tmpVar17 = icmp sge i16 %load_i9, %25
  br label %19

26:                                               ; preds = %14
  %load_i21 = load i16, i16* %i, align 2
  %MAX_instance22 = alloca %MAX_interface, align 8
  br label %input23

27:                                               ; preds = %continue26, %14
  %28 = phi i1 [ %tmpVar20, %14 ], [ %tmpVar29, %continue26 ]
  br label %16

input23:                                          ; preds = %26
  %29 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance22, i32 0, i32 0
  %load_pos27 = load i16, i16* %pos, align 2
  %30 = sext i16 %load_pos27 to i64
  store i64 %30, i64* %29, align 4
  %31 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance22, i32 0, i32 1
  store i64 1, i64* %31, align 4
  br label %call24

call24:                                           ; preds = %input23
  %call28 = call i64 @MAX(%MAX_interface* %MAX_instance22)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %32 = trunc i64 %call28 to i16
  %tmpVar29 = icmp sle i16 %load_i21, %32
  br label %27

condition_body:                                   ; preds = %36
  %load_i42 = load i16, i16* %i, align 2
  store i16 %load_i42, i16* %FIND_CHAR, align 2
  %FIND_CHAR_ret = load i16, i16* %FIND_CHAR, align 2
  ret i16 %FIND_CHAR_ret

buffer_block:                                     ; No predecessors!
  br label %continue34

continue34:                                       ; preds = %buffer_block, %36
  br label %increment

33:                                               ; preds = %for_body
  %load_ = load i8, i8* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 0), align 1
  %34 = zext i8 %load_ to i32
  %35 = icmp ne i32 %34, 0
  br i1 %35, label %44, label %47

36:                                               ; preds = %42, %for_body
  %37 = phi i32 [ %12, %for_body ], [ %43, %42 ]
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %condition_body, label %continue34

39:                                               ; preds = %47
  %load_38 = load i8, i8* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 0), align 1
  %tmpVar39 = xor i8 %load_38, -1
  %40 = zext i8 %tmpVar39 to i32
  %41 = icmp ne i32 %40, 0
  br i1 %41, label %50, label %53

42:                                               ; preds = %53, %47
  %43 = phi i32 [ %48, %47 ], [ %54, %53 ]
  br label %36

44:                                               ; preds = %33
  %load_X36 = load i8, i8* %X, align 1
  %45 = zext i8 %load_X36 to i32
  %tmpVar37 = icmp ne i32 %45, 127
  %46 = zext i1 %tmpVar37 to i32
  br label %47

47:                                               ; preds = %44, %33
  %48 = phi i32 [ %34, %33 ], [ %46, %44 ]
  %49 = icmp ne i32 %48, 0
  br i1 %49, label %42, label %39

50:                                               ; preds = %39
  %load_X40 = load i8, i8* %X, align 1
  %51 = zext i8 %load_X40 to i32
  %tmpVar41 = icmp slt i32 %51, 127
  %52 = zext i1 %tmpVar41 to i32
  br label %53

53:                                               ; preds = %50, %39
  %54 = phi i32 [ %40, %39 ], [ %52, %50 ]
  br label %42
}

define i16 @FIND_CTRL(%FIND_CTRL_interface* %0) {
entry:
  %str = getelementptr inbounds %FIND_CTRL_interface, %FIND_CTRL_interface* %0, i32 0, i32 0
  %pos = getelementptr inbounds %FIND_CTRL_interface, %FIND_CTRL_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %FIND_CTRL_interface, %FIND_CTRL_interface* %0, i32 0, i32 2
  %pt = getelementptr inbounds %FIND_CTRL_interface, %FIND_CTRL_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %FIND_CTRL_interface, %FIND_CTRL_interface* %0, i32 0, i32 4
  %x = getelementptr inbounds %FIND_CTRL_interface, %FIND_CTRL_interface* %0, i32 0, i32 5
  %FIND_CTRL = alloca i16, align 2
  store i16 0, i16* %i, align 2
  store [255 x i8]* null, [255 x i8]** %pt, align 8
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %x, align 1
  store i16 0, i16* %FIND_CTRL, align 2
  store [251 x i8]* %str, [255 x i8]** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  %MAX_instance = alloca %MAX_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %4 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 0
  %load_pos = load i16, i16* %pos, align 2
  %5 = sext i16 %load_pos to i64
  store i64 %5, i64* %4, align 4
  %6 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 1
  store i64 1, i64* %6, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @MAX(%MAX_interface* %MAX_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %7 = trunc i64 %call6 to i16
  store i16 %7, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue5
  %load_i = load i16, i16* %i, align 2
  %load_i8 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_i8, %load_stop
  %8 = icmp ne i1 %tmpVar, false
  br i1 %8, label %18, label %19

for_body:                                         ; preds = %16
  %deref = load [255 x i8]*, [255 x i8]** %pt, align 8
  %load_I = load i16, i16* %i, align 2
  %9 = sub i16 %load_I, 1
  %10 = sext i16 %9 to i32
  %tmpVar30 = mul i32 1, %10
  %tmpVar31 = add i32 %tmpVar30, 0
  %tmpVar32 = getelementptr inbounds [255 x i8], [255 x i8]* %deref, i32 0, i32 %tmpVar31
  %load_tmpVar = load i8, i8* %tmpVar32, align 1
  store i8 %load_tmpVar, i8* %x, align 1
  %load_x = load i8, i8* %x, align 1
  %11 = zext i8 %load_x to i32
  %tmpVar34 = icmp slt i32 %11, 32
  %12 = zext i1 %tmpVar34 to i32
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %36, label %33

increment:                                        ; preds = %continue33
  %tmpVar37 = add i16 %load_i, 1
  store i16 %tmpVar37, i16* %i, align 2
  br label %condition_check

continue7:                                        ; preds = %16
  store i16 0, i16* %FIND_CTRL, align 2
  %FIND_CTRL_ret38 = load i16, i16* %FIND_CTRL, align 2
  ret i16 %FIND_CTRL_ret38

14:                                               ; preds = %19
  %load_i18 = load i16, i16* %i, align 2
  %load_stop19 = load i16, i16* %stop, align 2
  %tmpVar20 = icmp sge i16 %load_i18, %load_stop19
  %15 = icmp ne i1 %tmpVar20, false
  br i1 %15, label %26, label %27

16:                                               ; preds = %27, %19
  %17 = phi i1 [ %20, %19 ], [ %28, %27 ]
  br i1 %17, label %for_body, label %continue7

18:                                               ; preds = %condition_check
  %load_i9 = load i16, i16* %i, align 2
  %MAX_instance10 = alloca %MAX_interface, align 8
  br label %input11

19:                                               ; preds = %continue14, %condition_check
  %20 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar17, %continue14 ]
  %21 = icmp ne i1 %20, false
  br i1 %21, label %16, label %14

input11:                                          ; preds = %18
  %22 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance10, i32 0, i32 0
  %load_pos15 = load i16, i16* %pos, align 2
  %23 = sext i16 %load_pos15 to i64
  store i64 %23, i64* %22, align 4
  %24 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance10, i32 0, i32 1
  store i64 1, i64* %24, align 4
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call i64 @MAX(%MAX_interface* %MAX_instance10)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %25 = trunc i64 %call16 to i16
  %tmpVar17 = icmp sge i16 %load_i9, %25
  br label %19

26:                                               ; preds = %14
  %load_i21 = load i16, i16* %i, align 2
  %MAX_instance22 = alloca %MAX_interface, align 8
  br label %input23

27:                                               ; preds = %continue26, %14
  %28 = phi i1 [ %tmpVar20, %14 ], [ %tmpVar29, %continue26 ]
  br label %16

input23:                                          ; preds = %26
  %29 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance22, i32 0, i32 0
  %load_pos27 = load i16, i16* %pos, align 2
  %30 = sext i16 %load_pos27 to i64
  store i64 %30, i64* %29, align 4
  %31 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance22, i32 0, i32 1
  store i64 1, i64* %31, align 4
  br label %call24

call24:                                           ; preds = %input23
  %call28 = call i64 @MAX(%MAX_interface* %MAX_instance22)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %32 = trunc i64 %call28 to i16
  %tmpVar29 = icmp sle i16 %load_i21, %32
  br label %27

condition_body:                                   ; preds = %36
  %load_i36 = load i16, i16* %i, align 2
  store i16 %load_i36, i16* %FIND_CTRL, align 2
  %FIND_CTRL_ret = load i16, i16* %FIND_CTRL, align 2
  ret i16 %FIND_CTRL_ret

buffer_block:                                     ; No predecessors!
  br label %continue33

continue33:                                       ; preds = %buffer_block, %36
  br label %increment

33:                                               ; preds = %for_body
  %load_X = load i8, i8* %x, align 1
  %34 = zext i8 %load_X to i32
  %tmpVar35 = icmp eq i32 %34, 127
  %35 = zext i1 %tmpVar35 to i32
  br label %36

36:                                               ; preds = %33, %for_body
  %37 = phi i32 [ %12, %for_body ], [ %35, %33 ]
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %condition_body, label %continue33
}

define i16 @FIND_NONUM(%FIND_NONUM_interface* %0) {
entry:
  %str = getelementptr inbounds %FIND_NONUM_interface, %FIND_NONUM_interface* %0, i32 0, i32 0
  %pos = getelementptr inbounds %FIND_NONUM_interface, %FIND_NONUM_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %FIND_NONUM_interface, %FIND_NONUM_interface* %0, i32 0, i32 2
  %pt = getelementptr inbounds %FIND_NONUM_interface, %FIND_NONUM_interface* %0, i32 0, i32 3
  %end = getelementptr inbounds %FIND_NONUM_interface, %FIND_NONUM_interface* %0, i32 0, i32 4
  %X = getelementptr inbounds %FIND_NONUM_interface, %FIND_NONUM_interface* %0, i32 0, i32 5
  %FIND_NONUM = alloca i16, align 2
  store i16 0, i16* %i, align 2
  store [255 x i8]* null, [255 x i8]** %pt, align 8
  store i16 0, i16* %end, align 2
  store i8 0, i8* %X, align 1
  store i16 0, i16* %FIND_NONUM, align 2
  store [251 x i8]* %str, [255 x i8]** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %end, align 2
  %MAX_instance = alloca %MAX_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %4 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 0
  %load_pos = load i16, i16* %pos, align 2
  %5 = sext i16 %load_pos to i64
  store i64 %5, i64* %4, align 4
  %6 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 1
  store i64 1, i64* %6, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @MAX(%MAX_interface* %MAX_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %7 = trunc i64 %call6 to i16
  store i16 %7, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue5
  %load_i = load i16, i16* %i, align 2
  %load_i8 = load i16, i16* %i, align 2
  %load_end = load i16, i16* %end, align 2
  %tmpVar = icmp sle i16 %load_i8, %load_end
  %8 = icmp ne i1 %tmpVar, false
  br i1 %8, label %18, label %19

for_body:                                         ; preds = %16
  %deref = load [255 x i8]*, [255 x i8]** %pt, align 8
  %load_i30 = load i16, i16* %i, align 2
  %9 = sub i16 %load_i30, 1
  %10 = sext i16 %9 to i32
  %tmpVar31 = mul i32 1, %10
  %tmpVar32 = add i32 %tmpVar31, 0
  %tmpVar33 = getelementptr inbounds [255 x i8], [255 x i8]* %deref, i32 0, i32 %tmpVar32
  %load_tmpVar = load i8, i8* %tmpVar33, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %11 = zext i8 %load_X to i32
  %tmpVar35 = icmp slt i32 %11, 48
  %12 = zext i1 %tmpVar35 to i32
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %39, label %42

increment:                                        ; preds = %continue34
  %tmpVar41 = add i16 %load_i, 1
  store i16 %tmpVar41, i16* %i, align 2
  br label %condition_check

continue7:                                        ; preds = %16
  store i16 0, i16* %FIND_NONUM, align 2
  %FIND_NONUM_ret42 = load i16, i16* %FIND_NONUM, align 2
  ret i16 %FIND_NONUM_ret42

14:                                               ; preds = %19
  %load_i18 = load i16, i16* %i, align 2
  %load_end19 = load i16, i16* %end, align 2
  %tmpVar20 = icmp sge i16 %load_i18, %load_end19
  %15 = icmp ne i1 %tmpVar20, false
  br i1 %15, label %26, label %27

16:                                               ; preds = %27, %19
  %17 = phi i1 [ %20, %19 ], [ %28, %27 ]
  br i1 %17, label %for_body, label %continue7

18:                                               ; preds = %condition_check
  %load_i9 = load i16, i16* %i, align 2
  %MAX_instance10 = alloca %MAX_interface, align 8
  br label %input11

19:                                               ; preds = %continue14, %condition_check
  %20 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar17, %continue14 ]
  %21 = icmp ne i1 %20, false
  br i1 %21, label %16, label %14

input11:                                          ; preds = %18
  %22 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance10, i32 0, i32 0
  %load_pos15 = load i16, i16* %pos, align 2
  %23 = sext i16 %load_pos15 to i64
  store i64 %23, i64* %22, align 4
  %24 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance10, i32 0, i32 1
  store i64 1, i64* %24, align 4
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call i64 @MAX(%MAX_interface* %MAX_instance10)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %25 = trunc i64 %call16 to i16
  %tmpVar17 = icmp sge i16 %load_i9, %25
  br label %19

26:                                               ; preds = %14
  %load_i21 = load i16, i16* %i, align 2
  %MAX_instance22 = alloca %MAX_interface, align 8
  br label %input23

27:                                               ; preds = %continue26, %14
  %28 = phi i1 [ %tmpVar20, %14 ], [ %tmpVar29, %continue26 ]
  br label %16

input23:                                          ; preds = %26
  %29 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance22, i32 0, i32 0
  %load_pos27 = load i16, i16* %pos, align 2
  %30 = sext i16 %load_pos27 to i64
  store i64 %30, i64* %29, align 4
  %31 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance22, i32 0, i32 1
  store i64 1, i64* %31, align 4
  br label %call24

call24:                                           ; preds = %input23
  %call28 = call i64 @MAX(%MAX_interface* %MAX_instance22)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %32 = trunc i64 %call28 to i16
  %tmpVar29 = icmp sle i16 %load_i21, %32
  br label %27

condition_body:                                   ; preds = %36
  %load_i40 = load i16, i16* %i, align 2
  store i16 %load_i40, i16* %FIND_NONUM, align 2
  %FIND_NONUM_ret = load i16, i16* %FIND_NONUM, align 2
  ret i16 %FIND_NONUM_ret

buffer_block:                                     ; No predecessors!
  br label %continue34

continue34:                                       ; preds = %buffer_block, %36
  br label %increment

33:                                               ; preds = %42
  %load_X38 = load i8, i8* %X, align 1
  %34 = zext i8 %load_X38 to i32
  %tmpVar39 = icmp sgt i32 %34, 57
  %35 = zext i1 %tmpVar39 to i32
  br label %36

36:                                               ; preds = %33, %42
  %37 = phi i32 [ %43, %42 ], [ %35, %33 ]
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %condition_body, label %continue34

39:                                               ; preds = %for_body
  %load_X36 = load i8, i8* %X, align 1
  %40 = zext i8 %load_X36 to i32
  %tmpVar37 = icmp ne i32 %40, 46
  %41 = zext i1 %tmpVar37 to i32
  br label %42

42:                                               ; preds = %39, %for_body
  %43 = phi i32 [ %12, %for_body ], [ %41, %39 ]
  %44 = icmp ne i32 %43, 0
  br i1 %44, label %36, label %33
}

define i16 @FIND_NUM(%FIND_NUM_interface* %0) {
entry:
  %str = getelementptr inbounds %FIND_NUM_interface, %FIND_NUM_interface* %0, i32 0, i32 0
  %pos = getelementptr inbounds %FIND_NUM_interface, %FIND_NUM_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %FIND_NUM_interface, %FIND_NUM_interface* %0, i32 0, i32 2
  %pt = getelementptr inbounds %FIND_NUM_interface, %FIND_NUM_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %FIND_NUM_interface, %FIND_NUM_interface* %0, i32 0, i32 4
  %X = getelementptr inbounds %FIND_NUM_interface, %FIND_NUM_interface* %0, i32 0, i32 5
  %FIND_NUM = alloca i16, align 2
  store i16 0, i16* %i, align 2
  store [255 x i8]* null, [255 x i8]** %pt, align 8
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %X, align 1
  store i16 0, i16* %FIND_NUM, align 2
  store [251 x i8]* %str, [255 x i8]** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  %MAX_instance = alloca %MAX_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %4 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 0
  %load_pos = load i16, i16* %pos, align 2
  %5 = sext i16 %load_pos to i64
  store i64 %5, i64* %4, align 4
  %6 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 1
  store i64 1, i64* %6, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @MAX(%MAX_interface* %MAX_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %7 = trunc i64 %call6 to i16
  store i16 %7, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue5
  %load_i = load i16, i16* %i, align 2
  %load_i8 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_i8, %load_stop
  %8 = icmp ne i1 %tmpVar, false
  br i1 %8, label %18, label %19

for_body:                                         ; preds = %16
  %deref = load [255 x i8]*, [255 x i8]** %pt, align 8
  %load_i30 = load i16, i16* %i, align 2
  %9 = sub i16 %load_i30, 1
  %10 = sext i16 %9 to i32
  %tmpVar31 = mul i32 1, %10
  %tmpVar32 = add i32 %tmpVar31, 0
  %tmpVar33 = getelementptr inbounds [255 x i8], [255 x i8]* %deref, i32 0, i32 %tmpVar32
  %load_tmpVar = load i8, i8* %tmpVar33, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %11 = zext i8 %load_X to i32
  %tmpVar35 = icmp sgt i32 %11, 47
  %12 = zext i1 %tmpVar35 to i32
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %39, label %42

increment:                                        ; preds = %continue34
  %tmpVar41 = add i16 %load_i, 1
  store i16 %tmpVar41, i16* %i, align 2
  br label %condition_check

continue7:                                        ; preds = %16
  store i16 0, i16* %FIND_NUM, align 2
  %FIND_NUM_ret42 = load i16, i16* %FIND_NUM, align 2
  ret i16 %FIND_NUM_ret42

14:                                               ; preds = %19
  %load_i18 = load i16, i16* %i, align 2
  %load_stop19 = load i16, i16* %stop, align 2
  %tmpVar20 = icmp sge i16 %load_i18, %load_stop19
  %15 = icmp ne i1 %tmpVar20, false
  br i1 %15, label %26, label %27

16:                                               ; preds = %27, %19
  %17 = phi i1 [ %20, %19 ], [ %28, %27 ]
  br i1 %17, label %for_body, label %continue7

18:                                               ; preds = %condition_check
  %load_i9 = load i16, i16* %i, align 2
  %MAX_instance10 = alloca %MAX_interface, align 8
  br label %input11

19:                                               ; preds = %continue14, %condition_check
  %20 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar17, %continue14 ]
  %21 = icmp ne i1 %20, false
  br i1 %21, label %16, label %14

input11:                                          ; preds = %18
  %22 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance10, i32 0, i32 0
  %load_pos15 = load i16, i16* %pos, align 2
  %23 = sext i16 %load_pos15 to i64
  store i64 %23, i64* %22, align 4
  %24 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance10, i32 0, i32 1
  store i64 1, i64* %24, align 4
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call i64 @MAX(%MAX_interface* %MAX_instance10)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %25 = trunc i64 %call16 to i16
  %tmpVar17 = icmp sge i16 %load_i9, %25
  br label %19

26:                                               ; preds = %14
  %load_i21 = load i16, i16* %i, align 2
  %MAX_instance22 = alloca %MAX_interface, align 8
  br label %input23

27:                                               ; preds = %continue26, %14
  %28 = phi i1 [ %tmpVar20, %14 ], [ %tmpVar29, %continue26 ]
  br label %16

input23:                                          ; preds = %26
  %29 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance22, i32 0, i32 0
  %load_pos27 = load i16, i16* %pos, align 2
  %30 = sext i16 %load_pos27 to i64
  store i64 %30, i64* %29, align 4
  %31 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance22, i32 0, i32 1
  store i64 1, i64* %31, align 4
  br label %call24

call24:                                           ; preds = %input23
  %call28 = call i64 @MAX(%MAX_interface* %MAX_instance22)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %32 = trunc i64 %call28 to i16
  %tmpVar29 = icmp sle i16 %load_i21, %32
  br label %27

condition_body:                                   ; preds = %36
  %load_i40 = load i16, i16* %i, align 2
  store i16 %load_i40, i16* %FIND_NUM, align 2
  %FIND_NUM_ret = load i16, i16* %FIND_NUM, align 2
  ret i16 %FIND_NUM_ret

buffer_block:                                     ; No predecessors!
  br label %continue34

continue34:                                       ; preds = %buffer_block, %36
  br label %increment

33:                                               ; preds = %42
  %load_X38 = load i8, i8* %X, align 1
  %34 = zext i8 %load_X38 to i32
  %tmpVar39 = icmp eq i32 %34, 46
  %35 = zext i1 %tmpVar39 to i32
  br label %36

36:                                               ; preds = %33, %42
  %37 = phi i32 [ %43, %42 ], [ %35, %33 ]
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %condition_body, label %continue34

39:                                               ; preds = %for_body
  %load_X36 = load i8, i8* %X, align 1
  %40 = zext i8 %load_X36 to i32
  %tmpVar37 = icmp slt i32 %40, 58
  %41 = zext i1 %tmpVar37 to i32
  br label %42

42:                                               ; preds = %39, %for_body
  %43 = phi i32 [ %12, %for_body ], [ %41, %39 ]
  %44 = icmp ne i32 %43, 0
  br i1 %44, label %36, label %33
}

define i16 @FINDB(%FINDB_interface* %0) {
entry:
  %str1 = getelementptr inbounds %FINDB_interface, %FINDB_interface* %0, i32 0, i32 0
  %str2 = getelementptr inbounds %FINDB_interface, %FINDB_interface* %0, i32 0, i32 1
  %pos = getelementptr inbounds %FINDB_interface, %FINDB_interface* %0, i32 0, i32 2
  %length = getelementptr inbounds %FINDB_interface, %FINDB_interface* %0, i32 0, i32 3
  %FINDB = alloca i16, align 2
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %length, align 2
  store i16 0, i16* %FINDB, align 2
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %length, align 2
  %LEN_instance2 = alloca %LEN_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %4 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance2, i32 0, i32 0
  %5 = bitcast [1024 x i8]* %4 to i8*
  %6 = bitcast [251 x i8]* %str1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 251, i1 false)
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i16 @LEN(%LEN_interface* %LEN_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %7 = sext i16 %call7 to i32
  %load_length = load i16, i16* %length, align 2
  %8 = sext i16 %load_length to i32
  %tmpVar = sub i32 %7, %8
  %tmpVar8 = add i32 %tmpVar, 1
  %9 = trunc i32 %tmpVar8 to i16
  store i16 %9, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue6
  %load_pos = load i16, i16* %pos, align 2
  %load_pos10 = load i16, i16* %pos, align 2
  %tmpVar11 = icmp sle i16 %load_pos10, 1
  %10 = icmp ne i1 %tmpVar11, false
  br i1 %10, label %15, label %16

for_body:                                         ; preds = %13
  %STRING_EQUAL_instance = alloca %STRING_EQUAL_interface, align 8
  br label %input37

increment:                                        ; preds = %continue36
  %tmpVar50 = add i16 %load_pos, -1
  store i16 %tmpVar50, i16* %pos, align 2
  br label %condition_check

continue9:                                        ; preds = %13
  store i16 0, i16* %FINDB, align 2
  %FINDB_ret51 = load i16, i16* %FINDB, align 2
  ret i16 %FINDB_ret51

11:                                               ; preds = %16
  %load_pos23 = load i16, i16* %pos, align 2
  %tmpVar24 = icmp sge i16 %load_pos23, 1
  %12 = icmp ne i1 %tmpVar24, false
  br i1 %12, label %25, label %26

13:                                               ; preds = %26, %16
  %14 = phi i1 [ %17, %16 ], [ %27, %26 ]
  br i1 %14, label %for_body, label %continue9

15:                                               ; preds = %condition_check
  %load_pos12 = load i16, i16* %pos, align 2
  %LEN_instance13 = alloca %LEN_interface, align 8
  br label %input14

16:                                               ; preds = %continue17, %condition_check
  %17 = phi i1 [ %tmpVar11, %condition_check ], [ %tmpVar22, %continue17 ]
  %18 = icmp ne i1 %17, false
  br i1 %18, label %13, label %11

input14:                                          ; preds = %15
  %19 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance13, i32 0, i32 0
  %20 = bitcast [1024 x i8]* %19 to i8*
  %21 = bitcast [251 x i8]* %str1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 251, i1 false)
  br label %call15

call15:                                           ; preds = %input14
  %call18 = call i16 @LEN(%LEN_interface* %LEN_instance13)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %22 = sext i16 %call18 to i32
  %load_length19 = load i16, i16* %length, align 2
  %23 = sext i16 %load_length19 to i32
  %tmpVar20 = sub i32 %22, %23
  %tmpVar21 = add i32 %tmpVar20, 1
  %24 = trunc i32 %tmpVar21 to i16
  %tmpVar22 = icmp sge i16 %load_pos12, %24
  br label %16

25:                                               ; preds = %11
  %load_pos25 = load i16, i16* %pos, align 2
  %LEN_instance26 = alloca %LEN_interface, align 8
  br label %input27

26:                                               ; preds = %continue30, %11
  %27 = phi i1 [ %tmpVar24, %11 ], [ %tmpVar35, %continue30 ]
  br label %13

input27:                                          ; preds = %25
  %28 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance26, i32 0, i32 0
  %29 = bitcast [1024 x i8]* %28 to i8*
  %30 = bitcast [251 x i8]* %str1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %29, i8* align 1 %30, i32 251, i1 false)
  br label %call28

call28:                                           ; preds = %input27
  %call31 = call i16 @LEN(%LEN_interface* %LEN_instance26)
  br label %output29

output29:                                         ; preds = %call28
  br label %continue30

continue30:                                       ; preds = %output29
  %31 = sext i16 %call31 to i32
  %load_length32 = load i16, i16* %length, align 2
  %32 = sext i16 %load_length32 to i32
  %tmpVar33 = sub i32 %31, %32
  %tmpVar34 = add i32 %tmpVar33, 1
  %33 = trunc i32 %tmpVar34 to i16
  %tmpVar35 = icmp sle i16 %load_pos25, %33
  br label %26

condition_body:                                   ; preds = %continue40
  %load_pos49 = load i16, i16* %pos, align 2
  store i16 %load_pos49, i16* %FINDB, align 2
  %FINDB_ret = load i16, i16* %FINDB, align 2
  ret i16 %FINDB_ret

buffer_block:                                     ; No predecessors!
  br label %continue36

continue36:                                       ; preds = %buffer_block, %continue40
  br label %increment

input37:                                          ; preds = %for_body
  %34 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 0
  %MID_instance = alloca %MID_interface, align 8
  br label %input41

call38:                                           ; preds = %continue44
  %call48 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance)
  br label %output39

output39:                                         ; preds = %call38
  br label %continue40

continue40:                                       ; preds = %output39
  %35 = icmp ne i8 %call48, 0
  br i1 %35, label %condition_body, label %continue36

input41:                                          ; preds = %input37
  %36 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %37 = bitcast [1024 x i8]* %36 to i8*
  %38 = bitcast [251 x i8]* %str1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %37, i8* align 1 %38, i32 251, i1 false)
  %39 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  %load_length45 = load i16, i16* %length, align 2
  store i16 %load_length45, i16* %39, align 2
  %40 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  %load_pos46 = load i16, i16* %pos, align 2
  store i16 %load_pos46, i16* %40, align 2
  br label %call42

call42:                                           ; preds = %input41
  %call47 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output43

output43:                                         ; preds = %call42
  br label %continue44

continue44:                                       ; preds = %output43
  %41 = alloca [1024 x i8], align 1
  store [1024 x i8] %call47, [1024 x i8]* %41, align 1
  %42 = bitcast [1025 x i8]* %34 to i8*
  %43 = bitcast [1024 x i8]* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %42, i8* align 1 %43, i32 1024, i1 false)
  %44 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 1
  %45 = bitcast [1025 x i8]* %44 to i8*
  %46 = bitcast [251 x i8]* %str2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %45, i8* align 1 %46, i32 251, i1 false)
  br label %call38
}

define i16 @FINDB_NONUM(%FINDB_NONUM_interface* %0) {
entry:
  %str = getelementptr inbounds %FINDB_NONUM_interface, %FINDB_NONUM_interface* %0, i32 0, i32 0
  %pos = getelementptr inbounds %FINDB_NONUM_interface, %FINDB_NONUM_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %FINDB_NONUM_interface, %FINDB_NONUM_interface* %0, i32 0, i32 2
  %FINDB_NONUM = alloca i16, align 2
  store i16 0, i16* %pos, align 2
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %FINDB_NONUM, align 2
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %access_POINTER_TO_STRING = getelementptr inbounds [251 x i8], [251 x i8]* %str, i16 %call1
  %access_POINTER_TO_STRING2 = getelementptr inbounds [251 x i8], [251 x i8]* %access_POINTER_TO_STRING, i32 -1
  store [251 x i8]* %access_POINTER_TO_STRING2, i8** %pt, align 8
  %LEN_instance3 = alloca %LEN_interface, align 8
  br label %input4

input4:                                           ; preds = %continue
  %4 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance3, i32 0, i32 0
  %5 = bitcast [1024 x i8]* %4 to i8*
  %6 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 251, i1 false)
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call i16 @LEN(%LEN_interface* %LEN_instance3)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  store i16 %call8, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue7
  %load_pos = load i16, i16* %pos, align 2
  %load_pos10 = load i16, i16* %pos, align 2
  %tmpVar = icmp sle i16 %load_pos10, 1
  %7 = icmp ne i1 %tmpVar, false
  br i1 %7, label %15, label %16

for_body:                                         ; preds = %13
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  %8 = zext i8 %load_tmpVar to i32
  %tmpVar30 = icmp slt i32 %8, 48
  %9 = zext i1 %tmpVar30 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %34, label %37

increment:                                        ; preds = %continue29
  %tmpVar38 = add i16 %load_pos, -1
  store i16 %tmpVar38, i16* %pos, align 2
  br label %condition_check

continue9:                                        ; preds = %13
  store i16 0, i16* %FINDB_NONUM, align 2
  %FINDB_NONUM_ret39 = load i16, i16* %FINDB_NONUM, align 2
  ret i16 %FINDB_NONUM_ret39

11:                                               ; preds = %16
  %load_pos19 = load i16, i16* %pos, align 2
  %tmpVar20 = icmp sge i16 %load_pos19, 1
  %12 = icmp ne i1 %tmpVar20, false
  br i1 %12, label %22, label %23

13:                                               ; preds = %23, %16
  %14 = phi i1 [ %17, %16 ], [ %24, %23 ]
  br i1 %14, label %for_body, label %continue9

15:                                               ; preds = %condition_check
  %load_pos11 = load i16, i16* %pos, align 2
  %LEN_instance12 = alloca %LEN_interface, align 8
  br label %input13

16:                                               ; preds = %continue16, %condition_check
  %17 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar18, %continue16 ]
  %18 = icmp ne i1 %17, false
  br i1 %18, label %13, label %11

input13:                                          ; preds = %15
  %19 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance12, i32 0, i32 0
  %20 = bitcast [1024 x i8]* %19 to i8*
  %21 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 251, i1 false)
  br label %call14

call14:                                           ; preds = %input13
  %call17 = call i16 @LEN(%LEN_interface* %LEN_instance12)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %tmpVar18 = icmp sge i16 %load_pos11, %call17
  br label %16

22:                                               ; preds = %11
  %load_pos21 = load i16, i16* %pos, align 2
  %LEN_instance22 = alloca %LEN_interface, align 8
  br label %input23

23:                                               ; preds = %continue26, %11
  %24 = phi i1 [ %tmpVar20, %11 ], [ %tmpVar28, %continue26 ]
  br label %13

input23:                                          ; preds = %22
  %25 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance22, i32 0, i32 0
  %26 = bitcast [1024 x i8]* %25 to i8*
  %27 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %26, i8* align 1 %27, i32 251, i1 false)
  br label %call24

call24:                                           ; preds = %input23
  %call27 = call i16 @LEN(%LEN_interface* %LEN_instance22)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %tmpVar28 = icmp sle i16 %load_pos21, %call27
  br label %23

condition_body:                                   ; preds = %31
  %load_pos37 = load i16, i16* %pos, align 2
  store i16 %load_pos37, i16* %FINDB_NONUM, align 2
  %FINDB_NONUM_ret = load i16, i16* %FINDB_NONUM, align 2
  ret i16 %FINDB_NONUM_ret

buffer_block:                                     ; No predecessors!
  br label %continue29

continue29:                                       ; preds = %buffer_block, %31
  %load_PT = load i8*, i8** %pt, align 8
  %access___FINDB_NONUM_pt = getelementptr inbounds i8, i8* %load_PT, i32 -1
  store i8* %access___FINDB_NONUM_pt, i8** %pt, align 8
  br label %increment

28:                                               ; preds = %37
  %deref34 = load i8*, i8** %pt, align 8
  %load_tmpVar35 = load i8, i8* %deref34, align 1
  %29 = zext i8 %load_tmpVar35 to i32
  %tmpVar36 = icmp sgt i32 %29, 57
  %30 = zext i1 %tmpVar36 to i32
  br label %31

31:                                               ; preds = %28, %37
  %32 = phi i32 [ %38, %37 ], [ %30, %28 ]
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %condition_body, label %continue29

34:                                               ; preds = %for_body
  %deref31 = load i8*, i8** %pt, align 8
  %load_tmpVar32 = load i8, i8* %deref31, align 1
  %35 = zext i8 %load_tmpVar32 to i32
  %tmpVar33 = icmp ne i32 %35, 46
  %36 = zext i1 %tmpVar33 to i32
  br label %37

37:                                               ; preds = %34, %for_body
  %38 = phi i32 [ %9, %for_body ], [ %36, %34 ]
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %31, label %28
}

define i16 @FINDB_NUM(%FINDB_NUM_interface* %0) {
entry:
  %str = getelementptr inbounds %FINDB_NUM_interface, %FINDB_NUM_interface* %0, i32 0, i32 0
  %pos = getelementptr inbounds %FINDB_NUM_interface, %FINDB_NUM_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %FINDB_NUM_interface, %FINDB_NUM_interface* %0, i32 0, i32 2
  %FINDB_NUM = alloca i16, align 2
  store i16 0, i16* %pos, align 2
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %FINDB_NUM, align 2
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %access_POINTER_TO_STRING = getelementptr inbounds [251 x i8], [251 x i8]* %str, i16 %call1
  %access_POINTER_TO_STRING2 = getelementptr inbounds [251 x i8], [251 x i8]* %access_POINTER_TO_STRING, i32 -1
  store [251 x i8]* %access_POINTER_TO_STRING2, i8** %pt, align 8
  %LEN_instance3 = alloca %LEN_interface, align 8
  br label %input4

input4:                                           ; preds = %continue
  %4 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance3, i32 0, i32 0
  %5 = bitcast [1024 x i8]* %4 to i8*
  %6 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 251, i1 false)
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call i16 @LEN(%LEN_interface* %LEN_instance3)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  store i16 %call8, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue7
  %load_pos = load i16, i16* %pos, align 2
  %load_pos10 = load i16, i16* %pos, align 2
  %tmpVar = icmp sle i16 %load_pos10, 1
  %7 = icmp ne i1 %tmpVar, false
  br i1 %7, label %15, label %16

for_body:                                         ; preds = %13
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  %8 = zext i8 %load_tmpVar to i32
  %tmpVar30 = icmp sgt i32 %8, 47
  %9 = zext i1 %tmpVar30 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %34, label %37

increment:                                        ; preds = %continue29
  %tmpVar38 = add i16 %load_pos, -1
  store i16 %tmpVar38, i16* %pos, align 2
  br label %condition_check

continue9:                                        ; preds = %13
  store i16 0, i16* %FINDB_NUM, align 2
  %FINDB_NUM_ret39 = load i16, i16* %FINDB_NUM, align 2
  ret i16 %FINDB_NUM_ret39

11:                                               ; preds = %16
  %load_pos19 = load i16, i16* %pos, align 2
  %tmpVar20 = icmp sge i16 %load_pos19, 1
  %12 = icmp ne i1 %tmpVar20, false
  br i1 %12, label %22, label %23

13:                                               ; preds = %23, %16
  %14 = phi i1 [ %17, %16 ], [ %24, %23 ]
  br i1 %14, label %for_body, label %continue9

15:                                               ; preds = %condition_check
  %load_pos11 = load i16, i16* %pos, align 2
  %LEN_instance12 = alloca %LEN_interface, align 8
  br label %input13

16:                                               ; preds = %continue16, %condition_check
  %17 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar18, %continue16 ]
  %18 = icmp ne i1 %17, false
  br i1 %18, label %13, label %11

input13:                                          ; preds = %15
  %19 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance12, i32 0, i32 0
  %20 = bitcast [1024 x i8]* %19 to i8*
  %21 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 251, i1 false)
  br label %call14

call14:                                           ; preds = %input13
  %call17 = call i16 @LEN(%LEN_interface* %LEN_instance12)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %tmpVar18 = icmp sge i16 %load_pos11, %call17
  br label %16

22:                                               ; preds = %11
  %load_pos21 = load i16, i16* %pos, align 2
  %LEN_instance22 = alloca %LEN_interface, align 8
  br label %input23

23:                                               ; preds = %continue26, %11
  %24 = phi i1 [ %tmpVar20, %11 ], [ %tmpVar28, %continue26 ]
  br label %13

input23:                                          ; preds = %22
  %25 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance22, i32 0, i32 0
  %26 = bitcast [1024 x i8]* %25 to i8*
  %27 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %26, i8* align 1 %27, i32 251, i1 false)
  br label %call24

call24:                                           ; preds = %input23
  %call27 = call i16 @LEN(%LEN_interface* %LEN_instance22)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %tmpVar28 = icmp sle i16 %load_pos21, %call27
  br label %23

condition_body:                                   ; preds = %31
  %load_pos37 = load i16, i16* %pos, align 2
  store i16 %load_pos37, i16* %FINDB_NUM, align 2
  %FINDB_NUM_ret = load i16, i16* %FINDB_NUM, align 2
  ret i16 %FINDB_NUM_ret

buffer_block:                                     ; No predecessors!
  br label %continue29

continue29:                                       ; preds = %buffer_block, %31
  %load_PT = load i8*, i8** %pt, align 8
  %access___FINDB_NUM_pt = getelementptr inbounds i8, i8* %load_PT, i32 -1
  store i8* %access___FINDB_NUM_pt, i8** %pt, align 8
  br label %increment

28:                                               ; preds = %37
  %deref34 = load i8*, i8** %pt, align 8
  %load_tmpVar35 = load i8, i8* %deref34, align 1
  %29 = zext i8 %load_tmpVar35 to i32
  %tmpVar36 = icmp eq i32 %29, 46
  %30 = zext i1 %tmpVar36 to i32
  br label %31

31:                                               ; preds = %28, %37
  %32 = phi i32 [ %38, %37 ], [ %30, %28 ]
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %condition_body, label %continue29

34:                                               ; preds = %for_body
  %deref31 = load i8*, i8** %pt, align 8
  %load_tmpVar32 = load i8, i8* %deref31, align 1
  %35 = zext i8 %load_tmpVar32 to i32
  %tmpVar33 = icmp slt i32 %35, 58
  %36 = zext i1 %tmpVar33 to i32
  br label %37

37:                                               ; preds = %34, %for_body
  %38 = phi i32 [ %9, %for_body ], [ %36, %34 ]
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %31, label %28
}

define i16 @FINDP(%FINDP_interface* %0) {
entry:
  %str = getelementptr inbounds %FINDP_interface, %FINDP_interface* %0, i32 0, i32 0
  %src = getelementptr inbounds %FINDP_interface, %FINDP_interface* %0, i32 0, i32 1
  %pos = getelementptr inbounds %FINDP_interface, %FINDP_interface* %0, i32 0, i32 2
  %i = getelementptr inbounds %FINDP_interface, %FINDP_interface* %0, i32 0, i32 3
  %ls = getelementptr inbounds %FINDP_interface, %FINDP_interface* %0, i32 0, i32 4
  %lx = getelementptr inbounds %FINDP_interface, %FINDP_interface* %0, i32 0, i32 5
  %stp = getelementptr inbounds %FINDP_interface, %FINDP_interface* %0, i32 0, i32 6
  %FINDP = alloca i16, align 2
  store i16 0, i16* %i, align 2
  store i16 0, i16* %ls, align 2
  store i16 0, i16* %lx, align 2
  store i16 0, i16* %stp, align 2
  store i16 0, i16* %FINDP, align 2
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %ls, align 2
  %LEN_instance2 = alloca %LEN_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %4 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance2, i32 0, i32 0
  %5 = bitcast [1024 x i8]* %4 to i8*
  %6 = bitcast [251 x i8]* %src to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 251, i1 false)
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i16 @LEN(%LEN_interface* %LEN_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  store i16 %call7, i16* %lx, align 2
  %load_ls = load i16, i16* %ls, align 2
  %7 = sext i16 %load_ls to i32
  %load_lx = load i16, i16* %lx, align 2
  %8 = sext i16 %load_lx to i32
  %tmpVar = icmp slt i32 %7, %8
  %9 = zext i1 %tmpVar to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %17, label %14

condition_body:                                   ; preds = %17
  %FINDP_ret = load i16, i16* %FINDP, align 2
  ret i16 %FINDP_ret

buffer_block:                                     ; No predecessors!
  br label %continue8

continue8:                                        ; preds = %buffer_block, %17
  %load_ls11 = load i16, i16* %ls, align 2
  %11 = sext i16 %load_ls11 to i32
  %load_lx12 = load i16, i16* %lx, align 2
  %12 = sext i16 %load_lx12 to i32
  %tmpVar13 = sub i32 %11, %12
  %tmpVar14 = add i32 %tmpVar13, 1
  %13 = trunc i32 %tmpVar14 to i16
  store i16 %13, i16* %stp, align 2
  %MAX_instance = alloca %MAX_interface, align 8
  br label %input15

14:                                               ; preds = %continue6
  %load_lx9 = load i16, i16* %lx, align 2
  %15 = sext i16 %load_lx9 to i32
  %tmpVar10 = icmp eq i32 %15, 0
  %16 = zext i1 %tmpVar10 to i32
  br label %17

17:                                               ; preds = %14, %continue6
  %18 = phi i32 [ %9, %continue6 ], [ %16, %14 ]
  %19 = icmp ne i32 %18, 0
  br i1 %19, label %condition_body, label %continue8

input15:                                          ; preds = %continue8
  %20 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 0
  %load_pos = load i16, i16* %pos, align 2
  %21 = sext i16 %load_pos to i64
  store i64 %21, i64* %20, align 4
  %22 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance, i32 0, i32 1
  store i64 1, i64* %22, align 4
  br label %call16

call16:                                           ; preds = %input15
  %call19 = call i64 @MAX(%MAX_interface* %MAX_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %23 = trunc i64 %call19 to i16
  store i16 %23, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue18
  %load_i = load i16, i16* %i, align 2
  %load_i21 = load i16, i16* %i, align 2
  %load_stp = load i16, i16* %stp, align 2
  %tmpVar22 = icmp sle i16 %load_i21, %load_stp
  %24 = icmp ne i1 %tmpVar22, false
  br i1 %24, label %29, label %30

for_body:                                         ; preds = %27
  %STRING_EQUAL_instance = alloca %STRING_EQUAL_interface, align 8
  br label %input46

increment:                                        ; preds = %continue44
  %tmpVar61 = add i16 %load_i, 1
  store i16 %tmpVar61, i16* %i, align 2
  br label %condition_check

continue20:                                       ; preds = %27
  store i16 0, i16* %FINDP, align 2
  %FINDP_ret62 = load i16, i16* %FINDP, align 2
  ret i16 %FINDP_ret62

25:                                               ; preds = %30
  %load_i32 = load i16, i16* %i, align 2
  %load_stp33 = load i16, i16* %stp, align 2
  %tmpVar34 = icmp sge i16 %load_i32, %load_stp33
  %26 = icmp ne i1 %tmpVar34, false
  br i1 %26, label %37, label %38

27:                                               ; preds = %38, %30
  %28 = phi i1 [ %31, %30 ], [ %39, %38 ]
  br i1 %28, label %for_body, label %continue20

29:                                               ; preds = %condition_check
  %load_i23 = load i16, i16* %i, align 2
  %MAX_instance24 = alloca %MAX_interface, align 8
  br label %input25

30:                                               ; preds = %continue28, %condition_check
  %31 = phi i1 [ %tmpVar22, %condition_check ], [ %tmpVar31, %continue28 ]
  %32 = icmp ne i1 %31, false
  br i1 %32, label %27, label %25

input25:                                          ; preds = %29
  %33 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance24, i32 0, i32 0
  %load_pos29 = load i16, i16* %pos, align 2
  %34 = sext i16 %load_pos29 to i64
  store i64 %34, i64* %33, align 4
  %35 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance24, i32 0, i32 1
  store i64 1, i64* %35, align 4
  br label %call26

call26:                                           ; preds = %input25
  %call30 = call i64 @MAX(%MAX_interface* %MAX_instance24)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  %36 = trunc i64 %call30 to i16
  %tmpVar31 = icmp sge i16 %load_i23, %36
  br label %30

37:                                               ; preds = %25
  %load_i35 = load i16, i16* %i, align 2
  %MAX_instance36 = alloca %MAX_interface, align 8
  br label %input37

38:                                               ; preds = %continue40, %25
  %39 = phi i1 [ %tmpVar34, %25 ], [ %tmpVar43, %continue40 ]
  br label %27

input37:                                          ; preds = %37
  %40 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance36, i32 0, i32 0
  %load_pos41 = load i16, i16* %pos, align 2
  %41 = sext i16 %load_pos41 to i64
  store i64 %41, i64* %40, align 4
  %42 = getelementptr inbounds %MAX_interface, %MAX_interface* %MAX_instance36, i32 0, i32 1
  store i64 1, i64* %42, align 4
  br label %call38

call38:                                           ; preds = %input37
  %call42 = call i64 @MAX(%MAX_interface* %MAX_instance36)
  br label %output39

output39:                                         ; preds = %call38
  br label %continue40

continue40:                                       ; preds = %output39
  %43 = trunc i64 %call42 to i16
  %tmpVar43 = icmp sle i16 %load_i35, %43
  br label %38

condition_body45:                                 ; preds = %continue49
  %load_i58 = load i16, i16* %i, align 2
  store i16 %load_i58, i16* %FINDP, align 2
  %FINDP_ret59 = load i16, i16* %FINDP, align 2
  ret i16 %FINDP_ret59

buffer_block60:                                   ; No predecessors!
  br label %continue44

continue44:                                       ; preds = %buffer_block60, %continue49
  br label %increment

input46:                                          ; preds = %for_body
  %44 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 0
  %MID_instance = alloca %MID_interface, align 8
  br label %input50

call47:                                           ; preds = %continue53
  %call57 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance)
  br label %output48

output48:                                         ; preds = %call47
  br label %continue49

continue49:                                       ; preds = %output48
  %45 = icmp ne i8 %call57, 0
  br i1 %45, label %condition_body45, label %continue44

input50:                                          ; preds = %input46
  %46 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %47 = bitcast [1024 x i8]* %46 to i8*
  %48 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %47, i8* align 1 %48, i32 251, i1 false)
  %49 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  %load_lx54 = load i16, i16* %lx, align 2
  store i16 %load_lx54, i16* %49, align 2
  %50 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  %load_i55 = load i16, i16* %i, align 2
  store i16 %load_i55, i16* %50, align 2
  br label %call51

call51:                                           ; preds = %input50
  %call56 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output52

output52:                                         ; preds = %call51
  br label %continue53

continue53:                                       ; preds = %output52
  %51 = alloca [1024 x i8], align 1
  store [1024 x i8] %call56, [1024 x i8]* %51, align 1
  %52 = bitcast [1025 x i8]* %44 to i8*
  %53 = bitcast [1024 x i8]* %51 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %52, i8* align 1 %53, i32 1024, i1 false)
  %54 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 1
  %55 = bitcast [1025 x i8]* %54 to i8*
  %56 = bitcast [251 x i8]* %src to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %55, i8* align 1 %56, i32 251, i1 false)
  br label %call47
}

define [251 x i8] @FIX(%FIX_interface* %0) {
entry:
  %str = getelementptr inbounds %FIX_interface, %FIX_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %FIX_interface, %FIX_interface* %0, i32 0, i32 1
  %C = getelementptr inbounds %FIX_interface, %FIX_interface* %0, i32 0, i32 2
  %M = getelementptr inbounds %FIX_interface, %FIX_interface* %0, i32 0, i32 3
  %N = getelementptr inbounds %FIX_interface, %FIX_interface* %0, i32 0, i32 4
  %SX = getelementptr inbounds %FIX_interface, %FIX_interface* %0, i32 0, i32 5
  %FIX = alloca [251 x i8], align 1
  store i16 0, i16* %N, align 2
  %1 = bitcast [251 x i8]* %SX to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %2 = bitcast [251 x i8]* %FIX to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %2, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %3, align 4
  %4 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_L = load i16, i16* %L, align 2
  %5 = sext i16 %load_L to i64
  store i64 %5, i64* %4, align 4
  %6 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  %load_STRING_LENGTH = load i16, i16* @STRING_LENGTH, align 2
  %7 = sext i16 %load_STRING_LENGTH to i64
  store i64 %7, i64* %6, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %8 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %9 = bitcast [1024 x i8]* %8 to i8*
  %10 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %9, i8* align 1 %10, i32 251, i1 false)
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %11 = sext i16 %call6 to i64
  %tmpVar = sub i64 %call1, %11
  %12 = trunc i64 %tmpVar to i16
  store i16 %12, i16* %N, align 2
  %load_N = load i16, i16* %N, align 2
  %13 = sext i16 %load_N to i32
  %tmpVar9 = icmp sle i32 %13, 0
  br i1 %tmpVar9, label %condition_body, label %branch

condition_body:                                   ; preds = %continue5
  %load_M = load i16, i16* %M, align 2
  %14 = sext i16 %load_M to i32
  %tmpVar13 = icmp eq i32 %14, 1
  br i1 %tmpVar13, label %condition_body12, label %else10

branch:                                           ; preds = %continue5
  %load_M27 = load i16, i16* %M, align 2
  %15 = sext i16 %load_M27 to i32
  %tmpVar28 = icmp eq i32 %15, 1
  br i1 %tmpVar28, label %condition_body26, label %branch7

condition_body26:                                 ; preds = %branch
  %FILL_instance = alloca %FILL_interface, align 8
  br label %input29

branch7:                                          ; preds = %branch
  %load_M41 = load i16, i16* %M, align 2
  %16 = sext i16 %load_M41 to i32
  %tmpVar42 = icmp eq i32 %16, 2
  br i1 %tmpVar42, label %condition_body40, label %else

condition_body40:                                 ; preds = %branch7
  %FILL_instance43 = alloca %FILL_interface, align 8
  br label %input44

else:                                             ; preds = %branch7
  %FILL_instance82 = alloca %FILL_interface, align 8
  br label %input83

continue8:                                        ; preds = %continue94, %continue80, %continue38, %continue11
  %FIX_ret = load [251 x i8], [251 x i8]* %FIX, align 1
  ret [251 x i8] %FIX_ret

condition_body12:                                 ; preds = %condition_body
  %RIGHT_instance = alloca %RIGHT_interface, align 8
  br label %input14

else10:                                           ; preds = %condition_body
  %LEFT_instance = alloca %LEFT_interface, align 8
  br label %input20

continue11:                                       ; preds = %continue23, %continue17
  br label %continue8

input14:                                          ; preds = %condition_body12
  %17 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 0
  %18 = bitcast [1024 x i8]* %17 to i8*
  %19 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %18, i8* align 1 %19, i32 251, i1 false)
  %20 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 1
  %load_L18 = load i16, i16* %L, align 2
  store i16 %load_L18, i16* %20, align 2
  br label %call15

call15:                                           ; preds = %input14
  %call19 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %21 = alloca [1024 x i8], align 1
  store [1024 x i8] %call19, [1024 x i8]* %21, align 1
  %22 = bitcast [251 x i8]* %FIX to i8*
  %23 = bitcast [1024 x i8]* %21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %22, i8* align 1 %23, i32 250, i1 false)
  br label %continue11

input20:                                          ; preds = %else10
  %24 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 0
  %25 = bitcast [1024 x i8]* %24 to i8*
  %26 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %25, i8* align 1 %26, i32 251, i1 false)
  %27 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 1
  %load_L24 = load i16, i16* %L, align 2
  store i16 %load_L24, i16* %27, align 2
  br label %call21

call21:                                           ; preds = %input20
  %call25 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance)
  br label %output22

output22:                                         ; preds = %call21
  br label %continue23

continue23:                                       ; preds = %output22
  %28 = alloca [1024 x i8], align 1
  store [1024 x i8] %call25, [1024 x i8]* %28, align 1
  %29 = bitcast [251 x i8]* %FIX to i8*
  %30 = bitcast [1024 x i8]* %28 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %29, i8* align 1 %30, i32 250, i1 false)
  br label %continue11

input29:                                          ; preds = %condition_body26
  %31 = getelementptr inbounds %FILL_interface, %FILL_interface* %FILL_instance, i32 0, i32 0
  %load_C = load i8, i8* %C, align 1
  store i8 %load_C, i8* %31, align 1
  %32 = getelementptr inbounds %FILL_interface, %FILL_interface* %FILL_instance, i32 0, i32 1
  %load_N33 = load i16, i16* %N, align 2
  store i16 %load_N33, i16* %32, align 2
  br label %call30

call30:                                           ; preds = %input29
  %call34 = call [251 x i8] @FILL(%FILL_interface* %FILL_instance)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  %33 = alloca [251 x i8], align 1
  store [251 x i8] %call34, [251 x i8]* %33, align 1
  %34 = bitcast [251 x i8]* %SX to i8*
  %35 = bitcast [251 x i8]* %33 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %34, i8* align 1 %35, i32 250, i1 false)
  %CONCAT_instance = alloca %CONCAT_interface, align 8
  br label %input35

input35:                                          ; preds = %continue32
  %36 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 0
  %37 = bitcast [1024 x i8]* %36 to i8*
  %38 = bitcast [251 x i8]* %SX to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %37, i8* align 1 %38, i32 251, i1 false)
  %39 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 1
  %40 = bitcast [1024 x i8]* %39 to i8*
  %41 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %40, i8* align 1 %41, i32 251, i1 false)
  br label %call36

call36:                                           ; preds = %input35
  %call39 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance)
  br label %output37

output37:                                         ; preds = %call36
  br label %continue38

continue38:                                       ; preds = %output37
  %42 = alloca [1024 x i8], align 1
  store [1024 x i8] %call39, [1024 x i8]* %42, align 1
  %43 = bitcast [251 x i8]* %FIX to i8*
  %44 = bitcast [1024 x i8]* %42 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %43, i8* align 1 %44, i32 250, i1 false)
  br label %continue8

input44:                                          ; preds = %condition_body40
  %45 = getelementptr inbounds %FILL_interface, %FILL_interface* %FILL_instance43, i32 0, i32 0
  %load_C48 = load i8, i8* %C, align 1
  store i8 %load_C48, i8* %45, align 1
  %46 = getelementptr inbounds %FILL_interface, %FILL_interface* %FILL_instance43, i32 0, i32 1
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input49

call45:                                           ; preds = %continue52
  %call56 = call [251 x i8] @FILL(%FILL_interface* %FILL_instance43)
  br label %output46

output46:                                         ; preds = %call45
  br label %continue47

continue47:                                       ; preds = %output46
  %47 = alloca [251 x i8], align 1
  store [251 x i8] %call56, [251 x i8]* %47, align 1
  %48 = bitcast [251 x i8]* %SX to i8*
  %49 = bitcast [251 x i8]* %47 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %48, i8* align 1 %49, i32 250, i1 false)
  %CONCAT_instance57 = alloca %CONCAT_interface, align 8
  br label %input58

input49:                                          ; preds = %input44
  %50 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_N53 = load i16, i16* %N, align 2
  %51 = sext i16 %load_N53 to i32
  %tmpVar54 = add i32 %51, 1
  %52 = sext i32 %tmpVar54 to i64
  store i64 %52, i64* %50, align 4
  %53 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 1, i16* %53, align 2
  br label %call50

call50:                                           ; preds = %input49
  %call55 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output51

output51:                                         ; preds = %call50
  br label %continue52

continue52:                                       ; preds = %output51
  %54 = trunc i64 %call55 to i16
  store i16 %54, i16* %46, align 2
  br label %call45

input58:                                          ; preds = %continue47
  %55 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance57, i32 0, i32 0
  %56 = bitcast [1024 x i8]* %55 to i8*
  %57 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %56, i8* align 1 %57, i32 251, i1 false)
  %58 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance57, i32 0, i32 1
  %59 = bitcast [1024 x i8]* %58 to i8*
  %60 = bitcast [251 x i8]* %SX to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %59, i8* align 1 %60, i32 251, i1 false)
  br label %call59

call59:                                           ; preds = %input58
  %call62 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance57)
  br label %output60

output60:                                         ; preds = %call59
  br label %continue61

continue61:                                       ; preds = %output60
  %61 = alloca [1024 x i8], align 1
  store [1024 x i8] %call62, [1024 x i8]* %61, align 1
  %62 = bitcast [251 x i8]* %FIX to i8*
  %63 = bitcast [1024 x i8]* %61 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %62, i8* align 1 %63, i32 250, i1 false)
  %LEFT_instance63 = alloca %LEFT_interface, align 8
  br label %input64

input64:                                          ; preds = %continue61
  %64 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance63, i32 0, i32 0
  %65 = bitcast [1024 x i8]* %64 to i8*
  %66 = bitcast [251 x i8]* %SX to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %65, i8* align 1 %66, i32 251, i1 false)
  %67 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance63, i32 0, i32 1
  %SHR_instance68 = alloca %SHR_interface, align 8
  br label %input69

call65:                                           ; preds = %continue72
  %call75 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance63)
  br label %output66

output66:                                         ; preds = %call65
  br label %continue67

continue67:                                       ; preds = %output66
  %68 = alloca [1024 x i8], align 1
  store [1024 x i8] %call75, [1024 x i8]* %68, align 1
  %69 = bitcast [251 x i8]* %SX to i8*
  %70 = bitcast [1024 x i8]* %68 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %69, i8* align 1 %70, i32 250, i1 false)
  %CONCAT_instance76 = alloca %CONCAT_interface, align 8
  br label %input77

input69:                                          ; preds = %input64
  %71 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance68, i32 0, i32 0
  %load_N73 = load i16, i16* %N, align 2
  %72 = sext i16 %load_N73 to i64
  store i64 %72, i64* %71, align 4
  %73 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance68, i32 0, i32 1
  store i16 1, i16* %73, align 2
  br label %call70

call70:                                           ; preds = %input69
  %call74 = call i64 @SHR(%SHR_interface* %SHR_instance68)
  br label %output71

output71:                                         ; preds = %call70
  br label %continue72

continue72:                                       ; preds = %output71
  %74 = trunc i64 %call74 to i16
  store i16 %74, i16* %67, align 2
  br label %call65

input77:                                          ; preds = %continue67
  %75 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance76, i32 0, i32 0
  %76 = bitcast [1024 x i8]* %75 to i8*
  %77 = bitcast [251 x i8]* %SX to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %76, i8* align 1 %77, i32 251, i1 false)
  %78 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance76, i32 0, i32 1
  %79 = bitcast [1024 x i8]* %78 to i8*
  %80 = bitcast [251 x i8]* %FIX to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %79, i8* align 1 %80, i32 251, i1 false)
  br label %call78

call78:                                           ; preds = %input77
  %call81 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance76)
  br label %output79

output79:                                         ; preds = %call78
  br label %continue80

continue80:                                       ; preds = %output79
  %81 = alloca [1024 x i8], align 1
  store [1024 x i8] %call81, [1024 x i8]* %81, align 1
  %82 = bitcast [251 x i8]* %FIX to i8*
  %83 = bitcast [1024 x i8]* %81 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %82, i8* align 1 %83, i32 250, i1 false)
  br label %continue8

input83:                                          ; preds = %else
  %84 = getelementptr inbounds %FILL_interface, %FILL_interface* %FILL_instance82, i32 0, i32 0
  %load_C87 = load i8, i8* %C, align 1
  store i8 %load_C87, i8* %84, align 1
  %85 = getelementptr inbounds %FILL_interface, %FILL_interface* %FILL_instance82, i32 0, i32 1
  %load_N88 = load i16, i16* %N, align 2
  store i16 %load_N88, i16* %85, align 2
  br label %call84

call84:                                           ; preds = %input83
  %call89 = call [251 x i8] @FILL(%FILL_interface* %FILL_instance82)
  br label %output85

output85:                                         ; preds = %call84
  br label %continue86

continue86:                                       ; preds = %output85
  %86 = alloca [251 x i8], align 1
  store [251 x i8] %call89, [251 x i8]* %86, align 1
  %87 = bitcast [251 x i8]* %SX to i8*
  %88 = bitcast [251 x i8]* %86 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %87, i8* align 1 %88, i32 250, i1 false)
  %CONCAT_instance90 = alloca %CONCAT_interface, align 8
  br label %input91

input91:                                          ; preds = %continue86
  %89 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance90, i32 0, i32 0
  %90 = bitcast [1024 x i8]* %89 to i8*
  %91 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %90, i8* align 1 %91, i32 251, i1 false)
  %92 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance90, i32 0, i32 1
  %93 = bitcast [1024 x i8]* %92 to i8*
  %94 = bitcast [251 x i8]* %SX to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %93, i8* align 1 %94, i32 251, i1 false)
  br label %call92

call92:                                           ; preds = %input91
  %call95 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance90)
  br label %output93

output93:                                         ; preds = %call92
  br label %continue94

continue94:                                       ; preds = %output93
  %95 = alloca [1024 x i8], align 1
  store [1024 x i8] %call95, [1024 x i8]* %95, align 1
  %96 = bitcast [251 x i8]* %FIX to i8*
  %97 = bitcast [1024 x i8]* %95 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %96, i8* align 1 %97, i32 250, i1 false)
  br label %continue8
}

define float @FLOAT_TO_REAL(%FLOAT_TO_REAL_interface* %0) {
entry:
  %FLT = getelementptr inbounds %FLOAT_TO_REAL_interface, %FLOAT_TO_REAL_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %FLOAT_TO_REAL_interface, %FLOAT_TO_REAL_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %FLOAT_TO_REAL_interface, %FLOAT_TO_REAL_interface* %0, i32 0, i32 2
  %X = getelementptr inbounds %FLOAT_TO_REAL_interface, %FLOAT_TO_REAL_interface* %0, i32 0, i32 3
  %sign = getelementptr inbounds %FLOAT_TO_REAL_interface, %FLOAT_TO_REAL_interface* %0, i32 0, i32 4
  %stop = getelementptr inbounds %FLOAT_TO_REAL_interface, %FLOAT_TO_REAL_interface* %0, i32 0, i32 5
  %tmp = getelementptr inbounds %FLOAT_TO_REAL_interface, %FLOAT_TO_REAL_interface* %0, i32 0, i32 6
  %d = getelementptr inbounds %FLOAT_TO_REAL_interface, %FLOAT_TO_REAL_interface* %0, i32 0, i32 7
  %FLOAT_TO_REAL = alloca float, align 4
  store [20 x i8]* null, [20 x i8]** %pt, align 8
  store i16 0, i16* %i, align 2
  store i8 0, i8* %X, align 1
  store i16 1, i16* %sign, align 2
  store i16 0, i16* %stop, align 2
  store i32 0, i32* %tmp, align 4
  store i16 0, i16* %d, align 2
  store float 0.000000e+00, float* %FLOAT_TO_REAL, align 4
  store [21 x i8]* %FLT, [20 x i8]** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [21 x i8]* %FLT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 21, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_i3, %load_stop
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %14, label %15

for_body:                                         ; preds = %12
  %deref = load [20 x i8]*, [20 x i8]** %pt, align 8
  %load_i11 = load i16, i16* %i, align 2
  %5 = sub i16 %load_i11, 1
  %6 = sext i16 %5 to i32
  %tmpVar12 = mul i32 1, %6
  %tmpVar13 = add i32 %tmpVar12, 0
  %tmpVar14 = getelementptr inbounds [20 x i8], [20 x i8]* %deref, i32 0, i32 %tmpVar13
  %load_tmpVar = load i8, i8* %tmpVar14, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %7 = zext i8 %load_X to i32
  %tmpVar16 = icmp sgt i32 %7, 47
  %8 = zext i1 %tmpVar16 to i32
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %28, label %31

increment:                                        ; preds = %continue15
  %tmpVar24 = add i16 %load_i, 1
  store i16 %tmpVar24, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %condition_body, %12
  %load_i25 = load i16, i16* %i, align 2
  store i16 %load_i25, i16* %i, align 2
  br label %condition_check26

10:                                               ; preds = %15
  %load_i6 = load i16, i16* %i, align 2
  %load_stop7 = load i16, i16* %stop, align 2
  %tmpVar8 = icmp sge i16 %load_i6, %load_stop7
  %11 = icmp ne i1 %tmpVar8, false
  br i1 %11, label %18, label %19

12:                                               ; preds = %19, %15
  %13 = phi i1 [ %16, %15 ], [ %20, %19 ]
  br i1 %13, label %for_body, label %continue2

14:                                               ; preds = %condition_check
  %load_i4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_i4, 1
  br label %15

15:                                               ; preds = %14, %condition_check
  %16 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %14 ]
  %17 = icmp ne i1 %16, false
  br i1 %17, label %12, label %10

18:                                               ; preds = %10
  %load_i9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sle i16 %load_i9, 1
  br label %19

19:                                               ; preds = %18, %10
  %20 = phi i1 [ %tmpVar8, %10 ], [ %tmpVar10, %18 ]
  br label %12

condition_body:                                   ; preds = %25
  br label %continue2

buffer_block:                                     ; No predecessors!
  br label %continue15

branch:                                           ; preds = %25
  %load_X22 = load i8, i8* %X, align 1
  %21 = zext i8 %load_X22 to i32
  %tmpVar23 = icmp eq i32 %21, 45
  br i1 %tmpVar23, label %condition_body21, label %continue15

condition_body21:                                 ; preds = %branch
  store i16 -1, i16* %sign, align 2
  br label %continue15

continue15:                                       ; preds = %condition_body21, %branch, %buffer_block
  br label %increment

22:                                               ; preds = %31
  %load_X19 = load i8, i8* %X, align 1
  %23 = zext i8 %load_X19 to i32
  %tmpVar20 = icmp eq i32 %23, 46
  %24 = zext i1 %tmpVar20 to i32
  br label %25

25:                                               ; preds = %22, %31
  %26 = phi i32 [ %32, %31 ], [ %24, %22 ]
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %condition_body, label %branch

28:                                               ; preds = %for_body
  %load_X17 = load i8, i8* %X, align 1
  %29 = zext i8 %load_X17 to i32
  %tmpVar18 = icmp slt i32 %29, 58
  %30 = zext i1 %tmpVar18 to i32
  br label %31

31:                                               ; preds = %28, %for_body
  %32 = phi i32 [ %8, %for_body ], [ %30, %28 ]
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %25, label %22

condition_check26:                                ; preds = %increment28, %continue2
  %load_i30 = load i16, i16* %i, align 2
  %load_i31 = load i16, i16* %i, align 2
  %load_stop32 = load i16, i16* %stop, align 2
  %tmpVar33 = icmp sle i16 %load_i31, %load_stop32
  %34 = icmp ne i1 %tmpVar33, false
  br i1 %34, label %47, label %48

for_body27:                                       ; preds = %45
  %deref43 = load [20 x i8]*, [20 x i8]** %pt, align 8
  %load_i44 = load i16, i16* %i, align 2
  %35 = sub i16 %load_i44, 1
  %36 = sext i16 %35 to i32
  %tmpVar45 = mul i32 1, %36
  %tmpVar46 = add i32 %tmpVar45, 0
  %tmpVar47 = getelementptr inbounds [20 x i8], [20 x i8]* %deref43, i32 0, i32 %tmpVar46
  %load_tmpVar48 = load i8, i8* %tmpVar47, align 1
  store i8 %load_tmpVar48, i8* %X, align 1
  %load_X52 = load i8, i8* %X, align 1
  %37 = zext i8 %load_X52 to i32
  %tmpVar53 = icmp eq i32 %37, 44
  %38 = zext i1 %tmpVar53 to i32
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %73, label %70

increment28:                                      ; preds = %continue50
  %tmpVar69 = add i16 %load_i30, 1
  store i16 %tmpVar69, i16* %i, align 2
  br label %condition_check26

continue29:                                       ; preds = %condition_body51, %45
  %load_x72 = load i8, i8* %X, align 1
  %40 = zext i8 %load_x72 to i32
  %tmpVar73 = icmp eq i32 %40, 44
  %41 = zext i1 %tmpVar73 to i32
  %42 = icmp ne i32 %41, 0
  br i1 %42, label %90, label %87

43:                                               ; preds = %48
  %load_i37 = load i16, i16* %i, align 2
  %load_stop38 = load i16, i16* %stop, align 2
  %tmpVar39 = icmp sge i16 %load_i37, %load_stop38
  %44 = icmp ne i1 %tmpVar39, false
  br i1 %44, label %51, label %52

45:                                               ; preds = %52, %48
  %46 = phi i1 [ %49, %48 ], [ %53, %52 ]
  br i1 %46, label %for_body27, label %continue29

47:                                               ; preds = %condition_check26
  %load_i34 = load i16, i16* %i, align 2
  %load_i35 = load i16, i16* %i, align 2
  %tmpVar36 = icmp sge i16 %load_i34, %load_i35
  br label %48

48:                                               ; preds = %47, %condition_check26
  %49 = phi i1 [ %tmpVar33, %condition_check26 ], [ %tmpVar36, %47 ]
  %50 = icmp ne i1 %49, false
  br i1 %50, label %45, label %43

51:                                               ; preds = %43
  %load_i40 = load i16, i16* %i, align 2
  %load_i41 = load i16, i16* %i, align 2
  %tmpVar42 = icmp sle i16 %load_i40, %load_i41
  br label %52

52:                                               ; preds = %51, %43
  %53 = phi i1 [ %tmpVar39, %43 ], [ %tmpVar42, %51 ]
  br label %45

condition_body51:                                 ; preds = %61
  br label %continue29

buffer_block60:                                   ; No predecessors!
  br label %continue50

branch49:                                         ; preds = %61
  %load_X62 = load i8, i8* %X, align 1
  %54 = zext i8 %load_X62 to i32
  %tmpVar63 = icmp sgt i32 %54, 47
  %55 = zext i1 %tmpVar63 to i32
  %56 = icmp ne i32 %55, 0
  br i1 %56, label %76, label %79

condition_body61:                                 ; preds = %79
  %load_tmp = load i32, i32* %tmp, align 4
  %tmpVar65 = mul i32 %load_tmp, 10
  %load_X66 = load i8, i8* %X, align 1
  %57 = zext i8 %load_X66 to i32
  %tmpVar67 = add i32 %tmpVar65, %57
  %tmpVar68 = sub i32 %tmpVar67, 48
  store i32 %tmpVar68, i32* %tmp, align 4
  br label %continue50

continue50:                                       ; preds = %condition_body61, %79, %buffer_block60
  br label %increment28

58:                                               ; preds = %67
  %load_X58 = load i8, i8* %X, align 1
  %59 = zext i8 %load_X58 to i32
  %tmpVar59 = icmp eq i32 %59, 101
  %60 = zext i1 %tmpVar59 to i32
  br label %61

61:                                               ; preds = %58, %67
  %62 = phi i32 [ %68, %67 ], [ %60, %58 ]
  %63 = icmp ne i32 %62, 0
  br i1 %63, label %condition_body51, label %branch49

64:                                               ; preds = %73
  %load_X56 = load i8, i8* %X, align 1
  %65 = zext i8 %load_X56 to i32
  %tmpVar57 = icmp eq i32 %65, 69
  %66 = zext i1 %tmpVar57 to i32
  br label %67

67:                                               ; preds = %64, %73
  %68 = phi i32 [ %74, %73 ], [ %66, %64 ]
  %69 = icmp ne i32 %68, 0
  br i1 %69, label %61, label %58

70:                                               ; preds = %for_body27
  %load_X54 = load i8, i8* %X, align 1
  %71 = zext i8 %load_X54 to i32
  %tmpVar55 = icmp eq i32 %71, 46
  %72 = zext i1 %tmpVar55 to i32
  br label %73

73:                                               ; preds = %70, %for_body27
  %74 = phi i32 [ %38, %for_body27 ], [ %72, %70 ]
  %75 = icmp ne i32 %74, 0
  br i1 %75, label %67, label %64

76:                                               ; preds = %branch49
  %load_x = load i8, i8* %X, align 1
  %77 = zext i8 %load_x to i32
  %tmpVar64 = icmp slt i32 %77, 58
  %78 = zext i1 %tmpVar64 to i32
  br label %79

79:                                               ; preds = %76, %branch49
  %80 = phi i32 [ %55, %branch49 ], [ %78, %76 ]
  %81 = icmp ne i32 %80, 0
  br i1 %81, label %condition_body61, label %continue50

condition_body71:                                 ; preds = %90
  %load_i76 = load i16, i16* %i, align 2
  %82 = sext i16 %load_i76 to i32
  %tmpVar77 = add i32 %82, 1
  %83 = trunc i32 %tmpVar77 to i16
  store i16 %83, i16* %i, align 2
  br label %condition_check78

continue70:                                       ; preds = %continue81, %90
  %load_X125 = load i8, i8* %X, align 1
  %84 = zext i8 %load_X125 to i32
  %tmpVar126 = icmp eq i32 %84, 69
  %85 = zext i1 %tmpVar126 to i32
  %86 = icmp ne i32 %85, 0
  br i1 %86, label %136, label %133

87:                                               ; preds = %continue29
  %load_X74 = load i8, i8* %X, align 1
  %88 = zext i8 %load_X74 to i32
  %tmpVar75 = icmp eq i32 %88, 46
  %89 = zext i1 %tmpVar75 to i32
  br label %90

90:                                               ; preds = %87, %continue29
  %91 = phi i32 [ %41, %continue29 ], [ %89, %87 ]
  %92 = icmp ne i32 %91, 0
  br i1 %92, label %condition_body71, label %continue70

condition_check78:                                ; preds = %increment80, %condition_body71
  %load_i82 = load i16, i16* %i, align 2
  %load_i83 = load i16, i16* %i, align 2
  %load_stop84 = load i16, i16* %stop, align 2
  %tmpVar85 = icmp sle i16 %load_i83, %load_stop84
  %93 = icmp ne i1 %tmpVar85, false
  br i1 %93, label %103, label %106

for_body79:                                       ; preds = %101
  %deref97 = load [20 x i8]*, [20 x i8]** %pt, align 8
  %load_i98 = load i16, i16* %i, align 2
  %94 = sub i16 %load_i98, 1
  %95 = sext i16 %94 to i32
  %tmpVar99 = mul i32 1, %95
  %tmpVar100 = add i32 %tmpVar99, 0
  %tmpVar101 = getelementptr inbounds [20 x i8], [20 x i8]* %deref97, i32 0, i32 %tmpVar100
  %load_tmpVar102 = load i8, i8* %tmpVar101, align 1
  store i8 %load_tmpVar102, i8* %X, align 1
  %load_X106 = load i8, i8* %X, align 1
  %96 = zext i8 %load_X106 to i32
  %tmpVar107 = icmp eq i32 %96, 69
  %97 = zext i1 %tmpVar107 to i32
  %98 = icmp ne i32 %97, 0
  br i1 %98, label %123, label %120

increment80:                                      ; preds = %continue104
  %tmpVar122 = add i16 %load_i82, 1
  store i16 %tmpVar122, i16* %i, align 2
  br label %condition_check78

continue81:                                       ; preds = %condition_body105, %101
  br label %continue70

99:                                               ; preds = %106
  %load_i90 = load i16, i16* %i, align 2
  %load_stop91 = load i16, i16* %stop, align 2
  %tmpVar92 = icmp sge i16 %load_i90, %load_stop91
  %100 = icmp ne i1 %tmpVar92, false
  br i1 %100, label %109, label %112

101:                                              ; preds = %112, %106
  %102 = phi i1 [ %107, %106 ], [ %113, %112 ]
  br i1 %102, label %for_body79, label %continue81

103:                                              ; preds = %condition_check78
  %load_i86 = load i16, i16* %i, align 2
  %load_i87 = load i16, i16* %i, align 2
  %104 = sext i16 %load_i87 to i32
  %tmpVar88 = add i32 %104, 1
  %105 = trunc i32 %tmpVar88 to i16
  %tmpVar89 = icmp sge i16 %load_i86, %105
  br label %106

106:                                              ; preds = %103, %condition_check78
  %107 = phi i1 [ %tmpVar85, %condition_check78 ], [ %tmpVar89, %103 ]
  %108 = icmp ne i1 %107, false
  br i1 %108, label %101, label %99

109:                                              ; preds = %99
  %load_i93 = load i16, i16* %i, align 2
  %load_i94 = load i16, i16* %i, align 2
  %110 = sext i16 %load_i94 to i32
  %tmpVar95 = add i32 %110, 1
  %111 = trunc i32 %tmpVar95 to i16
  %tmpVar96 = icmp sle i16 %load_i93, %111
  br label %112

112:                                              ; preds = %109, %99
  %113 = phi i1 [ %tmpVar92, %99 ], [ %tmpVar96, %109 ]
  br label %101

condition_body105:                                ; preds = %123
  br label %continue81

buffer_block110:                                  ; No predecessors!
  br label %continue104

branch103:                                        ; preds = %123
  %load_x112 = load i8, i8* %X, align 1
  %114 = zext i8 %load_x112 to i32
  %tmpVar113 = icmp sgt i32 %114, 47
  %115 = zext i1 %tmpVar113 to i32
  %116 = icmp ne i32 %115, 0
  br i1 %116, label %126, label %129

condition_body111:                                ; preds = %129
  %load_tmp116 = load i32, i32* %tmp, align 4
  %tmpVar117 = mul i32 %load_tmp116, 10
  %load_X118 = load i8, i8* %X, align 1
  %117 = zext i8 %load_X118 to i32
  %tmpVar119 = add i32 %tmpVar117, %117
  %tmpVar120 = sub i32 %tmpVar119, 48
  store i32 %tmpVar120, i32* %tmp, align 4
  %load_d = load i16, i16* %d, align 2
  %118 = sext i16 %load_d to i32
  %tmpVar121 = sub i32 %118, 1
  %119 = trunc i32 %tmpVar121 to i16
  store i16 %119, i16* %d, align 2
  br label %continue104

continue104:                                      ; preds = %condition_body111, %129, %buffer_block110
  br label %increment80

120:                                              ; preds = %for_body79
  %load_X108 = load i8, i8* %X, align 1
  %121 = zext i8 %load_X108 to i32
  %tmpVar109 = icmp eq i32 %121, 101
  %122 = zext i1 %tmpVar109 to i32
  br label %123

123:                                              ; preds = %120, %for_body79
  %124 = phi i32 [ %97, %for_body79 ], [ %122, %120 ]
  %125 = icmp ne i32 %124, 0
  br i1 %125, label %condition_body105, label %branch103

126:                                              ; preds = %branch103
  %load_x114 = load i8, i8* %X, align 1
  %127 = zext i8 %load_x114 to i32
  %tmpVar115 = icmp slt i32 %127, 58
  %128 = zext i1 %tmpVar115 to i32
  br label %129

129:                                              ; preds = %126, %branch103
  %130 = phi i32 [ %115, %branch103 ], [ %128, %126 ]
  %131 = icmp ne i32 %130, 0
  br i1 %131, label %condition_body111, label %continue104

condition_body124:                                ; preds = %136
  %load_d129 = load i16, i16* %d, align 2
  %132 = sext i16 %load_d129 to i32
  %DEC_TO_INT_instance = alloca %DEC_TO_INT_interface, align 8
  br label %input130

continue123:                                      ; preds = %continue133, %136
  %EXPN_instance = alloca %EXPN_interface, align 8
  br label %input144

133:                                              ; preds = %continue70
  %load_X127 = load i8, i8* %X, align 1
  %134 = zext i8 %load_X127 to i32
  %tmpVar128 = icmp eq i32 %134, 101
  %135 = zext i1 %tmpVar128 to i32
  br label %136

136:                                              ; preds = %133, %continue70
  %137 = phi i32 [ %85, %continue70 ], [ %135, %133 ]
  %138 = icmp ne i32 %137, 0
  br i1 %138, label %condition_body124, label %continue123

input130:                                         ; preds = %condition_body124
  %139 = getelementptr inbounds %DEC_TO_INT_interface, %DEC_TO_INT_interface* %DEC_TO_INT_instance, i32 0, i32 0
  %RIGHT_instance = alloca %RIGHT_interface, align 8
  br label %input134

call131:                                          ; preds = %continue137
  %call142 = call i16 @DEC_TO_INT(%DEC_TO_INT_interface* %DEC_TO_INT_instance)
  br label %output132

output132:                                        ; preds = %call131
  br label %continue133

continue133:                                      ; preds = %output132
  %140 = sext i16 %call142 to i32
  %tmpVar143 = add i32 %132, %140
  %141 = trunc i32 %tmpVar143 to i16
  store i16 %141, i16* %d, align 2
  br label %continue123

input134:                                         ; preds = %input130
  %142 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 0
  %143 = bitcast [1024 x i8]* %142 to i8*
  %144 = bitcast [21 x i8]* %FLT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %143, i8* align 1 %144, i32 21, i1 false)
  %145 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 1
  %load_stop138 = load i16, i16* %stop, align 2
  %146 = sext i16 %load_stop138 to i32
  %load_i139 = load i16, i16* %i, align 2
  %147 = sext i16 %load_i139 to i32
  %tmpVar140 = sub i32 %146, %147
  %148 = trunc i32 %tmpVar140 to i16
  store i16 %148, i16* %145, align 2
  br label %call135

call135:                                          ; preds = %input134
  %call141 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance)
  br label %output136

output136:                                        ; preds = %call135
  br label %continue137

continue137:                                      ; preds = %output136
  %149 = alloca [1024 x i8], align 1
  store [1024 x i8] %call141, [1024 x i8]* %149, align 1
  %150 = bitcast [11 x i8]* %139 to i8*
  %151 = bitcast [1024 x i8]* %149 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %150, i8* align 1 %151, i32 10, i1 false)
  br label %call131

input144:                                         ; preds = %continue123
  %152 = getelementptr inbounds %EXPN_interface, %EXPN_interface* %EXPN_instance, i32 0, i32 0
  store float 1.000000e+01, float* %152, align 4
  %153 = getelementptr inbounds %EXPN_interface, %EXPN_interface* %EXPN_instance, i32 0, i32 1
  %load_d148 = load i16, i16* %d, align 2
  store i16 %load_d148, i16* %153, align 2
  br label %call145

call145:                                          ; preds = %input144
  %call149 = call float @EXPN(%EXPN_interface* %EXPN_instance)
  br label %output146

output146:                                        ; preds = %call145
  br label %continue147

continue147:                                      ; preds = %output146
  %DINT_TO_REAL_instance = alloca %DINT_TO_REAL_interface, align 8
  br label %input150

input150:                                         ; preds = %continue147
  %154 = getelementptr inbounds %DINT_TO_REAL_interface, %DINT_TO_REAL_interface* %DINT_TO_REAL_instance, i32 0, i32 0
  %load_TMP = load i32, i32* %tmp, align 4
  %load_SIGN = load i16, i16* %sign, align 2
  %155 = sext i16 %load_SIGN to i32
  %tmpVar154 = mul i32 %load_TMP, %155
  store i32 %tmpVar154, i32* %154, align 4
  br label %call151

call151:                                          ; preds = %input150
  %call155 = call float @DINT_TO_REAL(%DINT_TO_REAL_interface* %DINT_TO_REAL_instance)
  br label %output152

output152:                                        ; preds = %call151
  br label %continue153

continue153:                                      ; preds = %output152
  %tmpVar156 = fmul float %call149, %call155
  store float %tmpVar156, float* %FLOAT_TO_REAL, align 4
  %FLOAT_TO_REAL_ret = load float, float* %FLOAT_TO_REAL, align 4
  ret float %FLOAT_TO_REAL_ret
}

define i8 @FSTRING_TO_BYTE(%FSTRING_TO_BYTE_interface* %0) {
entry:
  %IN = getelementptr inbounds %FSTRING_TO_BYTE_interface, %FSTRING_TO_BYTE_interface* %0, i32 0, i32 0
  %FSTRING_TO_BYTE = alloca i8, align 1
  store i8 0, i8* %FSTRING_TO_BYTE, align 1
  %STRING_EQUAL_instance = alloca %STRING_EQUAL_interface, align 8
  br label %input

condition_body:                                   ; preds = %continue2
  %BIN_TO_BYTE_instance = alloca %BIN_TO_BYTE_interface, align 8
  br label %input9

branch:                                           ; preds = %continue2
  %STRING_EQUAL_instance25 = alloca %STRING_EQUAL_interface, align 8
  br label %input26

condition_body24:                                 ; preds = %continue29
  %OCT_TO_BYTE_instance = alloca %OCT_TO_BYTE_interface, align 8
  br label %input37

branch1:                                          ; preds = %continue29
  %STRING_EQUAL_instance56 = alloca %STRING_EQUAL_interface, align 8
  br label %input57

condition_body55:                                 ; preds = %continue60
  %HEX_TO_BYTE_instance = alloca %HEX_TO_BYTE_interface, align 8
  br label %input68

else:                                             ; preds = %continue60
  %DEC_TO_BYTE_instance = alloca %DEC_TO_BYTE_interface, align 8
  br label %input86

continue:                                         ; preds = %continue89, %continue71, %continue40, %continue12
  %FSTRING_TO_BYTE_ret = load i8, i8* %FSTRING_TO_BYTE, align 1
  ret i8 %FSTRING_TO_BYTE_ret

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 0
  %LEFT_instance = alloca %LEFT_interface, align 8
  br label %input3

call:                                             ; preds = %continue6
  %call8 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue2

continue2:                                        ; preds = %output
  %2 = icmp ne i8 %call8, 0
  br i1 %2, label %condition_body, label %branch

input3:                                           ; preds = %input
  %3 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 0
  %4 = bitcast [1024 x i8]* %3 to i8*
  %5 = bitcast [13 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %4, i8* align 1 %5, i32 13, i1 false)
  %6 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 1
  store i16 2, i16* %6, align 2
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %7 = alloca [1024 x i8], align 1
  store [1024 x i8] %call7, [1024 x i8]* %7, align 1
  %8 = bitcast [1025 x i8]* %1 to i8*
  %9 = bitcast [1024 x i8]* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %8, i8* align 1 %9, i32 1024, i1 false)
  %10 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 1
  %11 = bitcast [1025 x i8]* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %11, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_16, i32 0, i32 0), i32 3, i1 false)
  br label %call

input9:                                           ; preds = %condition_body
  %12 = getelementptr inbounds %BIN_TO_BYTE_interface, %BIN_TO_BYTE_interface* %BIN_TO_BYTE_instance, i32 0, i32 0
  %RIGHT_instance = alloca %RIGHT_interface, align 8
  br label %input13

call10:                                           ; preds = %continue16
  %call23 = call i8 @BIN_TO_BYTE(%BIN_TO_BYTE_interface* %BIN_TO_BYTE_instance)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  store i8 %call23, i8* %FSTRING_TO_BYTE, align 1
  br label %continue

input13:                                          ; preds = %input9
  %13 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 0
  %14 = bitcast [1024 x i8]* %13 to i8*
  %15 = bitcast [13 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %14, i8* align 1 %15, i32 13, i1 false)
  %16 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 1
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input17

call14:                                           ; preds = %continue20
  %call22 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %17 = alloca [1024 x i8], align 1
  store [1024 x i8] %call22, [1024 x i8]* %17, align 1
  %18 = bitcast [13 x i8]* %12 to i8*
  %19 = bitcast [1024 x i8]* %17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %18, i8* align 1 %19, i32 12, i1 false)
  br label %call10

input17:                                          ; preds = %input13
  %20 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %21 = bitcast [1024 x i8]* %20 to i8*
  %22 = bitcast [13 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %21, i8* align 1 %22, i32 13, i1 false)
  br label %call18

call18:                                           ; preds = %input17
  %call21 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %23 = sext i16 %call21 to i32
  %tmpVar = sub i32 %23, 2
  %24 = trunc i32 %tmpVar to i16
  store i16 %24, i16* %16, align 2
  br label %call14

input26:                                          ; preds = %branch
  %25 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance25, i32 0, i32 0
  %LEFT_instance30 = alloca %LEFT_interface, align 8
  br label %input31

call27:                                           ; preds = %continue34
  %call36 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance25)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  %26 = icmp ne i8 %call36, 0
  br i1 %26, label %condition_body24, label %branch1

input31:                                          ; preds = %input26
  %27 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance30, i32 0, i32 0
  %28 = bitcast [1024 x i8]* %27 to i8*
  %29 = bitcast [13 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %28, i8* align 1 %29, i32 13, i1 false)
  %30 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance30, i32 0, i32 1
  store i16 2, i16* %30, align 2
  br label %call32

call32:                                           ; preds = %input31
  %call35 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance30)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  %31 = alloca [1024 x i8], align 1
  store [1024 x i8] %call35, [1024 x i8]* %31, align 1
  %32 = bitcast [1025 x i8]* %25 to i8*
  %33 = bitcast [1024 x i8]* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %32, i8* align 1 %33, i32 1024, i1 false)
  %34 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance25, i32 0, i32 1
  %35 = bitcast [1025 x i8]* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %35, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_17, i32 0, i32 0), i32 3, i1 false)
  br label %call27

input37:                                          ; preds = %condition_body24
  %36 = getelementptr inbounds %OCT_TO_BYTE_interface, %OCT_TO_BYTE_interface* %OCT_TO_BYTE_instance, i32 0, i32 0
  %RIGHT_instance41 = alloca %RIGHT_interface, align 8
  br label %input42

call38:                                           ; preds = %continue45
  %call54 = call i8 @OCT_TO_BYTE(%OCT_TO_BYTE_interface* %OCT_TO_BYTE_instance)
  br label %output39

output39:                                         ; preds = %call38
  br label %continue40

continue40:                                       ; preds = %output39
  store i8 %call54, i8* %FSTRING_TO_BYTE, align 1
  br label %continue

input42:                                          ; preds = %input37
  %37 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance41, i32 0, i32 0
  %38 = bitcast [1024 x i8]* %37 to i8*
  %39 = bitcast [13 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %38, i8* align 1 %39, i32 13, i1 false)
  %40 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance41, i32 0, i32 1
  %LEN_instance46 = alloca %LEN_interface, align 8
  br label %input47

call43:                                           ; preds = %continue50
  %call53 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance41)
  br label %output44

output44:                                         ; preds = %call43
  br label %continue45

continue45:                                       ; preds = %output44
  %41 = alloca [1024 x i8], align 1
  store [1024 x i8] %call53, [1024 x i8]* %41, align 1
  %42 = bitcast [11 x i8]* %36 to i8*
  %43 = bitcast [1024 x i8]* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %42, i8* align 1 %43, i32 10, i1 false)
  br label %call38

input47:                                          ; preds = %input42
  %44 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance46, i32 0, i32 0
  %45 = bitcast [1024 x i8]* %44 to i8*
  %46 = bitcast [13 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %45, i8* align 1 %46, i32 13, i1 false)
  br label %call48

call48:                                           ; preds = %input47
  %call51 = call i16 @LEN(%LEN_interface* %LEN_instance46)
  br label %output49

output49:                                         ; preds = %call48
  br label %continue50

continue50:                                       ; preds = %output49
  %47 = sext i16 %call51 to i32
  %tmpVar52 = sub i32 %47, 2
  %48 = trunc i32 %tmpVar52 to i16
  store i16 %48, i16* %40, align 2
  br label %call43

input57:                                          ; preds = %branch1
  %49 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance56, i32 0, i32 0
  %LEFT_instance61 = alloca %LEFT_interface, align 8
  br label %input62

call58:                                           ; preds = %continue65
  %call67 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance56)
  br label %output59

output59:                                         ; preds = %call58
  br label %continue60

continue60:                                       ; preds = %output59
  %50 = icmp ne i8 %call67, 0
  br i1 %50, label %condition_body55, label %else

input62:                                          ; preds = %input57
  %51 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance61, i32 0, i32 0
  %52 = bitcast [1024 x i8]* %51 to i8*
  %53 = bitcast [13 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %52, i8* align 1 %53, i32 13, i1 false)
  %54 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance61, i32 0, i32 1
  store i16 3, i16* %54, align 2
  br label %call63

call63:                                           ; preds = %input62
  %call66 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance61)
  br label %output64

output64:                                         ; preds = %call63
  br label %continue65

continue65:                                       ; preds = %output64
  %55 = alloca [1024 x i8], align 1
  store [1024 x i8] %call66, [1024 x i8]* %55, align 1
  %56 = bitcast [1025 x i8]* %49 to i8*
  %57 = bitcast [1024 x i8]* %55 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %56, i8* align 1 %57, i32 1024, i1 false)
  %58 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance56, i32 0, i32 1
  %59 = bitcast [1025 x i8]* %58 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %59, i8* align 1 getelementptr inbounds ([4 x i8], [4 x i8]* @utf08_literal_15, i32 0, i32 0), i32 4, i1 false)
  br label %call58

input68:                                          ; preds = %condition_body55
  %60 = getelementptr inbounds %HEX_TO_BYTE_interface, %HEX_TO_BYTE_interface* %HEX_TO_BYTE_instance, i32 0, i32 0
  %RIGHT_instance72 = alloca %RIGHT_interface, align 8
  br label %input73

call69:                                           ; preds = %continue76
  %call85 = call i8 @HEX_TO_BYTE(%HEX_TO_BYTE_interface* %HEX_TO_BYTE_instance)
  br label %output70

output70:                                         ; preds = %call69
  br label %continue71

continue71:                                       ; preds = %output70
  store i8 %call85, i8* %FSTRING_TO_BYTE, align 1
  br label %continue

input73:                                          ; preds = %input68
  %61 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance72, i32 0, i32 0
  %62 = bitcast [1024 x i8]* %61 to i8*
  %63 = bitcast [13 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %62, i8* align 1 %63, i32 13, i1 false)
  %64 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance72, i32 0, i32 1
  %LEN_instance77 = alloca %LEN_interface, align 8
  br label %input78

call74:                                           ; preds = %continue81
  %call84 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance72)
  br label %output75

output75:                                         ; preds = %call74
  br label %continue76

continue76:                                       ; preds = %output75
  %65 = alloca [1024 x i8], align 1
  store [1024 x i8] %call84, [1024 x i8]* %65, align 1
  %66 = bitcast [6 x i8]* %60 to i8*
  %67 = bitcast [1024 x i8]* %65 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %66, i8* align 1 %67, i32 5, i1 false)
  br label %call69

input78:                                          ; preds = %input73
  %68 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance77, i32 0, i32 0
  %69 = bitcast [1024 x i8]* %68 to i8*
  %70 = bitcast [13 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %69, i8* align 1 %70, i32 13, i1 false)
  br label %call79

call79:                                           ; preds = %input78
  %call82 = call i16 @LEN(%LEN_interface* %LEN_instance77)
  br label %output80

output80:                                         ; preds = %call79
  br label %continue81

continue81:                                       ; preds = %output80
  %71 = sext i16 %call82 to i32
  %tmpVar83 = sub i32 %71, 3
  %72 = trunc i32 %tmpVar83 to i16
  store i16 %72, i16* %64, align 2
  br label %call74

input86:                                          ; preds = %else
  %73 = getelementptr inbounds %DEC_TO_BYTE_interface, %DEC_TO_BYTE_interface* %DEC_TO_BYTE_instance, i32 0, i32 0
  %CLEAN_instance = alloca %CLEAN_interface, align 8
  br label %input90

call87:                                           ; preds = %continue93
  %call95 = call i8 @DEC_TO_BYTE(%DEC_TO_BYTE_interface* %DEC_TO_BYTE_instance)
  br label %output88

output88:                                         ; preds = %call87
  br label %continue89

continue89:                                       ; preds = %output88
  store i8 %call95, i8* %FSTRING_TO_BYTE, align 1
  br label %continue

input90:                                          ; preds = %input86
  %74 = getelementptr inbounds %CLEAN_interface, %CLEAN_interface* %CLEAN_instance, i32 0, i32 0
  %75 = bitcast [251 x i8]* %74 to i8*
  %76 = bitcast [13 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %75, i8* align 1 %76, i32 13, i1 false)
  %77 = getelementptr inbounds %CLEAN_interface, %CLEAN_interface* %CLEAN_instance, i32 0, i32 1
  %78 = bitcast [81 x i8]* %77 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %78, i8* align 1 getelementptr inbounds ([11 x i8], [11 x i8]* @utf08_literal_14, i32 0, i32 0), i32 11, i1 false)
  br label %call91

call91:                                           ; preds = %input90
  %call94 = call [251 x i8] @CLEAN(%CLEAN_interface* %CLEAN_instance)
  br label %output92

output92:                                         ; preds = %call91
  br label %continue93

continue93:                                       ; preds = %output92
  %79 = alloca [251 x i8], align 1
  store [251 x i8] %call94, [251 x i8]* %79, align 1
  %80 = bitcast [11 x i8]* %73 to i8*
  %81 = bitcast [251 x i8]* %79 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %80, i8* align 1 %81, i32 10, i1 false)
  br label %call87
}

define i64 @FSTRING_TO_DT(%FSTRING_TO_DT_interface* %0) {
entry:
  %SDT = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 0
  %FMT = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 1
  %ignore = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 2
  %fchar = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 3
  %c = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 4
  %tmp = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 5
  %end = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 6
  %dy = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 7
  %dm = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 8
  %dd = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 9
  %th = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 10
  %tm = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 11
  %ts = getelementptr inbounds %FSTRING_TO_DT_interface, %FSTRING_TO_DT_interface* %0, i32 0, i32 12
  %FSTRING_TO_DT = alloca i64, align 8
  %1 = bitcast [2 x i8]* %ignore to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @FSTRING_TO_DT.ignore__init, i32 0, i32 0), i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 2), i1 false)
  %2 = bitcast [2 x i8]* %fchar to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %2, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @FSTRING_TO_DT.fchar__init, i32 0, i32 0), i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 2), i1 false)
  %3 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %3, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 2), i1 false)
  %4 = bitcast [21 x i8]* %tmp to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %4, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 21), i1 false)
  store i16 0, i16* %end, align 2
  store i16 1970, i16* %dy, align 2
  store i16 1, i16* %dm, align 2
  store i16 1, i16* %dd, align 2
  store i16 0, i16* %th, align 2
  store i16 0, i16* %tm, align 2
  store i16 0, i16* %ts, align 2
  store i64 0, i64* %FSTRING_TO_DT, align 4
  br label %condition_check

condition_check:                                  ; preds = %entry, %continue9
  %STRING_EQUAL_instance = alloca %STRING_EQUAL_interface, align 8
  br label %input

while_body:                                       ; preds = %continue1
  %LEFT_instance = alloca %LEFT_interface, align 8
  br label %input3

continue:                                         ; preds = %continue1
  %SET_DT_instance = alloca %SET_DT_interface, align 8
  br label %input205

input:                                            ; preds = %condition_check
  %5 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 0
  %6 = bitcast [1025 x i8]* %5 to i8*
  %7 = bitcast [61 x i8]* %FMT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %6, i8* align 1 %7, i32 61, i1 false)
  %8 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 1
  %9 = bitcast [1025 x i8]* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %9, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  br label %call

call:                                             ; preds = %input
  %call2 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %tmpVar = xor i8 %call2, -1
  br i8 %tmpVar, label %while_body, label %continue

input3:                                           ; preds = %while_body
  %10 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 0
  %11 = bitcast [1024 x i8]* %10 to i8*
  %12 = bitcast [61 x i8]* %FMT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %11, i8* align 1 %12, i32 61, i1 false)
  %13 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 1
  store i16 1, i16* %13, align 2
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %14 = alloca [1024 x i8], align 1
  store [1024 x i8] %call7, [1024 x i8]* %14, align 1
  %15 = bitcast [2 x i8]* %c to i8*
  %16 = bitcast [1024 x i8]* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %15, i8* align 1 %16, i32 1, i1 false)
  %STRING_EQUAL_instance10 = alloca %STRING_EQUAL_interface, align 8
  br label %input11

condition_body:                                   ; preds = %continue14
  %DELETE_instance = alloca %DELETE_interface, align 8
  br label %input16

branch:                                           ; preds = %continue14
  %STRING_EQUAL_instance28 = alloca %STRING_EQUAL_interface, align 8
  br label %input29

condition_body27:                                 ; preds = %continue32
  %MID_instance = alloca %MID_interface, align 8
  br label %input34

branch8:                                          ; preds = %continue32
  %STRING_EQUAL_instance181 = alloca %STRING_EQUAL_interface, align 8
  br label %input182

condition_body180:                                ; preds = %continue185
  %DELETE_instance193 = alloca %DELETE_interface, align 8
  br label %input194

else:                                             ; preds = %continue185
  %FSTRING_TO_DT_ret = load i64, i64* %FSTRING_TO_DT, align 4
  ret i64 %FSTRING_TO_DT_ret

buffer_block:                                     ; No predecessors!
  br label %continue9

continue9:                                        ; preds = %buffer_block, %continue203, %continue85, %continue25
  br label %condition_check

input11:                                          ; preds = %continue6
  %17 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance10, i32 0, i32 0
  %18 = bitcast [1025 x i8]* %17 to i8*
  %19 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %18, i8* align 1 %19, i32 2, i1 false)
  %20 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance10, i32 0, i32 1
  %21 = bitcast [1025 x i8]* %20 to i8*
  %22 = bitcast [2 x i8]* %ignore to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %21, i8* align 1 %22, i32 2, i1 false)
  br label %call12

call12:                                           ; preds = %input11
  %call15 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance10)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %23 = icmp ne i8 %call15, 0
  br i1 %23, label %condition_body, label %branch

input16:                                          ; preds = %condition_body
  %24 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 0
  %25 = bitcast [1024 x i8]* %24 to i8*
  %26 = bitcast [61 x i8]* %FMT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %25, i8* align 1 %26, i32 61, i1 false)
  %27 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 1
  store i16 1, i16* %27, align 2
  %28 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 2
  store i16 1, i16* %28, align 2
  br label %call17

call17:                                           ; preds = %input16
  %call20 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %29 = alloca [1024 x i8], align 1
  store [1024 x i8] %call20, [1024 x i8]* %29, align 1
  %30 = bitcast [61 x i8]* %FMT to i8*
  %31 = bitcast [1024 x i8]* %29 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %30, i8* align 1 %31, i32 60, i1 false)
  %DELETE_instance21 = alloca %DELETE_interface, align 8
  br label %input22

input22:                                          ; preds = %continue19
  %32 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance21, i32 0, i32 0
  %33 = bitcast [1024 x i8]* %32 to i8*
  %34 = bitcast [61 x i8]* %SDT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %33, i8* align 1 %34, i32 61, i1 false)
  %35 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance21, i32 0, i32 1
  store i16 1, i16* %35, align 2
  %36 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance21, i32 0, i32 2
  store i16 1, i16* %36, align 2
  br label %call23

call23:                                           ; preds = %input22
  %call26 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance21)
  br label %output24

output24:                                         ; preds = %call23
  br label %continue25

continue25:                                       ; preds = %output24
  %37 = alloca [1024 x i8], align 1
  store [1024 x i8] %call26, [1024 x i8]* %37, align 1
  %38 = bitcast [61 x i8]* %SDT to i8*
  %39 = bitcast [1024 x i8]* %37 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %38, i8* align 1 %39, i32 60, i1 false)
  br label %continue9

input29:                                          ; preds = %branch
  %40 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance28, i32 0, i32 0
  %41 = bitcast [1025 x i8]* %40 to i8*
  %42 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %41, i8* align 1 %42, i32 2, i1 false)
  %43 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance28, i32 0, i32 1
  %44 = bitcast [1025 x i8]* %43 to i8*
  %45 = bitcast [2 x i8]* %fchar to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %44, i8* align 1 %45, i32 2, i1 false)
  br label %call30

call30:                                           ; preds = %input29
  %call33 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance28)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  %46 = icmp ne i8 %call33, 0
  br i1 %46, label %condition_body27, label %branch8

input34:                                          ; preds = %condition_body27
  %47 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %48 = bitcast [1024 x i8]* %47 to i8*
  %49 = bitcast [61 x i8]* %FMT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %48, i8* align 1 %49, i32 61, i1 false)
  %50 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  store i16 1, i16* %50, align 2
  %51 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  store i16 2, i16* %51, align 2
  br label %call35

call35:                                           ; preds = %input34
  %call38 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output36

output36:                                         ; preds = %call35
  br label %continue37

continue37:                                       ; preds = %output36
  %52 = alloca [1024 x i8], align 1
  store [1024 x i8] %call38, [1024 x i8]* %52, align 1
  %53 = bitcast [2 x i8]* %c to i8*
  %54 = bitcast [1024 x i8]* %52 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %53, i8* align 1 %54, i32 1, i1 false)
  %DELETE_instance39 = alloca %DELETE_interface, align 8
  br label %input40

input40:                                          ; preds = %continue37
  %55 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance39, i32 0, i32 0
  %56 = bitcast [1024 x i8]* %55 to i8*
  %57 = bitcast [61 x i8]* %FMT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %56, i8* align 1 %57, i32 61, i1 false)
  %58 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance39, i32 0, i32 1
  store i16 2, i16* %58, align 2
  %59 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance39, i32 0, i32 2
  store i16 1, i16* %59, align 2
  br label %call41

call41:                                           ; preds = %input40
  %call44 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance39)
  br label %output42

output42:                                         ; preds = %call41
  br label %continue43

continue43:                                       ; preds = %output42
  %60 = alloca [1024 x i8], align 1
  store [1024 x i8] %call44, [1024 x i8]* %60, align 1
  %61 = bitcast [61 x i8]* %FMT to i8*
  %62 = bitcast [1024 x i8]* %60 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %61, i8* align 1 %62, i32 60, i1 false)
  %STRING_EQUAL_instance48 = alloca %STRING_EQUAL_interface, align 8
  br label %input49

condition_body47:                                 ; preds = %continue52
  %63 = bitcast [21 x i8]* %tmp to i8*
  %64 = bitcast [61 x i8]* %SDT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %63, i8* align 1 %64, i32 20, i1 false)
  br label %continue46

else45:                                           ; preds = %continue52
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input54

continue46:                                       ; preds = %continue76, %condition_body47
  %STRING_EQUAL_instance87 = alloca %STRING_EQUAL_interface, align 8
  br label %input88

input49:                                          ; preds = %continue43
  %65 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance48, i32 0, i32 0
  %66 = bitcast [1025 x i8]* %65 to i8*
  %67 = bitcast [61 x i8]* %FMT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %66, i8* align 1 %67, i32 61, i1 false)
  %68 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance48, i32 0, i32 1
  %69 = bitcast [1025 x i8]* %68 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %69, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  br label %call50

call50:                                           ; preds = %input49
  %call53 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance48)
  br label %output51

output51:                                         ; preds = %call50
  br label %continue52

continue52:                                       ; preds = %output51
  %70 = icmp ne i8 %call53, 0
  br i1 %70, label %condition_body47, label %else45

input54:                                          ; preds = %else45
  %71 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %72 = bitcast [1024 x i8]* %71 to i8*
  %73 = bitcast [61 x i8]* %SDT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %72, i8* align 1 %73, i32 61, i1 false)
  %74 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %LEFT_instance58 = alloca %LEFT_interface, align 8
  br label %input59

call55:                                           ; preds = %continue62
  %call64 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output56

output56:                                         ; preds = %call55
  br label %continue57

continue57:                                       ; preds = %output56
  %75 = sext i16 %call64 to i32
  %tmpVar65 = sub i32 %75, 1
  %76 = trunc i32 %tmpVar65 to i16
  store i16 %76, i16* %end, align 2
  %LEFT_instance66 = alloca %LEFT_interface, align 8
  br label %input67

input59:                                          ; preds = %input54
  %77 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance58, i32 0, i32 0
  %78 = bitcast [1024 x i8]* %77 to i8*
  %79 = bitcast [61 x i8]* %FMT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %78, i8* align 1 %79, i32 61, i1 false)
  %80 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance58, i32 0, i32 1
  store i16 1, i16* %80, align 2
  br label %call60

call60:                                           ; preds = %input59
  %call63 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance58)
  br label %output61

output61:                                         ; preds = %call60
  br label %continue62

continue62:                                       ; preds = %output61
  %81 = alloca [1024 x i8], align 1
  store [1024 x i8] %call63, [1024 x i8]* %81, align 1
  %82 = bitcast [1024 x i8]* %74 to i8*
  %83 = bitcast [1024 x i8]* %81 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %82, i8* align 1 %83, i32 1023, i1 false)
  br label %call55

input67:                                          ; preds = %continue57
  %84 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance66, i32 0, i32 0
  %85 = bitcast [1024 x i8]* %84 to i8*
  %86 = bitcast [61 x i8]* %SDT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %85, i8* align 1 %86, i32 61, i1 false)
  %87 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance66, i32 0, i32 1
  %load_end = load i16, i16* %end, align 2
  store i16 %load_end, i16* %87, align 2
  br label %call68

call68:                                           ; preds = %input67
  %call71 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance66)
  br label %output69

output69:                                         ; preds = %call68
  br label %continue70

continue70:                                       ; preds = %output69
  %88 = alloca [1024 x i8], align 1
  store [1024 x i8] %call71, [1024 x i8]* %88, align 1
  %89 = bitcast [21 x i8]* %tmp to i8*
  %90 = bitcast [1024 x i8]* %88 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %89, i8* align 1 %90, i32 20, i1 false)
  %DELETE_instance72 = alloca %DELETE_interface, align 8
  br label %input73

input73:                                          ; preds = %continue70
  %91 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance72, i32 0, i32 0
  %92 = bitcast [1024 x i8]* %91 to i8*
  %93 = bitcast [61 x i8]* %SDT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %92, i8* align 1 %93, i32 61, i1 false)
  %94 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance72, i32 0, i32 1
  %load_end77 = load i16, i16* %end, align 2
  store i16 %load_end77, i16* %94, align 2
  %95 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance72, i32 0, i32 2
  store i16 1, i16* %95, align 2
  br label %call74

call74:                                           ; preds = %input73
  %call78 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance72)
  br label %output75

output75:                                         ; preds = %call74
  br label %continue76

continue76:                                       ; preds = %output75
  %96 = alloca [1024 x i8], align 1
  store [1024 x i8] %call78, [1024 x i8]* %96, align 1
  %97 = bitcast [61 x i8]* %SDT to i8*
  %98 = bitcast [1024 x i8]* %96 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %97, i8* align 1 %98, i32 60, i1 false)
  br label %continue46

condition_body86:                                 ; preds = %continue91
  %STRING_TO_INT_instance = alloca %STRING_TO_INT_interface, align 8
  br label %input93

branch79:                                         ; preds = %continue91
  %STRING_EQUAL_instance104 = alloca %STRING_EQUAL_interface, align 8
  br label %input105

condition_body103:                                ; preds = %continue108
  %STRING_TO_INT_instance110 = alloca %STRING_TO_INT_interface, align 8
  br label %input111

branch80:                                         ; preds = %continue108
  %STRING_EQUAL_instance117 = alloca %STRING_EQUAL_interface, align 8
  br label %input118

condition_body116:                                ; preds = %continue121
  %FSTRING_TO_MONTH_instance = alloca %FSTRING_TO_MONTH_interface, align 8
  br label %input123

branch81:                                         ; preds = %continue121
  %STRING_EQUAL_instance129 = alloca %STRING_EQUAL_interface, align 8
  br label %input130

condition_body128:                                ; preds = %continue133
  %STRING_TO_INT_instance135 = alloca %STRING_TO_INT_interface, align 8
  br label %input136

branch82:                                         ; preds = %continue133
  %STRING_EQUAL_instance142 = alloca %STRING_EQUAL_interface, align 8
  br label %input143

condition_body141:                                ; preds = %continue146
  %STRING_TO_INT_instance148 = alloca %STRING_TO_INT_interface, align 8
  br label %input149

branch83:                                         ; preds = %continue146
  %STRING_EQUAL_instance155 = alloca %STRING_EQUAL_interface, align 8
  br label %input156

condition_body154:                                ; preds = %continue159
  %STRING_TO_INT_instance161 = alloca %STRING_TO_INT_interface, align 8
  br label %input162

branch84:                                         ; preds = %continue159
  %STRING_EQUAL_instance168 = alloca %STRING_EQUAL_interface, align 8
  br label %input169

condition_body167:                                ; preds = %continue172
  %STRING_TO_INT_instance174 = alloca %STRING_TO_INT_interface, align 8
  br label %input175

continue85:                                       ; preds = %continue178, %continue172, %continue165, %continue152, %continue139, %continue126, %continue114, %continue98
  br label %continue9

input88:                                          ; preds = %continue46
  %99 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance87, i32 0, i32 0
  %100 = bitcast [1025 x i8]* %99 to i8*
  %101 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %100, i8* align 1 %101, i32 2, i1 false)
  %102 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance87, i32 0, i32 1
  %103 = bitcast [1025 x i8]* %102 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %103, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_32, i32 0, i32 0), i32 2, i1 false)
  br label %call89

call89:                                           ; preds = %input88
  %call92 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance87)
  br label %output90

output90:                                         ; preds = %call89
  br label %continue91

continue91:                                       ; preds = %output90
  %104 = icmp ne i8 %call92, 0
  br i1 %104, label %condition_body86, label %branch79

input93:                                          ; preds = %condition_body86
  %105 = getelementptr inbounds %STRING_TO_INT_interface, %STRING_TO_INT_interface* %STRING_TO_INT_instance, i32 0, i32 0
  %106 = bitcast [81 x i8]* %105 to i8*
  %107 = bitcast [21 x i8]* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %106, i8* align 1 %107, i32 21, i1 false)
  br label %call94

call94:                                           ; preds = %input93
  %call97 = call i16 @STRING_TO_INT(%STRING_TO_INT_interface* %STRING_TO_INT_instance)
  br label %output95

output95:                                         ; preds = %call94
  br label %continue96

continue96:                                       ; preds = %output95
  store i16 %call97, i16* %dy, align 2
  %load_dy = load i16, i16* %dy, align 2
  %108 = sext i16 %load_dy to i32
  %tmpVar100 = icmp slt i32 %108, 100
  br i1 %tmpVar100, label %condition_body99, label %continue98

condition_body99:                                 ; preds = %continue96
  %load_dy101 = load i16, i16* %dy, align 2
  %109 = sext i16 %load_dy101 to i32
  %tmpVar102 = add i32 %109, 2000
  %110 = trunc i32 %tmpVar102 to i16
  store i16 %110, i16* %dy, align 2
  br label %continue98

continue98:                                       ; preds = %condition_body99, %continue96
  br label %continue85

input105:                                         ; preds = %branch79
  %111 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance104, i32 0, i32 0
  %112 = bitcast [1025 x i8]* %111 to i8*
  %113 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %112, i8* align 1 %113, i32 2, i1 false)
  %114 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance104, i32 0, i32 1
  %115 = bitcast [1025 x i8]* %114 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %115, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_24, i32 0, i32 0), i32 2, i1 false)
  br label %call106

call106:                                          ; preds = %input105
  %call109 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance104)
  br label %output107

output107:                                        ; preds = %call106
  br label %continue108

continue108:                                      ; preds = %output107
  %116 = icmp ne i8 %call109, 0
  br i1 %116, label %condition_body103, label %branch80

input111:                                         ; preds = %condition_body103
  %117 = getelementptr inbounds %STRING_TO_INT_interface, %STRING_TO_INT_interface* %STRING_TO_INT_instance110, i32 0, i32 0
  %118 = bitcast [81 x i8]* %117 to i8*
  %119 = bitcast [21 x i8]* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %118, i8* align 1 %119, i32 21, i1 false)
  br label %call112

call112:                                          ; preds = %input111
  %call115 = call i16 @STRING_TO_INT(%STRING_TO_INT_interface* %STRING_TO_INT_instance110)
  br label %output113

output113:                                        ; preds = %call112
  br label %continue114

continue114:                                      ; preds = %output113
  store i16 %call115, i16* %dm, align 2
  br label %continue85

input118:                                         ; preds = %branch80
  %120 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance117, i32 0, i32 0
  %121 = bitcast [1025 x i8]* %120 to i8*
  %122 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %121, i8* align 1 %122, i32 2, i1 false)
  %123 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance117, i32 0, i32 1
  %124 = bitcast [1025 x i8]* %123 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %124, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_25, i32 0, i32 0), i32 2, i1 false)
  br label %call119

call119:                                          ; preds = %input118
  %call122 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance117)
  br label %output120

output120:                                        ; preds = %call119
  br label %continue121

continue121:                                      ; preds = %output120
  %125 = icmp ne i8 %call122, 0
  br i1 %125, label %condition_body116, label %branch81

input123:                                         ; preds = %condition_body116
  %126 = getelementptr inbounds %FSTRING_TO_MONTH_interface, %FSTRING_TO_MONTH_interface* %FSTRING_TO_MONTH_instance, i32 0, i32 0
  %127 = bitcast [21 x i8]* %126 to i8*
  %128 = bitcast [21 x i8]* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %127, i8* align 1 %128, i32 20, i1 false)
  %129 = getelementptr inbounds %FSTRING_TO_MONTH_interface, %FSTRING_TO_MONTH_interface* %FSTRING_TO_MONTH_instance, i32 0, i32 1
  store i16 0, i16* %129, align 2
  br label %call124

call124:                                          ; preds = %input123
  %call127 = call i16 @FSTRING_TO_MONTH(%FSTRING_TO_MONTH_interface* %FSTRING_TO_MONTH_instance)
  br label %output125

output125:                                        ; preds = %call124
  br label %continue126

continue126:                                      ; preds = %output125
  store i16 %call127, i16* %dm, align 2
  br label %continue85

input130:                                         ; preds = %branch81
  %130 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance129, i32 0, i32 0
  %131 = bitcast [1025 x i8]* %130 to i8*
  %132 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %131, i8* align 1 %132, i32 2, i1 false)
  %133 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance129, i32 0, i32 1
  %134 = bitcast [1025 x i8]* %133 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %134, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_22, i32 0, i32 0), i32 2, i1 false)
  br label %call131

call131:                                          ; preds = %input130
  %call134 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance129)
  br label %output132

output132:                                        ; preds = %call131
  br label %continue133

continue133:                                      ; preds = %output132
  %135 = icmp ne i8 %call134, 0
  br i1 %135, label %condition_body128, label %branch82

input136:                                         ; preds = %condition_body128
  %136 = getelementptr inbounds %STRING_TO_INT_interface, %STRING_TO_INT_interface* %STRING_TO_INT_instance135, i32 0, i32 0
  %137 = bitcast [81 x i8]* %136 to i8*
  %138 = bitcast [21 x i8]* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %137, i8* align 1 %138, i32 21, i1 false)
  br label %call137

call137:                                          ; preds = %input136
  %call140 = call i16 @STRING_TO_INT(%STRING_TO_INT_interface* %STRING_TO_INT_instance135)
  br label %output138

output138:                                        ; preds = %call137
  br label %continue139

continue139:                                      ; preds = %output138
  store i16 %call140, i16* %dd, align 2
  br label %continue85

input143:                                         ; preds = %branch82
  %139 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance142, i32 0, i32 0
  %140 = bitcast [1025 x i8]* %139 to i8*
  %141 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %140, i8* align 1 %141, i32 2, i1 false)
  %142 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance142, i32 0, i32 1
  %143 = bitcast [1025 x i8]* %142 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %143, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_35, i32 0, i32 0), i32 2, i1 false)
  br label %call144

call144:                                          ; preds = %input143
  %call147 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance142)
  br label %output145

output145:                                        ; preds = %call144
  br label %continue146

continue146:                                      ; preds = %output145
  %144 = icmp ne i8 %call147, 0
  br i1 %144, label %condition_body141, label %branch83

input149:                                         ; preds = %condition_body141
  %145 = getelementptr inbounds %STRING_TO_INT_interface, %STRING_TO_INT_interface* %STRING_TO_INT_instance148, i32 0, i32 0
  %146 = bitcast [81 x i8]* %145 to i8*
  %147 = bitcast [21 x i8]* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %146, i8* align 1 %147, i32 21, i1 false)
  br label %call150

call150:                                          ; preds = %input149
  %call153 = call i16 @STRING_TO_INT(%STRING_TO_INT_interface* %STRING_TO_INT_instance148)
  br label %output151

output151:                                        ; preds = %call150
  br label %continue152

continue152:                                      ; preds = %output151
  store i16 %call153, i16* %th, align 2
  br label %continue85

input156:                                         ; preds = %branch83
  %148 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance155, i32 0, i32 0
  %149 = bitcast [1025 x i8]* %148 to i8*
  %150 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %149, i8* align 1 %150, i32 2, i1 false)
  %151 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance155, i32 0, i32 1
  %152 = bitcast [1025 x i8]* %151 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %152, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_36, i32 0, i32 0), i32 2, i1 false)
  br label %call157

call157:                                          ; preds = %input156
  %call160 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance155)
  br label %output158

output158:                                        ; preds = %call157
  br label %continue159

continue159:                                      ; preds = %output158
  %153 = icmp ne i8 %call160, 0
  br i1 %153, label %condition_body154, label %branch84

input162:                                         ; preds = %condition_body154
  %154 = getelementptr inbounds %STRING_TO_INT_interface, %STRING_TO_INT_interface* %STRING_TO_INT_instance161, i32 0, i32 0
  %155 = bitcast [81 x i8]* %154 to i8*
  %156 = bitcast [21 x i8]* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %155, i8* align 1 %156, i32 21, i1 false)
  br label %call163

call163:                                          ; preds = %input162
  %call166 = call i16 @STRING_TO_INT(%STRING_TO_INT_interface* %STRING_TO_INT_instance161)
  br label %output164

output164:                                        ; preds = %call163
  br label %continue165

continue165:                                      ; preds = %output164
  store i16 %call166, i16* %tm, align 2
  br label %continue85

input169:                                         ; preds = %branch84
  %157 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance168, i32 0, i32 0
  %158 = bitcast [1025 x i8]* %157 to i8*
  %159 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %158, i8* align 1 %159, i32 2, i1 false)
  %160 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance168, i32 0, i32 1
  %161 = bitcast [1025 x i8]* %160 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %161, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_38, i32 0, i32 0), i32 2, i1 false)
  br label %call170

call170:                                          ; preds = %input169
  %call173 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance168)
  br label %output171

output171:                                        ; preds = %call170
  br label %continue172

continue172:                                      ; preds = %output171
  %162 = icmp ne i8 %call173, 0
  br i1 %162, label %condition_body167, label %continue85

input175:                                         ; preds = %condition_body167
  %163 = getelementptr inbounds %STRING_TO_INT_interface, %STRING_TO_INT_interface* %STRING_TO_INT_instance174, i32 0, i32 0
  %164 = bitcast [81 x i8]* %163 to i8*
  %165 = bitcast [21 x i8]* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %164, i8* align 1 %165, i32 21, i1 false)
  br label %call176

call176:                                          ; preds = %input175
  %call179 = call i16 @STRING_TO_INT(%STRING_TO_INT_interface* %STRING_TO_INT_instance174)
  br label %output177

output177:                                        ; preds = %call176
  br label %continue178

continue178:                                      ; preds = %output177
  store i16 %call179, i16* %ts, align 2
  br label %continue85

input182:                                         ; preds = %branch8
  %166 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance181, i32 0, i32 0
  %167 = bitcast [1025 x i8]* %166 to i8*
  %168 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %167, i8* align 1 %168, i32 2, i1 false)
  %169 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance181, i32 0, i32 1
  %LEFT_instance186 = alloca %LEFT_interface, align 8
  br label %input187

call183:                                          ; preds = %continue190
  %call192 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance181)
  br label %output184

output184:                                        ; preds = %call183
  br label %continue185

continue185:                                      ; preds = %output184
  %170 = icmp ne i8 %call192, 0
  br i1 %170, label %condition_body180, label %else

input187:                                         ; preds = %input182
  %171 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance186, i32 0, i32 0
  %172 = bitcast [1024 x i8]* %171 to i8*
  %173 = bitcast [61 x i8]* %SDT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %172, i8* align 1 %173, i32 61, i1 false)
  %174 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance186, i32 0, i32 1
  store i16 1, i16* %174, align 2
  br label %call188

call188:                                          ; preds = %input187
  %call191 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance186)
  br label %output189

output189:                                        ; preds = %call188
  br label %continue190

continue190:                                      ; preds = %output189
  %175 = alloca [1024 x i8], align 1
  store [1024 x i8] %call191, [1024 x i8]* %175, align 1
  %176 = bitcast [1025 x i8]* %169 to i8*
  %177 = bitcast [1024 x i8]* %175 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %176, i8* align 1 %177, i32 1024, i1 false)
  br label %call183

input194:                                         ; preds = %condition_body180
  %178 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance193, i32 0, i32 0
  %179 = bitcast [1024 x i8]* %178 to i8*
  %180 = bitcast [61 x i8]* %FMT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %179, i8* align 1 %180, i32 61, i1 false)
  %181 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance193, i32 0, i32 1
  store i16 1, i16* %181, align 2
  %182 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance193, i32 0, i32 2
  store i16 1, i16* %182, align 2
  br label %call195

call195:                                          ; preds = %input194
  %call198 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance193)
  br label %output196

output196:                                        ; preds = %call195
  br label %continue197

continue197:                                      ; preds = %output196
  %183 = alloca [1024 x i8], align 1
  store [1024 x i8] %call198, [1024 x i8]* %183, align 1
  %184 = bitcast [61 x i8]* %FMT to i8*
  %185 = bitcast [1024 x i8]* %183 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %184, i8* align 1 %185, i32 60, i1 false)
  %DELETE_instance199 = alloca %DELETE_interface, align 8
  br label %input200

input200:                                         ; preds = %continue197
  %186 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance199, i32 0, i32 0
  %187 = bitcast [1024 x i8]* %186 to i8*
  %188 = bitcast [61 x i8]* %SDT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %187, i8* align 1 %188, i32 61, i1 false)
  %189 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance199, i32 0, i32 1
  store i16 1, i16* %189, align 2
  %190 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance199, i32 0, i32 2
  store i16 1, i16* %190, align 2
  br label %call201

call201:                                          ; preds = %input200
  %call204 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance199)
  br label %output202

output202:                                        ; preds = %call201
  br label %continue203

continue203:                                      ; preds = %output202
  %191 = alloca [1024 x i8], align 1
  store [1024 x i8] %call204, [1024 x i8]* %191, align 1
  %192 = bitcast [61 x i8]* %SDT to i8*
  %193 = bitcast [1024 x i8]* %191 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %192, i8* align 1 %193, i32 60, i1 false)
  br label %continue9

input205:                                         ; preds = %continue
  %194 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 0
  %load_dy209 = load i16, i16* %dy, align 2
  store i16 %load_dy209, i16* %194, align 2
  %195 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 1
  %load_dm = load i16, i16* %dm, align 2
  store i16 %load_dm, i16* %195, align 2
  %196 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 2
  %load_dd = load i16, i16* %dd, align 2
  store i16 %load_dd, i16* %196, align 2
  %197 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 3
  %load_th = load i16, i16* %th, align 2
  store i16 %load_th, i16* %197, align 2
  %198 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 4
  %load_tm = load i16, i16* %tm, align 2
  store i16 %load_tm, i16* %198, align 2
  %199 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 5
  %load_ts = load i16, i16* %ts, align 2
  store i16 %load_ts, i16* %199, align 2
  br label %call206

call206:                                          ; preds = %input205
  %call210 = call i64 @SET_DT(%SET_DT_interface* %SET_DT_instance)
  br label %output207

output207:                                        ; preds = %call206
  br label %continue208

continue208:                                      ; preds = %output207
  store i64 %call210, i64* %FSTRING_TO_DT, align 4
  %FSTRING_TO_DT_ret211 = load i64, i64* %FSTRING_TO_DT, align 4
  ret i64 %FSTRING_TO_DT_ret211
}

define i32 @FSTRING_TO_DWORD(%FSTRING_TO_DWORD_interface* %0) {
entry:
  %IN = getelementptr inbounds %FSTRING_TO_DWORD_interface, %FSTRING_TO_DWORD_interface* %0, i32 0, i32 0
  %FSTRING_TO_DWORD = alloca i32, align 4
  store i32 0, i32* %FSTRING_TO_DWORD, align 4
  %STRING_EQUAL_instance = alloca %STRING_EQUAL_interface, align 8
  br label %input

condition_body:                                   ; preds = %continue2
  %BIN_TO_DWORD_instance = alloca %BIN_TO_DWORD_interface, align 8
  br label %input9

branch:                                           ; preds = %continue2
  %STRING_EQUAL_instance25 = alloca %STRING_EQUAL_interface, align 8
  br label %input26

condition_body24:                                 ; preds = %continue29
  %OCT_TO_DWORD_instance = alloca %OCT_TO_DWORD_interface, align 8
  br label %input37

branch1:                                          ; preds = %continue29
  %STRING_EQUAL_instance56 = alloca %STRING_EQUAL_interface, align 8
  br label %input57

condition_body55:                                 ; preds = %continue60
  %HEX_TO_DWORD_instance = alloca %HEX_TO_DWORD_interface, align 8
  br label %input68

else:                                             ; preds = %continue60
  %DEC_TO_DWORD_instance = alloca %DEC_TO_DWORD_interface, align 8
  br label %input86

continue:                                         ; preds = %continue89, %continue71, %continue40, %continue12
  %FSTRING_TO_DWORD_ret = load i32, i32* %FSTRING_TO_DWORD, align 4
  ret i32 %FSTRING_TO_DWORD_ret

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 0
  %LEFT_instance = alloca %LEFT_interface, align 8
  br label %input3

call:                                             ; preds = %continue6
  %call8 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue2

continue2:                                        ; preds = %output
  %2 = icmp ne i8 %call8, 0
  br i1 %2, label %condition_body, label %branch

input3:                                           ; preds = %input
  %3 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 0
  %4 = bitcast [1024 x i8]* %3 to i8*
  %5 = bitcast [41 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %4, i8* align 1 %5, i32 41, i1 false)
  %6 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 1
  store i16 2, i16* %6, align 2
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %7 = alloca [1024 x i8], align 1
  store [1024 x i8] %call7, [1024 x i8]* %7, align 1
  %8 = bitcast [1025 x i8]* %1 to i8*
  %9 = bitcast [1024 x i8]* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %8, i8* align 1 %9, i32 1024, i1 false)
  %10 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 1
  %11 = bitcast [1025 x i8]* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %11, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_16, i32 0, i32 0), i32 3, i1 false)
  br label %call

input9:                                           ; preds = %condition_body
  %12 = getelementptr inbounds %BIN_TO_DWORD_interface, %BIN_TO_DWORD_interface* %BIN_TO_DWORD_instance, i32 0, i32 0
  %RIGHT_instance = alloca %RIGHT_interface, align 8
  br label %input13

call10:                                           ; preds = %continue16
  %call23 = call i32 @BIN_TO_DWORD(%BIN_TO_DWORD_interface* %BIN_TO_DWORD_instance)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  store i32 %call23, i32* %FSTRING_TO_DWORD, align 4
  br label %continue

input13:                                          ; preds = %input9
  %13 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 0
  %14 = bitcast [1024 x i8]* %13 to i8*
  %15 = bitcast [41 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %14, i8* align 1 %15, i32 41, i1 false)
  %16 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 1
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input17

call14:                                           ; preds = %continue20
  %call22 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %17 = alloca [1024 x i8], align 1
  store [1024 x i8] %call22, [1024 x i8]* %17, align 1
  %18 = bitcast [41 x i8]* %12 to i8*
  %19 = bitcast [1024 x i8]* %17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %18, i8* align 1 %19, i32 40, i1 false)
  br label %call10

input17:                                          ; preds = %input13
  %20 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %21 = bitcast [1024 x i8]* %20 to i8*
  %22 = bitcast [41 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %21, i8* align 1 %22, i32 41, i1 false)
  br label %call18

call18:                                           ; preds = %input17
  %call21 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %23 = sext i16 %call21 to i32
  %tmpVar = sub i32 %23, 2
  %24 = trunc i32 %tmpVar to i16
  store i16 %24, i16* %16, align 2
  br label %call14

input26:                                          ; preds = %branch
  %25 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance25, i32 0, i32 0
  %LEFT_instance30 = alloca %LEFT_interface, align 8
  br label %input31

call27:                                           ; preds = %continue34
  %call36 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance25)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  %26 = icmp ne i8 %call36, 0
  br i1 %26, label %condition_body24, label %branch1

input31:                                          ; preds = %input26
  %27 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance30, i32 0, i32 0
  %28 = bitcast [1024 x i8]* %27 to i8*
  %29 = bitcast [41 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %28, i8* align 1 %29, i32 41, i1 false)
  %30 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance30, i32 0, i32 1
  store i16 2, i16* %30, align 2
  br label %call32

call32:                                           ; preds = %input31
  %call35 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance30)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  %31 = alloca [1024 x i8], align 1
  store [1024 x i8] %call35, [1024 x i8]* %31, align 1
  %32 = bitcast [1025 x i8]* %25 to i8*
  %33 = bitcast [1024 x i8]* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %32, i8* align 1 %33, i32 1024, i1 false)
  %34 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance25, i32 0, i32 1
  %35 = bitcast [1025 x i8]* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %35, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_17, i32 0, i32 0), i32 3, i1 false)
  br label %call27

input37:                                          ; preds = %condition_body24
  %36 = getelementptr inbounds %OCT_TO_DWORD_interface, %OCT_TO_DWORD_interface* %OCT_TO_DWORD_instance, i32 0, i32 0
  %RIGHT_instance41 = alloca %RIGHT_interface, align 8
  br label %input42

call38:                                           ; preds = %continue45
  %call54 = call i32 @OCT_TO_DWORD(%OCT_TO_DWORD_interface* %OCT_TO_DWORD_instance)
  br label %output39

output39:                                         ; preds = %call38
  br label %continue40

continue40:                                       ; preds = %output39
  store i32 %call54, i32* %FSTRING_TO_DWORD, align 4
  br label %continue

input42:                                          ; preds = %input37
  %37 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance41, i32 0, i32 0
  %38 = bitcast [1024 x i8]* %37 to i8*
  %39 = bitcast [41 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %38, i8* align 1 %39, i32 41, i1 false)
  %40 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance41, i32 0, i32 1
  %LEN_instance46 = alloca %LEN_interface, align 8
  br label %input47

call43:                                           ; preds = %continue50
  %call53 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance41)
  br label %output44

output44:                                         ; preds = %call43
  br label %continue45

continue45:                                       ; preds = %output44
  %41 = alloca [1024 x i8], align 1
  store [1024 x i8] %call53, [1024 x i8]* %41, align 1
  %42 = bitcast [21 x i8]* %36 to i8*
  %43 = bitcast [1024 x i8]* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %42, i8* align 1 %43, i32 20, i1 false)
  br label %call38

input47:                                          ; preds = %input42
  %44 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance46, i32 0, i32 0
  %45 = bitcast [1024 x i8]* %44 to i8*
  %46 = bitcast [41 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %45, i8* align 1 %46, i32 41, i1 false)
  br label %call48

call48:                                           ; preds = %input47
  %call51 = call i16 @LEN(%LEN_interface* %LEN_instance46)
  br label %output49

output49:                                         ; preds = %call48
  br label %continue50

continue50:                                       ; preds = %output49
  %47 = sext i16 %call51 to i32
  %tmpVar52 = sub i32 %47, 2
  %48 = trunc i32 %tmpVar52 to i16
  store i16 %48, i16* %40, align 2
  br label %call43

input57:                                          ; preds = %branch1
  %49 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance56, i32 0, i32 0
  %LEFT_instance61 = alloca %LEFT_interface, align 8
  br label %input62

call58:                                           ; preds = %continue65
  %call67 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance56)
  br label %output59

output59:                                         ; preds = %call58
  br label %continue60

continue60:                                       ; preds = %output59
  %50 = icmp ne i8 %call67, 0
  br i1 %50, label %condition_body55, label %else

input62:                                          ; preds = %input57
  %51 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance61, i32 0, i32 0
  %52 = bitcast [1024 x i8]* %51 to i8*
  %53 = bitcast [41 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %52, i8* align 1 %53, i32 41, i1 false)
  %54 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance61, i32 0, i32 1
  store i16 3, i16* %54, align 2
  br label %call63

call63:                                           ; preds = %input62
  %call66 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance61)
  br label %output64

output64:                                         ; preds = %call63
  br label %continue65

continue65:                                       ; preds = %output64
  %55 = alloca [1024 x i8], align 1
  store [1024 x i8] %call66, [1024 x i8]* %55, align 1
  %56 = bitcast [1025 x i8]* %49 to i8*
  %57 = bitcast [1024 x i8]* %55 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %56, i8* align 1 %57, i32 1024, i1 false)
  %58 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance56, i32 0, i32 1
  %59 = bitcast [1025 x i8]* %58 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %59, i8* align 1 getelementptr inbounds ([4 x i8], [4 x i8]* @utf08_literal_15, i32 0, i32 0), i32 4, i1 false)
  br label %call58

input68:                                          ; preds = %condition_body55
  %60 = getelementptr inbounds %HEX_TO_DWORD_interface, %HEX_TO_DWORD_interface* %HEX_TO_DWORD_instance, i32 0, i32 0
  %RIGHT_instance72 = alloca %RIGHT_interface, align 8
  br label %input73

call69:                                           ; preds = %continue76
  %call85 = call i32 @HEX_TO_DWORD(%HEX_TO_DWORD_interface* %HEX_TO_DWORD_instance)
  br label %output70

output70:                                         ; preds = %call69
  br label %continue71

continue71:                                       ; preds = %output70
  store i32 %call85, i32* %FSTRING_TO_DWORD, align 4
  br label %continue

input73:                                          ; preds = %input68
  %61 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance72, i32 0, i32 0
  %62 = bitcast [1024 x i8]* %61 to i8*
  %63 = bitcast [41 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %62, i8* align 1 %63, i32 41, i1 false)
  %64 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance72, i32 0, i32 1
  %LEN_instance77 = alloca %LEN_interface, align 8
  br label %input78

call74:                                           ; preds = %continue81
  %call84 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance72)
  br label %output75

output75:                                         ; preds = %call74
  br label %continue76

continue76:                                       ; preds = %output75
  %65 = alloca [1024 x i8], align 1
  store [1024 x i8] %call84, [1024 x i8]* %65, align 1
  %66 = bitcast [21 x i8]* %60 to i8*
  %67 = bitcast [1024 x i8]* %65 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %66, i8* align 1 %67, i32 20, i1 false)
  br label %call69

input78:                                          ; preds = %input73
  %68 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance77, i32 0, i32 0
  %69 = bitcast [1024 x i8]* %68 to i8*
  %70 = bitcast [41 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %69, i8* align 1 %70, i32 41, i1 false)
  br label %call79

call79:                                           ; preds = %input78
  %call82 = call i16 @LEN(%LEN_interface* %LEN_instance77)
  br label %output80

output80:                                         ; preds = %call79
  br label %continue81

continue81:                                       ; preds = %output80
  %71 = sext i16 %call82 to i32
  %tmpVar83 = sub i32 %71, 3
  %72 = trunc i32 %tmpVar83 to i16
  store i16 %72, i16* %64, align 2
  br label %call74

input86:                                          ; preds = %else
  %73 = getelementptr inbounds %DEC_TO_DWORD_interface, %DEC_TO_DWORD_interface* %DEC_TO_DWORD_instance, i32 0, i32 0
  %CLEAN_instance = alloca %CLEAN_interface, align 8
  br label %input90

call87:                                           ; preds = %continue93
  %call95 = call i32 @DEC_TO_DWORD(%DEC_TO_DWORD_interface* %DEC_TO_DWORD_instance)
  br label %output88

output88:                                         ; preds = %call87
  br label %continue89

continue89:                                       ; preds = %output88
  store i32 %call95, i32* %FSTRING_TO_DWORD, align 4
  br label %continue

input90:                                          ; preds = %input86
  %74 = getelementptr inbounds %CLEAN_interface, %CLEAN_interface* %CLEAN_instance, i32 0, i32 0
  %75 = bitcast [251 x i8]* %74 to i8*
  %76 = bitcast [41 x i8]* %IN to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %75, i8* align 1 %76, i32 41, i1 false)
  %77 = getelementptr inbounds %CLEAN_interface, %CLEAN_interface* %CLEAN_instance, i32 0, i32 1
  %78 = bitcast [81 x i8]* %77 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %78, i8* align 1 getelementptr inbounds ([11 x i8], [11 x i8]* @utf08_literal_14, i32 0, i32 0), i32 11, i1 false)
  br label %call91

call91:                                           ; preds = %input90
  %call94 = call [251 x i8] @CLEAN(%CLEAN_interface* %CLEAN_instance)
  br label %output92

output92:                                         ; preds = %call91
  br label %continue93

continue93:                                       ; preds = %output92
  %79 = alloca [251 x i8], align 1
  store [251 x i8] %call94, [251 x i8]* %79, align 1
  %80 = bitcast [21 x i8]* %73 to i8*
  %81 = bitcast [251 x i8]* %79 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %80, i8* align 1 %81, i32 20, i1 false)
  br label %call87
}

define i16 @FSTRING_TO_MONTH(%FSTRING_TO_MONTH_interface* %0) {
entry:
  %MTH = getelementptr inbounds %FSTRING_TO_MONTH_interface, %FSTRING_TO_MONTH_interface* %0, i32 0, i32 0
  %LANG = getelementptr inbounds %FSTRING_TO_MONTH_interface, %FSTRING_TO_MONTH_interface* %0, i32 0, i32 1
  %lx = getelementptr inbounds %FSTRING_TO_MONTH_interface, %FSTRING_TO_MONTH_interface* %0, i32 0, i32 2
  %FSTRING_TO_MONTH = alloca i16, align 2
  store i16 0, i16* %lx, align 2
  store i16 0, i16* %FSTRING_TO_MONTH, align 2
  %load_LANG = load i16, i16* %LANG, align 2
  %1 = sext i16 %load_LANG to i32
  %tmpVar = icmp eq i32 %1, 0
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_ = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 0), align 2
  store i16 %load_, i16* %lx, align 2
  br label %continue

else:                                             ; preds = %entry
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %condition_body
  %TRIM_instance = alloca %TRIM_interface, align 8
  br label %input5

input:                                            ; preds = %else
  %2 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_LANG2 = load i16, i16* %LANG, align 2
  %3 = sext i16 %load_LANG2 to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_3 = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 1), align 2
  %5 = sext i16 %load_3 to i64
  store i64 %5, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %6 = trunc i64 %call4 to i16
  store i16 %6, i16* %lx, align 2
  br label %continue

input5:                                           ; preds = %continue
  %7 = getelementptr inbounds %TRIM_interface, %TRIM_interface* %TRIM_instance, i32 0, i32 0
  %8 = bitcast [251 x i8]* %7 to i8*
  %9 = bitcast [21 x i8]* %MTH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %8, i8* align 1 %9, i32 21, i1 false)
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call [251 x i8] @TRIM(%TRIM_interface* %TRIM_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %10 = alloca [251 x i8], align 1
  store [251 x i8] %call9, [251 x i8]* %10, align 1
  %11 = bitcast [21 x i8]* %MTH to i8*
  %12 = bitcast [251 x i8]* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %11, i8* align 1 %12, i32 20, i1 false)
  %CAPITALIZE_instance = alloca %CAPITALIZE_interface, align 8
  br label %input10

input10:                                          ; preds = %continue8
  %13 = getelementptr inbounds %CAPITALIZE_interface, %CAPITALIZE_interface* %CAPITALIZE_instance, i32 0, i32 0
  %LOWERCASE_instance = alloca %LOWERCASE_interface, align 8
  br label %input14

call11:                                           ; preds = %continue17
  %call19 = call [251 x i8] @CAPITALIZE(%CAPITALIZE_interface* %CAPITALIZE_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %14 = alloca [251 x i8], align 1
  store [251 x i8] %call19, [251 x i8]* %14, align 1
  %15 = bitcast [21 x i8]* %MTH to i8*
  %16 = bitcast [251 x i8]* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %15, i8* align 1 %16, i32 20, i1 false)
  store i16 1, i16* %FSTRING_TO_MONTH, align 2
  br label %condition_check

input14:                                          ; preds = %input10
  %17 = getelementptr inbounds %LOWERCASE_interface, %LOWERCASE_interface* %LOWERCASE_instance, i32 0, i32 0
  %18 = bitcast [251 x i8]* %17 to i8*
  %19 = bitcast [21 x i8]* %MTH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %18, i8* align 1 %19, i32 21, i1 false)
  br label %call15

call15:                                           ; preds = %input14
  %call18 = call [251 x i8] @LOWERCASE(%LOWERCASE_interface* %LOWERCASE_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %20 = alloca [251 x i8], align 1
  store [251 x i8] %call18, [251 x i8]* %20, align 1
  %21 = bitcast [251 x i8]* %13 to i8*
  %22 = bitcast [251 x i8]* %20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %21, i8* align 1 %22, i32 250, i1 false)
  br label %call11

condition_check:                                  ; preds = %increment, %continue13
  %load_FSTRING_TO_MONTH = load i16, i16* %FSTRING_TO_MONTH, align 2
  %load_FSTRING_TO_MONTH21 = load i16, i16* %FSTRING_TO_MONTH, align 2
  %tmpVar22 = icmp sle i16 %load_FSTRING_TO_MONTH21, 12
  %23 = icmp ne i1 %tmpVar22, false
  br i1 %23, label %28, label %29

for_body:                                         ; preds = %26
  %STRING_EQUAL_instance = alloca %STRING_EQUAL_interface, align 8
  br label %input31

increment:                                        ; preds = %continue42
  %tmpVar59 = add i16 %load_FSTRING_TO_MONTH, 1
  store i16 %tmpVar59, i16* %FSTRING_TO_MONTH, align 2
  br label %condition_check

continue20:                                       ; preds = %26
  %STRING_TO_INT_instance = alloca %STRING_TO_INT_interface, align 8
  br label %input60

24:                                               ; preds = %29
  %load_FSTRING_TO_MONTH25 = load i16, i16* %FSTRING_TO_MONTH, align 2
  %tmpVar26 = icmp sge i16 %load_FSTRING_TO_MONTH25, 12
  %25 = icmp ne i1 %tmpVar26, false
  br i1 %25, label %32, label %33

26:                                               ; preds = %33, %29
  %27 = phi i1 [ %30, %29 ], [ %34, %33 ]
  br i1 %27, label %for_body, label %continue20

28:                                               ; preds = %condition_check
  %load_FSTRING_TO_MONTH23 = load i16, i16* %FSTRING_TO_MONTH, align 2
  %tmpVar24 = icmp sge i16 %load_FSTRING_TO_MONTH23, 1
  br label %29

29:                                               ; preds = %28, %condition_check
  %30 = phi i1 [ %tmpVar22, %condition_check ], [ %tmpVar24, %28 ]
  %31 = icmp ne i1 %30, false
  br i1 %31, label %26, label %24

32:                                               ; preds = %24
  %load_FSTRING_TO_MONTH27 = load i16, i16* %FSTRING_TO_MONTH, align 2
  %tmpVar28 = icmp sle i16 %load_FSTRING_TO_MONTH27, 1
  br label %33

33:                                               ; preds = %32, %24
  %34 = phi i1 [ %tmpVar26, %24 ], [ %tmpVar28, %32 ]
  br label %26

condition_body30:                                 ; preds = %continue34
  %FSTRING_TO_MONTH_ret = load i16, i16* %FSTRING_TO_MONTH, align 2
  ret i16 %FSTRING_TO_MONTH_ret

buffer_block:                                     ; No predecessors!
  br label %continue29

continue29:                                       ; preds = %buffer_block, %continue34
  %STRING_EQUAL_instance44 = alloca %STRING_EQUAL_interface, align 8
  br label %input45

input31:                                          ; preds = %for_body
  %35 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 0
  %36 = bitcast [1025 x i8]* %35 to i8*
  %37 = bitcast [21 x i8]* %MTH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %36, i8* align 1 %37, i32 21, i1 false)
  %38 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 1
  %load_lx = load i16, i16* %lx, align 2
  %39 = sub i16 %load_lx, 1
  %40 = sext i16 %39 to i32
  %tmpVar35 = mul i32 12, %40
  %tmpVar36 = add i32 %tmpVar35, 0
  %load_FSTRING_TO_MONTH37 = load i16, i16* %FSTRING_TO_MONTH, align 2
  %41 = sub i16 %load_FSTRING_TO_MONTH37, 1
  %42 = sext i16 %41 to i32
  %tmpVar38 = mul i32 1, %42
  %tmpVar39 = add i32 %tmpVar38, %tmpVar36
  %tmpVar40 = getelementptr inbounds [36 x [11 x i8]], [36 x [11 x i8]]* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 4), i32 0, i32 %tmpVar39
  %43 = bitcast [1025 x i8]* %38 to i8*
  %44 = bitcast [11 x i8]* %tmpVar40 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %43, i8* align 1 %44, i32 11, i1 false)
  br label %call32

call32:                                           ; preds = %input31
  %call41 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  %45 = icmp ne i8 %call41, 0
  br i1 %45, label %condition_body30, label %continue29

condition_body43:                                 ; preds = %continue48
  %FSTRING_TO_MONTH_ret57 = load i16, i16* %FSTRING_TO_MONTH, align 2
  ret i16 %FSTRING_TO_MONTH_ret57

buffer_block58:                                   ; No predecessors!
  br label %continue42

continue42:                                       ; preds = %buffer_block58, %continue48
  br label %increment

input45:                                          ; preds = %continue29
  %46 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance44, i32 0, i32 0
  %47 = bitcast [1025 x i8]* %46 to i8*
  %48 = bitcast [21 x i8]* %MTH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %47, i8* align 1 %48, i32 21, i1 false)
  %49 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance44, i32 0, i32 1
  %load_lx49 = load i16, i16* %lx, align 2
  %50 = sub i16 %load_lx49, 1
  %51 = sext i16 %50 to i32
  %tmpVar50 = mul i32 12, %51
  %tmpVar51 = add i32 %tmpVar50, 0
  %load_FSTRING_TO_MONTH52 = load i16, i16* %FSTRING_TO_MONTH, align 2
  %52 = sub i16 %load_FSTRING_TO_MONTH52, 1
  %53 = sext i16 %52 to i32
  %tmpVar53 = mul i32 1, %53
  %tmpVar54 = add i32 %tmpVar53, %tmpVar51
  %tmpVar55 = getelementptr inbounds [36 x [4 x i8]], [36 x [4 x i8]]* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 5), i32 0, i32 %tmpVar54
  %54 = bitcast [1025 x i8]* %49 to i8*
  %55 = bitcast [4 x i8]* %tmpVar55 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %54, i8* align 1 %55, i32 4, i1 false)
  br label %call46

call46:                                           ; preds = %input45
  %call56 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance44)
  br label %output47

output47:                                         ; preds = %call46
  br label %continue48

continue48:                                       ; preds = %output47
  %56 = icmp ne i8 %call56, 0
  br i1 %56, label %condition_body43, label %continue42

input60:                                          ; preds = %continue20
  %57 = getelementptr inbounds %STRING_TO_INT_interface, %STRING_TO_INT_interface* %STRING_TO_INT_instance, i32 0, i32 0
  %58 = bitcast [81 x i8]* %57 to i8*
  %59 = bitcast [21 x i8]* %MTH to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %58, i8* align 1 %59, i32 21, i1 false)
  br label %call61

call61:                                           ; preds = %input60
  %call64 = call i16 @STRING_TO_INT(%STRING_TO_INT_interface* %STRING_TO_INT_instance)
  br label %output62

output62:                                         ; preds = %call61
  br label %continue63

continue63:                                       ; preds = %output62
  store i16 %call64, i16* %FSTRING_TO_MONTH, align 2
  %FSTRING_TO_MONTH_ret65 = load i16, i16* %FSTRING_TO_MONTH, align 2
  ret i16 %FSTRING_TO_MONTH_ret65
}

define i8 @FSTRING_TO_WEEK(%FSTRING_TO_WEEK_interface* %0) {
entry:
  %WEEK = getelementptr inbounds %FSTRING_TO_WEEK_interface, %FSTRING_TO_WEEK_interface* %0, i32 0, i32 0
  %LANG = getelementptr inbounds %FSTRING_TO_WEEK_interface, %FSTRING_TO_WEEK_interface* %0, i32 0, i32 1
  %pos = getelementptr inbounds %FSTRING_TO_WEEK_interface, %FSTRING_TO_WEEK_interface* %0, i32 0, i32 2
  %FSTRING_TO_WEEK = alloca i8, align 1
  store i16 0, i16* %pos, align 2
  store i8 0, i8* %FSTRING_TO_WEEK, align 1
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [61 x i8]* %WEEK to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 61, i1 false)
  %4 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %5 = bitcast [1024 x i8]* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_7, i32 0, i32 0), i32 2, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %continue, %continue36
  %load_pos = load i16, i16* %pos, align 2
  %6 = sext i16 %load_pos to i32
  %tmpVar = icmp sgt i32 %6, 0
  br i1 %tmpVar, label %while_body, label %continue2

while_body:                                       ; preds = %condition_check
  %load_FSTRING_TO_WEEK = load i8, i8* %FSTRING_TO_WEEK, align 1
  %7 = zext i8 %load_FSTRING_TO_WEEK to i64
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %12, label %11

continue2:                                        ; preds = %condition_check
  %load_FSTRING_TO_WEEK38 = load i8, i8* %FSTRING_TO_WEEK, align 1
  %9 = zext i8 %load_FSTRING_TO_WEEK38 to i64
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %50, label %49

11:                                               ; preds = %while_body
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input3

12:                                               ; preds = %continue6, %while_body
  %13 = phi i64 [ %7, %while_body ], [ %call19, %continue6 ]
  store i64 %13, i8* %FSTRING_TO_WEEK, align 4
  %RIGHT_instance = alloca %RIGHT_interface, align 8
  br label %input20

input3:                                           ; preds = %11
  %14 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  store i64 128, i64* %14, align 4
  %15 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  %FSTRING_TO_WEEKDAY_instance = alloca %FSTRING_TO_WEEKDAY_interface, align 8
  br label %input7

call4:                                            ; preds = %continue10
  %call19 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  br label %12

input7:                                           ; preds = %input3
  %16 = getelementptr inbounds %FSTRING_TO_WEEKDAY_interface, %FSTRING_TO_WEEKDAY_interface* %FSTRING_TO_WEEKDAY_instance, i32 0, i32 0
  %MID_instance = alloca %MID_interface, align 8
  br label %input11

call8:                                            ; preds = %continue14
  %call18 = call i16 @FSTRING_TO_WEEKDAY(%FSTRING_TO_WEEKDAY_interface* %FSTRING_TO_WEEKDAY_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  store i16 %call18, i16* %15, align 2
  br label %call4

input11:                                          ; preds = %input7
  %17 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %18 = bitcast [1024 x i8]* %17 to i8*
  %19 = bitcast [61 x i8]* %WEEK to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %18, i8* align 1 %19, i32 61, i1 false)
  %20 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  %load_pos15 = load i16, i16* %pos, align 2
  %21 = sext i16 %load_pos15 to i32
  %tmpVar16 = sub i32 %21, 1
  %22 = trunc i32 %tmpVar16 to i16
  store i16 %22, i16* %20, align 2
  %23 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  store i16 1, i16* %23, align 2
  br label %call12

call12:                                           ; preds = %input11
  %call17 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %24 = alloca [1024 x i8], align 1
  store [1024 x i8] %call17, [1024 x i8]* %24, align 1
  %25 = bitcast [21 x i8]* %16 to i8*
  %26 = bitcast [1024 x i8]* %24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %25, i8* align 1 %26, i32 20, i1 false)
  %27 = getelementptr inbounds %FSTRING_TO_WEEKDAY_interface, %FSTRING_TO_WEEKDAY_interface* %FSTRING_TO_WEEKDAY_instance, i32 0, i32 1
  %load_LANG = load i16, i16* %LANG, align 2
  store i16 %load_LANG, i16* %27, align 2
  br label %call8

input20:                                          ; preds = %12
  %28 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 0
  %29 = bitcast [1024 x i8]* %28 to i8*
  %30 = bitcast [61 x i8]* %WEEK to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %29, i8* align 1 %30, i32 61, i1 false)
  %31 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 1
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input24

call21:                                           ; preds = %continue27
  %call31 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance)
  br label %output22

output22:                                         ; preds = %call21
  br label %continue23

continue23:                                       ; preds = %output22
  %32 = alloca [1024 x i8], align 1
  store [1024 x i8] %call31, [1024 x i8]* %32, align 1
  %33 = bitcast [61 x i8]* %WEEK to i8*
  %34 = bitcast [1024 x i8]* %32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %33, i8* align 1 %34, i32 60, i1 false)
  %FIND_instance32 = alloca %FIND_interface, align 8
  br label %input33

input24:                                          ; preds = %input20
  %35 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %36 = bitcast [1024 x i8]* %35 to i8*
  %37 = bitcast [61 x i8]* %WEEK to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %36, i8* align 1 %37, i32 61, i1 false)
  br label %call25

call25:                                           ; preds = %input24
  %call28 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output26

output26:                                         ; preds = %call25
  br label %continue27

continue27:                                       ; preds = %output26
  %38 = sext i16 %call28 to i32
  %load_pos29 = load i16, i16* %pos, align 2
  %39 = sext i16 %load_pos29 to i32
  %tmpVar30 = sub i32 %38, %39
  %40 = trunc i32 %tmpVar30 to i16
  store i16 %40, i16* %31, align 2
  br label %call21

input33:                                          ; preds = %continue23
  %41 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance32, i32 0, i32 0
  %42 = bitcast [1024 x i8]* %41 to i8*
  %43 = bitcast [61 x i8]* %WEEK to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %42, i8* align 1 %43, i32 61, i1 false)
  %44 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance32, i32 0, i32 1
  %45 = bitcast [1024 x i8]* %44 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %45, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_7, i32 0, i32 0), i32 2, i1 false)
  br label %call34

call34:                                           ; preds = %input33
  %call37 = call i16 @FIND(%FIND_interface* %FIND_instance32)
  br label %output35

output35:                                         ; preds = %call34
  br label %continue36

continue36:                                       ; preds = %output35
  store i16 %call37, i16* %pos, align 2
  br label %condition_check

46:                                               ; preds = %50
  br label %47

47:                                               ; preds = %46, %50
  %48 = phi i32 [ %51, %50 ], [ 127, %46 ]
  store i32 %48, i8* %FSTRING_TO_WEEK, align 4
  %FSTRING_TO_WEEK_ret = load i8, i8* %FSTRING_TO_WEEK, align 1
  ret i8 %FSTRING_TO_WEEK_ret

49:                                               ; preds = %continue2
  %SHR_instance39 = alloca %SHR_interface, align 8
  br label %input40

50:                                               ; preds = %continue43, %continue2
  %51 = phi i64 [ %9, %continue2 ], [ %call51, %continue43 ]
  %52 = icmp ne i64 %51, i32 0
  br i1 %52, label %46, label %47

input40:                                          ; preds = %49
  %53 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance39, i32 0, i32 0
  store i64 128, i64* %53, align 4
  %54 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance39, i32 0, i32 1
  %FSTRING_TO_WEEKDAY_instance44 = alloca %FSTRING_TO_WEEKDAY_interface, align 8
  br label %input45

call41:                                           ; preds = %continue48
  %call51 = call i64 @SHR(%SHR_interface* %SHR_instance39)
  br label %output42

output42:                                         ; preds = %call41
  br label %continue43

continue43:                                       ; preds = %output42
  br label %50

input45:                                          ; preds = %input40
  %55 = getelementptr inbounds %FSTRING_TO_WEEKDAY_interface, %FSTRING_TO_WEEKDAY_interface* %FSTRING_TO_WEEKDAY_instance44, i32 0, i32 0
  %56 = bitcast [21 x i8]* %55 to i8*
  %57 = bitcast [61 x i8]* %WEEK to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %56, i8* align 1 %57, i32 20, i1 false)
  %58 = getelementptr inbounds %FSTRING_TO_WEEKDAY_interface, %FSTRING_TO_WEEKDAY_interface* %FSTRING_TO_WEEKDAY_instance44, i32 0, i32 1
  %load_LANG49 = load i16, i16* %LANG, align 2
  store i16 %load_LANG49, i16* %58, align 2
  br label %call46

call46:                                           ; preds = %input45
  %call50 = call i16 @FSTRING_TO_WEEKDAY(%FSTRING_TO_WEEKDAY_interface* %FSTRING_TO_WEEKDAY_instance44)
  br label %output47

output47:                                         ; preds = %call46
  br label %continue48

continue48:                                       ; preds = %output47
  store i16 %call50, i16* %54, align 2
  br label %call41
}

define i16 @FSTRING_TO_WEEKDAY(%FSTRING_TO_WEEKDAY_interface* %0) {
entry:
  %WDAY = getelementptr inbounds %FSTRING_TO_WEEKDAY_interface, %FSTRING_TO_WEEKDAY_interface* %0, i32 0, i32 0
  %LANG = getelementptr inbounds %FSTRING_TO_WEEKDAY_interface, %FSTRING_TO_WEEKDAY_interface* %0, i32 0, i32 1
  %tmp = getelementptr inbounds %FSTRING_TO_WEEKDAY_interface, %FSTRING_TO_WEEKDAY_interface* %0, i32 0, i32 2
  %i = getelementptr inbounds %FSTRING_TO_WEEKDAY_interface, %FSTRING_TO_WEEKDAY_interface* %0, i32 0, i32 3
  %ly = getelementptr inbounds %FSTRING_TO_WEEKDAY_interface, %FSTRING_TO_WEEKDAY_interface* %0, i32 0, i32 4
  %FSTRING_TO_WEEKDAY = alloca i16, align 2
  %1 = bitcast [3 x i8]* %tmp to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 3), i1 false)
  store i16 0, i16* %i, align 2
  store i16 0, i16* %ly, align 2
  store i16 0, i16* %FSTRING_TO_WEEKDAY, align 2
  %load_LANG = load i16, i16* %LANG, align 2
  %2 = sext i16 %load_LANG to i32
  %tmpVar = icmp eq i32 %2, 0
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_ = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 0), align 2
  store i16 %load_, i16* %ly, align 2
  br label %continue

else:                                             ; preds = %entry
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %condition_body
  %TRIM_instance = alloca %TRIM_interface, align 8
  br label %input5

input:                                            ; preds = %else
  %3 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_LANG2 = load i16, i16* %LANG, align 2
  %4 = sext i16 %load_LANG2 to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_3 = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 1), align 2
  %6 = sext i16 %load_3 to i64
  store i64 %6, i64* %5, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %7 = trunc i64 %call4 to i16
  store i16 %7, i16* %ly, align 2
  br label %continue

input5:                                           ; preds = %continue
  %8 = getelementptr inbounds %TRIM_interface, %TRIM_interface* %TRIM_instance, i32 0, i32 0
  %9 = bitcast [251 x i8]* %8 to i8*
  %10 = bitcast [21 x i8]* %WDAY to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %9, i8* align 1 %10, i32 21, i1 false)
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call [251 x i8] @TRIM(%TRIM_interface* %TRIM_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %11 = alloca [251 x i8], align 1
  store [251 x i8] %call9, [251 x i8]* %11, align 1
  %12 = bitcast [3 x i8]* %tmp to i8*
  %13 = bitcast [251 x i8]* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %12, i8* align 1 %13, i32 2, i1 false)
  %CAPITALIZE_instance = alloca %CAPITALIZE_interface, align 8
  br label %input10

input10:                                          ; preds = %continue8
  %14 = getelementptr inbounds %CAPITALIZE_interface, %CAPITALIZE_interface* %CAPITALIZE_instance, i32 0, i32 0
  %LOWERCASE_instance = alloca %LOWERCASE_interface, align 8
  br label %input14

call11:                                           ; preds = %continue17
  %call19 = call [251 x i8] @CAPITALIZE(%CAPITALIZE_interface* %CAPITALIZE_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %15 = alloca [251 x i8], align 1
  store [251 x i8] %call19, [251 x i8]* %15, align 1
  %16 = bitcast [3 x i8]* %tmp to i8*
  %17 = bitcast [251 x i8]* %15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %16, i8* align 1 %17, i32 2, i1 false)
  store i16 1, i16* %i, align 2
  br label %condition_check

input14:                                          ; preds = %input10
  %18 = getelementptr inbounds %LOWERCASE_interface, %LOWERCASE_interface* %LOWERCASE_instance, i32 0, i32 0
  %19 = bitcast [251 x i8]* %18 to i8*
  %20 = bitcast [3 x i8]* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %19, i8* align 1 %20, i32 3, i1 false)
  br label %call15

call15:                                           ; preds = %input14
  %call18 = call [251 x i8] @LOWERCASE(%LOWERCASE_interface* %LOWERCASE_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %21 = alloca [251 x i8], align 1
  store [251 x i8] %call18, [251 x i8]* %21, align 1
  %22 = bitcast [251 x i8]* %14 to i8*
  %23 = bitcast [251 x i8]* %21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %22, i8* align 1 %23, i32 250, i1 false)
  br label %call11

condition_check:                                  ; preds = %increment, %continue13
  %load_i = load i16, i16* %i, align 2
  %load_i21 = load i16, i16* %i, align 2
  %tmpVar22 = icmp sle i16 %load_i21, 7
  %24 = icmp ne i1 %tmpVar22, false
  br i1 %24, label %29, label %30

for_body:                                         ; preds = %27
  %STRING_EQUAL_instance = alloca %STRING_EQUAL_interface, align 8
  br label %input31

increment:                                        ; preds = %continue29
  %tmpVar43 = add i16 %load_i, 1
  store i16 %tmpVar43, i16* %i, align 2
  br label %condition_check

continue20:                                       ; preds = %27
  %STRING_TO_INT_instance = alloca %STRING_TO_INT_interface, align 8
  br label %input44

25:                                               ; preds = %30
  %load_i25 = load i16, i16* %i, align 2
  %tmpVar26 = icmp sge i16 %load_i25, 7
  %26 = icmp ne i1 %tmpVar26, false
  br i1 %26, label %33, label %34

27:                                               ; preds = %34, %30
  %28 = phi i1 [ %31, %30 ], [ %35, %34 ]
  br i1 %28, label %for_body, label %continue20

29:                                               ; preds = %condition_check
  %load_i23 = load i16, i16* %i, align 2
  %tmpVar24 = icmp sge i16 %load_i23, 1
  br label %30

30:                                               ; preds = %29, %condition_check
  %31 = phi i1 [ %tmpVar22, %condition_check ], [ %tmpVar24, %29 ]
  %32 = icmp ne i1 %31, false
  br i1 %32, label %27, label %25

33:                                               ; preds = %25
  %load_i27 = load i16, i16* %i, align 2
  %tmpVar28 = icmp sle i16 %load_i27, 1
  br label %34

34:                                               ; preds = %33, %25
  %35 = phi i1 [ %tmpVar26, %25 ], [ %tmpVar28, %33 ]
  br label %27

condition_body30:                                 ; preds = %continue34
  %load_i42 = load i16, i16* %i, align 2
  store i16 %load_i42, i16* %FSTRING_TO_WEEKDAY, align 2
  %FSTRING_TO_WEEKDAY_ret = load i16, i16* %FSTRING_TO_WEEKDAY, align 2
  ret i16 %FSTRING_TO_WEEKDAY_ret

buffer_block:                                     ; No predecessors!
  br label %continue29

continue29:                                       ; preds = %buffer_block, %continue34
  br label %increment

input31:                                          ; preds = %for_body
  %36 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 0
  %load_ly = load i16, i16* %ly, align 2
  %37 = sub i16 %load_ly, 1
  %38 = sext i16 %37 to i32
  %tmpVar35 = mul i32 7, %38
  %tmpVar36 = add i32 %tmpVar35, 0
  %load_i37 = load i16, i16* %i, align 2
  %39 = sub i16 %load_i37, 1
  %40 = sext i16 %39 to i32
  %tmpVar38 = mul i32 1, %40
  %tmpVar39 = add i32 %tmpVar38, %tmpVar36
  %tmpVar40 = getelementptr inbounds [21 x [3 x i8]], [21 x [3 x i8]]* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 3), i32 0, i32 %tmpVar39
  %41 = bitcast [1025 x i8]* %36 to i8*
  %42 = bitcast [3 x i8]* %tmpVar40 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %41, i8* align 1 %42, i32 3, i1 false)
  %43 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 1
  %44 = bitcast [1025 x i8]* %43 to i8*
  %45 = bitcast [3 x i8]* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %44, i8* align 1 %45, i32 3, i1 false)
  br label %call32

call32:                                           ; preds = %input31
  %call41 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  %46 = icmp ne i8 %call41, 0
  br i1 %46, label %condition_body30, label %continue29

input44:                                          ; preds = %continue20
  %47 = getelementptr inbounds %STRING_TO_INT_interface, %STRING_TO_INT_interface* %STRING_TO_INT_instance, i32 0, i32 0
  %48 = bitcast [81 x i8]* %47 to i8*
  %49 = bitcast [21 x i8]* %WDAY to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %48, i8* align 1 %49, i32 21, i1 false)
  br label %call45

call45:                                           ; preds = %input44
  %call48 = call i16 @STRING_TO_INT(%STRING_TO_INT_interface* %STRING_TO_INT_instance)
  br label %output46

output46:                                         ; preds = %call45
  br label %continue47

continue47:                                       ; preds = %output46
  store i16 %call48, i16* %FSTRING_TO_WEEKDAY, align 2
  %FSTRING_TO_WEEKDAY_ret49 = load i16, i16* %FSTRING_TO_WEEKDAY, align 2
  ret i16 %FSTRING_TO_WEEKDAY_ret49
}

define i8 @HEX_TO_BYTE(%HEX_TO_BYTE_interface* %0) {
entry:
  %HEX = getelementptr inbounds %HEX_TO_BYTE_interface, %HEX_TO_BYTE_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %HEX_TO_BYTE_interface, %HEX_TO_BYTE_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %HEX_TO_BYTE_interface, %HEX_TO_BYTE_interface* %0, i32 0, i32 2
  %X = getelementptr inbounds %HEX_TO_BYTE_interface, %HEX_TO_BYTE_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %HEX_TO_BYTE_interface, %HEX_TO_BYTE_interface* %0, i32 0, i32 4
  %HEX_TO_BYTE = alloca i8, align 1
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %i, align 2
  store i8 0, i8* %X, align 1
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %HEX_TO_BYTE, align 1
  store [6 x i8]* %HEX, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [6 x i8]* %HEX to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 6, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_I = load i16, i16* %i, align 2
  %load_I3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_I3, %load_stop
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %12, label %13

for_body:                                         ; preds = %10
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %5 = zext i8 %load_X to i32
  %tmpVar13 = icmp sgt i32 %5, 47
  %6 = zext i1 %tmpVar13 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %25, label %28

increment:                                        ; preds = %continue12
  %tmpVar53 = add i16 %load_I, 1
  store i16 %tmpVar53, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  %HEX_TO_BYTE_ret = load i8, i8* %HEX_TO_BYTE, align 1
  ret i8 %HEX_TO_BYTE_ret

8:                                                ; preds = %13
  %load_I6 = load i16, i16* %i, align 2
  %load_stop7 = load i16, i16* %stop, align 2
  %tmpVar8 = icmp sge i16 %load_I6, %load_stop7
  %9 = icmp ne i1 %tmpVar8, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_I4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_I4, 1
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_I9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sle i16 %load_I9, 1
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar8, %8 ], [ %tmpVar10, %16 ]
  br label %10

condition_body:                                   ; preds = %28
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input15

branch:                                           ; preds = %28
  %load_X24 = load i8, i8* %X, align 1
  %19 = zext i8 %load_X24 to i32
  %tmpVar25 = icmp sgt i32 %19, 64
  %20 = zext i1 %tmpVar25 to i32
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %36, label %39

condition_body23:                                 ; preds = %39
  %SHL_instance28 = alloca %SHL_interface, align 8
  br label %input29

branch11:                                         ; preds = %39
  %load_X39 = load i8, i8* %X, align 1
  %22 = zext i8 %load_X39 to i32
  %tmpVar40 = icmp sgt i32 %22, 96
  %23 = zext i1 %tmpVar40 to i32
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %47, label %50

condition_body38:                                 ; preds = %50
  %SHL_instance43 = alloca %SHL_interface, align 8
  br label %input44

continue12:                                       ; preds = %continue47, %50, %continue32, %continue18
  %load_pt = load i8*, i8** %pt, align 8
  %access___HEX_TO_BYTE_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___HEX_TO_BYTE_pt, i8** %pt, align 8
  br label %increment

25:                                               ; preds = %for_body
  %load_x = load i8, i8* %X, align 1
  %26 = zext i8 %load_x to i32
  %tmpVar14 = icmp slt i32 %26, 58
  %27 = zext i1 %tmpVar14 to i32
  br label %28

28:                                               ; preds = %25, %for_body
  %29 = phi i32 [ %6, %for_body ], [ %27, %25 ]
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %condition_body, label %branch

input15:                                          ; preds = %condition_body
  %31 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_HEX_TO_BYTE = load i8, i8* %HEX_TO_BYTE, align 1
  %32 = zext i8 %load_HEX_TO_BYTE to i64
  store i64 %32, i64* %31, align 4
  %33 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 4, i16* %33, align 2
  br label %call16

call16:                                           ; preds = %input15
  %call19 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %load_X20 = load i8, i8* %X, align 1
  %34 = zext i8 %load_X20 to i64
  %tmpVar21 = add i64 %call19, %34
  %tmpVar22 = sub i64 %tmpVar21, 48
  %35 = trunc i64 %tmpVar22 to i8
  store i8 %35, i8* %HEX_TO_BYTE, align 1
  br label %continue12

36:                                               ; preds = %branch
  %load_X26 = load i8, i8* %X, align 1
  %37 = zext i8 %load_X26 to i32
  %tmpVar27 = icmp slt i32 %37, 71
  %38 = zext i1 %tmpVar27 to i32
  br label %39

39:                                               ; preds = %36, %branch
  %40 = phi i32 [ %20, %branch ], [ %38, %36 ]
  %41 = icmp ne i32 %40, 0
  br i1 %41, label %condition_body23, label %branch11

input29:                                          ; preds = %condition_body23
  %42 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance28, i32 0, i32 0
  %load_HEX_TO_BYTE33 = load i8, i8* %HEX_TO_BYTE, align 1
  %43 = zext i8 %load_HEX_TO_BYTE33 to i64
  store i64 %43, i64* %42, align 4
  %44 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance28, i32 0, i32 1
  store i16 4, i16* %44, align 2
  br label %call30

call30:                                           ; preds = %input29
  %call34 = call i64 @SHL(%SHL_interface* %SHL_instance28)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  %load_X35 = load i8, i8* %X, align 1
  %45 = zext i8 %load_X35 to i64
  %tmpVar36 = add i64 %call34, %45
  %tmpVar37 = sub i64 %tmpVar36, 55
  %46 = trunc i64 %tmpVar37 to i8
  store i8 %46, i8* %HEX_TO_BYTE, align 1
  br label %continue12

47:                                               ; preds = %branch11
  %load_X41 = load i8, i8* %X, align 1
  %48 = zext i8 %load_X41 to i32
  %tmpVar42 = icmp slt i32 %48, 103
  %49 = zext i1 %tmpVar42 to i32
  br label %50

50:                                               ; preds = %47, %branch11
  %51 = phi i32 [ %23, %branch11 ], [ %49, %47 ]
  %52 = icmp ne i32 %51, 0
  br i1 %52, label %condition_body38, label %continue12

input44:                                          ; preds = %condition_body38
  %53 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance43, i32 0, i32 0
  %load_HEX_TO_BYTE48 = load i8, i8* %HEX_TO_BYTE, align 1
  %54 = zext i8 %load_HEX_TO_BYTE48 to i64
  store i64 %54, i64* %53, align 4
  %55 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance43, i32 0, i32 1
  store i16 4, i16* %55, align 2
  br label %call45

call45:                                           ; preds = %input44
  %call49 = call i64 @SHL(%SHL_interface* %SHL_instance43)
  br label %output46

output46:                                         ; preds = %call45
  br label %continue47

continue47:                                       ; preds = %output46
  %load_X50 = load i8, i8* %X, align 1
  %56 = zext i8 %load_X50 to i64
  %tmpVar51 = add i64 %call49, %56
  %tmpVar52 = sub i64 %tmpVar51, 87
  %57 = trunc i64 %tmpVar52 to i8
  store i8 %57, i8* %HEX_TO_BYTE, align 1
  br label %continue12
}

define i32 @HEX_TO_DWORD(%HEX_TO_DWORD_interface* %0) {
entry:
  %Hex = getelementptr inbounds %HEX_TO_DWORD_interface, %HEX_TO_DWORD_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %HEX_TO_DWORD_interface, %HEX_TO_DWORD_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %HEX_TO_DWORD_interface, %HEX_TO_DWORD_interface* %0, i32 0, i32 2
  %X = getelementptr inbounds %HEX_TO_DWORD_interface, %HEX_TO_DWORD_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %HEX_TO_DWORD_interface, %HEX_TO_DWORD_interface* %0, i32 0, i32 4
  %HEX_TO_DWORD = alloca i32, align 4
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %i, align 2
  store i8 0, i8* %X, align 1
  store i16 0, i16* %stop, align 2
  store i32 0, i32* %HEX_TO_DWORD, align 4
  store [21 x i8]* %Hex, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [21 x i8]* %Hex to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 21, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_I = load i16, i16* %i, align 2
  %load_I3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_I3, %load_stop
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %12, label %13

for_body:                                         ; preds = %10
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %5 = zext i8 %load_X to i32
  %tmpVar13 = icmp sgt i32 %5, 47
  %6 = zext i1 %tmpVar13 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %25, label %28

increment:                                        ; preds = %continue12
  %tmpVar53 = add i16 %load_I, 1
  store i16 %tmpVar53, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  %HEX_TO_DWORD_ret = load i32, i32* %HEX_TO_DWORD, align 4
  ret i32 %HEX_TO_DWORD_ret

8:                                                ; preds = %13
  %load_I6 = load i16, i16* %i, align 2
  %load_stop7 = load i16, i16* %stop, align 2
  %tmpVar8 = icmp sge i16 %load_I6, %load_stop7
  %9 = icmp ne i1 %tmpVar8, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_I4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_I4, 1
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_I9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sle i16 %load_I9, 1
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar8, %8 ], [ %tmpVar10, %16 ]
  br label %10

condition_body:                                   ; preds = %28
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input15

branch:                                           ; preds = %28
  %load_X24 = load i8, i8* %X, align 1
  %19 = zext i8 %load_X24 to i32
  %tmpVar25 = icmp sgt i32 %19, 64
  %20 = zext i1 %tmpVar25 to i32
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %36, label %39

condition_body23:                                 ; preds = %39
  %SHL_instance28 = alloca %SHL_interface, align 8
  br label %input29

branch11:                                         ; preds = %39
  %load_X39 = load i8, i8* %X, align 1
  %22 = zext i8 %load_X39 to i32
  %tmpVar40 = icmp sgt i32 %22, 96
  %23 = zext i1 %tmpVar40 to i32
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %47, label %50

condition_body38:                                 ; preds = %50
  %SHL_instance43 = alloca %SHL_interface, align 8
  br label %input44

continue12:                                       ; preds = %continue47, %50, %continue32, %continue18
  %load_pt = load i8*, i8** %pt, align 8
  %access___HEX_TO_DWORD_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___HEX_TO_DWORD_pt, i8** %pt, align 8
  br label %increment

25:                                               ; preds = %for_body
  %load_x = load i8, i8* %X, align 1
  %26 = zext i8 %load_x to i32
  %tmpVar14 = icmp slt i32 %26, 58
  %27 = zext i1 %tmpVar14 to i32
  br label %28

28:                                               ; preds = %25, %for_body
  %29 = phi i32 [ %6, %for_body ], [ %27, %25 ]
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %condition_body, label %branch

input15:                                          ; preds = %condition_body
  %31 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_HEX_TO_DWORD = load i32, i32* %HEX_TO_DWORD, align 4
  %32 = zext i32 %load_HEX_TO_DWORD to i64
  store i64 %32, i64* %31, align 4
  %33 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 4, i16* %33, align 2
  br label %call16

call16:                                           ; preds = %input15
  %call19 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %load_X20 = load i8, i8* %X, align 1
  %34 = zext i8 %load_X20 to i64
  %tmpVar21 = add i64 %call19, %34
  %tmpVar22 = sub i64 %tmpVar21, 48
  %35 = trunc i64 %tmpVar22 to i32
  store i32 %35, i32* %HEX_TO_DWORD, align 4
  br label %continue12

36:                                               ; preds = %branch
  %load_X26 = load i8, i8* %X, align 1
  %37 = zext i8 %load_X26 to i32
  %tmpVar27 = icmp slt i32 %37, 71
  %38 = zext i1 %tmpVar27 to i32
  br label %39

39:                                               ; preds = %36, %branch
  %40 = phi i32 [ %20, %branch ], [ %38, %36 ]
  %41 = icmp ne i32 %40, 0
  br i1 %41, label %condition_body23, label %branch11

input29:                                          ; preds = %condition_body23
  %42 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance28, i32 0, i32 0
  %load_HEX_TO_DWORD33 = load i32, i32* %HEX_TO_DWORD, align 4
  %43 = zext i32 %load_HEX_TO_DWORD33 to i64
  store i64 %43, i64* %42, align 4
  %44 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance28, i32 0, i32 1
  store i16 4, i16* %44, align 2
  br label %call30

call30:                                           ; preds = %input29
  %call34 = call i64 @SHL(%SHL_interface* %SHL_instance28)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  %load_X35 = load i8, i8* %X, align 1
  %45 = zext i8 %load_X35 to i64
  %tmpVar36 = add i64 %call34, %45
  %tmpVar37 = sub i64 %tmpVar36, 55
  %46 = trunc i64 %tmpVar37 to i32
  store i32 %46, i32* %HEX_TO_DWORD, align 4
  br label %continue12

47:                                               ; preds = %branch11
  %load_X41 = load i8, i8* %X, align 1
  %48 = zext i8 %load_X41 to i32
  %tmpVar42 = icmp slt i32 %48, 103
  %49 = zext i1 %tmpVar42 to i32
  br label %50

50:                                               ; preds = %47, %branch11
  %51 = phi i32 [ %23, %branch11 ], [ %49, %47 ]
  %52 = icmp ne i32 %51, 0
  br i1 %52, label %condition_body38, label %continue12

input44:                                          ; preds = %condition_body38
  %53 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance43, i32 0, i32 0
  %load_HEX_TO_DWORD48 = load i32, i32* %HEX_TO_DWORD, align 4
  %54 = zext i32 %load_HEX_TO_DWORD48 to i64
  store i64 %54, i64* %53, align 4
  %55 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance43, i32 0, i32 1
  store i16 4, i16* %55, align 2
  br label %call45

call45:                                           ; preds = %input44
  %call49 = call i64 @SHL(%SHL_interface* %SHL_instance43)
  br label %output46

output46:                                         ; preds = %call45
  br label %continue47

continue47:                                       ; preds = %output46
  %load_X50 = load i8, i8* %X, align 1
  %56 = zext i8 %load_X50 to i64
  %tmpVar51 = add i64 %call49, %56
  %tmpVar52 = sub i64 %tmpVar51, 87
  %57 = trunc i64 %tmpVar52 to i32
  store i32 %57, i32* %HEX_TO_DWORD, align 4
  br label %continue12
}

define i8 @IS_ALNUM(%IS_ALNUM_interface* %0) {
entry:
  %str = getelementptr inbounds %IS_ALNUM_interface, %IS_ALNUM_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %IS_ALNUM_interface, %IS_ALNUM_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %IS_ALNUM_interface, %IS_ALNUM_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %IS_ALNUM_interface, %IS_ALNUM_interface* %0, i32 0, i32 3
  %IS_ALNUM = alloca i8, align 1
  store i16 0, i16* %L, align 2
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %pos, align 2
  store i8 0, i8* %IS_ALNUM, align 1
  store [251 x i8]* %str, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %L, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_L = load i16, i16* %L, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_L
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %11, label %12

for_body:                                         ; preds = %9
  %ISC_ALPHA_instance = alloca %ISC_ALPHA_interface, align 8
  br label %input12

increment:                                        ; preds = %continue11
  %tmpVar25 = add i16 %load_pos, 1
  store i16 %tmpVar25, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  %load_L26 = load i16, i16* %L, align 2
  %5 = sext i16 %load_L26 to i32
  %tmpVar27 = icmp sgt i32 %5, 0
  %6 = zext i1 %tmpVar27 to i8
  store i8 %6, i8* %IS_ALNUM, align 1
  %IS_ALNUM_ret28 = load i8, i8* %IS_ALNUM, align 1
  ret i8 %IS_ALNUM_ret28

7:                                                ; preds = %12
  %load_pos6 = load i16, i16* %pos, align 2
  %load_L7 = load i16, i16* %L, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_L7
  %8 = icmp ne i1 %tmpVar8, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar8, %7 ], [ %tmpVar10, %15 ]
  br label %9

condition_body:                                   ; preds = %19
  store i8 0, i8* %IS_ALNUM, align 1
  %IS_ALNUM_ret = load i8, i8* %IS_ALNUM, align 1
  ret i8 %IS_ALNUM_ret

buffer_block:                                     ; No predecessors!
  br label %continue11

continue11:                                       ; preds = %buffer_block, %19
  %load_PT = load i8*, i8** %pt, align 8
  %access___IS_ALNUM_pt = getelementptr inbounds i8, i8* %load_PT, i32 1
  store i8* %access___IS_ALNUM_pt, i8** %pt, align 8
  br label %increment

18:                                               ; preds = %continue15
  %ISC_NUM_instance = alloca %ISC_NUM_interface, align 8
  br label %input17

19:                                               ; preds = %continue20, %continue15
  %20 = phi i32 [ %23, %continue15 ], [ %26, %continue20 ]
  %tmpVar24 = xor i32 %20, -1
  %21 = icmp ne i32 %tmpVar24, 0
  br i1 %21, label %condition_body, label %continue11

input12:                                          ; preds = %for_body
  %22 = getelementptr inbounds %ISC_ALPHA_interface, %ISC_ALPHA_interface* %ISC_ALPHA_instance, i32 0, i32 0
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %22, align 1
  br label %call13

call13:                                           ; preds = %input12
  %call16 = call i8 @ISC_ALPHA(%ISC_ALPHA_interface* %ISC_ALPHA_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %23 = zext i8 %call16 to i32
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %19, label %18

input17:                                          ; preds = %18
  %25 = getelementptr inbounds %ISC_NUM_interface, %ISC_NUM_interface* %ISC_NUM_instance, i32 0, i32 0
  %deref21 = load i8*, i8** %pt, align 8
  %load_tmpVar22 = load i8, i8* %deref21, align 1
  store i8 %load_tmpVar22, i8* %25, align 1
  br label %call18

call18:                                           ; preds = %input17
  %call23 = call i8 @ISC_NUM(%ISC_NUM_interface* %ISC_NUM_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %26 = zext i8 %call23 to i32
  br label %19
}

define i8 @IS_ALPHA(%IS_ALPHA_interface* %0) {
entry:
  %str = getelementptr inbounds %IS_ALPHA_interface, %IS_ALPHA_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %IS_ALPHA_interface, %IS_ALPHA_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %IS_ALPHA_interface, %IS_ALPHA_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %IS_ALPHA_interface, %IS_ALPHA_interface* %0, i32 0, i32 3
  %IS_ALPHA = alloca i8, align 1
  store i16 0, i16* %L, align 2
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %pos, align 2
  store i8 0, i8* %IS_ALPHA, align 1
  store [251 x i8]* %str, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %L, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_L = load i16, i16* %L, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_L
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %11, label %12

for_body:                                         ; preds = %9
  %ISC_ALPHA_instance = alloca %ISC_ALPHA_interface, align 8
  br label %input12

increment:                                        ; preds = %continue11
  %tmpVar18 = add i16 %load_pos, 1
  store i16 %tmpVar18, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  %load_L19 = load i16, i16* %L, align 2
  %5 = sext i16 %load_L19 to i32
  %tmpVar20 = icmp sgt i32 %5, 0
  %6 = zext i1 %tmpVar20 to i8
  store i8 %6, i8* %IS_ALPHA, align 1
  %IS_ALPHA_ret21 = load i8, i8* %IS_ALPHA, align 1
  ret i8 %IS_ALPHA_ret21

7:                                                ; preds = %12
  %load_pos6 = load i16, i16* %pos, align 2
  %load_L7 = load i16, i16* %L, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_L7
  %8 = icmp ne i1 %tmpVar8, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar8, %7 ], [ %tmpVar10, %15 ]
  br label %9

condition_body:                                   ; preds = %continue15
  store i8 0, i8* %IS_ALPHA, align 1
  %IS_ALPHA_ret = load i8, i8* %IS_ALPHA, align 1
  ret i8 %IS_ALPHA_ret

buffer_block:                                     ; No predecessors!
  br label %continue11

continue11:                                       ; preds = %buffer_block, %continue15
  %load_PT = load i8*, i8** %pt, align 8
  %access___IS_ALPHA_pt = getelementptr inbounds i8, i8* %load_PT, i32 1
  store i8* %access___IS_ALPHA_pt, i8** %pt, align 8
  br label %increment

input12:                                          ; preds = %for_body
  %18 = getelementptr inbounds %ISC_ALPHA_interface, %ISC_ALPHA_interface* %ISC_ALPHA_instance, i32 0, i32 0
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %18, align 1
  br label %call13

call13:                                           ; preds = %input12
  %call16 = call i8 @ISC_ALPHA(%ISC_ALPHA_interface* %ISC_ALPHA_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %tmpVar17 = xor i8 %call16, -1
  %19 = icmp ne i8 %tmpVar17, 0
  br i1 %19, label %condition_body, label %continue11
}

define i8 @IS_CC(%IS_CC_interface* %0) {
entry:
  %str = getelementptr inbounds %IS_CC_interface, %IS_CC_interface* %0, i32 0, i32 0
  %cmp = getelementptr inbounds %IS_CC_interface, %IS_CC_interface* %0, i32 0, i32 1
  %L = getelementptr inbounds %IS_CC_interface, %IS_CC_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %IS_CC_interface, %IS_CC_interface* %0, i32 0, i32 3
  %IS_CC = alloca i8, align 1
  store i16 0, i16* %L, align 2
  store i16 0, i16* %pos, align 2
  store i8 0, i8* %IS_CC, align 1
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %L, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_L = load i16, i16* %L, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_L
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %11, label %12

for_body:                                         ; preds = %9
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input12

increment:                                        ; preds = %continue11
  %tmpVar24 = add i16 %load_pos, 1
  store i16 %tmpVar24, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  %load_L25 = load i16, i16* %L, align 2
  %5 = sext i16 %load_L25 to i32
  %tmpVar26 = icmp sgt i32 %5, 0
  %6 = zext i1 %tmpVar26 to i8
  store i8 %6, i8* %IS_CC, align 1
  %IS_CC_ret27 = load i8, i8* %IS_CC, align 1
  ret i8 %IS_CC_ret27

7:                                                ; preds = %12
  %load_pos6 = load i16, i16* %pos, align 2
  %load_L7 = load i16, i16* %L, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_L7
  %8 = icmp ne i1 %tmpVar8, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar8, %7 ], [ %tmpVar10, %15 ]
  br label %9

condition_body:                                   ; preds = %continue15
  %IS_CC_ret = load i8, i8* %IS_CC, align 1
  ret i8 %IS_CC_ret

buffer_block:                                     ; No predecessors!
  br label %continue11

continue11:                                       ; preds = %buffer_block, %continue15
  br label %increment

input12:                                          ; preds = %for_body
  %18 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %19 = bitcast [1024 x i8]* %18 to i8*
  %20 = bitcast [251 x i8]* %cmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %19, i8* align 1 %20, i32 251, i1 false)
  %21 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %MID_instance = alloca %MID_interface, align 8
  br label %input16

call13:                                           ; preds = %continue19
  %call22 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %22 = sext i16 %call22 to i32
  %tmpVar23 = icmp eq i32 %22, 0
  br i1 %tmpVar23, label %condition_body, label %continue11

input16:                                          ; preds = %input12
  %23 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %24 = bitcast [1024 x i8]* %23 to i8*
  %25 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %24, i8* align 1 %25, i32 251, i1 false)
  %26 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  store i16 1, i16* %26, align 2
  %27 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  %load_pos20 = load i16, i16* %pos, align 2
  store i16 %load_pos20, i16* %27, align 2
  br label %call17

call17:                                           ; preds = %input16
  %call21 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %28 = alloca [1024 x i8], align 1
  store [1024 x i8] %call21, [1024 x i8]* %28, align 1
  %29 = bitcast [1024 x i8]* %21 to i8*
  %30 = bitcast [1024 x i8]* %28 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %29, i8* align 1 %30, i32 1023, i1 false)
  br label %call13
}

define i8 @IS_CTRL(%IS_CTRL_interface* %0) {
entry:
  %STR = getelementptr inbounds %IS_CTRL_interface, %IS_CTRL_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %IS_CTRL_interface, %IS_CTRL_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %IS_CTRL_interface, %IS_CTRL_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %IS_CTRL_interface, %IS_CTRL_interface* %0, i32 0, i32 3
  %IS_CTRL = alloca i8, align 1
  store i16 0, i16* %L, align 2
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %pos, align 2
  store i8 0, i8* %IS_CTRL, align 1
  store [251 x i8]* %STR, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %L, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_L = load i16, i16* %L, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_L
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %11, label %12

for_body:                                         ; preds = %9
  %ISC_CTRL_instance = alloca %ISC_CTRL_interface, align 8
  br label %input12

increment:                                        ; preds = %continue11
  %tmpVar18 = add i16 %load_pos, 1
  store i16 %tmpVar18, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  %load_L19 = load i16, i16* %L, align 2
  %5 = sext i16 %load_L19 to i32
  %tmpVar20 = icmp sgt i32 %5, 0
  %6 = zext i1 %tmpVar20 to i8
  store i8 %6, i8* %IS_CTRL, align 1
  %IS_CTRL_ret21 = load i8, i8* %IS_CTRL, align 1
  ret i8 %IS_CTRL_ret21

7:                                                ; preds = %12
  %load_pos6 = load i16, i16* %pos, align 2
  %load_L7 = load i16, i16* %L, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_L7
  %8 = icmp ne i1 %tmpVar8, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar8, %7 ], [ %tmpVar10, %15 ]
  br label %9

condition_body:                                   ; preds = %continue15
  store i8 0, i8* %IS_CTRL, align 1
  %IS_CTRL_ret = load i8, i8* %IS_CTRL, align 1
  ret i8 %IS_CTRL_ret

buffer_block:                                     ; No predecessors!
  br label %continue11

continue11:                                       ; preds = %buffer_block, %continue15
  %load_PT = load i8*, i8** %pt, align 8
  %access___IS_CTRL_pt = getelementptr inbounds i8, i8* %load_PT, i32 1
  store i8* %access___IS_CTRL_pt, i8** %pt, align 8
  br label %increment

input12:                                          ; preds = %for_body
  %18 = getelementptr inbounds %ISC_CTRL_interface, %ISC_CTRL_interface* %ISC_CTRL_instance, i32 0, i32 0
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %18, align 1
  br label %call13

call13:                                           ; preds = %input12
  %call16 = call i8 @ISC_CTRL(%ISC_CTRL_interface* %ISC_CTRL_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %tmpVar17 = xor i8 %call16, -1
  %19 = icmp ne i8 %tmpVar17, 0
  br i1 %19, label %condition_body, label %continue11
}

define i8 @IS_HEX(%IS_HEX_interface* %0) {
entry:
  %str = getelementptr inbounds %IS_HEX_interface, %IS_HEX_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %IS_HEX_interface, %IS_HEX_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %IS_HEX_interface, %IS_HEX_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %IS_HEX_interface, %IS_HEX_interface* %0, i32 0, i32 3
  %IS_HEX = alloca i8, align 1
  store i16 0, i16* %L, align 2
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %pos, align 2
  store i8 0, i8* %IS_HEX, align 1
  store [251 x i8]* %str, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %L, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_L = load i16, i16* %L, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_L
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %11, label %12

for_body:                                         ; preds = %9
  %ISC_HEX_instance = alloca %ISC_HEX_interface, align 8
  br label %input12

increment:                                        ; preds = %continue11
  %tmpVar18 = add i16 %load_pos, 1
  store i16 %tmpVar18, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  %load_L19 = load i16, i16* %L, align 2
  %5 = sext i16 %load_L19 to i32
  %tmpVar20 = icmp sgt i32 %5, 0
  %6 = zext i1 %tmpVar20 to i8
  store i8 %6, i8* %IS_HEX, align 1
  %IS_HEX_ret21 = load i8, i8* %IS_HEX, align 1
  ret i8 %IS_HEX_ret21

7:                                                ; preds = %12
  %load_pos6 = load i16, i16* %pos, align 2
  %load_L7 = load i16, i16* %L, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_L7
  %8 = icmp ne i1 %tmpVar8, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar8, %7 ], [ %tmpVar10, %15 ]
  br label %9

condition_body:                                   ; preds = %continue15
  store i8 0, i8* %IS_HEX, align 1
  %IS_HEX_ret = load i8, i8* %IS_HEX, align 1
  ret i8 %IS_HEX_ret

buffer_block:                                     ; No predecessors!
  br label %continue11

continue11:                                       ; preds = %buffer_block, %continue15
  %load_PT = load i8*, i8** %pt, align 8
  %access___IS_HEX_pt = getelementptr inbounds i8, i8* %load_PT, i32 1
  store i8* %access___IS_HEX_pt, i8** %pt, align 8
  br label %increment

input12:                                          ; preds = %for_body
  %18 = getelementptr inbounds %ISC_HEX_interface, %ISC_HEX_interface* %ISC_HEX_instance, i32 0, i32 0
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %18, align 1
  br label %call13

call13:                                           ; preds = %input12
  %call16 = call i8 @ISC_HEX(%ISC_HEX_interface* %ISC_HEX_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %tmpVar17 = xor i8 %call16, -1
  %19 = icmp ne i8 %tmpVar17, 0
  br i1 %19, label %condition_body, label %continue11
}

define i8 @IS_LOWER(%IS_LOWER_interface* %0) {
entry:
  %str = getelementptr inbounds %IS_LOWER_interface, %IS_LOWER_interface* %0, i32 0, i32 0
  %l = getelementptr inbounds %IS_LOWER_interface, %IS_LOWER_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %IS_LOWER_interface, %IS_LOWER_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %IS_LOWER_interface, %IS_LOWER_interface* %0, i32 0, i32 3
  %IS_LOWER = alloca i8, align 1
  store i16 0, i16* %l, align 2
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %pos, align 2
  store i8 0, i8* %IS_LOWER, align 1
  store [251 x i8]* %str, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %l, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_L = load i16, i16* %l, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_L
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %11, label %12

for_body:                                         ; preds = %9
  %ISC_LOWER_instance = alloca %ISC_LOWER_interface, align 8
  br label %input12

increment:                                        ; preds = %continue11
  %tmpVar18 = add i16 %load_pos, 1
  store i16 %tmpVar18, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  %load_L19 = load i16, i16* %l, align 2
  %5 = sext i16 %load_L19 to i32
  %tmpVar20 = icmp sgt i32 %5, 0
  %6 = zext i1 %tmpVar20 to i8
  store i8 %6, i8* %IS_LOWER, align 1
  %IS_LOWER_ret21 = load i8, i8* %IS_LOWER, align 1
  ret i8 %IS_LOWER_ret21

7:                                                ; preds = %12
  %load_pos6 = load i16, i16* %pos, align 2
  %load_L7 = load i16, i16* %l, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_L7
  %8 = icmp ne i1 %tmpVar8, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar8, %7 ], [ %tmpVar10, %15 ]
  br label %9

condition_body:                                   ; preds = %continue15
  store i8 0, i8* %IS_LOWER, align 1
  %IS_LOWER_ret = load i8, i8* %IS_LOWER, align 1
  ret i8 %IS_LOWER_ret

buffer_block:                                     ; No predecessors!
  br label %continue11

continue11:                                       ; preds = %buffer_block, %continue15
  %load_PT = load i8*, i8** %pt, align 8
  %access___IS_LOWER_pt = getelementptr inbounds i8, i8* %load_PT, i32 1
  store i8* %access___IS_LOWER_pt, i8** %pt, align 8
  br label %increment

input12:                                          ; preds = %for_body
  %18 = getelementptr inbounds %ISC_LOWER_interface, %ISC_LOWER_interface* %ISC_LOWER_instance, i32 0, i32 0
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %18, align 1
  br label %call13

call13:                                           ; preds = %input12
  %call16 = call i8 @ISC_LOWER(%ISC_LOWER_interface* %ISC_LOWER_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %tmpVar17 = xor i8 %call16, -1
  %19 = icmp ne i8 %tmpVar17, 0
  br i1 %19, label %condition_body, label %continue11
}

define i8 @IS_NCC(%IS_NCC_interface* %0) {
entry:
  %str = getelementptr inbounds %IS_NCC_interface, %IS_NCC_interface* %0, i32 0, i32 0
  %cmp = getelementptr inbounds %IS_NCC_interface, %IS_NCC_interface* %0, i32 0, i32 1
  %L = getelementptr inbounds %IS_NCC_interface, %IS_NCC_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %IS_NCC_interface, %IS_NCC_interface* %0, i32 0, i32 3
  %IS_NCC = alloca i8, align 1
  store i16 0, i16* %L, align 2
  store i16 0, i16* %pos, align 2
  store i8 0, i8* %IS_NCC, align 1
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %L, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_L = load i16, i16* %L, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_L
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %9, label %10

for_body:                                         ; preds = %7
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input12

increment:                                        ; preds = %continue11
  %tmpVar24 = add i16 %load_pos, 1
  store i16 %tmpVar24, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %7
  store i8 1, i8* %IS_NCC, align 1
  %IS_NCC_ret25 = load i8, i8* %IS_NCC, align 1
  ret i8 %IS_NCC_ret25

5:                                                ; preds = %10
  %load_pos6 = load i16, i16* %pos, align 2
  %load_L7 = load i16, i16* %L, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_L7
  %6 = icmp ne i1 %tmpVar8, false
  br i1 %6, label %13, label %14

7:                                                ; preds = %14, %10
  %8 = phi i1 [ %11, %10 ], [ %15, %14 ]
  br i1 %8, label %for_body, label %continue2

9:                                                ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %10

10:                                               ; preds = %9, %condition_check
  %11 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %9 ]
  %12 = icmp ne i1 %11, false
  br i1 %12, label %7, label %5

13:                                               ; preds = %5
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %14

14:                                               ; preds = %13, %5
  %15 = phi i1 [ %tmpVar8, %5 ], [ %tmpVar10, %13 ]
  br label %7

condition_body:                                   ; preds = %continue15
  %IS_NCC_ret = load i8, i8* %IS_NCC, align 1
  ret i8 %IS_NCC_ret

buffer_block:                                     ; No predecessors!
  br label %continue11

continue11:                                       ; preds = %buffer_block, %continue15
  br label %increment

input12:                                          ; preds = %for_body
  %16 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %17 = bitcast [1024 x i8]* %16 to i8*
  %18 = bitcast [251 x i8]* %cmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %17, i8* align 1 %18, i32 251, i1 false)
  %19 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %MID_instance = alloca %MID_interface, align 8
  br label %input16

call13:                                           ; preds = %continue19
  %call22 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %20 = sext i16 %call22 to i32
  %tmpVar23 = icmp sgt i32 %20, 0
  br i1 %tmpVar23, label %condition_body, label %continue11

input16:                                          ; preds = %input12
  %21 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %22 = bitcast [1024 x i8]* %21 to i8*
  %23 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %22, i8* align 1 %23, i32 251, i1 false)
  %24 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  store i16 1, i16* %24, align 2
  %25 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  %load_pos20 = load i16, i16* %pos, align 2
  store i16 %load_pos20, i16* %25, align 2
  br label %call17

call17:                                           ; preds = %input16
  %call21 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %26 = alloca [1024 x i8], align 1
  store [1024 x i8] %call21, [1024 x i8]* %26, align 1
  %27 = bitcast [1024 x i8]* %19 to i8*
  %28 = bitcast [1024 x i8]* %26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %27, i8* align 1 %28, i32 1023, i1 false)
  br label %call13
}

define i8 @IS_NUM(%IS_NUM_interface* %0) {
entry:
  %str = getelementptr inbounds %IS_NUM_interface, %IS_NUM_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %IS_NUM_interface, %IS_NUM_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %IS_NUM_interface, %IS_NUM_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %IS_NUM_interface, %IS_NUM_interface* %0, i32 0, i32 3
  %IS_NUM = alloca i8, align 1
  store i16 0, i16* %L, align 2
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %pos, align 2
  store i8 0, i8* %IS_NUM, align 1
  store [251 x i8]* %str, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %L, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_L = load i16, i16* %L, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_L
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %11, label %12

for_body:                                         ; preds = %9
  %ISC_NUM_instance = alloca %ISC_NUM_interface, align 8
  br label %input12

increment:                                        ; preds = %continue11
  %tmpVar18 = add i16 %load_pos, 1
  store i16 %tmpVar18, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  %load_L19 = load i16, i16* %L, align 2
  %5 = sext i16 %load_L19 to i32
  %tmpVar20 = icmp sgt i32 %5, 0
  %6 = zext i1 %tmpVar20 to i8
  store i8 %6, i8* %IS_NUM, align 1
  %IS_NUM_ret21 = load i8, i8* %IS_NUM, align 1
  ret i8 %IS_NUM_ret21

7:                                                ; preds = %12
  %load_pos6 = load i16, i16* %pos, align 2
  %load_L7 = load i16, i16* %L, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_L7
  %8 = icmp ne i1 %tmpVar8, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar8, %7 ], [ %tmpVar10, %15 ]
  br label %9

condition_body:                                   ; preds = %continue15
  store i8 0, i8* %IS_NUM, align 1
  %IS_NUM_ret = load i8, i8* %IS_NUM, align 1
  ret i8 %IS_NUM_ret

buffer_block:                                     ; No predecessors!
  br label %continue11

continue11:                                       ; preds = %buffer_block, %continue15
  %load_PT = load i8*, i8** %pt, align 8
  %access___IS_NUM_pt = getelementptr inbounds i8, i8* %load_PT, i32 1
  store i8* %access___IS_NUM_pt, i8** %pt, align 8
  br label %increment

input12:                                          ; preds = %for_body
  %18 = getelementptr inbounds %ISC_NUM_interface, %ISC_NUM_interface* %ISC_NUM_instance, i32 0, i32 0
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %18, align 1
  br label %call13

call13:                                           ; preds = %input12
  %call16 = call i8 @ISC_NUM(%ISC_NUM_interface* %ISC_NUM_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %tmpVar17 = xor i8 %call16, -1
  %19 = icmp ne i8 %tmpVar17, 0
  br i1 %19, label %condition_body, label %continue11
}

define i8 @IS_UPPER(%IS_UPPER_interface* %0) {
entry:
  %str = getelementptr inbounds %IS_UPPER_interface, %IS_UPPER_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %IS_UPPER_interface, %IS_UPPER_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %IS_UPPER_interface, %IS_UPPER_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %IS_UPPER_interface, %IS_UPPER_interface* %0, i32 0, i32 3
  %IS_UPPER = alloca i8, align 1
  store i16 0, i16* %L, align 2
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %pos, align 2
  store i8 0, i8* %IS_UPPER, align 1
  store [251 x i8]* %str, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %L, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_L = load i16, i16* %L, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_L
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %11, label %12

for_body:                                         ; preds = %9
  %ISC_UPPER_instance = alloca %ISC_UPPER_interface, align 8
  br label %input12

increment:                                        ; preds = %continue11
  %tmpVar18 = add i16 %load_pos, 1
  store i16 %tmpVar18, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %9
  %load_L19 = load i16, i16* %L, align 2
  %5 = sext i16 %load_L19 to i32
  %tmpVar20 = icmp sgt i32 %5, 0
  %6 = zext i1 %tmpVar20 to i8
  store i8 %6, i8* %IS_UPPER, align 1
  %IS_UPPER_ret21 = load i8, i8* %IS_UPPER, align 1
  ret i8 %IS_UPPER_ret21

7:                                                ; preds = %12
  %load_pos6 = load i16, i16* %pos, align 2
  %load_L7 = load i16, i16* %L, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_L7
  %8 = icmp ne i1 %tmpVar8, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue2

11:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar8, %7 ], [ %tmpVar10, %15 ]
  br label %9

condition_body:                                   ; preds = %continue15
  store i8 0, i8* %IS_UPPER, align 1
  %IS_UPPER_ret = load i8, i8* %IS_UPPER, align 1
  ret i8 %IS_UPPER_ret

buffer_block:                                     ; No predecessors!
  br label %continue11

continue11:                                       ; preds = %buffer_block, %continue15
  %load_PT = load i8*, i8** %pt, align 8
  %access___IS_UPPER_pt = getelementptr inbounds i8, i8* %load_PT, i32 1
  store i8* %access___IS_UPPER_pt, i8** %pt, align 8
  br label %increment

input12:                                          ; preds = %for_body
  %18 = getelementptr inbounds %ISC_UPPER_interface, %ISC_UPPER_interface* %ISC_UPPER_instance, i32 0, i32 0
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %18, align 1
  br label %call13

call13:                                           ; preds = %input12
  %call16 = call i8 @ISC_UPPER(%ISC_UPPER_interface* %ISC_UPPER_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %tmpVar17 = xor i8 %call16, -1
  %19 = icmp ne i8 %tmpVar17, 0
  br i1 %19, label %condition_body, label %continue11
}

define i8 @ISC_ALPHA(%ISC_ALPHA_interface* %0) {
entry:
  %IN = getelementptr inbounds %ISC_ALPHA_interface, %ISC_ALPHA_interface* %0, i32 0, i32 0
  %ISC_ALPHA = alloca i8, align 1
  store i8 0, i8* %ISC_ALPHA, align 1
  %load_ = load i8, i8* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 0), align 1
  %1 = icmp ne i8 %load_, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_in = load i8, i8* %IN, align 1
  %2 = zext i8 %load_in to i32
  %tmpVar = icmp sgt i32 %2, 64
  %3 = zext i1 %tmpVar to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %21, label %24

else:                                             ; preds = %entry
  %load_IN = load i8, i8* %IN, align 1
  %5 = zext i8 %load_IN to i32
  %tmpVar13 = icmp sgt i32 %5, 64
  %6 = zext i1 %tmpVar13 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %49, label %52

continue:                                         ; preds = %47, %12
  %ISC_ALPHA_ret = load i8, i8* %ISC_ALPHA, align 1
  ret i8 %ISC_ALPHA_ret

8:                                                ; preds = %18
  %load_in9 = load i8, i8* %IN, align 1
  %9 = zext i8 %load_in9 to i32
  %tmpVar10 = icmp sgt i32 %9, 96
  %10 = zext i1 %tmpVar10 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %38, label %41

12:                                               ; preds = %41, %18
  %13 = phi i32 [ %19, %18 ], [ %42, %41 ]
  store i32 %13, i8* %ISC_ALPHA, align 4
  br label %continue

14:                                               ; preds = %24
  %load_in3 = load i8, i8* %IN, align 1
  %15 = zext i8 %load_in3 to i32
  %tmpVar4 = icmp sgt i32 %15, 191
  %16 = zext i1 %tmpVar4 to i32
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %32, label %35

18:                                               ; preds = %30, %24
  %19 = phi i32 [ %25, %24 ], [ %31, %30 ]
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %12, label %8

21:                                               ; preds = %condition_body
  %load_in1 = load i8, i8* %IN, align 1
  %22 = zext i8 %load_in1 to i32
  %tmpVar2 = icmp slt i32 %22, 91
  %23 = zext i1 %tmpVar2 to i32
  br label %24

24:                                               ; preds = %21, %condition_body
  %25 = phi i32 [ %3, %condition_body ], [ %23, %21 ]
  %26 = icmp ne i32 %25, 0
  br i1 %26, label %18, label %14

27:                                               ; preds = %35
  %load_in7 = load i8, i8* %IN, align 1
  %28 = zext i8 %load_in7 to i32
  %tmpVar8 = icmp ne i32 %28, 247
  %29 = zext i1 %tmpVar8 to i32
  br label %30

30:                                               ; preds = %27, %35
  %31 = phi i32 [ %36, %35 ], [ %29, %27 ]
  br label %18

32:                                               ; preds = %14
  %load_in5 = load i8, i8* %IN, align 1
  %33 = zext i8 %load_in5 to i32
  %tmpVar6 = icmp ne i32 %33, 215
  %34 = zext i1 %tmpVar6 to i32
  br label %35

35:                                               ; preds = %32, %14
  %36 = phi i32 [ %16, %14 ], [ %34, %32 ]
  %37 = icmp ne i32 %36, 0
  br i1 %37, label %27, label %30

38:                                               ; preds = %8
  %load_in11 = load i8, i8* %IN, align 1
  %39 = zext i8 %load_in11 to i32
  %tmpVar12 = icmp slt i32 %39, 123
  %40 = zext i1 %tmpVar12 to i32
  br label %41

41:                                               ; preds = %38, %8
  %42 = phi i32 [ %10, %8 ], [ %40, %38 ]
  br label %12

43:                                               ; preds = %52
  %load_in16 = load i8, i8* %IN, align 1
  %44 = zext i8 %load_in16 to i32
  %tmpVar17 = icmp sgt i32 %44, 96
  %45 = zext i1 %tmpVar17 to i32
  %46 = icmp ne i32 %45, 0
  br i1 %46, label %55, label %58

47:                                               ; preds = %58, %52
  %48 = phi i32 [ %53, %52 ], [ %59, %58 ]
  store i32 %48, i8* %ISC_ALPHA, align 4
  br label %continue

49:                                               ; preds = %else
  %load_IN14 = load i8, i8* %IN, align 1
  %50 = zext i8 %load_IN14 to i32
  %tmpVar15 = icmp slt i32 %50, 91
  %51 = zext i1 %tmpVar15 to i32
  br label %52

52:                                               ; preds = %49, %else
  %53 = phi i32 [ %6, %else ], [ %51, %49 ]
  %54 = icmp ne i32 %53, 0
  br i1 %54, label %47, label %43

55:                                               ; preds = %43
  %load_in18 = load i8, i8* %IN, align 1
  %56 = zext i8 %load_in18 to i32
  %tmpVar19 = icmp slt i32 %56, 123
  %57 = zext i1 %tmpVar19 to i32
  br label %58

58:                                               ; preds = %55, %43
  %59 = phi i32 [ %45, %43 ], [ %57, %55 ]
  br label %47
}

define i8 @ISC_CTRL(%ISC_CTRL_interface* %0) {
entry:
  %IN = getelementptr inbounds %ISC_CTRL_interface, %ISC_CTRL_interface* %0, i32 0, i32 0
  %ISC_CTRL = alloca i8, align 1
  store i8 0, i8* %ISC_CTRL, align 1
  %load_IN = load i8, i8* %IN, align 1
  %1 = zext i8 %load_IN to i32
  %tmpVar = icmp slt i32 %1, 32
  %2 = zext i1 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %7, label %4

4:                                                ; preds = %entry
  %load_IN1 = load i8, i8* %IN, align 1
  %5 = zext i8 %load_IN1 to i32
  %tmpVar2 = icmp eq i32 %5, 127
  %6 = zext i1 %tmpVar2 to i32
  br label %7

7:                                                ; preds = %4, %entry
  %8 = phi i32 [ %2, %entry ], [ %6, %4 ]
  store i32 %8, i8* %ISC_CTRL, align 4
  %ISC_CTRL_ret = load i8, i8* %ISC_CTRL, align 1
  ret i8 %ISC_CTRL_ret
}

define i8 @ISC_HEX(%ISC_HEX_interface* %0) {
entry:
  %IN = getelementptr inbounds %ISC_HEX_interface, %ISC_HEX_interface* %0, i32 0, i32 0
  %ISC_HEX = alloca i8, align 1
  store i8 0, i8* %ISC_HEX, align 1
  %load_IN = load i8, i8* %IN, align 1
  %1 = zext i8 %load_IN to i32
  %tmpVar = icmp sgt i32 %1, 47
  %2 = zext i1 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %17, label %20

4:                                                ; preds = %14
  %load_IN7 = load i8, i8* %IN, align 1
  %5 = zext i8 %load_IN7 to i32
  %tmpVar8 = icmp sgt i32 %5, 96
  %6 = zext i1 %tmpVar8 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %28, label %31

8:                                                ; preds = %31, %14
  %9 = phi i32 [ %15, %14 ], [ %32, %31 ]
  store i32 %9, i8* %ISC_HEX, align 4
  %ISC_HEX_ret = load i8, i8* %ISC_HEX, align 1
  ret i8 %ISC_HEX_ret

10:                                               ; preds = %20
  %load_IN3 = load i8, i8* %IN, align 1
  %11 = zext i8 %load_IN3 to i32
  %tmpVar4 = icmp sgt i32 %11, 64
  %12 = zext i1 %tmpVar4 to i32
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %23, label %26

14:                                               ; preds = %26, %20
  %15 = phi i32 [ %21, %20 ], [ %27, %26 ]
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %8, label %4

17:                                               ; preds = %entry
  %load_IN1 = load i8, i8* %IN, align 1
  %18 = zext i8 %load_IN1 to i32
  %tmpVar2 = icmp slt i32 %18, 58
  %19 = zext i1 %tmpVar2 to i32
  br label %20

20:                                               ; preds = %17, %entry
  %21 = phi i32 [ %2, %entry ], [ %19, %17 ]
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %14, label %10

23:                                               ; preds = %10
  %load_IN5 = load i8, i8* %IN, align 1
  %24 = zext i8 %load_IN5 to i32
  %tmpVar6 = icmp slt i32 %24, 71
  %25 = zext i1 %tmpVar6 to i32
  br label %26

26:                                               ; preds = %23, %10
  %27 = phi i32 [ %12, %10 ], [ %25, %23 ]
  br label %14

28:                                               ; preds = %4
  %load_IN9 = load i8, i8* %IN, align 1
  %29 = zext i8 %load_IN9 to i32
  %tmpVar10 = icmp slt i32 %29, 103
  %30 = zext i1 %tmpVar10 to i32
  br label %31

31:                                               ; preds = %28, %4
  %32 = phi i32 [ %6, %4 ], [ %30, %28 ]
  br label %8
}

define i8 @ISC_LOWER(%ISC_LOWER_interface* %0) {
entry:
  %IN = getelementptr inbounds %ISC_LOWER_interface, %ISC_LOWER_interface* %0, i32 0, i32 0
  %ISC_LOWER = alloca i8, align 1
  store i8 0, i8* %ISC_LOWER, align 1
  %load_ = load i8, i8* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 0), align 1
  %1 = icmp ne i8 %load_, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_in = load i8, i8* %IN, align 1
  %2 = zext i8 %load_in to i32
  %tmpVar = icmp sgt i32 %2, 96
  %3 = zext i1 %tmpVar to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %14, label %17

else:                                             ; preds = %entry
  %load_in7 = load i8, i8* %IN, align 1
  %5 = zext i8 %load_in7 to i32
  %tmpVar8 = icmp sgt i32 %5, 96
  %6 = zext i1 %tmpVar8 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %25, label %28

continue:                                         ; preds = %28, %12
  %ISC_LOWER_ret = load i8, i8* %ISC_LOWER, align 1
  ret i8 %ISC_LOWER_ret

8:                                                ; preds = %17
  %load_in3 = load i8, i8* %IN, align 1
  %9 = zext i8 %load_in3 to i32
  %tmpVar4 = icmp sgt i32 %9, 222
  %10 = zext i1 %tmpVar4 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %20, label %23

12:                                               ; preds = %23, %17
  %13 = phi i32 [ %18, %17 ], [ %24, %23 ]
  store i32 %13, i8* %ISC_LOWER, align 4
  br label %continue

14:                                               ; preds = %condition_body
  %load_in1 = load i8, i8* %IN, align 1
  %15 = zext i8 %load_in1 to i32
  %tmpVar2 = icmp slt i32 %15, 123
  %16 = zext i1 %tmpVar2 to i32
  br label %17

17:                                               ; preds = %14, %condition_body
  %18 = phi i32 [ %3, %condition_body ], [ %16, %14 ]
  %19 = icmp ne i32 %18, 0
  br i1 %19, label %12, label %8

20:                                               ; preds = %8
  %load_in5 = load i8, i8* %IN, align 1
  %21 = zext i8 %load_in5 to i32
  %tmpVar6 = icmp ne i32 %21, 247
  %22 = zext i1 %tmpVar6 to i32
  br label %23

23:                                               ; preds = %20, %8
  %24 = phi i32 [ %10, %8 ], [ %22, %20 ]
  br label %12

25:                                               ; preds = %else
  %load_in9 = load i8, i8* %IN, align 1
  %26 = zext i8 %load_in9 to i32
  %tmpVar10 = icmp slt i32 %26, 123
  %27 = zext i1 %tmpVar10 to i32
  br label %28

28:                                               ; preds = %25, %else
  %29 = phi i32 [ %6, %else ], [ %27, %25 ]
  store i32 %29, i8* %ISC_LOWER, align 4
  br label %continue
}

define i8 @ISC_NUM(%ISC_NUM_interface* %0) {
entry:
  %IN = getelementptr inbounds %ISC_NUM_interface, %ISC_NUM_interface* %0, i32 0, i32 0
  %ISC_NUM = alloca i8, align 1
  store i8 0, i8* %ISC_NUM, align 1
  %load_IN = load i8, i8* %IN, align 1
  %1 = zext i8 %load_IN to i32
  %tmpVar = icmp sgt i32 %1, 47
  %2 = zext i1 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %4, label %7

4:                                                ; preds = %entry
  %load_IN1 = load i8, i8* %IN, align 1
  %5 = zext i8 %load_IN1 to i32
  %tmpVar2 = icmp slt i32 %5, 58
  %6 = zext i1 %tmpVar2 to i32
  br label %7

7:                                                ; preds = %4, %entry
  %8 = phi i32 [ %2, %entry ], [ %6, %4 ]
  store i32 %8, i8* %ISC_NUM, align 4
  %ISC_NUM_ret = load i8, i8* %ISC_NUM, align 1
  ret i8 %ISC_NUM_ret
}

define i8 @ISC_UPPER(%ISC_UPPER_interface* %0) {
entry:
  %IN = getelementptr inbounds %ISC_UPPER_interface, %ISC_UPPER_interface* %0, i32 0, i32 0
  %ISC_UPPER = alloca i8, align 1
  store i8 0, i8* %ISC_UPPER, align 1
  %load_ = load i8, i8* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 0), align 1
  %1 = icmp ne i8 %load_, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_in = load i8, i8* %IN, align 1
  %2 = zext i8 %load_in to i32
  %tmpVar = icmp sgt i32 %2, 64
  %3 = zext i1 %tmpVar to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %14, label %17

else:                                             ; preds = %entry
  %load_in9 = load i8, i8* %IN, align 1
  %5 = zext i8 %load_in9 to i32
  %tmpVar10 = icmp sgt i32 %5, 64
  %6 = zext i1 %tmpVar10 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %31, label %34

continue:                                         ; preds = %34, %12
  %ISC_UPPER_ret = load i8, i8* %ISC_UPPER, align 1
  ret i8 %ISC_UPPER_ret

8:                                                ; preds = %17
  %load_in3 = load i8, i8* %IN, align 1
  %9 = zext i8 %load_in3 to i32
  %tmpVar4 = icmp sgt i32 %9, 191
  %10 = zext i1 %tmpVar4 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %25, label %28

12:                                               ; preds = %23, %17
  %13 = phi i32 [ %18, %17 ], [ %24, %23 ]
  store i32 %13, i8* %ISC_UPPER, align 4
  br label %continue

14:                                               ; preds = %condition_body
  %load_in1 = load i8, i8* %IN, align 1
  %15 = zext i8 %load_in1 to i32
  %tmpVar2 = icmp slt i32 %15, 91
  %16 = zext i1 %tmpVar2 to i32
  br label %17

17:                                               ; preds = %14, %condition_body
  %18 = phi i32 [ %3, %condition_body ], [ %16, %14 ]
  %19 = icmp ne i32 %18, 0
  br i1 %19, label %12, label %8

20:                                               ; preds = %28
  %load_in7 = load i8, i8* %IN, align 1
  %21 = zext i8 %load_in7 to i32
  %tmpVar8 = icmp ne i32 %21, 215
  %22 = zext i1 %tmpVar8 to i32
  br label %23

23:                                               ; preds = %20, %28
  %24 = phi i32 [ %29, %28 ], [ %22, %20 ]
  br label %12

25:                                               ; preds = %8
  %load_in5 = load i8, i8* %IN, align 1
  %26 = zext i8 %load_in5 to i32
  %tmpVar6 = icmp slt i32 %26, 223
  %27 = zext i1 %tmpVar6 to i32
  br label %28

28:                                               ; preds = %25, %8
  %29 = phi i32 [ %10, %8 ], [ %27, %25 ]
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %20, label %23

31:                                               ; preds = %else
  %load_in11 = load i8, i8* %IN, align 1
  %32 = zext i8 %load_in11 to i32
  %tmpVar12 = icmp slt i32 %32, 91
  %33 = zext i1 %tmpVar12 to i32
  br label %34

34:                                               ; preds = %31, %else
  %35 = phi i32 [ %6, %else ], [ %33, %31 ]
  store i32 %35, i8* %ISC_UPPER, align 4
  br label %continue
}

define [251 x i8] @LOWERCASE(%LOWERCASE_interface* %0) {
entry:
  %str = getelementptr inbounds %LOWERCASE_interface, %LOWERCASE_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %LOWERCASE_interface, %LOWERCASE_interface* %0, i32 0, i32 1
  %pos = getelementptr inbounds %LOWERCASE_interface, %LOWERCASE_interface* %0, i32 0, i32 2
  %l = getelementptr inbounds %LOWERCASE_interface, %LOWERCASE_interface* %0, i32 0, i32 3
  %LOWERCASE = alloca [251 x i8], align 1
  store i8* null, i8** %PT, align 8
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %l, align 2
  %1 = bitcast [251 x i8]* %LOWERCASE to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  store [251 x i8]* %LOWERCASE, i8** %PT, align 8
  %2 = bitcast [251 x i8]* %LOWERCASE to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 250, i1 false)
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %5 = bitcast [1024 x i8]* %4 to i8*
  %6 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %l, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_l = load i16, i16* %l, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_l
  %7 = icmp ne i1 %tmpVar, false
  br i1 %7, label %12, label %13

for_body:                                         ; preds = %10
  %deref = load i8*, i8** %PT, align 8
  %TO_LOWER_instance = alloca %TO_LOWER_interface, align 8
  br label %input11

increment:                                        ; preds = %continue14
  %tmpVar17 = add i16 %load_pos, 1
  store i16 %tmpVar17, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  %LOWERCASE_ret = load [251 x i8], [251 x i8]* %LOWERCASE, align 1
  ret [251 x i8] %LOWERCASE_ret

8:                                                ; preds = %13
  %load_pos6 = load i16, i16* %pos, align 2
  %load_l7 = load i16, i16* %l, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_l7
  %9 = icmp ne i1 %tmpVar8, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar8, %8 ], [ %tmpVar10, %16 ]
  br label %10

input11:                                          ; preds = %for_body
  %19 = getelementptr inbounds %TO_LOWER_interface, %TO_LOWER_interface* %TO_LOWER_instance, i32 0, i32 0
  %deref15 = load i8*, i8** %PT, align 8
  %load_tmpVar = load i8, i8* %deref15, align 1
  store i8 %load_tmpVar, i8* %19, align 1
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call i8 @TO_LOWER(%TO_LOWER_interface* %TO_LOWER_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  store i8 %call16, i8* %deref, align 1
  %load_PT = load i8*, i8** %PT, align 8
  %access___LOWERCASE_PT = getelementptr inbounds i8, i8* %load_PT, i32 1
  store i8* %access___LOWERCASE_PT, i8** %PT, align 8
  br label %increment
}

define void @MESSAGE_4R(%MESSAGE_4R_interface* %0) {
entry:
  %M0 = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 0
  %M1 = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 1
  %M2 = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 2
  %M3 = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 3
  %MM = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 4
  %ENQ = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 5
  %CLK = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 6
  %T1 = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 7
  %MX = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 8
  %MN = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 9
  %TR = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 10
  %timer = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 11
  %edge = getelementptr inbounds %MESSAGE_4R_interface, %MESSAGE_4R_interface* %0, i32 0, i32 12
  store i8 0, i8* %TR, align 1
  %load_ENQ = load i8, i8* %ENQ, align 1
  %1 = icmp ne i8 %load_ENQ, 0
  br i1 %1, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_edge = load i8, i8* %edge, align 1
  %tmpVar = xor i8 %load_edge, -1
  %2 = zext i8 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %10, label %12

else:                                             ; preds = %entry
  %4 = bitcast [251 x i8]* %MX to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %4, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  store i16 0, i16* %MN, align 2
  br label %continue

continue:                                         ; preds = %else, %continue19
  ret void

condition_body2:                                  ; preds = %7
  %INC1_instance = alloca %INC1_interface, align 8
  br label %input

continue1:                                        ; preds = %continue9, %7
  %load_clk15 = load i8, i8* %CLK, align 1
  store i8 %load_clk15, i8* %edge, align 1
  br label %input16

5:                                                ; preds = %12
  %q = getelementptr inbounds %TON_interface, %TON_interface* %timer, i32 0, i32 2
  %load_ = load i8, i8* %q, align 1
  %6 = zext i8 %load_ to i32
  br label %7

7:                                                ; preds = %5, %12
  %8 = phi i32 [ %13, %12 ], [ %6, %5 ]
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %condition_body2, label %continue1

10:                                               ; preds = %condition_body
  %load_clk = load i8, i8* %CLK, align 1
  %11 = zext i8 %load_clk to i32
  br label %12

12:                                               ; preds = %10, %condition_body
  %13 = phi i32 [ %2, %condition_body ], [ %11, %10 ]
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %7, label %5

input:                                            ; preds = %condition_body2
  %15 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 0
  %load_MN = load i16, i16* %MN, align 2
  store i16 %load_MN, i16* %15, align 2
  %16 = getelementptr inbounds %INC1_interface, %INC1_interface* %INC1_instance, i32 0, i32 1
  %load_MM = load i16, i16* %MM, align 2
  store i16 %load_MM, i16* %16, align 2
  br label %call

call:                                             ; preds = %input
  %call4 = call i16 @INC1(%INC1_interface* %INC1_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue3

continue3:                                        ; preds = %output
  store i16 %call4, i16* %MN, align 2
  store i8 1, i8* %TR, align 1
  br label %input5

input5:                                           ; preds = %continue3
  %17 = getelementptr inbounds %TON_interface, %TON_interface* %timer, i32 0, i32 0
  store i8 0, i8* %17, align 1
  br label %call6

call6:                                            ; preds = %input5
  call void @TON(%TON_interface* %timer)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %load_MN10 = load i16, i16* %MN, align 2
  switch i16 %load_MN10, label %else11 [
    i16 0, label %case
    i16 1, label %case12
    i16 2, label %case13
    i16 3, label %case14
  ]

case:                                             ; preds = %continue8
  %18 = bitcast [251 x i8]* %MX to i8*
  %19 = bitcast [251 x i8]* %M0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %18, i8* align 1 %19, i32 250, i1 false)
  br label %continue9

case12:                                           ; preds = %continue8
  %20 = bitcast [251 x i8]* %MX to i8*
  %21 = bitcast [251 x i8]* %M1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 250, i1 false)
  br label %continue9

case13:                                           ; preds = %continue8
  %22 = bitcast [251 x i8]* %MX to i8*
  %23 = bitcast [251 x i8]* %M2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %22, i8* align 1 %23, i32 250, i1 false)
  br label %continue9

case14:                                           ; preds = %continue8
  %24 = bitcast [251 x i8]* %MX to i8*
  %25 = bitcast [251 x i8]* %M3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %24, i8* align 1 %25, i32 250, i1 false)
  br label %continue9

else11:                                           ; preds = %continue8
  br label %continue9

continue9:                                        ; preds = %else11, %case14, %case13, %case12, %case
  br label %continue1

input16:                                          ; preds = %continue1
  %26 = getelementptr inbounds %TON_interface, %TON_interface* %timer, i32 0, i32 0
  %load_CLK = load i8, i8* %CLK, align 1
  store i8 %load_CLK, i8* %26, align 1
  %27 = getelementptr inbounds %TON_interface, %TON_interface* %timer, i32 0, i32 1
  %load_T1 = load i64, i64* %T1, align 4
  store i64 %load_T1, i64* %27, align 4
  br label %call17

call17:                                           ; preds = %input16
  call void @TON(%TON_interface* %timer)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  br label %continue
}

define void @MESSAGE_8(%MESSAGE_8_interface* %0) {
entry:
  %IN1 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 0
  %IN2 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 1
  %IN3 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 2
  %IN4 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 3
  %IN5 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 4
  %IN6 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 5
  %IN7 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 6
  %IN8 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 7
  %S1 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 8
  %S2 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 9
  %S3 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 10
  %S4 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 11
  %S5 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 12
  %S6 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 13
  %S7 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 14
  %S8 = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 15
  %M = getelementptr inbounds %MESSAGE_8_interface, %MESSAGE_8_interface* %0, i32 0, i32 16
  %load_in1 = load i8, i8* %IN1, align 1
  %1 = icmp ne i8 %load_in1, 0
  br i1 %1, label %condition_body, label %branch

condition_body:                                   ; preds = %entry
  %2 = bitcast [251 x i8]* %M to i8*
  %3 = bitcast [251 x i8]* %S1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 250, i1 false)
  br label %continue

branch:                                           ; preds = %entry
  %load_in2 = load i8, i8* %IN2, align 1
  %4 = icmp ne i8 %load_in2, 0
  br i1 %4, label %condition_body7, label %branch1

condition_body7:                                  ; preds = %branch
  %5 = bitcast [251 x i8]* %M to i8*
  %6 = bitcast [251 x i8]* %S2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 250, i1 false)
  br label %continue

branch1:                                          ; preds = %branch
  %load_in3 = load i8, i8* %IN3, align 1
  %7 = icmp ne i8 %load_in3, 0
  br i1 %7, label %condition_body8, label %branch2

condition_body8:                                  ; preds = %branch1
  %8 = bitcast [251 x i8]* %M to i8*
  %9 = bitcast [251 x i8]* %S3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %8, i8* align 1 %9, i32 250, i1 false)
  br label %continue

branch2:                                          ; preds = %branch1
  %load_in4 = load i8, i8* %IN4, align 1
  %10 = icmp ne i8 %load_in4, 0
  br i1 %10, label %condition_body9, label %branch3

condition_body9:                                  ; preds = %branch2
  %11 = bitcast [251 x i8]* %M to i8*
  %12 = bitcast [251 x i8]* %S4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %11, i8* align 1 %12, i32 250, i1 false)
  br label %continue

branch3:                                          ; preds = %branch2
  %load_in5 = load i8, i8* %IN5, align 1
  %13 = icmp ne i8 %load_in5, 0
  br i1 %13, label %condition_body10, label %branch4

condition_body10:                                 ; preds = %branch3
  %14 = bitcast [251 x i8]* %M to i8*
  %15 = bitcast [251 x i8]* %S5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %14, i8* align 1 %15, i32 250, i1 false)
  br label %continue

branch4:                                          ; preds = %branch3
  %load_in6 = load i8, i8* %IN6, align 1
  %16 = icmp ne i8 %load_in6, 0
  br i1 %16, label %condition_body11, label %branch5

condition_body11:                                 ; preds = %branch4
  %17 = bitcast [251 x i8]* %M to i8*
  %18 = bitcast [251 x i8]* %S6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %17, i8* align 1 %18, i32 250, i1 false)
  br label %continue

branch5:                                          ; preds = %branch4
  %load_in7 = load i8, i8* %IN7, align 1
  %19 = icmp ne i8 %load_in7, 0
  br i1 %19, label %condition_body12, label %branch6

condition_body12:                                 ; preds = %branch5
  %20 = bitcast [251 x i8]* %M to i8*
  %21 = bitcast [251 x i8]* %S7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 250, i1 false)
  br label %continue

branch6:                                          ; preds = %branch5
  %load_in8 = load i8, i8* %IN8, align 1
  %22 = icmp ne i8 %load_in8, 0
  br i1 %22, label %condition_body13, label %else

condition_body13:                                 ; preds = %branch6
  %23 = bitcast [251 x i8]* %M to i8*
  %24 = bitcast [251 x i8]* %S8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %23, i8* align 1 %24, i32 250, i1 false)
  br label %continue

else:                                             ; preds = %branch6
  %25 = bitcast [251 x i8]* %M to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %25, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  br label %continue

continue:                                         ; preds = %else, %condition_body13, %condition_body12, %condition_body11, %condition_body10, %condition_body9, %condition_body8, %condition_body7, %condition_body
  ret void
}

define [251 x i8] @MIRROR(%MIRROR_interface* %0) {
entry:
  %str = getelementptr inbounds %MIRROR_interface, %MIRROR_interface* %0, i32 0, i32 0
  %pi = getelementptr inbounds %MIRROR_interface, %MIRROR_interface* %0, i32 0, i32 1
  %po = getelementptr inbounds %MIRROR_interface, %MIRROR_interface* %0, i32 0, i32 2
  %lx = getelementptr inbounds %MIRROR_interface, %MIRROR_interface* %0, i32 0, i32 3
  %i = getelementptr inbounds %MIRROR_interface, %MIRROR_interface* %0, i32 0, i32 4
  %MIRROR = alloca [251 x i8], align 1
  store [255 x i8]* null, [255 x i8]** %pi, align 8
  store i8* null, i8** %po, align 8
  store i16 0, i16* %lx, align 2
  store i16 0, i16* %i, align 2
  %1 = bitcast [251 x i8]* %MIRROR to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  store [251 x i8]* %str, [255 x i8]** %pi, align 8
  store [251 x i8]* %MIRROR, i8** %po, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %3 = bitcast [1024 x i8]* %2 to i8*
  %4 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %3, i8* align 1 %4, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %lx, align 2
  %load_lx = load i16, i16* %lx, align 2
  store i16 %load_lx, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_i = load i16, i16* %i, align 2
  %load_i3 = load i16, i16* %i, align 2
  %tmpVar = icmp sle i16 %load_i3, 1
  %5 = icmp ne i1 %tmpVar, false
  br i1 %5, label %12, label %13

for_body:                                         ; preds = %10
  %deref = load i8*, i8** %po, align 8
  %deref12 = load [255 x i8]*, [255 x i8]** %pi, align 8
  %load_i13 = load i16, i16* %i, align 2
  %6 = sub i16 %load_i13, 1
  %7 = sext i16 %6 to i32
  %tmpVar14 = mul i32 1, %7
  %tmpVar15 = add i32 %tmpVar14, 0
  %tmpVar16 = getelementptr inbounds [255 x i8], [255 x i8]* %deref12, i32 0, i32 %tmpVar15
  %load_tmpVar = load i8, i8* %tmpVar16, align 1
  store i8 %load_tmpVar, i8* %deref, align 1
  %load_po = load i8*, i8** %po, align 8
  %access___MIRROR_po = getelementptr inbounds i8, i8* %load_po, i32 1
  store i8* %access___MIRROR_po, i8** %po, align 8
  br label %increment

increment:                                        ; preds = %for_body
  %tmpVar17 = add i16 %load_i, -1
  store i16 %tmpVar17, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  %deref18 = load i8*, i8** %po, align 8
  store i8 0, i8* %deref18, align 1
  %MIRROR_ret = load [251 x i8], [251 x i8]* %MIRROR, align 1
  ret [251 x i8] %MIRROR_ret

8:                                                ; preds = %13
  %load_i7 = load i16, i16* %i, align 2
  %tmpVar8 = icmp sge i16 %load_i7, 1
  %9 = icmp ne i1 %tmpVar8, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_i4 = load i16, i16* %i, align 2
  %load_lx5 = load i16, i16* %lx, align 2
  %tmpVar6 = icmp sge i16 %load_i4, %load_lx5
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar6, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_i9 = load i16, i16* %i, align 2
  %load_lx10 = load i16, i16* %lx, align 2
  %tmpVar11 = icmp sle i16 %load_i9, %load_lx10
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar8, %8 ], [ %tmpVar11, %16 ]
  br label %10
}

define [11 x i8] @MONTH_TO_STRING(%MONTH_TO_STRING_interface* %0) {
entry:
  %MTH = getelementptr inbounds %MONTH_TO_STRING_interface, %MONTH_TO_STRING_interface* %0, i32 0, i32 0
  %LANG = getelementptr inbounds %MONTH_TO_STRING_interface, %MONTH_TO_STRING_interface* %0, i32 0, i32 1
  %LX = getelementptr inbounds %MONTH_TO_STRING_interface, %MONTH_TO_STRING_interface* %0, i32 0, i32 2
  %ly = getelementptr inbounds %MONTH_TO_STRING_interface, %MONTH_TO_STRING_interface* %0, i32 0, i32 3
  %MONTH_TO_STRING = alloca [11 x i8], align 1
  store i16 0, i16* %ly, align 2
  %1 = bitcast [11 x i8]* %MONTH_TO_STRING to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 11), i1 false)
  %load_LANG = load i16, i16* %LANG, align 2
  %2 = sext i16 %load_LANG to i32
  %tmpVar = icmp eq i32 %2, 0
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_ = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 0), align 2
  store i16 %load_, i16* %ly, align 2
  br label %continue

else:                                             ; preds = %entry
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %condition_body
  %load_MTH = load i16, i16* %MTH, align 2
  %3 = sext i16 %load_MTH to i32
  %tmpVar8 = icmp slt i32 %3, 1
  %4 = zext i1 %tmpVar8 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %28, label %25

input:                                            ; preds = %else
  %6 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_LANG2 = load i16, i16* %LANG, align 2
  %7 = sext i16 %load_LANG2 to i64
  store i64 %7, i64* %6, align 4
  %8 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_3 = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 1), align 2
  %9 = sext i16 %load_3 to i64
  store i64 %9, i64* %8, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %10 = trunc i64 %call4 to i16
  store i16 %10, i16* %ly, align 2
  br label %continue

condition_body7:                                  ; preds = %28
  %MONTH_TO_STRING_ret = load [11 x i8], [11 x i8]* %MONTH_TO_STRING, align 1
  ret [11 x i8] %MONTH_TO_STRING_ret

buffer_block:                                     ; No predecessors!
  br label %continue6

branch:                                           ; preds = %28
  %load_LX = load i16, i16* %LX, align 2
  %11 = sext i16 %load_LX to i32
  %tmpVar12 = icmp eq i32 %11, 0
  br i1 %tmpVar12, label %condition_body11, label %branch5

condition_body11:                                 ; preds = %branch
  %load_ly = load i16, i16* %ly, align 2
  %12 = sub i16 %load_ly, 1
  %13 = sext i16 %12 to i32
  %tmpVar13 = mul i32 12, %13
  %tmpVar14 = add i32 %tmpVar13, 0
  %load_MTH15 = load i16, i16* %MTH, align 2
  %14 = sub i16 %load_MTH15, 1
  %15 = sext i16 %14 to i32
  %tmpVar16 = mul i32 1, %15
  %tmpVar17 = add i32 %tmpVar16, %tmpVar14
  %tmpVar18 = getelementptr inbounds [36 x [11 x i8]], [36 x [11 x i8]]* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 4), i32 0, i32 %tmpVar17
  %16 = bitcast [11 x i8]* %MONTH_TO_STRING to i8*
  %17 = bitcast [11 x i8]* %tmpVar18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %16, i8* align 1 %17, i32 10, i1 false)
  br label %continue6

branch5:                                          ; preds = %branch
  %load_Lx = load i16, i16* %LX, align 2
  %18 = sext i16 %load_Lx to i32
  %tmpVar20 = icmp eq i32 %18, 3
  br i1 %tmpVar20, label %condition_body19, label %continue6

condition_body19:                                 ; preds = %branch5
  %load_ly21 = load i16, i16* %ly, align 2
  %19 = sub i16 %load_ly21, 1
  %20 = sext i16 %19 to i32
  %tmpVar22 = mul i32 12, %20
  %tmpVar23 = add i32 %tmpVar22, 0
  %load_MTH24 = load i16, i16* %MTH, align 2
  %21 = sub i16 %load_MTH24, 1
  %22 = sext i16 %21 to i32
  %tmpVar25 = mul i32 1, %22
  %tmpVar26 = add i32 %tmpVar25, %tmpVar23
  %tmpVar27 = getelementptr inbounds [36 x [4 x i8]], [36 x [4 x i8]]* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 5), i32 0, i32 %tmpVar26
  %23 = bitcast [11 x i8]* %MONTH_TO_STRING to i8*
  %24 = bitcast [4 x i8]* %tmpVar27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %23, i8* align 1 %24, i32 4, i1 false)
  br label %continue6

continue6:                                        ; preds = %condition_body19, %branch5, %condition_body11, %buffer_block
  %MONTH_TO_STRING_ret28 = load [11 x i8], [11 x i8]* %MONTH_TO_STRING, align 1
  ret [11 x i8] %MONTH_TO_STRING_ret28

25:                                               ; preds = %continue
  %load_MTH9 = load i16, i16* %MTH, align 2
  %26 = sext i16 %load_MTH9 to i32
  %tmpVar10 = icmp sgt i32 %26, 12
  %27 = zext i1 %tmpVar10 to i32
  br label %28

28:                                               ; preds = %25, %continue
  %29 = phi i32 [ %4, %continue ], [ %27, %25 ]
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %condition_body7, label %branch
}

define i8 @OCT_TO_BYTE(%OCT_TO_BYTE_interface* %0) {
entry:
  %OCT = getelementptr inbounds %OCT_TO_BYTE_interface, %OCT_TO_BYTE_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %OCT_TO_BYTE_interface, %OCT_TO_BYTE_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %OCT_TO_BYTE_interface, %OCT_TO_BYTE_interface* %0, i32 0, i32 2
  %X = getelementptr inbounds %OCT_TO_BYTE_interface, %OCT_TO_BYTE_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %OCT_TO_BYTE_interface, %OCT_TO_BYTE_interface* %0, i32 0, i32 4
  %OCT_TO_BYTE = alloca i8, align 1
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %i, align 2
  store i8 0, i8* %X, align 1
  store i16 0, i16* %stop, align 2
  store i8 0, i8* %OCT_TO_BYTE, align 1
  store [11 x i8]* %OCT, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [11 x i8]* %OCT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 11, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_I = load i16, i16* %i, align 2
  %load_I3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_I3, %load_stop
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %12, label %13

for_body:                                         ; preds = %10
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %5 = zext i8 %load_X to i32
  %tmpVar12 = icmp sgt i32 %5, 47
  %6 = zext i1 %tmpVar12 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %19, label %22

increment:                                        ; preds = %continue11
  %tmpVar22 = add i16 %load_I, 1
  store i16 %tmpVar22, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  %OCT_TO_BYTE_ret = load i8, i8* %OCT_TO_BYTE, align 1
  ret i8 %OCT_TO_BYTE_ret

8:                                                ; preds = %13
  %load_I6 = load i16, i16* %i, align 2
  %load_stop7 = load i16, i16* %stop, align 2
  %tmpVar8 = icmp sge i16 %load_I6, %load_stop7
  %9 = icmp ne i1 %tmpVar8, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_I4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_I4, 1
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_I9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sle i16 %load_I9, 1
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar8, %8 ], [ %tmpVar10, %16 ]
  br label %10

condition_body:                                   ; preds = %22
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input14

continue11:                                       ; preds = %continue17, %22
  %load_pt = load i8*, i8** %pt, align 8
  %access___OCT_TO_BYTE_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___OCT_TO_BYTE_pt, i8** %pt, align 8
  br label %increment

19:                                               ; preds = %for_body
  %load_x = load i8, i8* %X, align 1
  %20 = zext i8 %load_x to i32
  %tmpVar13 = icmp slt i32 %20, 56
  %21 = zext i1 %tmpVar13 to i32
  br label %22

22:                                               ; preds = %19, %for_body
  %23 = phi i32 [ %6, %for_body ], [ %21, %19 ]
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %condition_body, label %continue11

input14:                                          ; preds = %condition_body
  %25 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_OCT_TO_BYTE = load i8, i8* %OCT_TO_BYTE, align 1
  %26 = zext i8 %load_OCT_TO_BYTE to i64
  store i64 %26, i64* %25, align 4
  %27 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 3, i16* %27, align 2
  br label %call15

call15:                                           ; preds = %input14
  %call18 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %load_X19 = load i8, i8* %X, align 1
  %28 = zext i8 %load_X19 to i64
  %tmpVar20 = add i64 %call18, %28
  %tmpVar21 = sub i64 %tmpVar20, 48
  %29 = trunc i64 %tmpVar21 to i8
  store i8 %29, i8* %OCT_TO_BYTE, align 1
  br label %continue11
}

define i32 @OCT_TO_DWORD(%OCT_TO_DWORD_interface* %0) {
entry:
  %OCT = getelementptr inbounds %OCT_TO_DWORD_interface, %OCT_TO_DWORD_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %OCT_TO_DWORD_interface, %OCT_TO_DWORD_interface* %0, i32 0, i32 1
  %i = getelementptr inbounds %OCT_TO_DWORD_interface, %OCT_TO_DWORD_interface* %0, i32 0, i32 2
  %X = getelementptr inbounds %OCT_TO_DWORD_interface, %OCT_TO_DWORD_interface* %0, i32 0, i32 3
  %stop = getelementptr inbounds %OCT_TO_DWORD_interface, %OCT_TO_DWORD_interface* %0, i32 0, i32 4
  %OCT_TO_DWORD = alloca i32, align 4
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %i, align 2
  store i8 0, i8* %X, align 1
  store i16 0, i16* %stop, align 2
  store i32 0, i32* %OCT_TO_DWORD, align 4
  store [21 x i8]* %OCT, i8** %pt, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %2 = bitcast [1024 x i8]* %1 to i8*
  %3 = bitcast [21 x i8]* %OCT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 21, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %stop, align 2
  store i16 1, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_I = load i16, i16* %i, align 2
  %load_I3 = load i16, i16* %i, align 2
  %load_stop = load i16, i16* %stop, align 2
  %tmpVar = icmp sle i16 %load_I3, %load_stop
  %4 = icmp ne i1 %tmpVar, false
  br i1 %4, label %12, label %13

for_body:                                         ; preds = %10
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  store i8 %load_tmpVar, i8* %X, align 1
  %load_X = load i8, i8* %X, align 1
  %5 = zext i8 %load_X to i32
  %tmpVar12 = icmp sgt i32 %5, 47
  %6 = zext i1 %tmpVar12 to i32
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %19, label %22

increment:                                        ; preds = %continue11
  %tmpVar22 = add i16 %load_I, 1
  store i16 %tmpVar22, i16* %i, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  %OCT_TO_DWORD_ret = load i32, i32* %OCT_TO_DWORD, align 4
  ret i32 %OCT_TO_DWORD_ret

8:                                                ; preds = %13
  %load_I6 = load i16, i16* %i, align 2
  %load_stop7 = load i16, i16* %stop, align 2
  %tmpVar8 = icmp sge i16 %load_I6, %load_stop7
  %9 = icmp ne i1 %tmpVar8, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_I4 = load i16, i16* %i, align 2
  %tmpVar5 = icmp sge i16 %load_I4, 1
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_I9 = load i16, i16* %i, align 2
  %tmpVar10 = icmp sle i16 %load_I9, 1
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar8, %8 ], [ %tmpVar10, %16 ]
  br label %10

condition_body:                                   ; preds = %22
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input14

continue11:                                       ; preds = %continue17, %22
  %load_pt = load i8*, i8** %pt, align 8
  %access___OCT_TO_DWORD_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___OCT_TO_DWORD_pt, i8** %pt, align 8
  br label %increment

19:                                               ; preds = %for_body
  %load_x = load i8, i8* %X, align 1
  %20 = zext i8 %load_x to i32
  %tmpVar13 = icmp slt i32 %20, 56
  %21 = zext i1 %tmpVar13 to i32
  br label %22

22:                                               ; preds = %19, %for_body
  %23 = phi i32 [ %6, %for_body ], [ %21, %19 ]
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %condition_body, label %continue11

input14:                                          ; preds = %condition_body
  %25 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_OCT_TO_DWORD = load i32, i32* %OCT_TO_DWORD, align 4
  %26 = zext i32 %load_OCT_TO_DWORD to i64
  store i64 %26, i64* %25, align 4
  %27 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 3, i16* %27, align 2
  br label %call15

call15:                                           ; preds = %input14
  %call18 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %load_X19 = load i8, i8* %X, align 1
  %28 = zext i8 %load_X19 to i64
  %tmpVar20 = add i64 %call18, %28
  %tmpVar21 = sub i64 %tmpVar20, 48
  %29 = trunc i64 %tmpVar21 to i32
  store i32 %29, i32* %OCT_TO_DWORD, align 4
  br label %continue11
}

define [21 x i8] @REAL_TO_STRF(%REAL_TO_STRF_interface* %0) {
entry:
  %IN = getelementptr inbounds %REAL_TO_STRF_interface, %REAL_TO_STRF_interface* %0, i32 0, i32 0
  %N = getelementptr inbounds %REAL_TO_STRF_interface, %REAL_TO_STRF_interface* %0, i32 0, i32 1
  %D = getelementptr inbounds %REAL_TO_STRF_interface, %REAL_TO_STRF_interface* %0, i32 0, i32 2
  %O = getelementptr inbounds %REAL_TO_STRF_interface, %REAL_TO_STRF_interface* %0, i32 0, i32 3
  %i = getelementptr inbounds %REAL_TO_STRF_interface, %REAL_TO_STRF_interface* %0, i32 0, i32 4
  %REAL_TO_STRF = alloca [21 x i8], align 1
  store float 0.000000e+00, float* %O, align 4
  store i16 0, i16* %i, align 2
  %1 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 21), i1 false)
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 0, i64* %2, align 4
  %3 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_N = load i16, i16* %N, align 2
  %4 = sext i16 %load_N to i64
  store i64 %4, i64* %3, align 4
  %5 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 7, i64* %5, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %6 = trunc i64 %call1 to i16
  store i16 %6, i16* %N, align 2
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %7 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_in = load float, float* %IN, align 4
  %8 = fptoui float %load_in to i64
  store i64 %8, i64* %7, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %9 = uitofp i64 %call6 to double
  %EXP10_instance = alloca %EXP10_interface, align 8
  br label %input7

input7:                                           ; preds = %continue5
  %10 = getelementptr inbounds %EXP10_interface, %EXP10_interface* %EXP10_instance, i32 0, i32 0
  %load_N11 = load i16, i16* %N, align 2
  %11 = sitofp i16 %load_N11 to float
  store float %11, float* %10, align 4
  br label %call8

call8:                                            ; preds = %input7
  %call12 = call float @EXP10(%EXP10_interface* %EXP10_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %12 = fpext float %call12 to double
  %tmpVar = fmul double %9, %12
  %13 = fptrunc double %tmpVar to float
  store float %13, float* %O, align 4
  %DINT_TO_STRING_instance = alloca %DINT_TO_STRING_interface, align 8
  br label %input13

input13:                                          ; preds = %continue10
  %14 = getelementptr inbounds %DINT_TO_STRING_interface, %DINT_TO_STRING_interface* %DINT_TO_STRING_instance, i32 0, i32 0
  %REAL_TO_DINT_instance = alloca %REAL_TO_DINT_interface, align 8
  br label %input17

call14:                                           ; preds = %continue20
  %call22 = call [81 x i8] @DINT_TO_STRING(%DINT_TO_STRING_interface* %DINT_TO_STRING_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %15 = alloca [81 x i8], align 1
  store [81 x i8] %call22, [81 x i8]* %15, align 1
  %16 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  %17 = bitcast [81 x i8]* %15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %16, i8* align 1 %17, i32 20, i1 false)
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input23

input17:                                          ; preds = %input13
  %18 = getelementptr inbounds %REAL_TO_DINT_interface, %REAL_TO_DINT_interface* %REAL_TO_DINT_instance, i32 0, i32 0
  %load_O = load float, float* %O, align 4
  store float %load_O, float* %18, align 4
  br label %call18

call18:                                           ; preds = %input17
  %call21 = call i32 @REAL_TO_DINT(%REAL_TO_DINT_interface* %REAL_TO_DINT_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  store i32 %call21, i32* %14, align 4
  br label %call14

input23:                                          ; preds = %continue16
  %19 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %20 = bitcast [1024 x i8]* %19 to i8*
  %21 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 21, i1 false)
  br label %call24

call24:                                           ; preds = %input23
  %call27 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  store i16 %call27, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue26
  %load_i = load i16, i16* %i, align 2
  %load_i29 = load i16, i16* %i, align 2
  %load_N30 = load i16, i16* %N, align 2
  %tmpVar31 = icmp sle i16 %load_i29, %load_N30
  %22 = icmp ne i1 %tmpVar31, false
  br i1 %22, label %28, label %29

for_body:                                         ; preds = %26
  %CONCAT_instance = alloca %CONCAT_interface, align 8
  br label %input51

increment:                                        ; preds = %continue54
  %tmpVar56 = add i16 %load_i, 1
  store i16 %tmpVar56, i16* %i, align 2
  br label %condition_check

continue28:                                       ; preds = %26
  %load_n = load i16, i16* %N, align 2
  %23 = sext i16 %load_n to i32
  %tmpVar58 = icmp sgt i32 %23, 0
  br i1 %tmpVar58, label %condition_body, label %continue57

24:                                               ; preds = %29
  %load_i40 = load i16, i16* %i, align 2
  %load_N41 = load i16, i16* %N, align 2
  %tmpVar42 = icmp sge i16 %load_i40, %load_N41
  %25 = icmp ne i1 %tmpVar42, false
  br i1 %25, label %35, label %36

26:                                               ; preds = %36, %29
  %27 = phi i1 [ %30, %29 ], [ %37, %36 ]
  br i1 %27, label %for_body, label %continue28

28:                                               ; preds = %condition_check
  %load_i32 = load i16, i16* %i, align 2
  %LEN_instance33 = alloca %LEN_interface, align 8
  br label %input34

29:                                               ; preds = %continue37, %condition_check
  %30 = phi i1 [ %tmpVar31, %condition_check ], [ %tmpVar39, %continue37 ]
  %31 = icmp ne i1 %30, false
  br i1 %31, label %26, label %24

input34:                                          ; preds = %28
  %32 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance33, i32 0, i32 0
  %33 = bitcast [1024 x i8]* %32 to i8*
  %34 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %33, i8* align 1 %34, i32 21, i1 false)
  br label %call35

call35:                                           ; preds = %input34
  %call38 = call i16 @LEN(%LEN_interface* %LEN_instance33)
  br label %output36

output36:                                         ; preds = %call35
  br label %continue37

continue37:                                       ; preds = %output36
  %tmpVar39 = icmp sge i16 %load_i32, %call38
  br label %29

35:                                               ; preds = %24
  %load_i43 = load i16, i16* %i, align 2
  %LEN_instance44 = alloca %LEN_interface, align 8
  br label %input45

36:                                               ; preds = %continue48, %24
  %37 = phi i1 [ %tmpVar42, %24 ], [ %tmpVar50, %continue48 ]
  br label %26

input45:                                          ; preds = %35
  %38 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance44, i32 0, i32 0
  %39 = bitcast [1024 x i8]* %38 to i8*
  %40 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %39, i8* align 1 %40, i32 21, i1 false)
  br label %call46

call46:                                           ; preds = %input45
  %call49 = call i16 @LEN(%LEN_interface* %LEN_instance44)
  br label %output47

output47:                                         ; preds = %call46
  br label %continue48

continue48:                                       ; preds = %output47
  %tmpVar50 = icmp sle i16 %load_i43, %call49
  br label %36

input51:                                          ; preds = %for_body
  %41 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 0
  %42 = bitcast [1024 x i8]* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %42, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_12, i32 0, i32 0), i32 2, i1 false)
  %43 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance, i32 0, i32 1
  %44 = bitcast [1024 x i8]* %43 to i8*
  %45 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %44, i8* align 1 %45, i32 21, i1 false)
  br label %call52

call52:                                           ; preds = %input51
  %call55 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance)
  br label %output53

output53:                                         ; preds = %call52
  br label %continue54

continue54:                                       ; preds = %output53
  %46 = alloca [1024 x i8], align 1
  store [1024 x i8] %call55, [1024 x i8]* %46, align 1
  %47 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  %48 = bitcast [1024 x i8]* %46 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %47, i8* align 1 %48, i32 20, i1 false)
  br label %increment

condition_body:                                   ; preds = %continue28
  %INSERT_instance = alloca %INSERT_interface, align 8
  br label %input59

continue57:                                       ; preds = %continue62, %continue28
  %load_in74 = load float, float* %IN, align 4
  %tmpVar75 = fcmp olt float %load_in74, 0.000000e+00
  br i1 %tmpVar75, label %condition_body73, label %continue72

input59:                                          ; preds = %condition_body
  %49 = getelementptr inbounds %INSERT_interface, %INSERT_interface* %INSERT_instance, i32 0, i32 0
  %50 = bitcast [1024 x i8]* %49 to i8*
  %51 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %50, i8* align 1 %51, i32 21, i1 false)
  %52 = getelementptr inbounds %INSERT_interface, %INSERT_interface* %INSERT_instance, i32 0, i32 1
  %53 = bitcast [1024 x i8]* %52 to i8*
  %54 = bitcast [2 x i8]* %D to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %53, i8* align 1 %54, i32 2, i1 false)
  %55 = getelementptr inbounds %INSERT_interface, %INSERT_interface* %INSERT_instance, i32 0, i32 2
  %LEN_instance63 = alloca %LEN_interface, align 8
  br label %input64

call60:                                           ; preds = %continue67
  %call71 = call [1024 x i8] @INSERT(%INSERT_interface* %INSERT_instance)
  br label %output61

output61:                                         ; preds = %call60
  br label %continue62

continue62:                                       ; preds = %output61
  %56 = alloca [1024 x i8], align 1
  store [1024 x i8] %call71, [1024 x i8]* %56, align 1
  %57 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  %58 = bitcast [1024 x i8]* %56 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %57, i8* align 1 %58, i32 20, i1 false)
  br label %continue57

input64:                                          ; preds = %input59
  %59 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance63, i32 0, i32 0
  %60 = bitcast [1024 x i8]* %59 to i8*
  %61 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %60, i8* align 1 %61, i32 21, i1 false)
  br label %call65

call65:                                           ; preds = %input64
  %call68 = call i16 @LEN(%LEN_interface* %LEN_instance63)
  br label %output66

output66:                                         ; preds = %call65
  br label %continue67

continue67:                                       ; preds = %output66
  %62 = sext i16 %call68 to i32
  %load_N69 = load i16, i16* %N, align 2
  %63 = sext i16 %load_N69 to i32
  %tmpVar70 = sub i32 %62, %63
  %64 = trunc i32 %tmpVar70 to i16
  store i16 %64, i16* %55, align 2
  br label %call60

condition_body73:                                 ; preds = %continue57
  %CONCAT_instance76 = alloca %CONCAT_interface, align 8
  br label %input77

continue72:                                       ; preds = %continue80, %continue57
  %REAL_TO_STRF_ret = load [21 x i8], [21 x i8]* %REAL_TO_STRF, align 1
  ret [21 x i8] %REAL_TO_STRF_ret

input77:                                          ; preds = %condition_body73
  %65 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance76, i32 0, i32 0
  %66 = bitcast [1024 x i8]* %65 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %66, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_8, i32 0, i32 0), i32 2, i1 false)
  %67 = getelementptr inbounds %CONCAT_interface, %CONCAT_interface* %CONCAT_instance76, i32 0, i32 1
  %68 = bitcast [1024 x i8]* %67 to i8*
  %69 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %68, i8* align 1 %69, i32 21, i1 false)
  br label %call78

call78:                                           ; preds = %input77
  %call81 = call [1024 x i8] @CONCAT(%CONCAT_interface* %CONCAT_instance76)
  br label %output79

output79:                                         ; preds = %call78
  br label %continue80

continue80:                                       ; preds = %output79
  %70 = alloca [1024 x i8], align 1
  store [1024 x i8] %call81, [1024 x i8]* %70, align 1
  %71 = bitcast [21 x i8]* %REAL_TO_STRF to i8*
  %72 = bitcast [1024 x i8]* %70 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %71, i8* align 1 %72, i32 20, i1 false)
  br label %continue72
}

define [251 x i8] @REPLACE_ALL(%REPLACE_ALL_interface* %0) {
entry:
  %str = getelementptr inbounds %REPLACE_ALL_interface, %REPLACE_ALL_interface* %0, i32 0, i32 0
  %src = getelementptr inbounds %REPLACE_ALL_interface, %REPLACE_ALL_interface* %0, i32 0, i32 1
  %rep = getelementptr inbounds %REPLACE_ALL_interface, %REPLACE_ALL_interface* %0, i32 0, i32 2
  %pos = getelementptr inbounds %REPLACE_ALL_interface, %REPLACE_ALL_interface* %0, i32 0, i32 3
  %lp = getelementptr inbounds %REPLACE_ALL_interface, %REPLACE_ALL_interface* %0, i32 0, i32 4
  %lx = getelementptr inbounds %REPLACE_ALL_interface, %REPLACE_ALL_interface* %0, i32 0, i32 5
  %REPLACE_ALL = alloca [251 x i8], align 1
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %lp, align 2
  store i16 0, i16* %lx, align 2
  %1 = bitcast [251 x i8]* %REPLACE_ALL to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %2 = bitcast [251 x i8]* %REPLACE_ALL to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 250, i1 false)
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %5 = bitcast [1024 x i8]* %4 to i8*
  %6 = bitcast [251 x i8]* %src to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %lx, align 2
  %LEN_instance2 = alloca %LEN_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %7 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance2, i32 0, i32 0
  %8 = bitcast [1024 x i8]* %7 to i8*
  %9 = bitcast [251 x i8]* %rep to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %8, i8* align 1 %9, i32 251, i1 false)
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i16 @LEN(%LEN_interface* %LEN_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  store i16 %call7, i16* %lp, align 2
  %FINDP_instance = alloca %FINDP_interface, align 8
  br label %input8

input8:                                           ; preds = %continue6
  %10 = getelementptr inbounds %FINDP_interface, %FINDP_interface* %FINDP_instance, i32 0, i32 0
  %11 = bitcast [251 x i8]* %10 to i8*
  %12 = bitcast [251 x i8]* %REPLACE_ALL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %11, i8* align 1 %12, i32 250, i1 false)
  %13 = getelementptr inbounds %FINDP_interface, %FINDP_interface* %FINDP_instance, i32 0, i32 1
  %14 = bitcast [251 x i8]* %13 to i8*
  %15 = bitcast [251 x i8]* %src to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %14, i8* align 1 %15, i32 250, i1 false)
  %16 = getelementptr inbounds %FINDP_interface, %FINDP_interface* %FINDP_instance, i32 0, i32 2
  store i16 1, i16* %16, align 2
  br label %call9

call9:                                            ; preds = %input8
  %call12 = call i16 @FINDP(%FINDP_interface* %FINDP_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  store i16 %call12, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %continue11, %continue24
  %load_pos = load i16, i16* %pos, align 2
  %17 = sext i16 %load_pos to i32
  %tmpVar = icmp sgt i32 %17, 0
  br i1 %tmpVar, label %while_body, label %continue13

while_body:                                       ; preds = %condition_check
  %REPLACE_instance = alloca %REPLACE_interface, align 8
  br label %input14

continue13:                                       ; preds = %condition_check
  %REPLACE_ALL_ret = load [251 x i8], [251 x i8]* %REPLACE_ALL, align 1
  ret [251 x i8] %REPLACE_ALL_ret

input14:                                          ; preds = %while_body
  %18 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 0
  %19 = bitcast [1024 x i8]* %18 to i8*
  %20 = bitcast [251 x i8]* %REPLACE_ALL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %19, i8* align 1 %20, i32 251, i1 false)
  %21 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 1
  %22 = bitcast [1024 x i8]* %21 to i8*
  %23 = bitcast [251 x i8]* %rep to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %22, i8* align 1 %23, i32 251, i1 false)
  %24 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 2
  %load_lx = load i16, i16* %lx, align 2
  store i16 %load_lx, i16* %24, align 2
  %25 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 3
  %load_pos18 = load i16, i16* %pos, align 2
  store i16 %load_pos18, i16* %25, align 2
  br label %call15

call15:                                           ; preds = %input14
  %call19 = call [1024 x i8] @REPLACE(%REPLACE_interface* %REPLACE_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %26 = alloca [1024 x i8], align 1
  store [1024 x i8] %call19, [1024 x i8]* %26, align 1
  %27 = bitcast [251 x i8]* %REPLACE_ALL to i8*
  %28 = bitcast [1024 x i8]* %26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %27, i8* align 1 %28, i32 250, i1 false)
  %FINDP_instance20 = alloca %FINDP_interface, align 8
  br label %input21

input21:                                          ; preds = %continue17
  %29 = getelementptr inbounds %FINDP_interface, %FINDP_interface* %FINDP_instance20, i32 0, i32 0
  %30 = bitcast [251 x i8]* %29 to i8*
  %31 = bitcast [251 x i8]* %REPLACE_ALL to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %30, i8* align 1 %31, i32 250, i1 false)
  %32 = getelementptr inbounds %FINDP_interface, %FINDP_interface* %FINDP_instance20, i32 0, i32 1
  %33 = bitcast [251 x i8]* %32 to i8*
  %34 = bitcast [251 x i8]* %src to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %33, i8* align 1 %34, i32 250, i1 false)
  %35 = getelementptr inbounds %FINDP_interface, %FINDP_interface* %FINDP_instance20, i32 0, i32 2
  %load_pos25 = load i16, i16* %pos, align 2
  %36 = sext i16 %load_pos25 to i32
  %load_lp = load i16, i16* %lp, align 2
  %37 = sext i16 %load_lp to i32
  %tmpVar26 = add i32 %36, %37
  %38 = trunc i32 %tmpVar26 to i16
  store i16 %38, i16* %35, align 2
  br label %call22

call22:                                           ; preds = %input21
  %call27 = call i16 @FINDP(%FINDP_interface* %FINDP_instance20)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  store i16 %call27, i16* %pos, align 2
  br label %condition_check
}

define [251 x i8] @REPLACE_CHARS(%REPLACE_CHARS_interface* %0) {
entry:
  %STR = getelementptr inbounds %REPLACE_CHARS_interface, %REPLACE_CHARS_interface* %0, i32 0, i32 0
  %SRC = getelementptr inbounds %REPLACE_CHARS_interface, %REPLACE_CHARS_interface* %0, i32 0, i32 1
  %REP = getelementptr inbounds %REPLACE_CHARS_interface, %REPLACE_CHARS_interface* %0, i32 0, i32 2
  %a = getelementptr inbounds %REPLACE_CHARS_interface, %REPLACE_CHARS_interface* %0, i32 0, i32 3
  %b = getelementptr inbounds %REPLACE_CHARS_interface, %REPLACE_CHARS_interface* %0, i32 0, i32 4
  %c = getelementptr inbounds %REPLACE_CHARS_interface, %REPLACE_CHARS_interface* %0, i32 0, i32 5
  %stp = getelementptr inbounds %REPLACE_CHARS_interface, %REPLACE_CHARS_interface* %0, i32 0, i32 6
  %REPLACE_CHARS = alloca [251 x i8], align 1
  store i16 0, i16* %a, align 2
  store i16 0, i16* %b, align 2
  %1 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 2), i1 false)
  store i16 0, i16* %stp, align 2
  %2 = bitcast [251 x i8]* %REPLACE_CHARS to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %2, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %3 = bitcast [251 x i8]* %REPLACE_CHARS to i8*
  %4 = bitcast [251 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %3, i8* align 1 %4, i32 250, i1 false)
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %5 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %6 = bitcast [1024 x i8]* %5 to i8*
  %7 = bitcast [81 x i8]* %SRC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %6, i8* align 1 %7, i32 81, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %a, align 2
  %LEN_instance2 = alloca %LEN_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %8 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance2, i32 0, i32 0
  %9 = bitcast [1024 x i8]* %8 to i8*
  %10 = bitcast [81 x i8]* %REP to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %9, i8* align 1 %10, i32 81, i1 false)
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i16 @LEN(%LEN_interface* %LEN_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  store i16 %call7, i16* %b, align 2
  %load_a = load i16, i16* %a, align 2
  %11 = sext i16 %load_a to i32
  %load_b = load i16, i16* %b, align 2
  %12 = sext i16 %load_b to i32
  %tmpVar = icmp slt i32 %11, %12
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %continue6
  %LEFT_instance = alloca %LEFT_interface, align 8
  br label %input9

branch:                                           ; preds = %continue6
  %load_b16 = load i16, i16* %b, align 2
  %13 = sext i16 %load_b16 to i32
  %load_a17 = load i16, i16* %a, align 2
  %14 = sext i16 %load_a17 to i32
  %tmpVar18 = icmp slt i32 %13, %14
  br i1 %tmpVar18, label %condition_body15, label %continue8

condition_body15:                                 ; preds = %branch
  %LEFT_instance19 = alloca %LEFT_interface, align 8
  br label %input20

continue8:                                        ; preds = %continue23, %branch, %continue12
  %LEN_instance26 = alloca %LEN_interface, align 8
  br label %input27

input9:                                           ; preds = %condition_body
  %15 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 0
  %16 = bitcast [1024 x i8]* %15 to i8*
  %17 = bitcast [81 x i8]* %REP to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %16, i8* align 1 %17, i32 81, i1 false)
  %18 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 1
  %load_a13 = load i16, i16* %a, align 2
  store i16 %load_a13, i16* %18, align 2
  br label %call10

call10:                                           ; preds = %input9
  %call14 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  %19 = alloca [1024 x i8], align 1
  store [1024 x i8] %call14, [1024 x i8]* %19, align 1
  %20 = bitcast [81 x i8]* %REP to i8*
  %21 = bitcast [1024 x i8]* %19 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 80, i1 false)
  br label %continue8

input20:                                          ; preds = %condition_body15
  %22 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance19, i32 0, i32 0
  %23 = bitcast [1024 x i8]* %22 to i8*
  %24 = bitcast [81 x i8]* %SRC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %23, i8* align 1 %24, i32 81, i1 false)
  %25 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance19, i32 0, i32 1
  %load_b24 = load i16, i16* %b, align 2
  store i16 %load_b24, i16* %25, align 2
  br label %call21

call21:                                           ; preds = %input20
  %call25 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance19)
  br label %output22

output22:                                         ; preds = %call21
  br label %continue23

continue23:                                       ; preds = %output22
  %26 = alloca [1024 x i8], align 1
  store [1024 x i8] %call25, [1024 x i8]* %26, align 1
  %27 = bitcast [81 x i8]* %SRC to i8*
  %28 = bitcast [1024 x i8]* %26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %27, i8* align 1 %28, i32 80, i1 false)
  br label %continue8

input27:                                          ; preds = %continue8
  %29 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance26, i32 0, i32 0
  %30 = bitcast [1024 x i8]* %29 to i8*
  %31 = bitcast [251 x i8]* %STR to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %30, i8* align 1 %31, i32 251, i1 false)
  br label %call28

call28:                                           ; preds = %input27
  %call31 = call i16 @LEN(%LEN_interface* %LEN_instance26)
  br label %output29

output29:                                         ; preds = %call28
  br label %continue30

continue30:                                       ; preds = %output29
  store i16 %call31, i16* %stp, align 2
  store i16 1, i16* %a, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue30
  %load_a33 = load i16, i16* %a, align 2
  %load_a34 = load i16, i16* %a, align 2
  %load_stp = load i16, i16* %stp, align 2
  %tmpVar35 = icmp sle i16 %load_a34, %load_stp
  %32 = icmp ne i1 %tmpVar35, false
  br i1 %32, label %37, label %38

for_body:                                         ; preds = %35
  %MID_instance = alloca %MID_interface, align 8
  br label %input43

increment:                                        ; preds = %continue54
  %tmpVar71 = add i16 %load_a33, 1
  store i16 %tmpVar71, i16* %a, align 2
  br label %condition_check

continue32:                                       ; preds = %35
  %REPLACE_CHARS_ret = load [251 x i8], [251 x i8]* %REPLACE_CHARS, align 1
  ret [251 x i8] %REPLACE_CHARS_ret

33:                                               ; preds = %38
  %load_a38 = load i16, i16* %a, align 2
  %load_stp39 = load i16, i16* %stp, align 2
  %tmpVar40 = icmp sge i16 %load_a38, %load_stp39
  %34 = icmp ne i1 %tmpVar40, false
  br i1 %34, label %41, label %42

35:                                               ; preds = %42, %38
  %36 = phi i1 [ %39, %38 ], [ %43, %42 ]
  br i1 %36, label %for_body, label %continue32

37:                                               ; preds = %condition_check
  %load_a36 = load i16, i16* %a, align 2
  %tmpVar37 = icmp sge i16 %load_a36, 1
  br label %38

38:                                               ; preds = %37, %condition_check
  %39 = phi i1 [ %tmpVar35, %condition_check ], [ %tmpVar37, %37 ]
  %40 = icmp ne i1 %39, false
  br i1 %40, label %35, label %33

41:                                               ; preds = %33
  %load_a41 = load i16, i16* %a, align 2
  %tmpVar42 = icmp sle i16 %load_a41, 1
  br label %42

42:                                               ; preds = %41, %33
  %43 = phi i1 [ %tmpVar40, %33 ], [ %tmpVar42, %41 ]
  br label %35

input43:                                          ; preds = %for_body
  %44 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %45 = bitcast [1024 x i8]* %44 to i8*
  %46 = bitcast [251 x i8]* %REPLACE_CHARS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %45, i8* align 1 %46, i32 251, i1 false)
  %47 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  store i16 1, i16* %47, align 2
  %48 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  %load_a47 = load i16, i16* %a, align 2
  store i16 %load_a47, i16* %48, align 2
  br label %call44

call44:                                           ; preds = %input43
  %call48 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output45

output45:                                         ; preds = %call44
  br label %continue46

continue46:                                       ; preds = %output45
  %49 = alloca [1024 x i8], align 1
  store [1024 x i8] %call48, [1024 x i8]* %49, align 1
  %50 = bitcast [2 x i8]* %c to i8*
  %51 = bitcast [1024 x i8]* %49 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %50, i8* align 1 %51, i32 1, i1 false)
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input49

input49:                                          ; preds = %continue46
  %52 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %53 = bitcast [1024 x i8]* %52 to i8*
  %54 = bitcast [81 x i8]* %SRC to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %53, i8* align 1 %54, i32 81, i1 false)
  %55 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %56 = bitcast [1024 x i8]* %55 to i8*
  %57 = bitcast [2 x i8]* %c to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %56, i8* align 1 %57, i32 2, i1 false)
  br label %call50

call50:                                           ; preds = %input49
  %call53 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output51

output51:                                         ; preds = %call50
  br label %continue52

continue52:                                       ; preds = %output51
  store i16 %call53, i16* %b, align 2
  %load_b56 = load i16, i16* %b, align 2
  %58 = sext i16 %load_b56 to i32
  %tmpVar57 = icmp sgt i32 %58, 0
  br i1 %tmpVar57, label %condition_body55, label %continue54

condition_body55:                                 ; preds = %continue52
  %REPLACE_instance = alloca %REPLACE_interface, align 8
  br label %input58

continue54:                                       ; preds = %continue61, %continue52
  br label %increment

input58:                                          ; preds = %condition_body55
  %59 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 0
  %60 = bitcast [1024 x i8]* %59 to i8*
  %61 = bitcast [251 x i8]* %REPLACE_CHARS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %60, i8* align 1 %61, i32 251, i1 false)
  %62 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 1
  %MID_instance62 = alloca %MID_interface, align 8
  br label %input63

call59:                                           ; preds = %continue66
  %call70 = call [1024 x i8] @REPLACE(%REPLACE_interface* %REPLACE_instance)
  br label %output60

output60:                                         ; preds = %call59
  br label %continue61

continue61:                                       ; preds = %output60
  %63 = alloca [1024 x i8], align 1
  store [1024 x i8] %call70, [1024 x i8]* %63, align 1
  %64 = bitcast [251 x i8]* %REPLACE_CHARS to i8*
  %65 = bitcast [1024 x i8]* %63 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %64, i8* align 1 %65, i32 250, i1 false)
  br label %continue54

input63:                                          ; preds = %input58
  %66 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance62, i32 0, i32 0
  %67 = bitcast [1024 x i8]* %66 to i8*
  %68 = bitcast [81 x i8]* %REP to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %67, i8* align 1 %68, i32 81, i1 false)
  %69 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance62, i32 0, i32 1
  store i16 1, i16* %69, align 2
  %70 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance62, i32 0, i32 2
  %load_b67 = load i16, i16* %b, align 2
  store i16 %load_b67, i16* %70, align 2
  br label %call64

call64:                                           ; preds = %input63
  %call68 = call [1024 x i8] @MID(%MID_interface* %MID_instance62)
  br label %output65

output65:                                         ; preds = %call64
  br label %continue66

continue66:                                       ; preds = %output65
  %71 = alloca [1024 x i8], align 1
  store [1024 x i8] %call68, [1024 x i8]* %71, align 1
  %72 = bitcast [1024 x i8]* %62 to i8*
  %73 = bitcast [1024 x i8]* %71 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %72, i8* align 1 %73, i32 1023, i1 false)
  %74 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 2
  store i16 1, i16* %74, align 2
  %75 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 3
  %load_a69 = load i16, i16* %a, align 2
  store i16 %load_a69, i16* %75, align 2
  br label %call59
}

define [251 x i8] @REPLACE_UML(%REPLACE_UML_interface* %0) {
entry:
  %str = getelementptr inbounds %REPLACE_UML_interface, %REPLACE_UML_interface* %0, i32 0, i32 0
  %L = getelementptr inbounds %REPLACE_UML_interface, %REPLACE_UML_interface* %0, i32 0, i32 1
  %pt = getelementptr inbounds %REPLACE_UML_interface, %REPLACE_UML_interface* %0, i32 0, i32 2
  %pto = getelementptr inbounds %REPLACE_UML_interface, %REPLACE_UML_interface* %0, i32 0, i32 3
  %ptm = getelementptr inbounds %REPLACE_UML_interface, %REPLACE_UML_interface* %0, i32 0, i32 4
  %pt1 = getelementptr inbounds %REPLACE_UML_interface, %REPLACE_UML_interface* %0, i32 0, i32 5
  %pt2 = getelementptr inbounds %REPLACE_UML_interface, %REPLACE_UML_interface* %0, i32 0, i32 6
  %su = getelementptr inbounds %REPLACE_UML_interface, %REPLACE_UML_interface* %0, i32 0, i32 7
  %pos = getelementptr inbounds %REPLACE_UML_interface, %REPLACE_UML_interface* %0, i32 0, i32 8
  %REPLACE_UML = alloca [251 x i8], align 1
  store i16 0, i16* %L, align 2
  store i8* null, i8** %pt, align 8
  store i8* null, i8** %pto, align 8
  store i8* null, i8** %ptm, align 8
  store i8* null, i8** %pt1, align 8
  store i8* null, i8** %pt2, align 8
  %1 = bitcast [3 x i8]* %su to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 3), i1 false)
  store i16 0, i16* %pos, align 2
  %2 = bitcast [251 x i8]* %REPLACE_UML to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %2, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  store [251 x i8]* %str, i8** %pt, align 8
  store [251 x i8]* %REPLACE_UML, i8** %pto, align 8
  %load_pto = load i8*, i8** %pto, align 8
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %3 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_string_length = load i16, i16* @STRING_LENGTH, align 2
  store i16 %load_string_length, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %access___REPLACE_UML_pto = getelementptr inbounds i8, i8* %load_pto, i32 %call1
  store i8* %access___REPLACE_UML_pto, i8** %ptm, align 8
  store [3 x i8]* %su, i8** %pt1, align 8
  %load_pt1 = load i8*, i8** %pt1, align 8
  %access___REPLACE_UML_pt1 = getelementptr inbounds i8, i8* %load_pt1, i32 1
  store i8* %access___REPLACE_UML_pt1, i8** %pt2, align 8
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %4 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %5 = bitcast [1024 x i8]* %4 to i8*
  %6 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 251, i1 false)
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i16 %call6, i16* %L, align 2
  br label %condition_check

condition_check:                                  ; preds = %continue5, %continue11
  %load_pos = load i16, i16* %pos, align 2
  %7 = sext i16 %load_pos to i32
  %load_L = load i16, i16* %L, align 2
  %8 = sext i16 %load_L to i32
  %tmpVar = icmp slt i32 %7, %8
  %9 = zext i1 %tmpVar to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %12, label %16

while_body:                                       ; preds = %16
  %deref = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref, align 1
  %11 = zext i8 %load_tmpVar to i32
  %tmpVar12 = icmp slt i32 %11, 127
  br i1 %tmpVar12, label %condition_body, label %else

continue7:                                        ; preds = %16
  %deref41 = load i8*, i8** %pto, align 8
  store i8 0, i8* %deref41, align 1
  %REPLACE_UML_ret = load [251 x i8], [251 x i8]* %REPLACE_UML, align 1
  ret [251 x i8] %REPLACE_UML_ret

12:                                               ; preds = %condition_check
  %load_pos8 = load i16, i16* %pos, align 2
  %13 = sext i16 %load_pos8 to i32
  %load_string_length9 = load i16, i16* @STRING_LENGTH, align 2
  %14 = sext i16 %load_string_length9 to i32
  %tmpVar10 = icmp slt i32 %13, %14
  %15 = zext i1 %tmpVar10 to i32
  br label %16

16:                                               ; preds = %12, %condition_check
  %17 = phi i32 [ %9, %condition_check ], [ %15, %12 ]
  br i32 %17, label %while_body, label %continue7

condition_body:                                   ; preds = %while_body
  %deref13 = load i8*, i8** %pto, align 8
  %deref14 = load i8*, i8** %pt, align 8
  %load_tmpVar15 = load i8, i8* %deref14, align 1
  store i8 %load_tmpVar15, i8* %deref13, align 1
  br label %continue11

else:                                             ; preds = %while_body
  %TO_UML_instance = alloca %TO_UML_interface, align 8
  br label %input16

continue11:                                       ; preds = %continue26, %condition_body
  %load_pt = load i8*, i8** %pt, align 8
  %access___REPLACE_UML_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___REPLACE_UML_pt, i8** %pt, align 8
  %load_pto37 = load i8*, i8** %pto, align 8
  %access___REPLACE_UML_pto38 = getelementptr inbounds i8, i8* %load_pto37, i32 1
  store i8* %access___REPLACE_UML_pto38, i8** %pto, align 8
  %load_pos39 = load i16, i16* %pos, align 2
  %18 = sext i16 %load_pos39 to i32
  %tmpVar40 = add i32 %18, 1
  %19 = trunc i32 %tmpVar40 to i16
  store i16 %19, i16* %pos, align 2
  br label %condition_check

input16:                                          ; preds = %else
  %20 = getelementptr inbounds %TO_UML_interface, %TO_UML_interface* %TO_UML_instance, i32 0, i32 0
  %deref20 = load i8*, i8** %pt, align 8
  %load_tmpVar21 = load i8, i8* %deref20, align 1
  store i8 %load_tmpVar21, i8* %20, align 1
  br label %call17

call17:                                           ; preds = %input16
  %call22 = call [3 x i8] @TO_UML(%TO_UML_interface* %TO_UML_instance)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %21 = alloca [3 x i8], align 1
  store [3 x i8] %call22, [3 x i8]* %21, align 1
  %22 = bitcast [3 x i8]* %su to i8*
  %23 = bitcast [3 x i8]* %21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %22, i8* align 1 %23, i32 2, i1 false)
  %deref23 = load i8*, i8** %pto, align 8
  %deref24 = load i8*, i8** %pt1, align 8
  %load_tmpVar25 = load i8, i8* %deref24, align 1
  store i8 %load_tmpVar25, i8* %deref23, align 1
  %load_pto28 = load i8*, i8** %pto, align 8
  %load_ptm = load i8*, i8** %ptm, align 8
  br i1 icmp slt (i64 ptrtoint (i8* %load_pto28 to i64), i64 ptrtoint (i8* %load_ptm to i64)), label %24, label %27

condition_body27:                                 ; preds = %27
  %load_pto32 = load i8*, i8** %pto, align 8
  %access___REPLACE_UML_pto33 = getelementptr inbounds i8, i8* %load_pto32, i32 1
  store i8* %access___REPLACE_UML_pto33, i8** %pto, align 8
  %deref34 = load i8*, i8** %pto, align 8
  %deref35 = load i8*, i8** %pt2, align 8
  %load_tmpVar36 = load i8, i8* %deref35, align 1
  store i8 %load_tmpVar36, i8* %deref34, align 1
  br label %continue26

continue26:                                       ; preds = %condition_body27, %27
  br label %continue11

24:                                               ; preds = %continue19
  %deref29 = load i8*, i8** %pt2, align 8
  %load_tmpVar30 = load i8, i8* %deref29, align 1
  %25 = zext i8 %load_tmpVar30 to i32
  %tmpVar31 = icmp sgt i32 %25, 0
  %26 = zext i1 %tmpVar31 to i32
  br label %27

27:                                               ; preds = %24, %continue19
  %28 = phi i32 [ zext (i1 icmp slt (i64 ptrtoint (i8* %load_pto28 to i64), i64 ptrtoint (i8* %load_ptm to i64)) to i32), %continue19 ], [ %26, %24 ]
  %29 = icmp ne i32 %28, 0
  br i1 %29, label %condition_body27, label %continue26
}

define void @TICKER(%TICKER_interface* %0) {
entry:
  %N = getelementptr inbounds %TICKER_interface, %TICKER_interface* %0, i32 0, i32 0
  %PT = getelementptr inbounds %TICKER_interface, %TICKER_interface* %0, i32 0, i32 1
  %Text = getelementptr inbounds %TICKER_interface, %TICKER_interface* %0, i32 0, i32 2
  %Display = getelementptr inbounds %TICKER_interface, %TICKER_interface* %0, i32 0, i32 3
  %delay = getelementptr inbounds %TICKER_interface, %TICKER_interface* %0, i32 0, i32 4
  %step = getelementptr inbounds %TICKER_interface, %TICKER_interface* %0, i32 0, i32 5
  %load_N = load i16, i16* %N, align 2
  %1 = sext i16 %load_N to i32
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

condition_body:                                   ; preds = %continue1
  %Q = getelementptr inbounds %TP_interface, %TP_interface* %delay, i32 0, i32 2
  %load_ = load i8, i8* %Q, align 1
  %tmpVar6 = xor i8 %load_, -1
  %2 = icmp ne i8 %tmpVar6, 0
  br i1 %2, label %condition_body5, label %else3

else:                                             ; preds = %continue1
  %deref35 = load [251 x i8]*, [251 x i8]** %Text, align 8
  %3 = bitcast [251 x i8]* %Display to i8*
  %4 = bitcast [251 x i8]* %deref35 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %3, i8* align 1 %4, i32 250, i1 false)
  br label %continue

continue:                                         ; preds = %else, %continue4
  ret void

input:                                            ; preds = %entry
  %5 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %deref = load [251 x i8]*, [251 x i8]** %Text, align 8
  %6 = bitcast [1024 x i8]* %5 to i8*
  %7 = bitcast [251 x i8]* %deref to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %6, i8* align 1 %7, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call2 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %8 = sext i16 %call2 to i32
  %tmpVar = icmp slt i32 %1, %8
  br i1 %tmpVar, label %condition_body, label %else

condition_body5:                                  ; preds = %condition_body
  %load_step = load i16, i16* %step, align 2
  %9 = sext i16 %load_step to i32
  %tmpVar7 = add i32 %9, 1
  %10 = trunc i32 %tmpVar7 to i16
  store i16 %10, i16* %step, align 2
  %load_step10 = load i16, i16* %step, align 2
  %11 = sext i16 %load_step10 to i32
  %LEN_instance11 = alloca %LEN_interface, align 8
  br label %input12

else3:                                            ; preds = %condition_body
  br label %input31

continue4:                                        ; preds = %continue34, %continue30
  br label %continue

condition_body9:                                  ; preds = %continue15
  store i16 1, i16* %step, align 2
  br label %continue8

continue8:                                        ; preds = %condition_body9, %continue15
  %MID_instance = alloca %MID_interface, align 8
  br label %input19

input12:                                          ; preds = %condition_body5
  %12 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance11, i32 0, i32 0
  %deref16 = load [251 x i8]*, [251 x i8]** %Text, align 8
  %13 = bitcast [1024 x i8]* %12 to i8*
  %14 = bitcast [251 x i8]* %deref16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %13, i8* align 1 %14, i32 251, i1 false)
  br label %call13

call13:                                           ; preds = %input12
  %call17 = call i16 @LEN(%LEN_interface* %LEN_instance11)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %15 = sext i16 %call17 to i32
  %tmpVar18 = icmp sgt i32 %11, %15
  br i1 %tmpVar18, label %condition_body9, label %continue8

input19:                                          ; preds = %continue8
  %16 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 0
  %deref23 = load [251 x i8]*, [251 x i8]** %Text, align 8
  %17 = bitcast [1024 x i8]* %16 to i8*
  %18 = bitcast [251 x i8]* %deref23 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %17, i8* align 1 %18, i32 251, i1 false)
  %19 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 1
  %load_N24 = load i16, i16* %N, align 2
  store i16 %load_N24, i16* %19, align 2
  %20 = getelementptr inbounds %MID_interface, %MID_interface* %MID_instance, i32 0, i32 2
  %load_step25 = load i16, i16* %step, align 2
  store i16 %load_step25, i16* %20, align 2
  br label %call20

call20:                                           ; preds = %input19
  %call26 = call [1024 x i8] @MID(%MID_interface* %MID_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  %21 = alloca [1024 x i8], align 1
  store [1024 x i8] %call26, [1024 x i8]* %21, align 1
  %22 = bitcast [251 x i8]* %Display to i8*
  %23 = bitcast [1024 x i8]* %21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %22, i8* align 1 %23, i32 250, i1 false)
  br label %input27

input27:                                          ; preds = %continue22
  %24 = getelementptr inbounds %TP_interface, %TP_interface* %delay, i32 0, i32 0
  store i8 1, i8* %24, align 1
  %25 = getelementptr inbounds %TP_interface, %TP_interface* %delay, i32 0, i32 1
  %load_PT = load i64, i64* %PT, align 4
  store i64 %load_PT, i64* %25, align 4
  br label %call28

call28:                                           ; preds = %input27
  call void @TP(%TP_interface* %delay)
  br label %output29

output29:                                         ; preds = %call28
  br label %continue30

continue30:                                       ; preds = %output29
  br label %continue4

input31:                                          ; preds = %else3
  %26 = getelementptr inbounds %TP_interface, %TP_interface* %delay, i32 0, i32 0
  store i8 0, i8* %26, align 1
  br label %call32

call32:                                           ; preds = %input31
  call void @TP(%TP_interface* %delay)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  br label %continue4
}

define i8 @TO_LOWER(%TO_LOWER_interface* %0) {
entry:
  %IN = getelementptr inbounds %TO_LOWER_interface, %TO_LOWER_interface* %0, i32 0, i32 0
  %TO_LOWER = alloca i8, align 1
  store i8 0, i8* %TO_LOWER, align 1
  %load_in = load i8, i8* %IN, align 1
  %1 = zext i8 %load_in to i32
  %tmpVar = icmp sgt i32 %1, 64
  %2 = zext i1 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %11, label %14

condition_body:                                   ; preds = %14
  %load_in3 = load i8, i8* %IN, align 1
  %4 = zext i8 %load_in3 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %18, label %17

branch:                                           ; preds = %14
  %load_in5 = load i8, i8* %IN, align 1
  %6 = zext i8 %load_in5 to i32
  %tmpVar6 = icmp sgt i32 %6, 191
  %7 = zext i1 %tmpVar6 to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %31, label %34

condition_body4:                                  ; preds = %22
  %load_in11 = load i8, i8* %IN, align 1
  %9 = zext i8 %load_in11 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %38, label %37

else:                                             ; preds = %22
  %load_in12 = load i8, i8* %IN, align 1
  store i8 %load_in12, i8* %TO_LOWER, align 1
  br label %continue

continue:                                         ; preds = %else, %38, %18
  %TO_LOWER_ret = load i8, i8* %TO_LOWER, align 1
  ret i8 %TO_LOWER_ret

11:                                               ; preds = %entry
  %load_in1 = load i8, i8* %IN, align 1
  %12 = zext i8 %load_in1 to i32
  %tmpVar2 = icmp slt i32 %12, 91
  %13 = zext i1 %tmpVar2 to i32
  br label %14

14:                                               ; preds = %11, %entry
  %15 = phi i32 [ %2, %entry ], [ %13, %11 ]
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %condition_body, label %branch

17:                                               ; preds = %condition_body
  br label %18

18:                                               ; preds = %17, %condition_body
  %19 = phi i32 [ %4, %condition_body ], [ 32, %17 ]
  store i32 %19, i8* %TO_LOWER, align 4
  br label %continue

20:                                               ; preds = %28
  %load_ = load i8, i8* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 0), align 1
  %21 = zext i8 %load_ to i32
  br label %22

22:                                               ; preds = %20, %28
  %23 = phi i32 [ %29, %28 ], [ %21, %20 ]
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %condition_body4, label %else

25:                                               ; preds = %34
  %load_in9 = load i8, i8* %IN, align 1
  %26 = zext i8 %load_in9 to i32
  %tmpVar10 = icmp ne i32 %26, 215
  %27 = zext i1 %tmpVar10 to i32
  br label %28

28:                                               ; preds = %25, %34
  %29 = phi i32 [ %35, %34 ], [ %27, %25 ]
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %20, label %22

31:                                               ; preds = %branch
  %load_in7 = load i8, i8* %IN, align 1
  %32 = zext i8 %load_in7 to i32
  %tmpVar8 = icmp slt i32 %32, 223
  %33 = zext i1 %tmpVar8 to i32
  br label %34

34:                                               ; preds = %31, %branch
  %35 = phi i32 [ %7, %branch ], [ %33, %31 ]
  %36 = icmp ne i32 %35, 0
  br i1 %36, label %25, label %28

37:                                               ; preds = %condition_body4
  br label %38

38:                                               ; preds = %37, %condition_body4
  %39 = phi i32 [ %9, %condition_body4 ], [ 32, %37 ]
  store i32 %39, i8* %TO_LOWER, align 4
  br label %continue
}

define [3 x i8] @TO_UML(%TO_UML_interface* %0) {
entry:
  %IN = getelementptr inbounds %TO_UML_interface, %TO_UML_interface* %0, i32 0, i32 0
  %TO_UML = alloca [3 x i8], align 1
  %1 = bitcast [3 x i8]* %TO_UML to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 3), i1 false)
  %load_in = load i8, i8* %IN, align 1
  switch i8 %load_in, label %else [
    i8 -60, label %case
    i8 -42, label %case1
    i8 -36, label %case2
    i8 -33, label %case3
    i8 -28, label %case4
    i8 -10, label %case5
    i8 -4, label %case6
  ]

case:                                             ; preds = %entry
  %2 = bitcast [3 x i8]* %TO_UML to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_20, i32 0, i32 0), i32 2, i1 false)
  br label %continue

case1:                                            ; preds = %entry
  %3 = bitcast [3 x i8]* %TO_UML to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %3, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_26, i32 0, i32 0), i32 2, i1 false)
  br label %continue

case2:                                            ; preds = %entry
  %4 = bitcast [3 x i8]* %TO_UML to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %4, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_31, i32 0, i32 0), i32 2, i1 false)
  br label %continue

case3:                                            ; preds = %entry
  %5 = bitcast [3 x i8]* %TO_UML to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_39, i32 0, i32 0), i32 2, i1 false)
  br label %continue

case4:                                            ; preds = %entry
  %6 = bitcast [3 x i8]* %TO_UML to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %6, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_34, i32 0, i32 0), i32 2, i1 false)
  br label %continue

case5:                                            ; preds = %entry
  %7 = bitcast [3 x i8]* %TO_UML to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %7, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_37, i32 0, i32 0), i32 2, i1 false)
  br label %continue

case6:                                            ; preds = %entry
  %8 = bitcast [3 x i8]* %TO_UML to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %8, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_40, i32 0, i32 0), i32 2, i1 false)
  br label %continue

else:                                             ; preds = %entry
  %CHR_TO_STRING_instance = alloca %CHR_TO_STRING_interface, align 8
  br label %input

continue:                                         ; preds = %continue7, %case6, %case5, %case4, %case3, %case2, %case1, %case
  %TO_UML_ret = load [3 x i8], [3 x i8]* %TO_UML, align 1
  ret [3 x i8] %TO_UML_ret

input:                                            ; preds = %else
  %9 = getelementptr inbounds %CHR_TO_STRING_interface, %CHR_TO_STRING_interface* %CHR_TO_STRING_instance, i32 0, i32 0
  %load_IN = load i8, i8* %IN, align 1
  store i8 %load_IN, i8* %9, align 1
  br label %call

call:                                             ; preds = %input
  %call8 = call [2 x i8] @CHR_TO_STRING(%CHR_TO_STRING_interface* %CHR_TO_STRING_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue7

continue7:                                        ; preds = %output
  %10 = alloca [2 x i8], align 1
  store [2 x i8] %call8, [2 x i8]* %10, align 1
  %11 = bitcast [3 x i8]* %TO_UML to i8*
  %12 = bitcast [2 x i8]* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %11, i8* align 1 %12, i32 2, i1 false)
  br label %continue
}

define i8 @TO_UPPER(%TO_UPPER_interface* %0) {
entry:
  %IN = getelementptr inbounds %TO_UPPER_interface, %TO_UPPER_interface* %0, i32 0, i32 0
  %TO_UPPER = alloca i8, align 1
  store i8 0, i8* %TO_UPPER, align 1
  %load_in = load i8, i8* %IN, align 1
  %1 = zext i8 %load_in to i32
  %tmpVar = icmp sgt i32 %1, 96
  %2 = zext i1 %tmpVar to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %11, label %14

condition_body:                                   ; preds = %14
  %load_in3 = load i8, i8* %IN, align 1
  %4 = zext i8 %load_in3 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %17, label %18

branch:                                           ; preds = %14
  %load_in5 = load i8, i8* %IN, align 1
  %6 = zext i8 %load_in5 to i32
  %tmpVar6 = icmp sgt i32 %6, 223
  %7 = zext i1 %tmpVar6 to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %31, label %34

condition_body4:                                  ; preds = %22
  %load_in11 = load i8, i8* %IN, align 1
  %9 = zext i8 %load_in11 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %37, label %38

else:                                             ; preds = %22
  %load_in12 = load i8, i8* %IN, align 1
  store i8 %load_in12, i8* %TO_UPPER, align 1
  br label %continue

continue:                                         ; preds = %else, %38, %18
  %TO_UPPER_ret = load i8, i8* %TO_UPPER, align 1
  ret i8 %TO_UPPER_ret

11:                                               ; preds = %entry
  %load_in1 = load i8, i8* %IN, align 1
  %12 = zext i8 %load_in1 to i32
  %tmpVar2 = icmp slt i32 %12, 123
  %13 = zext i1 %tmpVar2 to i32
  br label %14

14:                                               ; preds = %11, %entry
  %15 = phi i32 [ %2, %entry ], [ %13, %11 ]
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %condition_body, label %branch

17:                                               ; preds = %condition_body
  br label %18

18:                                               ; preds = %17, %condition_body
  %19 = phi i32 [ %4, %condition_body ], [ 223, %17 ]
  store i32 %19, i8* %TO_UPPER, align 4
  br label %continue

20:                                               ; preds = %28
  %load_ = load i8, i8* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 0), align 1
  %21 = zext i8 %load_ to i32
  br label %22

22:                                               ; preds = %20, %28
  %23 = phi i32 [ %29, %28 ], [ %21, %20 ]
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %condition_body4, label %else

25:                                               ; preds = %34
  %load_in9 = load i8, i8* %IN, align 1
  %26 = zext i8 %load_in9 to i32
  %tmpVar10 = icmp ne i32 %26, 255
  %27 = zext i1 %tmpVar10 to i32
  br label %28

28:                                               ; preds = %25, %34
  %29 = phi i32 [ %35, %34 ], [ %27, %25 ]
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %20, label %22

31:                                               ; preds = %branch
  %load_in7 = load i8, i8* %IN, align 1
  %32 = zext i8 %load_in7 to i32
  %tmpVar8 = icmp ne i32 %32, 247
  %33 = zext i1 %tmpVar8 to i32
  br label %34

34:                                               ; preds = %31, %branch
  %35 = phi i32 [ %7, %branch ], [ %33, %31 ]
  %36 = icmp ne i32 %35, 0
  br i1 %36, label %25, label %28

37:                                               ; preds = %condition_body4
  br label %38

38:                                               ; preds = %37, %condition_body4
  %39 = phi i32 [ %9, %condition_body4 ], [ 223, %37 ]
  store i32 %39, i8* %TO_UPPER, align 4
  br label %continue
}

define [251 x i8] @TRIM(%TRIM_interface* %0) {
entry:
  %str = getelementptr inbounds %TRIM_interface, %TRIM_interface* %0, i32 0, i32 0
  %pos = getelementptr inbounds %TRIM_interface, %TRIM_interface* %0, i32 0, i32 1
  %TRIM = alloca [251 x i8], align 1
  store i16 0, i16* %pos, align 2
  %1 = bitcast [251 x i8]* %TRIM to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %2 = bitcast [251 x i8]* %TRIM to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 250, i1 false)
  br label %while_body

condition_check:                                  ; preds = %continue3
  %load_pos = load i16, i16* %pos, align 2
  %4 = sext i16 %load_pos to i32
  %tmpVar = icmp eq i32 %4, 0
  br i1 %tmpVar, label %while_body, label %continue

while_body:                                       ; preds = %entry, %condition_check
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input

continue:                                         ; preds = %condition_check
  %TRIM_ret = load [251 x i8], [251 x i8]* %TRIM, align 1
  ret [251 x i8] %TRIM_ret

input:                                            ; preds = %while_body
  %5 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %6 = bitcast [1024 x i8]* %5 to i8*
  %7 = bitcast [251 x i8]* %TRIM to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %6, i8* align 1 %7, i32 251, i1 false)
  %8 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %9 = bitcast [1024 x i8]* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %9, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_1, i32 0, i32 0), i32 2, i1 false)
  br label %call

call:                                             ; preds = %input
  %call2 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store i16 %call2, i16* %pos, align 2
  %load_pos4 = load i16, i16* %pos, align 2
  %10 = sext i16 %load_pos4 to i32
  %tmpVar5 = icmp sgt i32 %10, 0
  br i1 %tmpVar5, label %condition_body, label %continue3

condition_body:                                   ; preds = %continue1
  %REPLACE_instance = alloca %REPLACE_interface, align 8
  br label %input6

continue3:                                        ; preds = %continue9, %continue1
  br label %condition_check

input6:                                           ; preds = %condition_body
  %11 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 0
  %12 = bitcast [1024 x i8]* %11 to i8*
  %13 = bitcast [251 x i8]* %TRIM to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %12, i8* align 1 %13, i32 251, i1 false)
  %14 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 1
  %15 = bitcast [1024 x i8]* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %15, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  %16 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 2
  store i16 1, i16* %16, align 2
  %17 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 3
  %load_pos10 = load i16, i16* %pos, align 2
  store i16 %load_pos10, i16* %17, align 2
  br label %call7

call7:                                            ; preds = %input6
  %call11 = call [1024 x i8] @REPLACE(%REPLACE_interface* %REPLACE_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %18 = alloca [1024 x i8], align 1
  store [1024 x i8] %call11, [1024 x i8]* %18, align 1
  %19 = bitcast [251 x i8]* %TRIM to i8*
  %20 = bitcast [1024 x i8]* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %19, i8* align 1 %20, i32 250, i1 false)
  br label %continue3
}

define [251 x i8] @TRIM1(%TRIM1_interface* %0) {
entry:
  %str = getelementptr inbounds %TRIM1_interface, %TRIM1_interface* %0, i32 0, i32 0
  %pos = getelementptr inbounds %TRIM1_interface, %TRIM1_interface* %0, i32 0, i32 1
  %TRIM1 = alloca [251 x i8], align 1
  store i16 0, i16* %pos, align 2
  %1 = bitcast [251 x i8]* %TRIM1 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %2 = bitcast [251 x i8]* %TRIM1 to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 250, i1 false)
  br label %while_body

condition_check:                                  ; preds = %continue3
  %load_pos = load i16, i16* %pos, align 2
  %4 = sext i16 %load_pos to i32
  %tmpVar = icmp eq i32 %4, 0
  br i1 %tmpVar, label %while_body, label %continue

while_body:                                       ; preds = %entry, %condition_check
  %FIND_instance = alloca %FIND_interface, align 8
  br label %input

continue:                                         ; preds = %condition_check
  %STRING_EQUAL_instance = alloca %STRING_EQUAL_interface, align 8
  br label %input14

input:                                            ; preds = %while_body
  %5 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 0
  %6 = bitcast [1024 x i8]* %5 to i8*
  %7 = bitcast [251 x i8]* %TRIM1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %6, i8* align 1 %7, i32 251, i1 false)
  %8 = getelementptr inbounds %FIND_interface, %FIND_interface* %FIND_instance, i32 0, i32 1
  %9 = bitcast [1024 x i8]* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %9, i8* align 1 getelementptr inbounds ([3 x i8], [3 x i8]* @utf08_literal_2, i32 0, i32 0), i32 3, i1 false)
  br label %call

call:                                             ; preds = %input
  %call2 = call i16 @FIND(%FIND_interface* %FIND_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store i16 %call2, i16* %pos, align 2
  %load_pos4 = load i16, i16* %pos, align 2
  %10 = sext i16 %load_pos4 to i32
  %tmpVar5 = icmp sgt i32 %10, 0
  br i1 %tmpVar5, label %condition_body, label %continue3

condition_body:                                   ; preds = %continue1
  %REPLACE_instance = alloca %REPLACE_interface, align 8
  br label %input6

continue3:                                        ; preds = %continue9, %continue1
  br label %condition_check

input6:                                           ; preds = %condition_body
  %11 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 0
  %12 = bitcast [1024 x i8]* %11 to i8*
  %13 = bitcast [251 x i8]* %TRIM1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %12, i8* align 1 %13, i32 251, i1 false)
  %14 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 1
  %15 = bitcast [1024 x i8]* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %15, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_1, i32 0, i32 0), i32 2, i1 false)
  %16 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 2
  store i16 2, i16* %16, align 2
  %17 = getelementptr inbounds %REPLACE_interface, %REPLACE_interface* %REPLACE_instance, i32 0, i32 3
  %load_pos10 = load i16, i16* %pos, align 2
  store i16 %load_pos10, i16* %17, align 2
  br label %call7

call7:                                            ; preds = %input6
  %call11 = call [1024 x i8] @REPLACE(%REPLACE_interface* %REPLACE_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %18 = alloca [1024 x i8], align 1
  store [1024 x i8] %call11, [1024 x i8]* %18, align 1
  %19 = bitcast [251 x i8]* %TRIM1 to i8*
  %20 = bitcast [1024 x i8]* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %19, i8* align 1 %20, i32 250, i1 false)
  br label %continue3

condition_body13:                                 ; preds = %continue17
  %DELETE_instance = alloca %DELETE_interface, align 8
  br label %input24

continue12:                                       ; preds = %continue27, %continue17
  %STRING_EQUAL_instance31 = alloca %STRING_EQUAL_interface, align 8
  br label %input32

input14:                                          ; preds = %continue
  %21 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 0
  %LEFT_instance = alloca %LEFT_interface, align 8
  br label %input18

call15:                                           ; preds = %continue21
  %call23 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %22 = icmp ne i8 %call23, 0
  br i1 %22, label %condition_body13, label %continue12

input18:                                          ; preds = %input14
  %23 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 0
  %24 = bitcast [1024 x i8]* %23 to i8*
  %25 = bitcast [251 x i8]* %TRIM1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %24, i8* align 1 %25, i32 251, i1 false)
  %26 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 1
  store i16 1, i16* %26, align 2
  br label %call19

call19:                                           ; preds = %input18
  %call22 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  %27 = alloca [1024 x i8], align 1
  store [1024 x i8] %call22, [1024 x i8]* %27, align 1
  %28 = bitcast [1025 x i8]* %21 to i8*
  %29 = bitcast [1024 x i8]* %27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %28, i8* align 1 %29, i32 1024, i1 false)
  %30 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 1
  %31 = bitcast [1025 x i8]* %30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %31, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_1, i32 0, i32 0), i32 2, i1 false)
  br label %call15

input24:                                          ; preds = %condition_body13
  %32 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 0
  %33 = bitcast [1024 x i8]* %32 to i8*
  %34 = bitcast [251 x i8]* %TRIM1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %33, i8* align 1 %34, i32 251, i1 false)
  %35 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 1
  store i16 1, i16* %35, align 2
  %36 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 2
  store i16 1, i16* %36, align 2
  br label %call25

call25:                                           ; preds = %input24
  %call28 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance)
  br label %output26

output26:                                         ; preds = %call25
  br label %continue27

continue27:                                       ; preds = %output26
  %37 = alloca [1024 x i8], align 1
  store [1024 x i8] %call28, [1024 x i8]* %37, align 1
  %38 = bitcast [251 x i8]* %TRIM1 to i8*
  %39 = bitcast [1024 x i8]* %37 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %38, i8* align 1 %39, i32 250, i1 false)
  br label %continue12

condition_body30:                                 ; preds = %continue35
  %DELETE_instance42 = alloca %DELETE_interface, align 8
  br label %input43

continue29:                                       ; preds = %continue46, %continue35
  %TRIM1_ret = load [251 x i8], [251 x i8]* %TRIM1, align 1
  ret [251 x i8] %TRIM1_ret

input32:                                          ; preds = %continue12
  %40 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance31, i32 0, i32 0
  %RIGHT_instance = alloca %RIGHT_interface, align 8
  br label %input36

call33:                                           ; preds = %continue39
  %call41 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance31)
  br label %output34

output34:                                         ; preds = %call33
  br label %continue35

continue35:                                       ; preds = %output34
  %41 = icmp ne i8 %call41, 0
  br i1 %41, label %condition_body30, label %continue29

input36:                                          ; preds = %input32
  %42 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 0
  %43 = bitcast [1024 x i8]* %42 to i8*
  %44 = bitcast [251 x i8]* %TRIM1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %43, i8* align 1 %44, i32 251, i1 false)
  %45 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 1
  store i16 1, i16* %45, align 2
  br label %call37

call37:                                           ; preds = %input36
  %call40 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance)
  br label %output38

output38:                                         ; preds = %call37
  br label %continue39

continue39:                                       ; preds = %output38
  %46 = alloca [1024 x i8], align 1
  store [1024 x i8] %call40, [1024 x i8]* %46, align 1
  %47 = bitcast [1025 x i8]* %40 to i8*
  %48 = bitcast [1024 x i8]* %46 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %47, i8* align 1 %48, i32 1024, i1 false)
  %49 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance31, i32 0, i32 1
  %50 = bitcast [1025 x i8]* %49 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %50, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_1, i32 0, i32 0), i32 2, i1 false)
  br label %call33

input43:                                          ; preds = %condition_body30
  %51 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance42, i32 0, i32 0
  %52 = bitcast [1024 x i8]* %51 to i8*
  %53 = bitcast [251 x i8]* %TRIM1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %52, i8* align 1 %53, i32 251, i1 false)
  %54 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance42, i32 0, i32 1
  store i16 1, i16* %54, align 2
  %55 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance42, i32 0, i32 2
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input47

call44:                                           ; preds = %continue50
  %call52 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance42)
  br label %output45

output45:                                         ; preds = %call44
  br label %continue46

continue46:                                       ; preds = %output45
  %56 = alloca [1024 x i8], align 1
  store [1024 x i8] %call52, [1024 x i8]* %56, align 1
  %57 = bitcast [251 x i8]* %TRIM1 to i8*
  %58 = bitcast [1024 x i8]* %56 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %57, i8* align 1 %58, i32 250, i1 false)
  br label %continue29

input47:                                          ; preds = %input43
  %59 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %60 = bitcast [1024 x i8]* %59 to i8*
  %61 = bitcast [251 x i8]* %TRIM1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %60, i8* align 1 %61, i32 251, i1 false)
  br label %call48

call48:                                           ; preds = %input47
  %call51 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output49

output49:                                         ; preds = %call48
  br label %continue50

continue50:                                       ; preds = %output49
  store i16 %call51, i16* %55, align 2
  br label %call44
}

define [251 x i8] @TRIME(%TRIME_interface* %0) {
entry:
  %str = getelementptr inbounds %TRIME_interface, %TRIME_interface* %0, i32 0, i32 0
  %TRIME = alloca [251 x i8], align 1
  %1 = bitcast [251 x i8]* %TRIME to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  %2 = bitcast [251 x i8]* %TRIME to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 250, i1 false)
  br label %condition_check

condition_check:                                  ; preds = %entry, %continue11
  %STRING_EQUAL_instance = alloca %STRING_EQUAL_interface, align 8
  br label %input

while_body:                                       ; preds = %continue1
  %DELETE_instance = alloca %DELETE_interface, align 8
  br label %input8

continue:                                         ; preds = %continue1
  br label %condition_check13

input:                                            ; preds = %condition_check
  %4 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 0
  %LEFT_instance = alloca %LEFT_interface, align 8
  br label %input2

call:                                             ; preds = %continue5
  %call7 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  br i8 %call7, label %while_body, label %continue

input2:                                           ; preds = %input
  %5 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 0
  %6 = bitcast [1024 x i8]* %5 to i8*
  %7 = bitcast [251 x i8]* %TRIME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %6, i8* align 1 %7, i32 251, i1 false)
  %8 = getelementptr inbounds %LEFT_interface, %LEFT_interface* %LEFT_instance, i32 0, i32 1
  store i16 1, i16* %8, align 2
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call [1024 x i8] @LEFT(%LEFT_interface* %LEFT_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %9 = alloca [1024 x i8], align 1
  store [1024 x i8] %call6, [1024 x i8]* %9, align 1
  %10 = bitcast [1025 x i8]* %4 to i8*
  %11 = bitcast [1024 x i8]* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %10, i8* align 1 %11, i32 1024, i1 false)
  %12 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance, i32 0, i32 1
  %13 = bitcast [1025 x i8]* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %13, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_1, i32 0, i32 0), i32 2, i1 false)
  br label %call

input8:                                           ; preds = %while_body
  %14 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 0
  %15 = bitcast [1024 x i8]* %14 to i8*
  %16 = bitcast [251 x i8]* %TRIME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %15, i8* align 1 %16, i32 251, i1 false)
  %17 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 1
  store i16 1, i16* %17, align 2
  %18 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance, i32 0, i32 2
  store i16 1, i16* %18, align 2
  br label %call9

call9:                                            ; preds = %input8
  %call12 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %19 = alloca [1024 x i8], align 1
  store [1024 x i8] %call12, [1024 x i8]* %19, align 1
  %20 = bitcast [251 x i8]* %TRIME to i8*
  %21 = bitcast [1024 x i8]* %19 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %20, i8* align 1 %21, i32 250, i1 false)
  br label %condition_check

condition_check13:                                ; preds = %continue, %continue31
  %STRING_EQUAL_instance16 = alloca %STRING_EQUAL_interface, align 8
  br label %input17

while_body14:                                     ; preds = %continue20
  %DELETE_instance27 = alloca %DELETE_interface, align 8
  br label %input28

continue15:                                       ; preds = %continue20
  %TRIME_ret = load [251 x i8], [251 x i8]* %TRIME, align 1
  ret [251 x i8] %TRIME_ret

input17:                                          ; preds = %condition_check13
  %22 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance16, i32 0, i32 0
  %RIGHT_instance = alloca %RIGHT_interface, align 8
  br label %input21

call18:                                           ; preds = %continue24
  %call26 = call i8 @STRING_EQUAL(%STRING_EQUAL_interface* %STRING_EQUAL_instance16)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  br i8 %call26, label %while_body14, label %continue15

input21:                                          ; preds = %input17
  %23 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 0
  %24 = bitcast [1024 x i8]* %23 to i8*
  %25 = bitcast [251 x i8]* %TRIME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %24, i8* align 1 %25, i32 251, i1 false)
  %26 = getelementptr inbounds %RIGHT_interface, %RIGHT_interface* %RIGHT_instance, i32 0, i32 1
  store i16 1, i16* %26, align 2
  br label %call22

call22:                                           ; preds = %input21
  %call25 = call [1024 x i8] @RIGHT(%RIGHT_interface* %RIGHT_instance)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %27 = alloca [1024 x i8], align 1
  store [1024 x i8] %call25, [1024 x i8]* %27, align 1
  %28 = bitcast [1025 x i8]* %22 to i8*
  %29 = bitcast [1024 x i8]* %27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %28, i8* align 1 %29, i32 1024, i1 false)
  %30 = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %STRING_EQUAL_instance16, i32 0, i32 1
  %31 = bitcast [1025 x i8]* %30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %31, i8* align 1 getelementptr inbounds ([2 x i8], [2 x i8]* @utf08_literal_1, i32 0, i32 0), i32 2, i1 false)
  br label %call18

input28:                                          ; preds = %while_body14
  %32 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance27, i32 0, i32 0
  %33 = bitcast [1024 x i8]* %32 to i8*
  %34 = bitcast [251 x i8]* %TRIME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %33, i8* align 1 %34, i32 251, i1 false)
  %35 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance27, i32 0, i32 1
  store i16 1, i16* %35, align 2
  %36 = getelementptr inbounds %DELETE_interface, %DELETE_interface* %DELETE_instance27, i32 0, i32 2
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input32

call29:                                           ; preds = %continue35
  %call37 = call [1024 x i8] @DELETE(%DELETE_interface* %DELETE_instance27)
  br label %output30

output30:                                         ; preds = %call29
  br label %continue31

continue31:                                       ; preds = %output30
  %37 = alloca [1024 x i8], align 1
  store [1024 x i8] %call37, [1024 x i8]* %37, align 1
  %38 = bitcast [251 x i8]* %TRIME to i8*
  %39 = bitcast [1024 x i8]* %37 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %38, i8* align 1 %39, i32 250, i1 false)
  br label %condition_check13

input32:                                          ; preds = %input28
  %40 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %41 = bitcast [1024 x i8]* %40 to i8*
  %42 = bitcast [251 x i8]* %TRIME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %41, i8* align 1 %42, i32 251, i1 false)
  br label %call33

call33:                                           ; preds = %input32
  %call36 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output34

output34:                                         ; preds = %call33
  br label %continue35

continue35:                                       ; preds = %output34
  store i16 %call36, i16* %36, align 2
  br label %call29
}

define [251 x i8] @UPPERCASE(%UPPERCASE_interface* %0) {
entry:
  %str = getelementptr inbounds %UPPERCASE_interface, %UPPERCASE_interface* %0, i32 0, i32 0
  %pt = getelementptr inbounds %UPPERCASE_interface, %UPPERCASE_interface* %0, i32 0, i32 1
  %pos = getelementptr inbounds %UPPERCASE_interface, %UPPERCASE_interface* %0, i32 0, i32 2
  %l = getelementptr inbounds %UPPERCASE_interface, %UPPERCASE_interface* %0, i32 0, i32 3
  %UPPERCASE = alloca [251 x i8], align 1
  store i8* null, i8** %pt, align 8
  store i16 0, i16* %pos, align 2
  store i16 0, i16* %l, align 2
  %1 = bitcast [251 x i8]* %UPPERCASE to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 251), i1 false)
  store [251 x i8]* %UPPERCASE, i8** %pt, align 8
  %2 = bitcast [251 x i8]* %UPPERCASE to i8*
  %3 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %2, i8* align 1 %3, i32 250, i1 false)
  %LEN_instance = alloca %LEN_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %4 = getelementptr inbounds %LEN_interface, %LEN_interface* %LEN_instance, i32 0, i32 0
  %5 = bitcast [1024 x i8]* %4 to i8*
  %6 = bitcast [251 x i8]* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %5, i8* align 1 %6, i32 251, i1 false)
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @LEN(%LEN_interface* %LEN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %l, align 2
  store i16 1, i16* %pos, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue
  %load_pos = load i16, i16* %pos, align 2
  %load_pos3 = load i16, i16* %pos, align 2
  %load_l = load i16, i16* %l, align 2
  %tmpVar = icmp sle i16 %load_pos3, %load_l
  %7 = icmp ne i1 %tmpVar, false
  br i1 %7, label %12, label %13

for_body:                                         ; preds = %10
  %deref = load i8*, i8** %pt, align 8
  %TO_UPPER_instance = alloca %TO_UPPER_interface, align 8
  br label %input11

increment:                                        ; preds = %continue14
  %tmpVar17 = add i16 %load_pos, 1
  store i16 %tmpVar17, i16* %pos, align 2
  br label %condition_check

continue2:                                        ; preds = %10
  %UPPERCASE_ret = load [251 x i8], [251 x i8]* %UPPERCASE, align 1
  ret [251 x i8] %UPPERCASE_ret

8:                                                ; preds = %13
  %load_pos6 = load i16, i16* %pos, align 2
  %load_l7 = load i16, i16* %l, align 2
  %tmpVar8 = icmp sge i16 %load_pos6, %load_l7
  %9 = icmp ne i1 %tmpVar8, false
  br i1 %9, label %16, label %17

10:                                               ; preds = %17, %13
  %11 = phi i1 [ %14, %13 ], [ %18, %17 ]
  br i1 %11, label %for_body, label %continue2

12:                                               ; preds = %condition_check
  %load_pos4 = load i16, i16* %pos, align 2
  %tmpVar5 = icmp sge i16 %load_pos4, 1
  br label %13

13:                                               ; preds = %12, %condition_check
  %14 = phi i1 [ %tmpVar, %condition_check ], [ %tmpVar5, %12 ]
  %15 = icmp ne i1 %14, false
  br i1 %15, label %10, label %8

16:                                               ; preds = %8
  %load_pos9 = load i16, i16* %pos, align 2
  %tmpVar10 = icmp sle i16 %load_pos9, 1
  br label %17

17:                                               ; preds = %16, %8
  %18 = phi i1 [ %tmpVar8, %8 ], [ %tmpVar10, %16 ]
  br label %10

input11:                                          ; preds = %for_body
  %19 = getelementptr inbounds %TO_UPPER_interface, %TO_UPPER_interface* %TO_UPPER_instance, i32 0, i32 0
  %deref15 = load i8*, i8** %pt, align 8
  %load_tmpVar = load i8, i8* %deref15, align 1
  store i8 %load_tmpVar, i8* %19, align 1
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call i8 @TO_UPPER(%TO_UPPER_interface* %TO_UPPER_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  store i8 %call16, i8* %deref, align 1
  %load_pt = load i8*, i8** %pt, align 8
  %access___UPPERCASE_pt = getelementptr inbounds i8, i8* %load_pt, i32 1
  store i8* %access___UPPERCASE_pt, i8** %pt, align 8
  br label %increment
}

define [11 x i8] @WEEKDAY_TO_STRING(%WEEKDAY_TO_STRING_interface* %0) {
entry:
  %WDAY = getelementptr inbounds %WEEKDAY_TO_STRING_interface, %WEEKDAY_TO_STRING_interface* %0, i32 0, i32 0
  %LANG = getelementptr inbounds %WEEKDAY_TO_STRING_interface, %WEEKDAY_TO_STRING_interface* %0, i32 0, i32 1
  %LX = getelementptr inbounds %WEEKDAY_TO_STRING_interface, %WEEKDAY_TO_STRING_interface* %0, i32 0, i32 2
  %ly = getelementptr inbounds %WEEKDAY_TO_STRING_interface, %WEEKDAY_TO_STRING_interface* %0, i32 0, i32 3
  %WEEKDAY_TO_STRING = alloca [11 x i8], align 1
  store i16 0, i16* %ly, align 2
  %1 = bitcast [11 x i8]* %WEEKDAY_TO_STRING to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 mul nuw (i64 ptrtoint (i8* getelementptr (i8, i8* null, i32 1) to i64), i64 11), i1 false)
  %load_LANG = load i16, i16* %LANG, align 2
  %2 = sext i16 %load_LANG to i32
  %tmpVar = icmp eq i32 %2, 0
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_ = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 0), align 2
  store i16 %load_, i16* %ly, align 2
  br label %continue

else:                                             ; preds = %entry
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

continue:                                         ; preds = %continue1, %condition_body
  %load_wday = load i16, i16* %WDAY, align 2
  %3 = sext i16 %load_wday to i32
  %tmpVar8 = icmp slt i32 %3, 1
  %4 = zext i1 %tmpVar8 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %28, label %25

input:                                            ; preds = %else
  %6 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_LANG2 = load i16, i16* %LANG, align 2
  %7 = sext i16 %load_LANG2 to i64
  store i64 %7, i64* %6, align 4
  %8 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_3 = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 1), align 2
  %9 = sext i16 %load_3 to i64
  store i64 %9, i64* %8, align 4
  br label %call

call:                                             ; preds = %input
  %call4 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %10 = trunc i64 %call4 to i16
  store i16 %10, i16* %ly, align 2
  br label %continue

condition_body7:                                  ; preds = %28
  %WEEKDAY_TO_STRING_ret = load [11 x i8], [11 x i8]* %WEEKDAY_TO_STRING, align 1
  ret [11 x i8] %WEEKDAY_TO_STRING_ret

buffer_block:                                     ; No predecessors!
  br label %continue6

branch:                                           ; preds = %28
  %load_LX = load i16, i16* %LX, align 2
  %11 = sext i16 %load_LX to i32
  %tmpVar12 = icmp eq i32 %11, 0
  br i1 %tmpVar12, label %condition_body11, label %branch5

condition_body11:                                 ; preds = %branch
  %load_ly = load i16, i16* %ly, align 2
  %12 = sub i16 %load_ly, 1
  %13 = sext i16 %12 to i32
  %tmpVar13 = mul i32 7, %13
  %tmpVar14 = add i32 %tmpVar13, 0
  %load_WDAY = load i16, i16* %WDAY, align 2
  %14 = sub i16 %load_WDAY, 1
  %15 = sext i16 %14 to i32
  %tmpVar15 = mul i32 1, %15
  %tmpVar16 = add i32 %tmpVar15, %tmpVar14
  %tmpVar17 = getelementptr inbounds [21 x [11 x i8]], [21 x [11 x i8]]* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 2), i32 0, i32 %tmpVar16
  %16 = bitcast [11 x i8]* %WEEKDAY_TO_STRING to i8*
  %17 = bitcast [11 x i8]* %tmpVar17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %16, i8* align 1 %17, i32 10, i1 false)
  br label %continue6

branch5:                                          ; preds = %branch
  %load_Lx = load i16, i16* %LX, align 2
  %18 = sext i16 %load_Lx to i32
  %tmpVar19 = icmp eq i32 %18, 2
  br i1 %tmpVar19, label %condition_body18, label %continue6

condition_body18:                                 ; preds = %branch5
  %load_ly20 = load i16, i16* %ly, align 2
  %19 = sub i16 %load_ly20, 1
  %20 = sext i16 %19 to i32
  %tmpVar21 = mul i32 7, %20
  %tmpVar22 = add i32 %tmpVar21, 0
  %load_WDAY23 = load i16, i16* %WDAY, align 2
  %21 = sub i16 %load_WDAY23, 1
  %22 = sext i16 %21 to i32
  %tmpVar24 = mul i32 1, %22
  %tmpVar25 = add i32 %tmpVar24, %tmpVar22
  %tmpVar26 = getelementptr inbounds [21 x [3 x i8]], [21 x [3 x i8]]* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 3), i32 0, i32 %tmpVar25
  %23 = bitcast [11 x i8]* %WEEKDAY_TO_STRING to i8*
  %24 = bitcast [3 x i8]* %tmpVar26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %23, i8* align 1 %24, i32 3, i1 false)
  br label %continue6

continue6:                                        ; preds = %condition_body18, %branch5, %condition_body11, %buffer_block
  %WEEKDAY_TO_STRING_ret27 = load [11 x i8], [11 x i8]* %WEEKDAY_TO_STRING, align 1
  ret [11 x i8] %WEEKDAY_TO_STRING_ret27

25:                                               ; preds = %continue
  %load_wday9 = load i16, i16* %WDAY, align 2
  %26 = sext i16 %load_wday9 to i32
  %tmpVar10 = icmp sgt i32 %26, 7
  %27 = zext i1 %tmpVar10 to i32
  br label %28

28:                                               ; preds = %25, %continue
  %29 = phi i32 [ %4, %continue ], [ %27, %25 ]
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %condition_body7, label %branch
}

define void @CALENDAR_CALC(%CALENDAR_CALC_interface* %0) {
entry:
  %SPE = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 0
  %H = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 1
  %XCAL = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 2
  %HOLIDAYS = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 3
  %last = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 4
  %last_day = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 5
  %holy = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 6
  %sun = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 7
  %last_hour = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 8
  %utod = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 9
  %pos = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 10
  %plast = getelementptr inbounds %CALENDAR_CALC_interface, %CALENDAR_CALC_interface* %0, i32 0, i32 11
  %dtemp = alloca i32, align 4
  %tmp = alloca i16, align 2
  store i32 0, i32* %dtemp, align 4
  store i16 0, i16* %tmp, align 2
  %deref = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %UTC = getelementptr inbounds %CALENDAR, %CALENDAR* %deref, i32 0, i32 0
  %load_ = load i64, i64* %UTC, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar = icmp ne i64 %load_, %load_last
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %deref1 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %UTC2 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref1, i32 0, i32 0
  %load_3 = load i64, i64* %UTC2, align 4
  store i64 %load_3, i64* %last, align 4
  %DT_TO_TOD_instance = alloca %DT_TO_TOD_interface, align 8
  br label %input

continue:                                         ; preds = %continue253, %entry
  ret void

input:                                            ; preds = %condition_body
  %1 = getelementptr inbounds %DT_TO_TOD_interface, %DT_TO_TOD_interface* %DT_TO_TOD_instance, i32 0, i32 0
  %deref5 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %UTC6 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref5, i32 0, i32 0
  %load_7 = load i64, i64* %UTC6, align 4
  store i64 %load_7, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call8 = call i64 @DT_TO_TOD(%DT_TO_TOD_interface* %DT_TO_TOD_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue4

continue4:                                        ; preds = %output
  store i64 %call8, i64* %utod, align 4
  %deref9 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LDT = getelementptr inbounds %CALENDAR, %CALENDAR* %deref9, i32 0, i32 1
  %UTC_TO_LTIME_instance = alloca %UTC_TO_LTIME_interface, align 8
  br label %input10

input10:                                          ; preds = %continue4
  %2 = getelementptr inbounds %UTC_TO_LTIME_interface, %UTC_TO_LTIME_interface* %UTC_TO_LTIME_instance, i32 0, i32 0
  %deref14 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %UTC15 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref14, i32 0, i32 0
  %load_16 = load i64, i64* %UTC15, align 4
  store i64 %load_16, i64* %2, align 4
  %3 = getelementptr inbounds %UTC_TO_LTIME_interface, %UTC_TO_LTIME_interface* %UTC_TO_LTIME_instance, i32 0, i32 1
  %deref17 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %DST_EN = getelementptr inbounds %CALENDAR, %CALENDAR* %deref17, i32 0, i32 9
  %load_18 = load i8, i8* %DST_EN, align 1
  store i8 %load_18, i8* %3, align 1
  %4 = getelementptr inbounds %UTC_TO_LTIME_interface, %UTC_TO_LTIME_interface* %UTC_TO_LTIME_instance, i32 0, i32 2
  %deref19 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %OFFSET = getelementptr inbounds %CALENDAR, %CALENDAR* %deref19, i32 0, i32 8
  %load_20 = load i16, i16* %OFFSET, align 2
  store i16 %load_20, i16* %4, align 2
  br label %call11

call11:                                           ; preds = %input10
  %call21 = call i64 @UTC_TO_LTIME(%UTC_TO_LTIME_interface* %UTC_TO_LTIME_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  store i64 %call21, i64* %LDT, align 4
  %deref22 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LDATE = getelementptr inbounds %CALENDAR, %CALENDAR* %deref22, i32 0, i32 2
  %DT_TO_DATE_instance = alloca %DT_TO_DATE_interface, align 8
  br label %input23

input23:                                          ; preds = %continue13
  %5 = getelementptr inbounds %DT_TO_DATE_interface, %DT_TO_DATE_interface* %DT_TO_DATE_instance, i32 0, i32 0
  %deref27 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LDT28 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref27, i32 0, i32 1
  %load_29 = load i64, i64* %LDT28, align 4
  store i64 %load_29, i64* %5, align 4
  br label %call24

call24:                                           ; preds = %input23
  %call30 = call i64 @DT_TO_DATE(%DT_TO_DATE_interface* %DT_TO_DATE_instance)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  store i64 %call30, i64* %LDATE, align 4
  %deref31 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LTOD = getelementptr inbounds %CALENDAR, %CALENDAR* %deref31, i32 0, i32 3
  %DT_TO_TOD_instance32 = alloca %DT_TO_TOD_interface, align 8
  br label %input33

input33:                                          ; preds = %continue26
  %6 = getelementptr inbounds %DT_TO_TOD_interface, %DT_TO_TOD_interface* %DT_TO_TOD_instance32, i32 0, i32 0
  %deref37 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LDT38 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref37, i32 0, i32 1
  %load_39 = load i64, i64* %LDT38, align 4
  store i64 %load_39, i64* %6, align 4
  br label %call34

call34:                                           ; preds = %input33
  %call40 = call i64 @DT_TO_TOD(%DT_TO_TOD_interface* %DT_TO_TOD_instance32)
  br label %output35

output35:                                         ; preds = %call34
  br label %continue36

continue36:                                       ; preds = %output35
  store i64 %call40, i64* %LTOD, align 4
  %DAY_OF_DATE_instance = alloca %DAY_OF_DATE_interface, align 8
  br label %input41

input41:                                          ; preds = %continue36
  %7 = getelementptr inbounds %DAY_OF_DATE_interface, %DAY_OF_DATE_interface* %DAY_OF_DATE_instance, i32 0, i32 0
  %deref45 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LDATE46 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref45, i32 0, i32 2
  %load_47 = load i64, i64* %LDATE46, align 4
  store i64 %load_47, i64* %7, align 4
  br label %call42

call42:                                           ; preds = %input41
  %call48 = call i32 @DAY_OF_DATE(%DAY_OF_DATE_interface* %DAY_OF_DATE_instance)
  br label %output43

output43:                                         ; preds = %call42
  br label %continue44

continue44:                                       ; preds = %output43
  store i32 %call48, i32* %dtemp, align 4
  %deref49 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %night = getelementptr inbounds %CALENDAR, %CALENDAR* %deref49, i32 0, i32 21
  %deref50 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LTOD51 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref50, i32 0, i32 3
  %load_52 = load i64, i64* %LTOD51, align 4
  %deref53 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %SUN_RISE = getelementptr inbounds %CALENDAR, %CALENDAR* %deref53, i32 0, i32 15
  %load_54 = load i64, i64* %SUN_RISE, align 4
  %tmpVar55 = icmp slt i64 %load_52, %load_54
  %8 = zext i1 %tmpVar55 to i32
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %continue44
  %deref56 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LTOD57 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref56, i32 0, i32 3
  %load_58 = load i64, i64* %LTOD57, align 4
  %deref59 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %SUN_SET = getelementptr inbounds %CALENDAR, %CALENDAR* %deref59, i32 0, i32 16
  %load_60 = load i64, i64* %SUN_SET, align 4
  %tmpVar61 = icmp sgt i64 %load_58, %load_60
  %11 = zext i1 %tmpVar61 to i32
  br label %12

12:                                               ; preds = %10, %continue44
  %13 = phi i32 [ %8, %continue44 ], [ %11, %10 ]
  store i32 %13, i8* %night, align 4
  %HOUR_instance = alloca %HOUR_interface, align 8
  br label %input62

input62:                                          ; preds = %12
  %14 = getelementptr inbounds %HOUR_interface, %HOUR_interface* %HOUR_instance, i32 0, i32 0
  %deref66 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LTOD67 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref66, i32 0, i32 3
  %load_68 = load i64, i64* %LTOD67, align 4
  store i64 %load_68, i64* %14, align 4
  br label %call63

call63:                                           ; preds = %input62
  %call69 = call i16 @HOUR(%HOUR_interface* %HOUR_instance)
  br label %output64

output64:                                         ; preds = %call63
  br label %continue65

continue65:                                       ; preds = %output64
  store i16 %call69, i16* %tmp, align 2
  %load_tmp = load i16, i16* %tmp, align 2
  %15 = sext i16 %load_tmp to i32
  %load_last_hour = load i16, i16* %last_hour, align 2
  %16 = sext i16 %load_last_hour to i32
  %tmpVar72 = icmp ne i32 %15, %16
  br i1 %tmpVar72, label %condition_body71, label %continue70

condition_body71:                                 ; preds = %continue65
  %deref73 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %DST_ON = getelementptr inbounds %CALENDAR, %CALENDAR* %deref73, i32 0, i32 10
  %DST_instance = alloca %DST_interface, align 8
  br label %input74

continue70:                                       ; preds = %19, %continue65
  %load_dtemp = load i32, i32* %dtemp, align 4
  %load_last_day = load i32, i32* %last_day, align 4
  %tmpVar88 = icmp ne i32 %load_dtemp, %load_last_day
  br i1 %tmpVar88, label %condition_body87, label %continue86

17:                                               ; preds = %continue77
  %deref82 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %DST_EN83 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref82, i32 0, i32 9
  %load_84 = load i8, i8* %DST_EN83, align 1
  %18 = zext i8 %load_84 to i32
  br label %19

19:                                               ; preds = %17, %continue77
  %20 = phi i32 [ %22, %continue77 ], [ %18, %17 ]
  store i32 %20, i8* %DST_ON, align 4
  %load_tmp85 = load i16, i16* %tmp, align 2
  store i16 %load_tmp85, i16* %last_hour, align 2
  br label %continue70

input74:                                          ; preds = %condition_body71
  %21 = getelementptr inbounds %DST_interface, %DST_interface* %DST_instance, i32 0, i32 0
  %deref78 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %UTC79 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref78, i32 0, i32 0
  %load_80 = load i64, i64* %UTC79, align 4
  store i64 %load_80, i64* %21, align 4
  br label %call75

call75:                                           ; preds = %input74
  %call81 = call i8 @DST(%DST_interface* %DST_instance)
  br label %output76

output76:                                         ; preds = %call75
  br label %continue77

continue77:                                       ; preds = %output76
  %22 = zext i8 %call81 to i32
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %17, label %19

condition_body87:                                 ; preds = %continue70
  %load_dtemp89 = load i32, i32* %dtemp, align 4
  store i32 %load_dtemp89, i32* %last_day, align 4
  %deref90 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %YEAR = getelementptr inbounds %CALENDAR, %CALENDAR* %deref90, i32 0, i32 4
  %YEAR_OF_DATE_instance = alloca %YEAR_OF_DATE_interface, align 8
  br label %input91

continue86:                                       ; preds = %continue248, %continue70
  %load_SPE = load i8, i8* %SPE, align 1
  %24 = zext i8 %load_SPE to i32
  %25 = icmp ne i32 %24, 0
  br i1 %25, label %65, label %67

input91:                                          ; preds = %condition_body87
  %26 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance, i32 0, i32 0
  %deref95 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LDATE96 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref95, i32 0, i32 2
  %load_97 = load i64, i64* %LDATE96, align 4
  store i64 %load_97, i64* %26, align 4
  br label %call92

call92:                                           ; preds = %input91
  %call98 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance)
  br label %output93

output93:                                         ; preds = %call92
  br label %continue94

continue94:                                       ; preds = %output93
  store i16 %call98, i16* %YEAR, align 2
  %deref99 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %MONTH = getelementptr inbounds %CALENDAR, %CALENDAR* %deref99, i32 0, i32 5
  %MONTH_OF_DATE_instance = alloca %MONTH_OF_DATE_interface, align 8
  br label %input100

input100:                                         ; preds = %continue94
  %27 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance, i32 0, i32 0
  %deref104 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LDATE105 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref104, i32 0, i32 2
  %load_106 = load i64, i64* %LDATE105, align 4
  store i64 %load_106, i64* %27, align 4
  br label %call101

call101:                                          ; preds = %input100
  %call107 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance)
  br label %output102

output102:                                        ; preds = %call101
  br label %continue103

continue103:                                      ; preds = %output102
  store i16 %call107, i16* %MONTH, align 2
  %deref108 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %DAY = getelementptr inbounds %CALENDAR, %CALENDAR* %deref108, i32 0, i32 6
  %DAY_OF_MONTH_instance = alloca %DAY_OF_MONTH_interface, align 8
  br label %input109

input109:                                         ; preds = %continue103
  %28 = getelementptr inbounds %DAY_OF_MONTH_interface, %DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance, i32 0, i32 0
  %deref113 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LDATE114 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref113, i32 0, i32 2
  %load_115 = load i64, i64* %LDATE114, align 4
  store i64 %load_115, i64* %28, align 4
  br label %call110

call110:                                          ; preds = %input109
  %call116 = call i16 @DAY_OF_MONTH(%DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance)
  br label %output111

output111:                                        ; preds = %call110
  br label %continue112

continue112:                                      ; preds = %output111
  store i16 %call116, i16* %DAY, align 2
  %deref117 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %WEEKDAY = getelementptr inbounds %CALENDAR, %CALENDAR* %deref117, i32 0, i32 7
  %DAY_OF_WEEK_instance = alloca %DAY_OF_WEEK_interface, align 8
  br label %input118

input118:                                         ; preds = %continue112
  %29 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance, i32 0, i32 0
  %deref122 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LDATE123 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref122, i32 0, i32 2
  %load_124 = load i64, i64* %LDATE123, align 4
  store i64 %load_124, i64* %29, align 4
  br label %call119

call119:                                          ; preds = %input118
  %call125 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance)
  br label %output120

output120:                                        ; preds = %call119
  br label %continue121

continue121:                                      ; preds = %output120
  store i16 %call125, i16* %WEEKDAY, align 2
  br label %input126

input126:                                         ; preds = %continue121
  %30 = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %holy, i32 0, i32 0
  %deref130 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LDATE131 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref130, i32 0, i32 2
  %load_132 = load i64, i64* %LDATE131, align 4
  store i64 %load_132, i64* %30, align 4
  %31 = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %holy, i32 0, i32 1
  %deref133 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LANGUAGE = getelementptr inbounds %CALENDAR, %CALENDAR* %deref133, i32 0, i32 12
  %load_134 = load i16, i16* %LANGUAGE, align 2
  store i16 %load_134, i16* %31, align 2
  %32 = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %holy, i32 0, i32 5
  %deref135 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  store [30 x %HOLIDAY_DATA]* %deref135, [30 x %HOLIDAY_DATA]** %32, align 8
  br label %call127

call127:                                          ; preds = %input126
  call void @HOLIDAY(%HOLIDAY_interface* %holy)
  br label %output128

output128:                                        ; preds = %call127
  br label %continue129

continue129:                                      ; preds = %output128
  %deref136 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %HOLIDAY = getelementptr inbounds %CALENDAR, %CALENDAR* %deref136, i32 0, i32 22
  %Y = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %holy, i32 0, i32 7
  %load_137 = load i8, i8* %Y, align 1
  store i8 %load_137, i8* %HOLIDAY, align 1
  %deref138 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %HOLY_NAME = getelementptr inbounds %CALENDAR, %CALENDAR* %deref138, i32 0, i32 23
  %NAME = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %holy, i32 0, i32 8
  %33 = bitcast [31 x i8]* %HOLY_NAME to i8*
  %34 = bitcast [31 x i8]* %NAME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %33, i8* align 1 %34, i32 30, i1 false)
  br label %input139

input139:                                         ; preds = %continue129
  %35 = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %sun, i32 0, i32 0
  %deref143 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LATITUDE = getelementptr inbounds %CALENDAR, %CALENDAR* %deref143, i32 0, i32 14
  %load_144 = load float, float* %LATITUDE, align 4
  store float %load_144, float* %35, align 4
  %36 = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %sun, i32 0, i32 1
  %deref145 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LONGITUDE = getelementptr inbounds %CALENDAR, %CALENDAR* %deref145, i32 0, i32 13
  %load_146 = load float, float* %LONGITUDE, align 4
  store float %load_146, float* %36, align 4
  %37 = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %sun, i32 0, i32 2
  %DT_TO_DATE_instance147 = alloca %DT_TO_DATE_interface, align 8
  br label %input148
  %38 = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %sun, i32 0, i32 3
  %load_H = load float, float* %H, align 4
  store float %load_H, float* %38, align 4
  br label %call140

call140:                                          ; preds = %input139
  call void @SUN_TIME(%SUN_TIME_interface* %sun)
  br label %output141

output141:                                        ; preds = %call140
  br label %continue142

continue142:                                      ; preds = %output141
  %deref156 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %SUN_RISE157 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref156, i32 0, i32 15
  %DINT_TO_TOD_instance = alloca %DINT_TO_TOD_interface, align 8
  br label %input158

input148:                                         ; preds = %input139
  %39 = getelementptr inbounds %DT_TO_DATE_interface, %DT_TO_DATE_interface* %DT_TO_DATE_instance147, i32 0, i32 0
  %deref152 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %UTC153 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref152, i32 0, i32 0
  %load_154 = load i64, i64* %UTC153, align 4
  store i64 %load_154, i64* %39, align 4
  br label %call149

call149:                                          ; preds = %input148
  %call155 = call i64 @DT_TO_DATE(%DT_TO_DATE_interface* %DT_TO_DATE_instance147)
  br label %output150

output150:                                        ; preds = %call149
  br label %continue151

continue151:                                      ; preds = %output150
  store i64 %call155, i64* %37, align 4

input158:                                         ; preds = %continue142
  %40 = getelementptr inbounds %DINT_TO_TOD_interface, %DINT_TO_TOD_interface* %DINT_TO_TOD_instance, i32 0, i32 0
  %TOD_TO_DINT_instance = alloca %TOD_TO_DINT_interface, align 8
  br label %input162

call159:                                          ; preds = %continue176
  %call182 = call i64 @DINT_TO_TOD(%DINT_TO_TOD_interface* %DINT_TO_TOD_instance)
  br label %output160

output160:                                        ; preds = %call159
  br label %continue161

continue161:                                      ; preds = %output160
  store i64 %call182, i64* %SUN_RISE157, align 4
  %deref183 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %SUN_SET184 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref183, i32 0, i32 16
  %DINT_TO_TOD_instance185 = alloca %DINT_TO_TOD_interface, align 8
  br label %input186

input162:                                         ; preds = %input158
  %41 = getelementptr inbounds %TOD_TO_DINT_interface, %TOD_TO_DINT_interface* %TOD_TO_DINT_instance, i32 0, i32 0
  %sun_rise = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %sun, i32 0, i32 5
  %load_166 = load i64, i64* %sun_rise, align 4
  store i64 %load_166, i64* %41, align 4
  br label %call163

call163:                                          ; preds = %input162
  %call167 = call i32 @TOD_TO_DINT(%TOD_TO_DINT_interface* %TOD_TO_DINT_instance)
  br label %output164

output164:                                        ; preds = %call163
  br label %continue165

continue165:                                      ; preds = %output164
  %deref168 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %OFFSET169 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref168, i32 0, i32 8
  %load_170 = load i16, i16* %OFFSET169, align 2
  %42 = sext i16 %load_170 to i32
  %tmpVar171 = mul i32 %42, 60000
  %tmpVar172 = add i32 %call167, %tmpVar171
  %43 = sext i32 %tmpVar172 to i64
  %SEL_instance = alloca %SEL_interface, align 8
  br label %input173

input173:                                         ; preds = %continue165
  %44 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 0
  %deref177 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %DST_ON178 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref177, i32 0, i32 10
  %load_179 = load i8, i8* %DST_ON178, align 1
  store i8 %load_179, i8* %44, align 1
  %45 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 1
  store i64 0, i64* %45, align 4
  %46 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance, i32 0, i32 2
  store i64 3600000, i64* %46, align 4
  br label %call174

call174:                                          ; preds = %input173
  %call180 = call i64 @SEL(%SEL_interface* %SEL_instance)
  br label %output175

output175:                                        ; preds = %call174
  br label %continue176

continue176:                                      ; preds = %output175
  %tmpVar181 = add i64 %43, %call180
  %47 = trunc i64 %tmpVar181 to i32
  store i32 %47, i32* %40, align 4
  br label %call159

input186:                                         ; preds = %continue161
  %48 = getelementptr inbounds %DINT_TO_TOD_interface, %DINT_TO_TOD_interface* %DINT_TO_TOD_instance185, i32 0, i32 0
  %TOD_TO_DINT_instance190 = alloca %TOD_TO_DINT_interface, align 8
  br label %input191

call187:                                          ; preds = %continue206
  %call212 = call i64 @DINT_TO_TOD(%DINT_TO_TOD_interface* %DINT_TO_TOD_instance185)
  br label %output188

output188:                                        ; preds = %call187
  br label %continue189

continue189:                                      ; preds = %output188
  store i64 %call212, i64* %SUN_SET184, align 4
  %deref213 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %SUN_MIDDAY = getelementptr inbounds %CALENDAR, %CALENDAR* %deref213, i32 0, i32 17
  %DINT_TO_TOD_instance214 = alloca %DINT_TO_TOD_interface, align 8
  br label %input215

input191:                                         ; preds = %input186
  %49 = getelementptr inbounds %TOD_TO_DINT_interface, %TOD_TO_DINT_interface* %TOD_TO_DINT_instance190, i32 0, i32 0
  %sun_set = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %sun, i32 0, i32 6
  %load_195 = load i64, i64* %sun_set, align 4
  store i64 %load_195, i64* %49, align 4
  br label %call192

call192:                                          ; preds = %input191
  %call196 = call i32 @TOD_TO_DINT(%TOD_TO_DINT_interface* %TOD_TO_DINT_instance190)
  br label %output193

output193:                                        ; preds = %call192
  br label %continue194

continue194:                                      ; preds = %output193
  %deref197 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %OFFSET198 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref197, i32 0, i32 8
  %load_199 = load i16, i16* %OFFSET198, align 2
  %50 = sext i16 %load_199 to i32
  %tmpVar200 = mul i32 %50, 60000
  %tmpVar201 = add i32 %call196, %tmpVar200
  %51 = sext i32 %tmpVar201 to i64
  %SEL_instance202 = alloca %SEL_interface, align 8
  br label %input203

input203:                                         ; preds = %continue194
  %52 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance202, i32 0, i32 0
  %deref207 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %DST_ON208 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref207, i32 0, i32 10
  %load_209 = load i8, i8* %DST_ON208, align 1
  store i8 %load_209, i8* %52, align 1
  %53 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance202, i32 0, i32 1
  store i64 0, i64* %53, align 4
  %54 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance202, i32 0, i32 2
  store i64 3600000, i64* %54, align 4
  br label %call204

call204:                                          ; preds = %input203
  %call210 = call i64 @SEL(%SEL_interface* %SEL_instance202)
  br label %output205

output205:                                        ; preds = %call204
  br label %continue206

continue206:                                      ; preds = %output205
  %tmpVar211 = add i64 %51, %call210
  %55 = trunc i64 %tmpVar211 to i32
  store i32 %55, i32* %48, align 4
  br label %call187

input215:                                         ; preds = %continue189
  %56 = getelementptr inbounds %DINT_TO_TOD_interface, %DINT_TO_TOD_interface* %DINT_TO_TOD_instance214, i32 0, i32 0
  %TOD_TO_DINT_instance219 = alloca %TOD_TO_DINT_interface, align 8
  br label %input220

call216:                                          ; preds = %continue235
  %call241 = call i64 @DINT_TO_TOD(%DINT_TO_TOD_interface* %DINT_TO_TOD_instance214)
  br label %output217

output217:                                        ; preds = %call216
  br label %continue218

continue218:                                      ; preds = %output217
  store i64 %call241, i64* %SUN_MIDDAY, align 4
  %deref242 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %SUN_HEIGTH = getelementptr inbounds %CALENDAR, %CALENDAR* %deref242, i32 0, i32 18
  %sun_declination = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %sun, i32 0, i32 7
  %load_243 = load float, float* %sun_declination, align 4
  store float %load_243, float* %SUN_HEIGTH, align 4
  %deref244 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %WORK_WEEK = getelementptr inbounds %CALENDAR, %CALENDAR* %deref244, i32 0, i32 24
  %WORK_WEEK_instance = alloca %WORK_WEEK_interface, align 8
  br label %input245

input220:                                         ; preds = %input215
  %57 = getelementptr inbounds %TOD_TO_DINT_interface, %TOD_TO_DINT_interface* %TOD_TO_DINT_instance219, i32 0, i32 0
  %MIDDAY = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %sun, i32 0, i32 4
  %load_224 = load i64, i64* %MIDDAY, align 4
  store i64 %load_224, i64* %57, align 4
  br label %call221

call221:                                          ; preds = %input220
  %call225 = call i32 @TOD_TO_DINT(%TOD_TO_DINT_interface* %TOD_TO_DINT_instance219)
  br label %output222

output222:                                        ; preds = %call221
  br label %continue223

continue223:                                      ; preds = %output222
  %deref226 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %OFFSET227 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref226, i32 0, i32 8
  %load_228 = load i16, i16* %OFFSET227, align 2
  %58 = sext i16 %load_228 to i32
  %tmpVar229 = mul i32 %58, 60000
  %tmpVar230 = add i32 %call225, %tmpVar229
  %59 = sext i32 %tmpVar230 to i64
  %SEL_instance231 = alloca %SEL_interface, align 8
  br label %input232

input232:                                         ; preds = %continue223
  %60 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance231, i32 0, i32 0
  %deref236 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %DST_ON237 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref236, i32 0, i32 10
  %load_238 = load i8, i8* %DST_ON237, align 1
  store i8 %load_238, i8* %60, align 1
  %61 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance231, i32 0, i32 1
  store i64 0, i64* %61, align 4
  %62 = getelementptr inbounds %SEL_interface, %SEL_interface* %SEL_instance231, i32 0, i32 2
  store i64 3600000, i64* %62, align 4
  br label %call233

call233:                                          ; preds = %input232
  %call239 = call i64 @SEL(%SEL_interface* %SEL_instance231)
  br label %output234

output234:                                        ; preds = %call233
  br label %continue235

continue235:                                      ; preds = %output234
  %tmpVar240 = add i64 %59, %call239
  %63 = trunc i64 %tmpVar240 to i32
  store i32 %63, i32* %56, align 4
  br label %call216

input245:                                         ; preds = %continue218
  %64 = getelementptr inbounds %WORK_WEEK_interface, %WORK_WEEK_interface* %WORK_WEEK_instance, i32 0, i32 0
  %deref249 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LDATE250 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref249, i32 0, i32 2
  %load_251 = load i64, i64* %LDATE250, align 4
  store i64 %load_251, i64* %64, align 4
  br label %call246

call246:                                          ; preds = %input245
  %call252 = call i16 @WORK_WEEK(%WORK_WEEK_interface* %WORK_WEEK_instance)
  br label %output247

output247:                                        ; preds = %call246
  br label %continue248

continue248:                                      ; preds = %output247
  store i16 %call252, i16* %WORK_WEEK, align 2
  br label %continue86

condition_body254:                                ; preds = %67
  %load_last260 = load i64, i64* %last, align 4
  store i64 %load_last260, i64* %plast, align 4
  br label %input261

continue253:                                      ; preds = %continue264, %67
  br label %continue

65:                                               ; preds = %continue86
  %deref255 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %UTC256 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref255, i32 0, i32 0
  %load_257 = load i64, i64* %UTC256, align 4
  %load_plast = load i64, i64* %plast, align 4
  %tmpVar258 = sub i64 %load_257, %load_plast
  %tmpVar259 = icmp sge i64 %tmpVar258, 25000000000
  %66 = zext i1 %tmpVar259 to i32
  br label %67

67:                                               ; preds = %65, %continue86
  %68 = phi i32 [ %24, %continue86 ], [ %66, %65 ]
  %69 = icmp ne i32 %68, 0
  br i1 %69, label %condition_body254, label %continue253

input261:                                         ; preds = %condition_body254
  %70 = getelementptr inbounds %SUN_POS_interface, %SUN_POS_interface* %pos, i32 0, i32 0
  %deref265 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LATITUDE266 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref265, i32 0, i32 14
  %load_267 = load float, float* %LATITUDE266, align 4
  store float %load_267, float* %70, align 4
  %71 = getelementptr inbounds %SUN_POS_interface, %SUN_POS_interface* %pos, i32 0, i32 1
  %deref268 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %LONGITUDE269 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref268, i32 0, i32 13
  %load_270 = load float, float* %LONGITUDE269, align 4
  store float %load_270, float* %71, align 4
  %72 = getelementptr inbounds %SUN_POS_interface, %SUN_POS_interface* %pos, i32 0, i32 2
  %deref271 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %UTC272 = getelementptr inbounds %CALENDAR, %CALENDAR* %deref271, i32 0, i32 0
  %load_273 = load i64, i64* %UTC272, align 4
  store i64 %load_273, i64* %72, align 4
  br label %call262

call262:                                          ; preds = %input261
  call void @SUN_POS(%SUN_POS_interface* %pos)
  br label %output263

output263:                                        ; preds = %call262
  br label %continue264

continue264:                                      ; preds = %output263
  %deref274 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %SUN_HOR = getelementptr inbounds %CALENDAR, %CALENDAR* %deref274, i32 0, i32 19
  %B = getelementptr inbounds %SUN_POS_interface, %SUN_POS_interface* %pos, i32 0, i32 3
  %load_275 = load float, float* %B, align 4
  store float %load_275, float* %SUN_HOR, align 4
  %deref276 = load %CALENDAR*, %CALENDAR** %XCAL, align 8
  %SUN_VER = getelementptr inbounds %CALENDAR, %CALENDAR* %deref276, i32 0, i32 20
  %HR = getelementptr inbounds %SUN_POS_interface, %SUN_POS_interface* %pos, i32 0, i32 5
  %load_277 = load float, float* %HR, align 4
  store float %load_277, float* %SUN_VER, align 4
  br label %continue253
}

define i64 @DATE_ADD(%DATE_ADD_interface* %0) {
entry:
  %IDATE = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %0, i32 0, i32 0
  %D = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %0, i32 0, i32 1
  %W = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %0, i32 0, i32 2
  %M = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %0, i32 0, i32 3
  %Y = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %0, i32 0, i32 4
  %mo = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %0, i32 0, i32 5
  %yr = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %0, i32 0, i32 6
  %dm = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %0, i32 0, i32 7
  %DATE_ADD = alloca i64, align 8
  store i16 0, i16* %mo, align 2
  store i16 0, i16* %yr, align 2
  store i16 0, i16* %dm, align 2
  store i64 0, i64* %DATE_ADD, align 4
  %UDINT_TO_DATE_instance = alloca %UDINT_TO_DATE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %UDINT_TO_DATE_interface, %UDINT_TO_DATE_interface* %UDINT_TO_DATE_instance, i32 0, i32 0
  %DATE_TO_UDINT_instance = alloca %DATE_TO_UDINT_interface, align 8
  br label %input1

call:                                             ; preds = %continue9
  %call14 = call i64 @UDINT_TO_DATE(%UDINT_TO_DATE_interface* %UDINT_TO_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call14, i64* %DATE_ADD, align 4
  %load_Y = load i16, i16* %Y, align 2
  %2 = sext i16 %load_Y to i32
  %YEAR_OF_DATE_instance = alloca %YEAR_OF_DATE_interface, align 8
  br label %input15

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %DATE_TO_UDINT_interface, %DATE_TO_UDINT_interface* %DATE_TO_UDINT_instance, i32 0, i32 0
  %load_IDATE = load i64, i64* %IDATE, align 4
  store i64 %load_IDATE, i64* %3, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DATE_TO_UDINT(%DATE_TO_UDINT_interface* %DATE_TO_UDINT_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %INT_TO_UDINT_instance = alloca %INT_TO_UDINT_interface, align 8
  br label %input6

input6:                                           ; preds = %continue4
  %4 = getelementptr inbounds %INT_TO_UDINT_interface, %INT_TO_UDINT_interface* %INT_TO_UDINT_instance, i32 0, i32 0
  %load_D = load i16, i16* %D, align 2
  %5 = sext i16 %load_D to i32
  %load_W = load i16, i16* %W, align 2
  %6 = sext i16 %load_W to i32
  %tmpVar = mul i32 %6, 7
  %tmpVar10 = add i32 %5, %tmpVar
  %7 = trunc i32 %tmpVar10 to i16
  store i16 %7, i16* %4, align 2
  br label %call7

call7:                                            ; preds = %input6
  %call11 = call i32 @INT_TO_UDINT(%INT_TO_UDINT_interface* %INT_TO_UDINT_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %tmpVar12 = mul i32 %call11, 86400
  %tmpVar13 = add i32 %call5, %tmpVar12
  store i32 %tmpVar13, i32* %1, align 4
  br label %call

input15:                                          ; preds = %continue
  %8 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance, i32 0, i32 0
  %load_DATE_ADD = load i64, i64* %DATE_ADD, align 4
  store i64 %load_DATE_ADD, i64* %8, align 4
  br label %call16

call16:                                           ; preds = %input15
  %call19 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %9 = sext i16 %call19 to i32
  %tmpVar20 = add i32 %2, %9
  %10 = trunc i32 %tmpVar20 to i16
  store i16 %10, i16* %yr, align 2
  %load_M = load i16, i16* %M, align 2
  %11 = sext i16 %load_M to i32
  %MONTH_OF_DATE_instance = alloca %MONTH_OF_DATE_interface, align 8
  br label %input21

input21:                                          ; preds = %continue18
  %12 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance, i32 0, i32 0
  %load_DATE_ADD25 = load i64, i64* %DATE_ADD, align 4
  store i64 %load_DATE_ADD25, i64* %12, align 4
  br label %call22

call22:                                           ; preds = %input21
  %call26 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %13 = sext i16 %call26 to i32
  %tmpVar27 = add i32 %11, %13
  %14 = trunc i32 %tmpVar27 to i16
  store i16 %14, i16* %mo, align 2
  %DAY_OF_MONTH_instance = alloca %DAY_OF_MONTH_interface, align 8
  br label %input28

input28:                                          ; preds = %continue24
  %15 = getelementptr inbounds %DAY_OF_MONTH_interface, %DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance, i32 0, i32 0
  %load_DATE_ADD32 = load i64, i64* %DATE_ADD, align 4
  store i64 %load_DATE_ADD32, i64* %15, align 4
  br label %call29

call29:                                           ; preds = %input28
  %call33 = call i16 @DAY_OF_MONTH(%DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance)
  br label %output30

output30:                                         ; preds = %call29
  br label %continue31

continue31:                                       ; preds = %output30
  store i16 %call33, i16* %dm, align 2
  br label %condition_check

condition_check:                                  ; preds = %continue31, %while_body
  %load_mo = load i16, i16* %mo, align 2
  %16 = sext i16 %load_mo to i32
  %tmpVar35 = icmp sgt i32 %16, 12
  br i1 %tmpVar35, label %while_body, label %continue34

while_body:                                       ; preds = %condition_check
  %load_mo36 = load i16, i16* %mo, align 2
  %17 = sext i16 %load_mo36 to i32
  %tmpVar37 = sub i32 %17, 12
  %18 = trunc i32 %tmpVar37 to i16
  store i16 %18, i16* %mo, align 2
  %load_yr = load i16, i16* %yr, align 2
  %19 = sext i16 %load_yr to i32
  %tmpVar38 = add i32 %19, 1
  %20 = trunc i32 %tmpVar38 to i16
  store i16 %20, i16* %yr, align 2
  br label %condition_check

continue34:                                       ; preds = %condition_check
  br label %condition_check39

condition_check39:                                ; preds = %continue34, %while_body40
  %load_mo42 = load i16, i16* %mo, align 2
  %21 = sext i16 %load_mo42 to i32
  %tmpVar43 = icmp slt i32 %21, 1
  br i1 %tmpVar43, label %while_body40, label %continue41

while_body40:                                     ; preds = %condition_check39
  %load_mo44 = load i16, i16* %mo, align 2
  %22 = sext i16 %load_mo44 to i32
  %tmpVar45 = add i32 %22, 12
  %23 = trunc i32 %tmpVar45 to i16
  store i16 %23, i16* %mo, align 2
  %load_yr46 = load i16, i16* %yr, align 2
  %24 = sext i16 %load_yr46 to i32
  %tmpVar47 = sub i32 %24, 1
  %25 = trunc i32 %tmpVar47 to i16
  store i16 %25, i16* %yr, align 2
  br label %condition_check39

continue41:                                       ; preds = %condition_check39
  %SET_DATE_instance = alloca %SET_DATE_interface, align 8
  br label %input48

input48:                                          ; preds = %continue41
  %26 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 0
  %load_yr52 = load i16, i16* %yr, align 2
  store i16 %load_yr52, i16* %26, align 2
  %27 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 1
  %load_mo53 = load i16, i16* %mo, align 2
  store i16 %load_mo53, i16* %27, align 2
  %28 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 2
  %load_dm = load i16, i16* %dm, align 2
  store i16 %load_dm, i16* %28, align 2
  br label %call49

call49:                                           ; preds = %input48
  %call54 = call i64 @SET_DATE(%SET_DATE_interface* %SET_DATE_instance)
  br label %output50

output50:                                         ; preds = %call49
  br label %continue51

continue51:                                       ; preds = %output50
  store i64 %call54, i64* %DATE_ADD, align 4
  %DATE_ADD_ret = load i64, i64* %DATE_ADD, align 4
  ret i64 %DATE_ADD_ret
}

define i32 @DAY_OF_DATE(%DAY_OF_DATE_interface* %0) {
entry:
  %idate = getelementptr inbounds %DAY_OF_DATE_interface, %DAY_OF_DATE_interface* %0, i32 0, i32 0
  %DAY_OF_DATE = alloca i32, align 4
  store i32 0, i32* %DAY_OF_DATE, align 4
  %DWORD_TO_DINT_instance = alloca %DWORD_TO_DINT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_DINT_interface, %DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance, i32 0, i32 0
  %DATE_TO_DWORD_instance = alloca %DATE_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i32 @DWORD_TO_DINT(%DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call6, i32* %DAY_OF_DATE, align 4
  %DAY_OF_DATE_ret = load i32, i32* %DAY_OF_DATE, align 4
  ret i32 %DAY_OF_DATE_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance, i32 0, i32 0
  %load_idate = load i64, i64* %idate, align 4
  store i64 %load_idate, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = sdiv i32 %call5, 86400
  store i32 %tmpVar, i32* %1, align 4
  br label %call
}

define i16 @DAY_OF_MONTH(%DAY_OF_MONTH_interface* %0) {
entry:
  %IDATE = getelementptr inbounds %DAY_OF_MONTH_interface, %DAY_OF_MONTH_interface* %0, i32 0, i32 0
  %leap = getelementptr inbounds %DAY_OF_MONTH_interface, %DAY_OF_MONTH_interface* %0, i32 0, i32 1
  %DAY_OF_MONTH = alloca i16, align 2
  store i16 0, i16* %leap, align 2
  store i16 0, i16* %DAY_OF_MONTH, align 2
  %DAY_OF_YEAR_instance = alloca %DAY_OF_YEAR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DAY_OF_YEAR_interface, %DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance, i32 0, i32 0
  %load_idate = load i64, i64* %IDATE, align 4
  store i64 %load_idate, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @DAY_OF_YEAR(%DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %DAY_OF_MONTH, align 2
  %BOOL_TO_INT_instance = alloca %BOOL_TO_INT_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %2 = getelementptr inbounds %BOOL_TO_INT_interface, %BOOL_TO_INT_interface* %BOOL_TO_INT_instance, i32 0, i32 0
  %LEAP_OF_DATE_instance = alloca %LEAP_OF_DATE_interface, align 8
  br label %input6

call3:                                            ; preds = %continue9
  %call12 = call i16 @BOOL_TO_INT(%BOOL_TO_INT_interface* %BOOL_TO_INT_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i16 %call12, i16* %leap, align 2
  %load_DAY_OF_MONTH = load i16, i16* %DAY_OF_MONTH, align 2
  %3 = sext i16 %load_DAY_OF_MONTH to i32
  %load_leap = load i16, i16* %leap, align 2
  %4 = sext i16 %load_leap to i32
  %tmpVar = sub i32 %3, %4
  %5 = trunc i32 %tmpVar to i16
  store i16 %5, i16* %DAY_OF_MONTH, align 2
  %load_DAY_OF_MONTH15 = load i16, i16* %DAY_OF_MONTH, align 2
  %6 = sext i16 %load_DAY_OF_MONTH15 to i32
  %load_ = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 8), align 2
  %7 = sext i16 %load_ to i32
  %tmpVar16 = icmp sgt i32 %6, %7
  br i1 %tmpVar16, label %condition_body, label %branch

input6:                                           ; preds = %input2
  %8 = getelementptr inbounds %LEAP_OF_DATE_interface, %LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance, i32 0, i32 0
  %load_idate10 = load i64, i64* %IDATE, align 4
  store i64 %load_idate10, i64* %8, align 4
  br label %call7

call7:                                            ; preds = %input6
  %call11 = call i8 @LEAP_OF_DATE(%LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  store i8 %call11, i8* %2, align 1
  br label %call3

condition_body:                                   ; preds = %continue5
  %load_DAY_OF_MONTH20 = load i16, i16* %DAY_OF_MONTH, align 2
  %9 = sext i16 %load_DAY_OF_MONTH20 to i32
  %load_21 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 10), align 2
  %10 = sext i16 %load_21 to i32
  %tmpVar22 = icmp sgt i32 %9, %10
  br i1 %tmpVar22, label %condition_body19, label %else17

branch:                                           ; preds = %continue5
  %load_DAY_OF_MONTH48 = load i16, i16* %DAY_OF_MONTH, align 2
  %11 = sext i16 %load_DAY_OF_MONTH48 to i32
  %load_49 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 4), align 2
  %12 = sext i16 %load_49 to i32
  %tmpVar50 = icmp sgt i32 %11, %12
  br i1 %tmpVar50, label %condition_body47, label %branch13

condition_body47:                                 ; preds = %branch
  %load_DAY_OF_MONTH54 = load i16, i16* %DAY_OF_MONTH, align 2
  %13 = sext i16 %load_DAY_OF_MONTH54 to i32
  %load_55 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 6), align 2
  %14 = sext i16 %load_55 to i32
  %tmpVar56 = icmp sgt i32 %13, %14
  br i1 %tmpVar56, label %condition_body53, label %else51

branch13:                                         ; preds = %branch
  %load_DAY_OF_MONTH82 = load i16, i16* %DAY_OF_MONTH, align 2
  %15 = sext i16 %load_DAY_OF_MONTH82 to i32
  %load_83 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 2), align 2
  %16 = sext i16 %load_83 to i32
  %tmpVar84 = icmp sgt i32 %15, %16
  br i1 %tmpVar84, label %condition_body81, label %else

condition_body81:                                 ; preds = %branch13
  %load_DAY_OF_MONTH88 = load i16, i16* %DAY_OF_MONTH, align 2
  %17 = sext i16 %load_DAY_OF_MONTH88 to i32
  %load_89 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 3), align 2
  %18 = sext i16 %load_89 to i32
  %tmpVar90 = icmp sgt i32 %17, %18
  br i1 %tmpVar90, label %condition_body87, label %else85

else:                                             ; preds = %branch13
  %load_DAY_OF_MONTH97 = load i16, i16* %DAY_OF_MONTH, align 2
  %19 = sext i16 %load_DAY_OF_MONTH97 to i32
  %load_leap98 = load i16, i16* %leap, align 2
  %20 = sext i16 %load_leap98 to i32
  %tmpVar99 = add i32 %19, %20
  %21 = trunc i32 %tmpVar99 to i16
  store i16 %21, i16* %DAY_OF_MONTH, align 2
  %load_DAY_OF_MONTH102 = load i16, i16* %DAY_OF_MONTH, align 2
  %22 = sext i16 %load_DAY_OF_MONTH102 to i32
  %load_103 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 1), align 2
  %23 = sext i16 %load_103 to i32
  %tmpVar104 = icmp sgt i32 %22, %23
  br i1 %tmpVar104, label %condition_body101, label %continue100

continue14:                                       ; preds = %continue100, %continue86, %continue52, %continue18
  %DAY_OF_MONTH_ret = load i16, i16* %DAY_OF_MONTH, align 2
  ret i16 %DAY_OF_MONTH_ret

condition_body19:                                 ; preds = %condition_body
  %load_DAY_OF_MONTH26 = load i16, i16* %DAY_OF_MONTH, align 2
  %24 = sext i16 %load_DAY_OF_MONTH26 to i32
  %load_27 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 11), align 2
  %25 = sext i16 %load_27 to i32
  %tmpVar28 = icmp sgt i32 %24, %25
  br i1 %tmpVar28, label %condition_body25, label %else23

else17:                                           ; preds = %condition_body
  %load_DAY_OF_MONTH38 = load i16, i16* %DAY_OF_MONTH, align 2
  %26 = sext i16 %load_DAY_OF_MONTH38 to i32
  %load_39 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 9), align 2
  %27 = sext i16 %load_39 to i32
  %tmpVar40 = icmp sgt i32 %26, %27
  br i1 %tmpVar40, label %condition_body37, label %else35

continue18:                                       ; preds = %continue36, %continue24
  br label %continue14

condition_body25:                                 ; preds = %condition_body19
  %load_DAY_OF_MONTH29 = load i16, i16* %DAY_OF_MONTH, align 2
  %28 = sext i16 %load_DAY_OF_MONTH29 to i32
  %load_30 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 11), align 2
  %29 = sext i16 %load_30 to i32
  %tmpVar31 = sub i32 %28, %29
  %30 = trunc i32 %tmpVar31 to i16
  store i16 %30, i16* %DAY_OF_MONTH, align 2
  br label %continue24

else23:                                           ; preds = %condition_body19
  %load_DAY_OF_MONTH32 = load i16, i16* %DAY_OF_MONTH, align 2
  %31 = sext i16 %load_DAY_OF_MONTH32 to i32
  %load_33 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 10), align 2
  %32 = sext i16 %load_33 to i32
  %tmpVar34 = sub i32 %31, %32
  %33 = trunc i32 %tmpVar34 to i16
  store i16 %33, i16* %DAY_OF_MONTH, align 2
  br label %continue24

continue24:                                       ; preds = %else23, %condition_body25
  br label %continue18

condition_body37:                                 ; preds = %else17
  %load_DAY_OF_MONTH41 = load i16, i16* %DAY_OF_MONTH, align 2
  %34 = sext i16 %load_DAY_OF_MONTH41 to i32
  %load_42 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 9), align 2
  %35 = sext i16 %load_42 to i32
  %tmpVar43 = sub i32 %34, %35
  %36 = trunc i32 %tmpVar43 to i16
  store i16 %36, i16* %DAY_OF_MONTH, align 2
  br label %continue36

else35:                                           ; preds = %else17
  %load_DAY_OF_MONTH44 = load i16, i16* %DAY_OF_MONTH, align 2
  %37 = sext i16 %load_DAY_OF_MONTH44 to i32
  %load_45 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 8), align 2
  %38 = sext i16 %load_45 to i32
  %tmpVar46 = sub i32 %37, %38
  %39 = trunc i32 %tmpVar46 to i16
  store i16 %39, i16* %DAY_OF_MONTH, align 2
  br label %continue36

continue36:                                       ; preds = %else35, %condition_body37
  br label %continue18

condition_body53:                                 ; preds = %condition_body47
  %load_DAY_OF_MONTH60 = load i16, i16* %DAY_OF_MONTH, align 2
  %40 = sext i16 %load_DAY_OF_MONTH60 to i32
  %load_61 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 7), align 2
  %41 = sext i16 %load_61 to i32
  %tmpVar62 = icmp sgt i32 %40, %41
  br i1 %tmpVar62, label %condition_body59, label %else57

else51:                                           ; preds = %condition_body47
  %load_DAY_OF_MONTH72 = load i16, i16* %DAY_OF_MONTH, align 2
  %42 = sext i16 %load_DAY_OF_MONTH72 to i32
  %load_73 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 5), align 2
  %43 = sext i16 %load_73 to i32
  %tmpVar74 = icmp sgt i32 %42, %43
  br i1 %tmpVar74, label %condition_body71, label %else69

continue52:                                       ; preds = %continue70, %continue58
  br label %continue14

condition_body59:                                 ; preds = %condition_body53
  %load_DAY_OF_MONTH63 = load i16, i16* %DAY_OF_MONTH, align 2
  %44 = sext i16 %load_DAY_OF_MONTH63 to i32
  %load_64 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 7), align 2
  %45 = sext i16 %load_64 to i32
  %tmpVar65 = sub i32 %44, %45
  %46 = trunc i32 %tmpVar65 to i16
  store i16 %46, i16* %DAY_OF_MONTH, align 2
  br label %continue58

else57:                                           ; preds = %condition_body53
  %load_DAY_OF_MONTH66 = load i16, i16* %DAY_OF_MONTH, align 2
  %47 = sext i16 %load_DAY_OF_MONTH66 to i32
  %load_67 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 6), align 2
  %48 = sext i16 %load_67 to i32
  %tmpVar68 = sub i32 %47, %48
  %49 = trunc i32 %tmpVar68 to i16
  store i16 %49, i16* %DAY_OF_MONTH, align 2
  br label %continue58

continue58:                                       ; preds = %else57, %condition_body59
  br label %continue52

condition_body71:                                 ; preds = %else51
  %load_DAY_OF_MONTH75 = load i16, i16* %DAY_OF_MONTH, align 2
  %50 = sext i16 %load_DAY_OF_MONTH75 to i32
  %load_76 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 5), align 2
  %51 = sext i16 %load_76 to i32
  %tmpVar77 = sub i32 %50, %51
  %52 = trunc i32 %tmpVar77 to i16
  store i16 %52, i16* %DAY_OF_MONTH, align 2
  br label %continue70

else69:                                           ; preds = %else51
  %load_DAY_OF_MONTH78 = load i16, i16* %DAY_OF_MONTH, align 2
  %53 = sext i16 %load_DAY_OF_MONTH78 to i32
  %load_79 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 4), align 2
  %54 = sext i16 %load_79 to i32
  %tmpVar80 = sub i32 %53, %54
  %55 = trunc i32 %tmpVar80 to i16
  store i16 %55, i16* %DAY_OF_MONTH, align 2
  br label %continue70

continue70:                                       ; preds = %else69, %condition_body71
  br label %continue52

condition_body87:                                 ; preds = %condition_body81
  %load_DAY_OF_MONTH91 = load i16, i16* %DAY_OF_MONTH, align 2
  %56 = sext i16 %load_DAY_OF_MONTH91 to i32
  %load_92 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 3), align 2
  %57 = sext i16 %load_92 to i32
  %tmpVar93 = sub i32 %56, %57
  %58 = trunc i32 %tmpVar93 to i16
  store i16 %58, i16* %DAY_OF_MONTH, align 2
  br label %continue86

else85:                                           ; preds = %condition_body81
  %load_DAY_OF_MONTH94 = load i16, i16* %DAY_OF_MONTH, align 2
  %59 = sext i16 %load_DAY_OF_MONTH94 to i32
  %load_95 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 2), align 2
  %60 = sext i16 %load_95 to i32
  %tmpVar96 = sub i32 %59, %60
  %61 = trunc i32 %tmpVar96 to i16
  store i16 %61, i16* %DAY_OF_MONTH, align 2
  br label %continue86

continue86:                                       ; preds = %else85, %condition_body87
  br label %continue14

condition_body101:                                ; preds = %else
  %load_DAY_OF_MONTH105 = load i16, i16* %DAY_OF_MONTH, align 2
  %62 = sext i16 %load_DAY_OF_MONTH105 to i32
  %load_106 = load i16, i16* getelementptr inbounds (%CONSTANTS_SETUP, %CONSTANTS_SETUP* @SETUP, i32 0, i32 2, i32 1), align 2
  %63 = sext i16 %load_106 to i32
  %tmpVar107 = sub i32 %62, %63
  %64 = trunc i32 %tmpVar107 to i16
  store i16 %64, i16* %DAY_OF_MONTH, align 2
  br label %continue100

continue100:                                      ; preds = %condition_body101, %else
  br label %continue14
}

define i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %0) {
entry:
  %IDATE = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %0, i32 0, i32 0
  %DAY_OF_WEEK = alloca i16, align 2
  store i16 0, i16* %DAY_OF_WEEK, align 2
  %DWORD_TO_INT_instance = alloca %DWORD_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance, i32 0, i32 0
  %DATE_TO_DWORD_instance = alloca %DATE_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call8 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %2 = sext i16 %call8 to i32
  %tmpVar9 = add i32 %2, 1
  %3 = trunc i32 %tmpVar9 to i16
  store i16 %3, i16* %DAY_OF_WEEK, align 2
  %DAY_OF_WEEK_ret = load i16, i16* %DAY_OF_WEEK, align 2
  ret i16 %DAY_OF_WEEK_ret

input1:                                           ; preds = %input
  %4 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance, i32 0, i32 0
  %load_idate = load i64, i64* %IDATE, align 4
  store i64 %load_idate, i64* %4, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = sdiv i32 %call5, 86400
  %tmpVar6 = add i32 %tmpVar, 3
  %tmpVar7 = srem i32 %tmpVar6, 7
  store i32 %tmpVar7, i32* %1, align 4
  br label %call
}

define i16 @DAY_OF_YEAR(%DAY_OF_YEAR_interface* %0) {
entry:
  %IDATE = getelementptr inbounds %DAY_OF_YEAR_interface, %DAY_OF_YEAR_interface* %0, i32 0, i32 0
  %DAY_OF_YEAR = alloca i16, align 2
  store i16 0, i16* %DAY_OF_YEAR, align 2
  %UDINT_TO_INT_instance = alloca %UDINT_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %UDINT_TO_INT_interface, %UDINT_TO_INT_interface* %UDINT_TO_INT_instance, i32 0, i32 0
  %DATE_TO_UDINT_instance = alloca %DATE_TO_UDINT_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call7 = call i16 @UDINT_TO_INT(%UDINT_TO_INT_interface* %UDINT_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call7, i16* %DAY_OF_YEAR, align 2
  %load_DAY_OF_YEAR = load i16, i16* %DAY_OF_YEAR, align 2
  %2 = sext i16 %load_DAY_OF_YEAR to i32
  %tmpVar9 = icmp sgt i32 %2, 729
  br i1 %tmpVar9, label %condition_body, label %branch

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %DATE_TO_UDINT_interface, %DATE_TO_UDINT_interface* %DATE_TO_UDINT_instance, i32 0, i32 0
  %load_idate = load i64, i64* %IDATE, align 4
  store i64 %load_idate, i64* %3, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DATE_TO_UDINT(%DATE_TO_UDINT_interface* %DATE_TO_UDINT_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = sdiv i32 %call5, 86400
  %tmpVar6 = srem i32 %tmpVar, 1461
  store i32 %tmpVar6, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  %load_DAY_OF_YEAR13 = load i16, i16* %DAY_OF_YEAR, align 2
  %4 = sext i16 %load_DAY_OF_YEAR13 to i32
  %tmpVar14 = icmp sgt i32 %4, 1095
  br i1 %tmpVar14, label %condition_body12, label %else10

branch:                                           ; preds = %continue
  %load_DAY_OF_YEAR20 = load i16, i16* %DAY_OF_YEAR, align 2
  %5 = sext i16 %load_DAY_OF_YEAR20 to i32
  %tmpVar21 = icmp sgt i32 %5, 364
  br i1 %tmpVar21, label %condition_body19, label %else

condition_body19:                                 ; preds = %branch
  %load_DAY_OF_YEAR22 = load i16, i16* %DAY_OF_YEAR, align 2
  %6 = sext i16 %load_DAY_OF_YEAR22 to i32
  %tmpVar23 = sub i32 %6, 364
  %7 = trunc i32 %tmpVar23 to i16
  store i16 %7, i16* %DAY_OF_YEAR, align 2
  br label %continue8

else:                                             ; preds = %branch
  %load_DAY_OF_YEAR24 = load i16, i16* %DAY_OF_YEAR, align 2
  %8 = sext i16 %load_DAY_OF_YEAR24 to i32
  %tmpVar25 = add i32 %8, 1
  %9 = trunc i32 %tmpVar25 to i16
  store i16 %9, i16* %DAY_OF_YEAR, align 2
  br label %continue8

continue8:                                        ; preds = %else, %condition_body19, %continue11
  %DAY_OF_YEAR_ret = load i16, i16* %DAY_OF_YEAR, align 2
  ret i16 %DAY_OF_YEAR_ret

condition_body12:                                 ; preds = %condition_body
  %load_DAY_OF_YEAR15 = load i16, i16* %DAY_OF_YEAR, align 2
  %10 = sext i16 %load_DAY_OF_YEAR15 to i32
  %tmpVar16 = sub i32 %10, 1095
  %11 = trunc i32 %tmpVar16 to i16
  store i16 %11, i16* %DAY_OF_YEAR, align 2
  br label %continue11

else10:                                           ; preds = %condition_body
  %load_DAY_OF_YEAR17 = load i16, i16* %DAY_OF_YEAR, align 2
  %12 = sext i16 %load_DAY_OF_YEAR17 to i32
  %tmpVar18 = sub i32 %12, 729
  %13 = trunc i32 %tmpVar18 to i16
  store i16 %13, i16* %DAY_OF_YEAR, align 2
  br label %continue11

continue11:                                       ; preds = %else10, %condition_body12
  br label %continue8
}

define i64 @DAY_TO_TIME(%DAY_TO_TIME_interface* %0) {
entry:
  %IN = getelementptr inbounds %DAY_TO_TIME_interface, %DAY_TO_TIME_interface* %0, i32 0, i32 0
  %DAY_TO_TIME = alloca i64, align 8
  store i64 0, i64* %DAY_TO_TIME, align 4
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %DAY_TO_TIME, align 4
  %DAY_TO_TIME_ret = load i64, i64* %DAY_TO_TIME, align 4
  ret i64 %DAY_TO_TIME_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %load_IN = load float, float* %IN, align 4
  %tmpVar = fmul float %load_IN, 8.640000e+07
  store float %tmpVar, float* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call
}

define i32 @DAYS_DELTA(%DAYS_DELTA_interface* %0) {
entry:
  %date_1 = getelementptr inbounds %DAYS_DELTA_interface, %DAYS_DELTA_interface* %0, i32 0, i32 0
  %date_2 = getelementptr inbounds %DAYS_DELTA_interface, %DAYS_DELTA_interface* %0, i32 0, i32 1
  %DAYS_DELTA = alloca i32, align 4
  store i32 0, i32* %DAYS_DELTA, align 4
  %load_DATE_1 = load i64, i64* %date_1, align 4
  %load_DATE_2 = load i64, i64* %date_2, align 4
  %tmpVar = icmp sgt i64 %load_DATE_1, %load_DATE_2
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %DWORD_TO_DINT_instance = alloca %DWORD_TO_DINT_interface, align 8
  br label %input

else:                                             ; preds = %entry
  %DWORD_TO_DINT_instance17 = alloca %DWORD_TO_DINT_interface, align 8
  br label %input18

continue:                                         ; preds = %continue21, %continue1
  %DAYS_DELTA_ret = load i32, i32* %DAYS_DELTA, align 4
  ret i32 %DAYS_DELTA_ret

input:                                            ; preds = %condition_body
  %1 = getelementptr inbounds %DWORD_TO_DINT_interface, %DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance, i32 0, i32 0
  %DATE_TO_DWORD_instance = alloca %DATE_TO_DWORD_interface, align 8
  br label %input2

call:                                             ; preds = %continue11
  %call15 = call i32 @DWORD_TO_DINT(%DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %tmpVar16 = sub i32 0, %call15
  store i32 %tmpVar16, i32* %DAYS_DELTA, align 4
  br label %continue

input2:                                           ; preds = %input
  %2 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance, i32 0, i32 0
  %load_date_1 = load i64, i64* %date_1, align 4
  store i64 %load_date_1, i64* %2, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %DATE_TO_DWORD_instance7 = alloca %DATE_TO_DWORD_interface, align 8
  br label %input8

input8:                                           ; preds = %continue5
  %3 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance7, i32 0, i32 0
  %load_date_2 = load i64, i64* %date_2, align 4
  store i64 %load_date_2, i64* %3, align 4
  br label %call9

call9:                                            ; preds = %input8
  %call12 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance7)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %tmpVar13 = sub i32 %call6, %call12
  %tmpVar14 = sdiv i32 %tmpVar13, 86400
  store i32 %tmpVar14, i32* %1, align 4
  br label %call

input18:                                          ; preds = %else
  %4 = getelementptr inbounds %DWORD_TO_DINT_interface, %DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance17, i32 0, i32 0
  %DATE_TO_DWORD_instance22 = alloca %DATE_TO_DWORD_interface, align 8
  br label %input23

call19:                                           ; preds = %continue33
  %call38 = call i32 @DWORD_TO_DINT(%DWORD_TO_DINT_interface* %DWORD_TO_DINT_instance17)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  store i32 %call38, i32* %DAYS_DELTA, align 4
  br label %continue

input23:                                          ; preds = %input18
  %5 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance22, i32 0, i32 0
  %load_date_227 = load i64, i64* %date_2, align 4
  store i64 %load_date_227, i64* %5, align 4
  br label %call24

call24:                                           ; preds = %input23
  %call28 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance22)
  br label %output25

output25:                                         ; preds = %call24
  br label %continue26

continue26:                                       ; preds = %output25
  %DATE_TO_DWORD_instance29 = alloca %DATE_TO_DWORD_interface, align 8
  br label %input30

input30:                                          ; preds = %continue26
  %6 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance29, i32 0, i32 0
  %load_date_134 = load i64, i64* %date_1, align 4
  store i64 %load_date_134, i64* %6, align 4
  br label %call31

call31:                                           ; preds = %input30
  %call35 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance29)
  br label %output32

output32:                                         ; preds = %call31
  br label %continue33

continue33:                                       ; preds = %output32
  %tmpVar36 = sub i32 %call28, %call35
  %tmpVar37 = sdiv i32 %tmpVar36, 86400
  store i32 %tmpVar37, i32* %4, align 4
  br label %call19
}

define i16 @DAYS_IN_MONTH(%DAYS_IN_MONTH_interface* %0) {
entry:
  %IDATE = getelementptr inbounds %DAYS_IN_MONTH_interface, %DAYS_IN_MONTH_interface* %0, i32 0, i32 0
  %DAYS_IN_MONTH = alloca i16, align 2
  store i16 0, i16* %DAYS_IN_MONTH, align 2
  %DAY_OF_YEAR_instance = alloca %DAY_OF_YEAR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DAY_OF_YEAR_interface, %DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance, i32 0, i32 0
  %load_IDATE = load i64, i64* %IDATE, align 4
  store i64 %load_IDATE, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @DAY_OF_YEAR(%DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %DAYS_IN_MONTH, align 2
  %LEAP_OF_DATE_instance = alloca %LEAP_OF_DATE_interface, align 8
  br label %input3

condition_body:                                   ; preds = %continue6
  %load_DAYS_IN_MONTH = load i16, i16* %DAYS_IN_MONTH, align 2
  switch i16 %load_DAYS_IN_MONTH, label %else10 [
  ]

else:                                             ; preds = %continue6
  %load_DAYS_IN_MONTH43 = load i16, i16* %DAYS_IN_MONTH, align 2
  switch i16 %load_DAYS_IN_MONTH43, label %else44 [
  ]

continue2:                                        ; preds = %continue42, %continue9
  %DAYS_IN_MONTH_ret = load i16, i16* %DAYS_IN_MONTH, align 2
  ret i16 %DAYS_IN_MONTH_ret

input3:                                           ; preds = %continue
  %2 = getelementptr inbounds %LEAP_OF_DATE_interface, %LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance, i32 0, i32 0
  %load_IDATE7 = load i64, i64* %IDATE, align 4
  store i64 %load_IDATE7, i64* %2, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call i8 @LEAP_OF_DATE(%LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %3 = icmp ne i8 %call8, 0
  br i1 %3, label %condition_body, label %else

case:                                             ; preds = %range_then
  store i16 29, i16* %DAYS_IN_MONTH, align 2
  br label %continue9

case14:                                           ; preds = %range_then15
  store i16 30, i16* %DAYS_IN_MONTH, align 2
  br label %continue9

case21:                                           ; preds = %range_then22
  store i16 30, i16* %DAYS_IN_MONTH, align 2
  br label %continue9

case28:                                           ; preds = %range_then29
  store i16 30, i16* %DAYS_IN_MONTH, align 2
  br label %continue9

case35:                                           ; preds = %range_then36
  store i16 30, i16* %DAYS_IN_MONTH, align 2
  br label %continue9

else10:                                           ; preds = %condition_body
  %load_DAYS_IN_MONTH11 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar = icmp sge i16 %load_DAYS_IN_MONTH11, 32
  br i1 %tmpVar, label %range_then, label %range_else

range_then:                                       ; preds = %else10
  %load_DAYS_IN_MONTH12 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar13 = icmp sle i16 %load_DAYS_IN_MONTH12, 60
  br i1 %tmpVar13, label %case, label %range_else

range_else:                                       ; preds = %range_then, %else10
  %load_DAYS_IN_MONTH17 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar18 = icmp sge i16 %load_DAYS_IN_MONTH17, 92
  br i1 %tmpVar18, label %range_then15, label %range_else16

range_then15:                                     ; preds = %range_else
  %load_DAYS_IN_MONTH19 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar20 = icmp sle i16 %load_DAYS_IN_MONTH19, 121
  br i1 %tmpVar20, label %case14, label %range_else16

range_else16:                                     ; preds = %range_then15, %range_else
  %load_DAYS_IN_MONTH24 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar25 = icmp sge i16 %load_DAYS_IN_MONTH24, 153
  br i1 %tmpVar25, label %range_then22, label %range_else23

range_then22:                                     ; preds = %range_else16
  %load_DAYS_IN_MONTH26 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar27 = icmp sle i16 %load_DAYS_IN_MONTH26, 182
  br i1 %tmpVar27, label %case21, label %range_else23

range_else23:                                     ; preds = %range_then22, %range_else16
  %load_DAYS_IN_MONTH31 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar32 = icmp sge i16 %load_DAYS_IN_MONTH31, 245
  br i1 %tmpVar32, label %range_then29, label %range_else30

range_then29:                                     ; preds = %range_else23
  %load_DAYS_IN_MONTH33 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar34 = icmp sle i16 %load_DAYS_IN_MONTH33, 274
  br i1 %tmpVar34, label %case28, label %range_else30

range_else30:                                     ; preds = %range_then29, %range_else23
  %load_DAYS_IN_MONTH38 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar39 = icmp sge i16 %load_DAYS_IN_MONTH38, 306
  br i1 %tmpVar39, label %range_then36, label %range_else37

range_then36:                                     ; preds = %range_else30
  %load_DAYS_IN_MONTH40 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar41 = icmp sle i16 %load_DAYS_IN_MONTH40, 335
  br i1 %tmpVar41, label %case35, label %range_else37

range_else37:                                     ; preds = %range_then36, %range_else30
  store i16 31, i16* %DAYS_IN_MONTH, align 2
  br label %continue9

continue9:                                        ; preds = %range_else37, %case35, %case28, %case21, %case14, %case
  br label %continue2

case45:                                           ; preds = %range_then46
  store i16 28, i16* %DAYS_IN_MONTH, align 2
  br label %continue42

case52:                                           ; preds = %range_then53
  store i16 30, i16* %DAYS_IN_MONTH, align 2
  br label %continue42

case59:                                           ; preds = %range_then60
  store i16 30, i16* %DAYS_IN_MONTH, align 2
  br label %continue42

case66:                                           ; preds = %range_then67
  store i16 30, i16* %DAYS_IN_MONTH, align 2
  br label %continue42

case73:                                           ; preds = %range_then74
  store i16 30, i16* %DAYS_IN_MONTH, align 2
  br label %continue42

else44:                                           ; preds = %else
  %load_DAYS_IN_MONTH48 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar49 = icmp sge i16 %load_DAYS_IN_MONTH48, 32
  br i1 %tmpVar49, label %range_then46, label %range_else47

range_then46:                                     ; preds = %else44
  %load_DAYS_IN_MONTH50 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar51 = icmp sle i16 %load_DAYS_IN_MONTH50, 59
  br i1 %tmpVar51, label %case45, label %range_else47

range_else47:                                     ; preds = %range_then46, %else44
  %load_DAYS_IN_MONTH55 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar56 = icmp sge i16 %load_DAYS_IN_MONTH55, 91
  br i1 %tmpVar56, label %range_then53, label %range_else54

range_then53:                                     ; preds = %range_else47
  %load_DAYS_IN_MONTH57 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar58 = icmp sle i16 %load_DAYS_IN_MONTH57, 120
  br i1 %tmpVar58, label %case52, label %range_else54

range_else54:                                     ; preds = %range_then53, %range_else47
  %load_DAYS_IN_MONTH62 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar63 = icmp sge i16 %load_DAYS_IN_MONTH62, 152
  br i1 %tmpVar63, label %range_then60, label %range_else61

range_then60:                                     ; preds = %range_else54
  %load_DAYS_IN_MONTH64 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar65 = icmp sle i16 %load_DAYS_IN_MONTH64, 181
  br i1 %tmpVar65, label %case59, label %range_else61

range_else61:                                     ; preds = %range_then60, %range_else54
  %load_DAYS_IN_MONTH69 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar70 = icmp sge i16 %load_DAYS_IN_MONTH69, 244
  br i1 %tmpVar70, label %range_then67, label %range_else68

range_then67:                                     ; preds = %range_else61
  %load_DAYS_IN_MONTH71 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar72 = icmp sle i16 %load_DAYS_IN_MONTH71, 273
  br i1 %tmpVar72, label %case66, label %range_else68

range_else68:                                     ; preds = %range_then67, %range_else61
  %load_DAYS_IN_MONTH76 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar77 = icmp sge i16 %load_DAYS_IN_MONTH76, 305
  br i1 %tmpVar77, label %range_then74, label %range_else75

range_then74:                                     ; preds = %range_else68
  %load_DAYS_IN_MONTH78 = load i16, i16* %DAYS_IN_MONTH, align 2
  %tmpVar79 = icmp sle i16 %load_DAYS_IN_MONTH78, 334
  br i1 %tmpVar79, label %case73, label %range_else75

range_else75:                                     ; preds = %range_then74, %range_else68
  store i16 31, i16* %DAYS_IN_MONTH, align 2
  br label %continue42

continue42:                                       ; preds = %range_else75, %case73, %case66, %case59, %case52, %case45
  br label %continue2
}

define i16 @DAYS_IN_YEAR(%DAYS_IN_YEAR_interface* %0) {
entry:
  %IDATE = getelementptr inbounds %DAYS_IN_YEAR_interface, %DAYS_IN_YEAR_interface* %0, i32 0, i32 0
  %DAYS_IN_YEAR = alloca i16, align 2
  store i16 0, i16* %DAYS_IN_YEAR, align 2
  %LEAP_OF_DATE_instance = alloca %LEAP_OF_DATE_interface, align 8
  br label %input

condition_body:                                   ; preds = %continue1
  store i16 366, i16* %DAYS_IN_YEAR, align 2
  br label %continue

else:                                             ; preds = %continue1
  store i16 365, i16* %DAYS_IN_YEAR, align 2
  br label %continue

continue:                                         ; preds = %else, %condition_body
  %DAYS_IN_YEAR_ret = load i16, i16* %DAYS_IN_YEAR, align 2
  ret i16 %DAYS_IN_YEAR_ret

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LEAP_OF_DATE_interface, %LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance, i32 0, i32 0
  %load_IDATE = load i64, i64* %IDATE, align 4
  store i64 %load_IDATE, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call2 = call i8 @LEAP_OF_DATE(%LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  %2 = icmp ne i8 %call2, 0
  br i1 %2, label %condition_body, label %else
}

define void @DCF77(%DCF77_interface* %0) {
entry:
  %REC = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 0
  %SET = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 1
  %SDT = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 2
  %DSI = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 3
  %SYNC_TIMEOUT = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 4
  %TIME_OFFSET = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 5
  %DST_EN = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 6
  %TP = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 7
  %DS = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 8
  %WDAY = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 9
  %ERROR = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 10
  %RTC = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 11
  %RTC1 = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 12
  %MSEC = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 13
  %SYNC = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 14
  %mez = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 15
  %utc = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 16
  %state = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 17
  %edge = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 18
  %tx = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 19
  %ty = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 20
  %last = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 21
  %bits = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 22
  %cnt = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 23
  %i = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 24
  %old_time = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 25
  %minute = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 26
  %hour = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 27
  %day = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 28
  %month = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 29
  %year = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 30
  %last_sync = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 31
  %t1 = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 32
  %tz = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 33
  %init = getelementptr inbounds %DCF77_interface, %DCF77_interface* %0, i32 0, i32 34
  store i8 0, i8* %TP, align 1
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %t1, align 4
  %load_t1 = load i64, i64* %t1, align 4
  %load_last = load i64, i64* %last, align 4
  %tmpVar = sub i64 %load_t1, %load_last
  store i64 %tmpVar, i64* %tx, align 4
  %load_rec = load i8, i8* %REC, align 1
  %2 = zext i8 %load_rec to i32
  %load_edge = load i8, i8* %edge, align 1
  %3 = zext i8 %load_edge to i32
  %tmpVar8 = xor i32 %2, %3
  %4 = icmp ne i32 %tmpVar8, 0
  br i1 %4, label %condition_body, label %continue7

input1:                                           ; preds = %input
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  %load_rec9 = load i8, i8* %REC, align 1
  store i8 %load_rec9, i8* %edge, align 1
  %load_rec14 = load i8, i8* %REC, align 1
  %tmpVar15 = xor i8 %load_rec14, -1
  %5 = zext i8 %tmpVar15 to i32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %23, label %25

continue7:                                        ; preds = %continue54, %continue
  %DWORD_TO_TIME_instance400 = alloca %DWORD_TO_TIME_interface, align 8
  br label %input401

condition_body13:                                 ; preds = %20
  store i16 0, i16* %state, align 2
  %load_error = load i8, i8* %ERROR, align 1
  %tmpVar19 = xor i8 %load_error, -1
  store i8 %tmpVar19, i8* %TP, align 1
  br label %continue12

branch:                                           ; preds = %20
  %load_rec21 = load i8, i8* %REC, align 1
  %tmpVar22 = xor i8 %load_rec21, -1
  %7 = zext i8 %tmpVar22 to i32
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %33, label %35

condition_body20:                                 ; preds = %30
  %load_state = load i16, i16* %state, align 2
  %9 = sext i16 %load_state to i32
  %tmpVar30 = icmp slt i32 %9, 58
  br i1 %tmpVar30, label %condition_body29, label %else27

branch10:                                         ; preds = %30
  %load_rec34 = load i8, i8* %REC, align 1
  %10 = zext i8 %load_rec34 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %40, label %42

condition_body33:                                 ; preds = %42
  %load_state37 = load i16, i16* %state, align 2
  %12 = sext i16 %load_state37 to i32
  %tmpVar38 = mul i32 1, %12
  %tmpVar39 = add i32 %tmpVar38, 0
  %tmpVar40 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 %tmpVar39
  store i8 0, i8* %tmpVar40, align 1
  br label %continue12

branch11:                                         ; preds = %42
  %load_rec42 = load i8, i8* %REC, align 1
  %13 = zext i8 %load_rec42 to i32
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %50, label %52

condition_body41:                                 ; preds = %47
  %load_state47 = load i16, i16* %state, align 2
  %15 = sext i16 %load_state47 to i32
  %tmpVar48 = mul i32 1, %15
  %tmpVar49 = add i32 %tmpVar48, 0
  %tmpVar50 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 %tmpVar49
  store i8 1, i8* %tmpVar50, align 1
  br label %continue12

else:                                             ; preds = %47
  store i8 1, i8* %ERROR, align 1
  store i16 0, i16* %state, align 2
  br label %continue12

continue12:                                       ; preds = %else, %condition_body41, %condition_body33, %continue28, %condition_body13
  %load_last51 = load i64, i64* %last, align 4
  %load_tx52 = load i64, i64* %tx, align 4
  %tmpVar53 = add i64 %load_last51, %load_tx52
  store i64 %tmpVar53, i64* %last, align 4
  %load_rec56 = load i8, i8* %REC, align 1
  %16 = zext i8 %load_rec56 to i32
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %57, label %60

18:                                               ; preds = %25
  %load_tx17 = load i64, i64* %tx, align 4
  %tmpVar18 = icmp slt i64 %load_tx17, 2000000000
  %19 = zext i1 %tmpVar18 to i32
  br label %20

20:                                               ; preds = %18, %25
  %21 = phi i32 [ %26, %25 ], [ %19, %18 ]
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %condition_body13, label %branch

23:                                               ; preds = %condition_body
  %load_tx = load i64, i64* %tx, align 4
  %tmpVar16 = icmp sgt i64 %load_tx, 1700000000
  %24 = zext i1 %tmpVar16 to i32
  br label %25

25:                                               ; preds = %23, %condition_body
  %26 = phi i32 [ %5, %condition_body ], [ %24, %23 ]
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %18, label %20

28:                                               ; preds = %35
  %load_tx25 = load i64, i64* %tx, align 4
  %tmpVar26 = icmp slt i64 %load_tx25, 1000000000
  %29 = zext i1 %tmpVar26 to i32
  br label %30

30:                                               ; preds = %28, %35
  %31 = phi i32 [ %36, %35 ], [ %29, %28 ]
  %32 = icmp ne i32 %31, 0
  br i1 %32, label %condition_body20, label %branch10

33:                                               ; preds = %branch
  %load_tx23 = load i64, i64* %tx, align 4
  %tmpVar24 = icmp sgt i64 %load_tx23, 700000000
  %34 = zext i1 %tmpVar24 to i32
  br label %35

35:                                               ; preds = %33, %branch
  %36 = phi i32 [ %7, %branch ], [ %34, %33 ]
  %37 = icmp ne i32 %36, 0
  br i1 %37, label %28, label %30

condition_body29:                                 ; preds = %condition_body20
  %load_state31 = load i16, i16* %state, align 2
  %38 = sext i16 %load_state31 to i32
  %tmpVar32 = add i32 %38, 1
  %39 = trunc i32 %tmpVar32 to i16
  store i16 %39, i16* %state, align 2
  br label %continue28

else27:                                           ; preds = %condition_body20
  store i16 0, i16* %state, align 2
  br label %continue28

continue28:                                       ; preds = %else27, %condition_body29
  br label %continue12

40:                                               ; preds = %branch10
  %load_tx35 = load i64, i64* %tx, align 4
  %tmpVar36 = icmp slt i64 %load_tx35, 120000000
  %41 = zext i1 %tmpVar36 to i32
  br label %42

42:                                               ; preds = %40, %branch10
  %43 = phi i32 [ %10, %branch10 ], [ %41, %40 ]
  %44 = icmp ne i32 %43, 0
  br i1 %44, label %condition_body33, label %branch11

45:                                               ; preds = %52
  %load_tx45 = load i64, i64* %tx, align 4
  %tmpVar46 = icmp slt i64 %load_tx45, 250000000
  %46 = zext i1 %tmpVar46 to i32
  br label %47

47:                                               ; preds = %45, %52
  %48 = phi i32 [ %53, %52 ], [ %46, %45 ]
  %49 = icmp ne i32 %48, 0
  br i1 %49, label %condition_body41, label %else

50:                                               ; preds = %branch11
  %load_tx43 = load i64, i64* %tx, align 4
  %tmpVar44 = icmp sgt i64 %load_tx43, 120000000
  %51 = zext i1 %tmpVar44 to i32
  br label %52

52:                                               ; preds = %50, %branch11
  %53 = phi i32 [ %13, %branch11 ], [ %51, %50 ]
  %54 = icmp ne i32 %53, 0
  br i1 %54, label %45, label %47

condition_body55:                                 ; preds = %60
  store i8 0, i8* %ERROR, align 1
  %tmpVar61 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 0
  %load_tmpVar = load i8, i8* %tmpVar61, align 1
  %55 = zext i8 %load_tmpVar to i32
  %56 = icmp ne i32 %55, 0
  br i1 %56, label %80, label %77

continue54:                                       ; preds = %continue341, %60
  br label %continue7

57:                                               ; preds = %continue12
  %load_state57 = load i16, i16* %state, align 2
  %58 = sext i16 %load_state57 to i32
  %tmpVar58 = icmp eq i32 %58, 58
  %59 = zext i1 %tmpVar58 to i32
  br label %60

60:                                               ; preds = %57, %continue12
  %61 = phi i32 [ %16, %continue12 ], [ %59, %57 ]
  %62 = icmp ne i32 %61, 0
  br i1 %62, label %condition_body55, label %continue54

condition_body60:                                 ; preds = %74
  store i8 1, i8* %ERROR, align 1
  br label %continue59

continue59:                                       ; preds = %condition_body60, %74
  store i16 0, i16* %minute, align 2
  %63 = load i16, i16* %minute, align 2
  %erase = and i16 %63, -2
  %tmpVar71 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 21
  %load_tmpVar72 = load i8, i8* %tmpVar71, align 1
  %64 = zext i8 %load_tmpVar72 to i16
  %value = shl i16 %64, 0
  %or = or i16 %erase, %value
  store i16 %or, i16* %minute, align 2
  %65 = load i16, i16* %minute, align 2
  %erase73 = and i16 %65, -3
  %tmpVar74 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 22
  %load_tmpVar75 = load i8, i8* %tmpVar74, align 1
  %66 = zext i8 %load_tmpVar75 to i16
  %value76 = shl i16 %66, 1
  %or77 = or i16 %erase73, %value76
  store i16 %or77, i16* %minute, align 2
  %67 = load i16, i16* %minute, align 2
  %erase78 = and i16 %67, -5
  %tmpVar79 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 23
  %load_tmpVar80 = load i8, i8* %tmpVar79, align 1
  %68 = zext i8 %load_tmpVar80 to i16
  %value81 = shl i16 %68, 2
  %or82 = or i16 %erase78, %value81
  store i16 %or82, i16* %minute, align 2
  %69 = load i16, i16* %minute, align 2
  %erase83 = and i16 %69, -9
  %tmpVar84 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 24
  %load_tmpVar85 = load i8, i8* %tmpVar84, align 1
  %70 = zext i8 %load_tmpVar85 to i16
  %value86 = shl i16 %70, 3
  %or87 = or i16 %erase83, %value86
  store i16 %or87, i16* %minute, align 2
  %tmpVar90 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 25
  %load_tmpVar91 = load i8, i8* %tmpVar90, align 1
  %71 = icmp ne i8 %load_tmpVar91, 0
  br i1 %71, label %condition_body89, label %continue88

72:                                               ; preds = %80
  %tmpVar68 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 20
  %load_tmpVar69 = load i8, i8* %tmpVar68, align 1
  %tmpVar70 = xor i8 %load_tmpVar69, -1
  %73 = zext i8 %tmpVar70 to i32
  br label %74

74:                                               ; preds = %72, %80
  %75 = phi i32 [ %81, %80 ], [ %73, %72 ]
  %76 = icmp ne i32 %75, 0
  br i1 %76, label %condition_body60, label %continue59

77:                                               ; preds = %condition_body55
  %tmpVar62 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 17
  %load_tmpVar63 = load i8, i8* %tmpVar62, align 1
  %78 = zext i8 %load_tmpVar63 to i32
  %tmpVar64 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 18
  %load_tmpVar65 = load i8, i8* %tmpVar64, align 1
  %79 = zext i8 %load_tmpVar65 to i32
  %tmpVar66 = xor i32 %78, %79
  %tmpVar67 = xor i32 %tmpVar66, -1
  br label %80

80:                                               ; preds = %77, %condition_body55
  %81 = phi i32 [ %55, %condition_body55 ], [ %tmpVar67, %77 ]
  %82 = icmp ne i32 %81, 0
  br i1 %82, label %74, label %72

condition_body89:                                 ; preds = %continue59
  %load_MINUTE = load i16, i16* %minute, align 2
  %83 = sext i16 %load_MINUTE to i32
  %tmpVar92 = add i32 %83, 10
  %84 = trunc i32 %tmpVar92 to i16
  store i16 %84, i16* %minute, align 2
  br label %continue88

continue88:                                       ; preds = %condition_body89, %continue59
  %tmpVar95 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 26
  %load_tmpVar96 = load i8, i8* %tmpVar95, align 1
  %85 = icmp ne i8 %load_tmpVar96, 0
  br i1 %85, label %condition_body94, label %continue93

condition_body94:                                 ; preds = %continue88
  %load_MINUTE97 = load i16, i16* %minute, align 2
  %86 = sext i16 %load_MINUTE97 to i32
  %tmpVar98 = add i32 %86, 20
  %87 = trunc i32 %tmpVar98 to i16
  store i16 %87, i16* %minute, align 2
  br label %continue93

continue93:                                       ; preds = %condition_body94, %continue88
  %tmpVar101 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 27
  %load_tmpVar102 = load i8, i8* %tmpVar101, align 1
  %88 = icmp ne i8 %load_tmpVar102, 0
  br i1 %88, label %condition_body100, label %continue99

condition_body100:                                ; preds = %continue93
  %load_MINUTE103 = load i16, i16* %minute, align 2
  %89 = sext i16 %load_MINUTE103 to i32
  %tmpVar104 = add i32 %89, 40
  %90 = trunc i32 %tmpVar104 to i16
  store i16 %90, i16* %minute, align 2
  br label %continue99

continue99:                                       ; preds = %condition_body100, %continue93
  %load_MINUTE107 = load i16, i16* %minute, align 2
  %91 = sext i16 %load_MINUTE107 to i32
  %tmpVar108 = icmp sgt i32 %91, 59
  %92 = zext i1 %tmpVar108 to i32
  %93 = icmp ne i32 %92, 0
  br i1 %93, label %112, label %103

condition_body106:                                ; preds = %112
  store i8 1, i8* %ERROR, align 1
  br label %continue105

continue105:                                      ; preds = %condition_body106, %112
  store i16 0, i16* %hour, align 2
  %94 = load i16, i16* %hour, align 2
  %erase132 = and i16 %94, -2
  %tmpVar133 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 29
  %load_tmpVar134 = load i8, i8* %tmpVar133, align 1
  %95 = zext i8 %load_tmpVar134 to i16
  %value135 = shl i16 %95, 0
  %or136 = or i16 %erase132, %value135
  store i16 %or136, i16* %hour, align 2
  %96 = load i16, i16* %hour, align 2
  %erase137 = and i16 %96, -3
  %tmpVar138 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 30
  %load_tmpVar139 = load i8, i8* %tmpVar138, align 1
  %97 = zext i8 %load_tmpVar139 to i16
  %value140 = shl i16 %97, 1
  %or141 = or i16 %erase137, %value140
  store i16 %or141, i16* %hour, align 2
  %98 = load i16, i16* %hour, align 2
  %erase142 = and i16 %98, -5
  %tmpVar143 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 31
  %load_tmpVar144 = load i8, i8* %tmpVar143, align 1
  %99 = zext i8 %load_tmpVar144 to i16
  %value145 = shl i16 %99, 2
  %or146 = or i16 %erase142, %value145
  store i16 %or146, i16* %hour, align 2
  %100 = load i16, i16* %hour, align 2
  %erase147 = and i16 %100, -9
  %tmpVar148 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 32
  %load_tmpVar149 = load i8, i8* %tmpVar148, align 1
  %101 = zext i8 %load_tmpVar149 to i16
  %value150 = shl i16 %101, 3
  %or151 = or i16 %erase147, %value150
  store i16 %or151, i16* %hour, align 2
  %tmpVar154 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 33
  %load_tmpVar155 = load i8, i8* %tmpVar154, align 1
  %102 = icmp ne i8 %load_tmpVar155, 0
  br i1 %102, label %condition_body153, label %continue152

103:                                              ; preds = %continue99
  %tmpVar109 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 21
  %load_tmpVar110 = load i8, i8* %tmpVar109, align 1
  %104 = zext i8 %load_tmpVar110 to i32
  %tmpVar111 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 22
  %load_tmpVar112 = load i8, i8* %tmpVar111, align 1
  %105 = zext i8 %load_tmpVar112 to i32
  %tmpVar113 = xor i32 %104, %105
  %tmpVar114 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 23
  %load_tmpVar115 = load i8, i8* %tmpVar114, align 1
  %106 = zext i8 %load_tmpVar115 to i32
  %tmpVar116 = xor i32 %tmpVar113, %106
  %tmpVar117 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 24
  %load_tmpVar118 = load i8, i8* %tmpVar117, align 1
  %107 = zext i8 %load_tmpVar118 to i32
  %tmpVar119 = xor i32 %tmpVar116, %107
  %tmpVar120 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 25
  %load_tmpVar121 = load i8, i8* %tmpVar120, align 1
  %108 = zext i8 %load_tmpVar121 to i32
  %tmpVar122 = xor i32 %tmpVar119, %108
  %tmpVar123 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 26
  %load_tmpVar124 = load i8, i8* %tmpVar123, align 1
  %109 = zext i8 %load_tmpVar124 to i32
  %tmpVar125 = xor i32 %tmpVar122, %109
  %tmpVar126 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 27
  %load_tmpVar127 = load i8, i8* %tmpVar126, align 1
  %110 = zext i8 %load_tmpVar127 to i32
  %tmpVar128 = xor i32 %tmpVar125, %110
  %tmpVar129 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 28
  %load_tmpVar130 = load i8, i8* %tmpVar129, align 1
  %111 = zext i8 %load_tmpVar130 to i32
  %tmpVar131 = xor i32 %tmpVar128, %111
  br label %112

112:                                              ; preds = %103, %continue99
  %113 = phi i32 [ %92, %continue99 ], [ %tmpVar131, %103 ]
  %114 = icmp ne i32 %113, 0
  br i1 %114, label %condition_body106, label %continue105

condition_body153:                                ; preds = %continue105
  %load_HOUR = load i16, i16* %hour, align 2
  %115 = sext i16 %load_HOUR to i32
  %tmpVar156 = add i32 %115, 10
  %116 = trunc i32 %tmpVar156 to i16
  store i16 %116, i16* %hour, align 2
  br label %continue152

continue152:                                      ; preds = %condition_body153, %continue105
  %tmpVar159 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 34
  %load_tmpVar160 = load i8, i8* %tmpVar159, align 1
  %117 = icmp ne i8 %load_tmpVar160, 0
  br i1 %117, label %condition_body158, label %continue157

condition_body158:                                ; preds = %continue152
  %load_HOUR161 = load i16, i16* %hour, align 2
  %118 = sext i16 %load_HOUR161 to i32
  %tmpVar162 = add i32 %118, 20
  %119 = trunc i32 %tmpVar162 to i16
  store i16 %119, i16* %hour, align 2
  br label %continue157

continue157:                                      ; preds = %condition_body158, %continue152
  %load_HOUR165 = load i16, i16* %hour, align 2
  %120 = sext i16 %load_HOUR165 to i32
  %tmpVar166 = icmp sgt i32 %120, 23
  %121 = zext i1 %tmpVar166 to i32
  %122 = icmp ne i32 %121, 0
  br i1 %122, label %140, label %132

condition_body164:                                ; preds = %140
  store i8 1, i8* %ERROR, align 1
  br label %continue163

continue163:                                      ; preds = %condition_body164, %140
  store i16 0, i16* %day, align 2
  %123 = load i16, i16* %day, align 2
  %erase187 = and i16 %123, -2
  %tmpVar188 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 36
  %load_tmpVar189 = load i8, i8* %tmpVar188, align 1
  %124 = zext i8 %load_tmpVar189 to i16
  %value190 = shl i16 %124, 0
  %or191 = or i16 %erase187, %value190
  store i16 %or191, i16* %day, align 2
  %125 = load i16, i16* %day, align 2
  %erase192 = and i16 %125, -3
  %tmpVar193 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 37
  %load_tmpVar194 = load i8, i8* %tmpVar193, align 1
  %126 = zext i8 %load_tmpVar194 to i16
  %value195 = shl i16 %126, 1
  %or196 = or i16 %erase192, %value195
  store i16 %or196, i16* %day, align 2
  %127 = load i16, i16* %day, align 2
  %erase197 = and i16 %127, -5
  %tmpVar198 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 38
  %load_tmpVar199 = load i8, i8* %tmpVar198, align 1
  %128 = zext i8 %load_tmpVar199 to i16
  %value200 = shl i16 %128, 2
  %or201 = or i16 %erase197, %value200
  store i16 %or201, i16* %day, align 2
  %129 = load i16, i16* %day, align 2
  %erase202 = and i16 %129, -9
  %tmpVar203 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 39
  %load_tmpVar204 = load i8, i8* %tmpVar203, align 1
  %130 = zext i8 %load_tmpVar204 to i16
  %value205 = shl i16 %130, 3
  %or206 = or i16 %erase202, %value205
  store i16 %or206, i16* %day, align 2
  %tmpVar209 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 40
  %load_tmpVar210 = load i8, i8* %tmpVar209, align 1
  %131 = icmp ne i8 %load_tmpVar210, 0
  br i1 %131, label %condition_body208, label %continue207

132:                                              ; preds = %continue157
  %tmpVar167 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 29
  %load_tmpVar168 = load i8, i8* %tmpVar167, align 1
  %133 = zext i8 %load_tmpVar168 to i32
  %tmpVar169 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 30
  %load_tmpVar170 = load i8, i8* %tmpVar169, align 1
  %134 = zext i8 %load_tmpVar170 to i32
  %tmpVar171 = xor i32 %133, %134
  %tmpVar172 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 31
  %load_tmpVar173 = load i8, i8* %tmpVar172, align 1
  %135 = zext i8 %load_tmpVar173 to i32
  %tmpVar174 = xor i32 %tmpVar171, %135
  %tmpVar175 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 32
  %load_tmpVar176 = load i8, i8* %tmpVar175, align 1
  %136 = zext i8 %load_tmpVar176 to i32
  %tmpVar177 = xor i32 %tmpVar174, %136
  %tmpVar178 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 33
  %load_tmpVar179 = load i8, i8* %tmpVar178, align 1
  %137 = zext i8 %load_tmpVar179 to i32
  %tmpVar180 = xor i32 %tmpVar177, %137
  %tmpVar181 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 34
  %load_tmpVar182 = load i8, i8* %tmpVar181, align 1
  %138 = zext i8 %load_tmpVar182 to i32
  %tmpVar183 = xor i32 %tmpVar180, %138
  %tmpVar184 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 35
  %load_tmpVar185 = load i8, i8* %tmpVar184, align 1
  %139 = zext i8 %load_tmpVar185 to i32
  %tmpVar186 = xor i32 %tmpVar183, %139
  br label %140

140:                                              ; preds = %132, %continue157
  %141 = phi i32 [ %121, %continue157 ], [ %tmpVar186, %132 ]
  %142 = icmp ne i32 %141, 0
  br i1 %142, label %condition_body164, label %continue163

condition_body208:                                ; preds = %continue163
  %load_day = load i16, i16* %day, align 2
  %143 = sext i16 %load_day to i32
  %tmpVar211 = add i32 %143, 10
  %144 = trunc i32 %tmpVar211 to i16
  store i16 %144, i16* %day, align 2
  br label %continue207

continue207:                                      ; preds = %condition_body208, %continue163
  %tmpVar214 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 41
  %load_tmpVar215 = load i8, i8* %tmpVar214, align 1
  %145 = icmp ne i8 %load_tmpVar215, 0
  br i1 %145, label %condition_body213, label %continue212

condition_body213:                                ; preds = %continue207
  %load_day216 = load i16, i16* %day, align 2
  %146 = sext i16 %load_day216 to i32
  %tmpVar217 = add i32 %146, 20
  %147 = trunc i32 %tmpVar217 to i16
  store i16 %147, i16* %day, align 2
  br label %continue212

continue212:                                      ; preds = %condition_body213, %continue207
  %load_day220 = load i16, i16* %day, align 2
  %148 = sext i16 %load_day220 to i32
  %tmpVar221 = icmp sgt i32 %148, 31
  br i1 %tmpVar221, label %condition_body219, label %continue218

condition_body219:                                ; preds = %continue212
  store i8 1, i8* %ERROR, align 1
  br label %continue218

continue218:                                      ; preds = %condition_body219, %continue212
  store i16 0, i16* %WDAY, align 2
  %149 = load i16, i16* %WDAY, align 2
  %erase222 = and i16 %149, -2
  %tmpVar223 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 42
  %load_tmpVar224 = load i8, i8* %tmpVar223, align 1
  %150 = zext i8 %load_tmpVar224 to i16
  %value225 = shl i16 %150, 0
  %or226 = or i16 %erase222, %value225
  store i16 %or226, i16* %WDAY, align 2
  %151 = load i16, i16* %WDAY, align 2
  %erase227 = and i16 %151, -3
  %tmpVar228 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 43
  %load_tmpVar229 = load i8, i8* %tmpVar228, align 1
  %152 = zext i8 %load_tmpVar229 to i16
  %value230 = shl i16 %152, 1
  %or231 = or i16 %erase227, %value230
  store i16 %or231, i16* %WDAY, align 2
  %153 = load i16, i16* %WDAY, align 2
  %erase232 = and i16 %153, -5
  %tmpVar233 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 44
  %load_tmpVar234 = load i8, i8* %tmpVar233, align 1
  %154 = zext i8 %load_tmpVar234 to i16
  %value235 = shl i16 %154, 2
  %or236 = or i16 %erase232, %value235
  store i16 %or236, i16* %WDAY, align 2
  %load_wday = load i16, i16* %WDAY, align 2
  %155 = sext i16 %load_wday to i32
  %tmpVar239 = icmp sgt i32 %155, 7
  %156 = zext i1 %tmpVar239 to i32
  %157 = icmp ne i32 %156, 0
  br i1 %157, label %170, label %167

condition_body238:                                ; preds = %170
  store i8 1, i8* %ERROR, align 1
  br label %continue237

continue237:                                      ; preds = %condition_body238, %170
  store i16 0, i16* %month, align 2
  %158 = load i16, i16* %month, align 2
  %erase242 = and i16 %158, -2
  %tmpVar243 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 45
  %load_tmpVar244 = load i8, i8* %tmpVar243, align 1
  %159 = zext i8 %load_tmpVar244 to i16
  %value245 = shl i16 %159, 0
  %or246 = or i16 %erase242, %value245
  store i16 %or246, i16* %month, align 2
  %160 = load i16, i16* %month, align 2
  %erase247 = and i16 %160, -3
  %tmpVar248 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 46
  %load_tmpVar249 = load i8, i8* %tmpVar248, align 1
  %161 = zext i8 %load_tmpVar249 to i16
  %value250 = shl i16 %161, 1
  %or251 = or i16 %erase247, %value250
  store i16 %or251, i16* %month, align 2
  %162 = load i16, i16* %month, align 2
  %erase252 = and i16 %162, -5
  %tmpVar253 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 47
  %load_tmpVar254 = load i8, i8* %tmpVar253, align 1
  %163 = zext i8 %load_tmpVar254 to i16
  %value255 = shl i16 %163, 2
  %or256 = or i16 %erase252, %value255
  store i16 %or256, i16* %month, align 2
  %164 = load i16, i16* %month, align 2
  %erase257 = and i16 %164, -9
  %tmpVar258 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 48
  %load_tmpVar259 = load i8, i8* %tmpVar258, align 1
  %165 = zext i8 %load_tmpVar259 to i16
  %value260 = shl i16 %165, 3
  %or261 = or i16 %erase257, %value260
  store i16 %or261, i16* %month, align 2
  %tmpVar264 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 49
  %load_tmpVar265 = load i8, i8* %tmpVar264, align 1
  %166 = icmp ne i8 %load_tmpVar265, 0
  br i1 %166, label %condition_body263, label %continue262

167:                                              ; preds = %continue218
  %load_wday240 = load i16, i16* %WDAY, align 2
  %168 = sext i16 %load_wday240 to i32
  %tmpVar241 = icmp slt i32 %168, 1
  %169 = zext i1 %tmpVar241 to i32
  br label %170

170:                                              ; preds = %167, %continue218
  %171 = phi i32 [ %156, %continue218 ], [ %169, %167 ]
  %172 = icmp ne i32 %171, 0
  br i1 %172, label %condition_body238, label %continue237

condition_body263:                                ; preds = %continue237
  %load_MONTH = load i16, i16* %month, align 2
  %173 = sext i16 %load_MONTH to i32
  %tmpVar266 = add i32 %173, 10
  %174 = trunc i32 %tmpVar266 to i16
  store i16 %174, i16* %month, align 2
  br label %continue262

continue262:                                      ; preds = %condition_body263, %continue237
  %load_MONTH269 = load i16, i16* %month, align 2
  %175 = sext i16 %load_MONTH269 to i32
  %tmpVar270 = icmp sgt i32 %175, 12
  br i1 %tmpVar270, label %condition_body268, label %continue267

condition_body268:                                ; preds = %continue262
  store i8 1, i8* %ERROR, align 1
  br label %continue267

continue267:                                      ; preds = %condition_body268, %continue262
  store i16 0, i16* %year, align 2
  %176 = load i16, i16* %year, align 2
  %erase271 = and i16 %176, -2
  %tmpVar272 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 50
  %load_tmpVar273 = load i8, i8* %tmpVar272, align 1
  %177 = zext i8 %load_tmpVar273 to i16
  %value274 = shl i16 %177, 0
  %or275 = or i16 %erase271, %value274
  store i16 %or275, i16* %year, align 2
  %178 = load i16, i16* %year, align 2
  %erase276 = and i16 %178, -3
  %tmpVar277 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 51
  %load_tmpVar278 = load i8, i8* %tmpVar277, align 1
  %179 = zext i8 %load_tmpVar278 to i16
  %value279 = shl i16 %179, 1
  %or280 = or i16 %erase276, %value279
  store i16 %or280, i16* %year, align 2
  %180 = load i16, i16* %year, align 2
  %erase281 = and i16 %180, -5
  %tmpVar282 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 52
  %load_tmpVar283 = load i8, i8* %tmpVar282, align 1
  %181 = zext i8 %load_tmpVar283 to i16
  %value284 = shl i16 %181, 2
  %or285 = or i16 %erase281, %value284
  store i16 %or285, i16* %year, align 2
  %182 = load i16, i16* %year, align 2
  %erase286 = and i16 %182, -9
  %tmpVar287 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 53
  %load_tmpVar288 = load i8, i8* %tmpVar287, align 1
  %183 = zext i8 %load_tmpVar288 to i16
  %value289 = shl i16 %183, 3
  %or290 = or i16 %erase286, %value289
  store i16 %or290, i16* %year, align 2
  %tmpVar293 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 54
  %load_tmpVar294 = load i8, i8* %tmpVar293, align 1
  %184 = icmp ne i8 %load_tmpVar294, 0
  br i1 %184, label %condition_body292, label %continue291

condition_body292:                                ; preds = %continue267
  %load_YEAR = load i16, i16* %year, align 2
  %185 = sext i16 %load_YEAR to i32
  %tmpVar295 = add i32 %185, 10
  %186 = trunc i32 %tmpVar295 to i16
  store i16 %186, i16* %year, align 2
  br label %continue291

continue291:                                      ; preds = %condition_body292, %continue267
  %tmpVar298 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 55
  %load_tmpVar299 = load i8, i8* %tmpVar298, align 1
  %187 = icmp ne i8 %load_tmpVar299, 0
  br i1 %187, label %condition_body297, label %continue296

condition_body297:                                ; preds = %continue291
  %load_YEAR300 = load i16, i16* %year, align 2
  %188 = sext i16 %load_YEAR300 to i32
  %tmpVar301 = add i32 %188, 20
  %189 = trunc i32 %tmpVar301 to i16
  store i16 %189, i16* %year, align 2
  br label %continue296

continue296:                                      ; preds = %condition_body297, %continue291
  %tmpVar304 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 56
  %load_tmpVar305 = load i8, i8* %tmpVar304, align 1
  %190 = icmp ne i8 %load_tmpVar305, 0
  br i1 %190, label %condition_body303, label %continue302

condition_body303:                                ; preds = %continue296
  %load_YEAR306 = load i16, i16* %year, align 2
  %191 = sext i16 %load_YEAR306 to i32
  %tmpVar307 = add i32 %191, 40
  %192 = trunc i32 %tmpVar307 to i16
  store i16 %192, i16* %year, align 2
  br label %continue302

continue302:                                      ; preds = %condition_body303, %continue296
  %tmpVar310 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 57
  %load_tmpVar311 = load i8, i8* %tmpVar310, align 1
  %193 = icmp ne i8 %load_tmpVar311, 0
  br i1 %193, label %condition_body309, label %continue308

condition_body309:                                ; preds = %continue302
  %load_YEAR312 = load i16, i16* %year, align 2
  %194 = sext i16 %load_YEAR312 to i32
  %tmpVar313 = add i32 %194, 80
  %195 = trunc i32 %tmpVar313 to i16
  store i16 %195, i16* %year, align 2
  br label %continue308

continue308:                                      ; preds = %condition_body309, %continue302
  store i16 0, i16* %cnt, align 2
  store i16 36, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue308
  %load_i = load i16, i16* %i, align 2
  %load_i315 = load i16, i16* %i, align 2
  %tmpVar316 = icmp sle i16 %load_i315, 58
  %196 = icmp ne i1 %tmpVar316, false
  br i1 %196, label %203, label %204

for_body:                                         ; preds = %201
  %load_i325 = load i16, i16* %i, align 2
  %197 = sext i16 %load_i325 to i32
  %tmpVar326 = mul i32 1, %197
  %tmpVar327 = add i32 %tmpVar326, 0
  %tmpVar328 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 %tmpVar327
  %load_tmpVar329 = load i8, i8* %tmpVar328, align 1
  %198 = icmp ne i8 %load_tmpVar329, 0
  br i1 %198, label %condition_body324, label %continue323

increment:                                        ; preds = %continue323
  %tmpVar331 = add i16 %load_i, 1
  store i16 %tmpVar331, i16* %i, align 2
  br label %condition_check

continue314:                                      ; preds = %201
  %EVEN_instance = alloca %EVEN_interface, align 8
  br label %input334

199:                                              ; preds = %204
  %load_i319 = load i16, i16* %i, align 2
  %tmpVar320 = icmp sge i16 %load_i319, 58
  %200 = icmp ne i1 %tmpVar320, false
  br i1 %200, label %207, label %208

201:                                              ; preds = %208, %204
  %202 = phi i1 [ %205, %204 ], [ %209, %208 ]
  br i1 %202, label %for_body, label %continue314

203:                                              ; preds = %condition_check
  %load_i317 = load i16, i16* %i, align 2
  %tmpVar318 = icmp sge i16 %load_i317, 36
  br label %204

204:                                              ; preds = %203, %condition_check
  %205 = phi i1 [ %tmpVar316, %condition_check ], [ %tmpVar318, %203 ]
  %206 = icmp ne i1 %205, false
  br i1 %206, label %201, label %199

207:                                              ; preds = %199
  %load_i321 = load i16, i16* %i, align 2
  %tmpVar322 = icmp sle i16 %load_i321, 36
  br label %208

208:                                              ; preds = %207, %199
  %209 = phi i1 [ %tmpVar320, %199 ], [ %tmpVar322, %207 ]
  br label %201

condition_body324:                                ; preds = %for_body
  %load_cnt = load i16, i16* %cnt, align 2
  %210 = sext i16 %load_cnt to i32
  %tmpVar330 = add i32 %210, 1
  %211 = trunc i32 %tmpVar330 to i16
  store i16 %211, i16* %cnt, align 2
  br label %continue323

continue323:                                      ; preds = %condition_body324, %for_body
  br label %increment

condition_body333:                                ; preds = %continue337
  store i8 1, i8* %ERROR, align 1
  br label %continue332

continue332:                                      ; preds = %condition_body333, %continue337
  %load_error343 = load i8, i8* %ERROR, align 1
  %tmpVar344 = xor i8 %load_error343, -1
  %212 = icmp ne i8 %tmpVar344, 0
  br i1 %212, label %condition_body342, label %continue341

input334:                                         ; preds = %continue314
  %213 = getelementptr inbounds %EVEN_interface, %EVEN_interface* %EVEN_instance, i32 0, i32 0
  %load_cnt338 = load i16, i16* %cnt, align 2
  %214 = sext i16 %load_cnt338 to i32
  store i32 %214, i32* %213, align 4
  br label %call335

call335:                                          ; preds = %input334
  %call339 = call i8 @EVEN(%EVEN_interface* %EVEN_instance)
  br label %output336

output336:                                        ; preds = %call335
  br label %continue337

continue337:                                      ; preds = %output336
  %tmpVar340 = xor i8 %call339, -1
  %215 = icmp ne i8 %tmpVar340, 0
  br i1 %215, label %condition_body333, label %continue332

condition_body342:                                ; preds = %continue332
  %load_mez = load i64, i64* %mez, align 4
  store i64 %load_mez, i64* %old_time, align 4
  %load_YEAR348 = load i16, i16* %year, align 2
  %216 = sext i16 %load_YEAR348 to i32
  %tmpVar349 = icmp sge i32 %216, 70
  br i1 %tmpVar349, label %condition_body347, label %else345

continue341:                                      ; preds = %continue395, %continue332
  br label %continue54

condition_body347:                                ; preds = %condition_body342
  %load_YEAR350 = load i16, i16* %year, align 2
  %217 = sext i16 %load_YEAR350 to i32
  %tmpVar351 = add i32 %217, 1900
  %218 = trunc i32 %tmpVar351 to i16
  store i16 %218, i16* %year, align 2
  br label %continue346

else345:                                          ; preds = %condition_body342
  %load_YEAR352 = load i16, i16* %year, align 2
  %219 = sext i16 %load_YEAR352 to i32
  %tmpVar353 = add i32 %219, 2000
  %220 = trunc i32 %tmpVar353 to i16
  store i16 %220, i16* %year, align 2
  br label %continue346

continue346:                                      ; preds = %else345, %condition_body347
  %SET_DT_instance = alloca %SET_DT_interface, align 8
  br label %input354

input354:                                         ; preds = %continue346
  %221 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 0
  %load_YEAR358 = load i16, i16* %year, align 2
  store i16 %load_YEAR358, i16* %221, align 2
  %222 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 1
  %load_MONTH359 = load i16, i16* %month, align 2
  store i16 %load_MONTH359, i16* %222, align 2
  %223 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 2
  %load_day360 = load i16, i16* %day, align 2
  store i16 %load_day360, i16* %223, align 2
  %224 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 3
  %load_HOUR361 = load i16, i16* %hour, align 2
  store i16 %load_HOUR361, i16* %224, align 2
  %225 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 4
  %load_MINUTE362 = load i16, i16* %minute, align 2
  store i16 %load_MINUTE362, i16* %225, align 2
  %226 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 5
  store i16 0, i16* %226, align 2
  br label %call355

call355:                                          ; preds = %input354
  %call363 = call i64 @SET_DT(%SET_DT_interface* %SET_DT_instance)
  br label %output356

output356:                                        ; preds = %call355
  br label %continue357

continue357:                                      ; preds = %output356
  store i64 %call363, i64* %mez, align 4
  %tmpVar364 = getelementptr inbounds [59 x i8], [59 x i8]* %bits, i32 0, i32 17
  %load_tmpVar365 = load i8, i8* %tmpVar364, align 1
  store i8 %load_tmpVar365, i8* %DS, align 1
  %load_DS = load i8, i8* %DS, align 1
  %227 = icmp ne i8 %load_DS, 0
  br i1 %227, label %condition_body368, label %else366

condition_body368:                                ; preds = %continue357
  %DWORD_TO_DT_instance = alloca %DWORD_TO_DT_interface, align 8
  br label %input369

else366:                                          ; preds = %continue357
  %DWORD_TO_DT_instance381 = alloca %DWORD_TO_DT_interface, align 8
  br label %input382

continue367:                                      ; preds = %continue385, %continue372
  %load_mez397 = load i64, i64* %mez, align 4
  %load_old_time = load i64, i64* %old_time, align 4
  %tmpVar398 = add i64 %load_old_time, 60000000000
  %tmpVar399 = icmp ne i64 %load_mez397, %tmpVar398
  br i1 %tmpVar399, label %condition_body396, label %continue395

input369:                                         ; preds = %condition_body368
  %228 = getelementptr inbounds %DWORD_TO_DT_interface, %DWORD_TO_DT_interface* %DWORD_TO_DT_instance, i32 0, i32 0
  %DT_TO_DWORD_instance = alloca %DT_TO_DWORD_interface, align 8
  br label %input373

call370:                                          ; preds = %continue376
  %call380 = call i64 @DWORD_TO_DT(%DWORD_TO_DT_interface* %DWORD_TO_DT_instance)
  br label %output371

output371:                                        ; preds = %call370
  br label %continue372

continue372:                                      ; preds = %output371
  store i64 %call380, i64* %utc, align 4
  br label %continue367

input373:                                         ; preds = %input369
  %229 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance, i32 0, i32 0
  %load_mez377 = load i64, i64* %mez, align 4
  store i64 %load_mez377, i64* %229, align 4
  br label %call374

call374:                                          ; preds = %input373
  %call378 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance)
  br label %output375

output375:                                        ; preds = %call374
  br label %continue376

continue376:                                      ; preds = %output375
  %tmpVar379 = sub i32 %call378, 7200
  store i32 %tmpVar379, i32* %228, align 4
  br label %call370

input382:                                         ; preds = %else366
  %230 = getelementptr inbounds %DWORD_TO_DT_interface, %DWORD_TO_DT_interface* %DWORD_TO_DT_instance381, i32 0, i32 0
  %DT_TO_DWORD_instance386 = alloca %DT_TO_DWORD_interface, align 8
  br label %input387

call383:                                          ; preds = %continue390
  %call394 = call i64 @DWORD_TO_DT(%DWORD_TO_DT_interface* %DWORD_TO_DT_instance381)
  br label %output384

output384:                                        ; preds = %call383
  br label %continue385

continue385:                                      ; preds = %output384
  store i64 %call394, i64* %utc, align 4
  br label %continue367

input387:                                         ; preds = %input382
  %231 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance386, i32 0, i32 0
  %load_mez391 = load i64, i64* %mez, align 4
  store i64 %load_mez391, i64* %231, align 4
  br label %call388

call388:                                          ; preds = %input387
  %call392 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance386)
  br label %output389

output389:                                        ; preds = %call388
  br label %continue390

continue390:                                      ; preds = %output389
  %tmpVar393 = sub i32 %call392, 3600
  store i32 %tmpVar393, i32* %230, align 4
  br label %call383

condition_body396:                                ; preds = %continue367
  store i8 1, i8* %ERROR, align 1
  br label %continue395

continue395:                                      ; preds = %condition_body396, %continue367
  br label %continue341

input401:                                         ; preds = %continue7
  %232 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance400, i32 0, i32 0
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input405

call402:                                          ; preds = %continue408
  %call416 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance400)
  br label %output403

output403:                                        ; preds = %call402
  br label %continue404

continue404:                                      ; preds = %output403
  store i64 %call416, i64* %tz, align 4
  %load_init = load i8, i8* %init, align 1
  %tmpVar419 = xor i8 %load_init, -1
  %233 = zext i8 %tmpVar419 to i32
  %234 = icmp ne i32 %233, 0
  br i1 %234, label %242, label %240

input405:                                         ; preds = %input401
  %235 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input409

call406:                                          ; preds = %continue412
  %call414 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output407

output407:                                        ; preds = %call406
  br label %continue408

continue408:                                      ; preds = %output407
  %tmpVar415 = mul i32 %call414, 3600000
  store i32 %tmpVar415, i32* %232, align 4
  br label %call402

input409:                                         ; preds = %input405
  %236 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_time_offset = load i16, i16* %TIME_OFFSET, align 2
  %237 = sext i16 %load_time_offset to i64
  store i64 %237, i64* %236, align 4
  br label %call410

call410:                                          ; preds = %input409
  %call413 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output411

output411:                                        ; preds = %call410
  br label %continue412

continue412:                                      ; preds = %output411
  %238 = trunc i64 %call413 to i16
  store i16 %238, i16* %235, align 2
  br label %call406

condition_body418:                                ; preds = %242
  store i8 1, i8* %init, align 1
  %load_sdt = load i64, i64* %SDT, align 4
  store i64 %load_sdt, i64* %utc, align 4
  store i8 1, i8* %TP, align 1
  %load_DSI = load i8, i8* %DSI, align 1
  store i8 %load_DSI, i8* %DS, align 1
  br label %continue417

continue417:                                      ; preds = %condition_body418, %242
  %load_tp = load i8, i8* %TP, align 1
  %239 = icmp ne i8 %load_tp, 0
  br i1 %239, label %condition_body422, label %branch420

240:                                              ; preds = %continue404
  %load_SET = load i8, i8* %SET, align 1
  %241 = zext i8 %load_SET to i32
  br label %242

242:                                              ; preds = %240, %continue404
  %243 = phi i32 [ %233, %continue404 ], [ %241, %240 ]
  %244 = icmp ne i32 %243, 0
  br i1 %244, label %condition_body418, label %continue417

condition_body422:                                ; preds = %continue417
  %load_utc = load i64, i64* %utc, align 4
  store i64 %load_utc, i64* %RTC, align 4
  %load_DS426 = load i8, i8* %DS, align 1
  %245 = zext i8 %load_DS426 to i32
  %246 = icmp ne i32 %245, 0
  br i1 %246, label %251, label %253

branch420:                                        ; preds = %continue417
  %load_rtc452 = load i64, i64* %RTC, align 4
  %DWORD_TO_DT_instance453 = alloca %DWORD_TO_DT_interface, align 8
  br label %input454

condition_body451:                                ; preds = %258
  %load_rtc462 = load i64, i64* %RTC, align 4
  %tmpVar463 = add i64 %load_rtc462, 1000000000
  store i64 %tmpVar463, i64* %RTC, align 4
  %load_rtc1 = load i64, i64* %RTC1, align 4
  %tmpVar464 = add i64 %load_rtc1, 1000000000
  store i64 %tmpVar464, i64* %RTC1, align 4
  %load_ty465 = load i64, i64* %ty, align 4
  %tmpVar466 = add i64 %load_ty465, 1000000000
  store i64 %tmpVar466, i64* %ty, align 4
  %load_ty467 = load i64, i64* %ty, align 4
  %load_last_sync = load i64, i64* %last_sync, align 4
  %tmpVar468 = sub i64 %load_ty467, %load_last_sync
  %load_sync_timeout = load i64, i64* %SYNC_TIMEOUT, align 4
  %tmpVar469 = icmp slt i64 %tmpVar468, %load_sync_timeout
  %247 = zext i1 %tmpVar469 to i32
  %248 = icmp ne i32 %247, 0
  br i1 %248, label %264, label %265

continue421:                                      ; preds = %274, %258, %continue424
  %TIME_TO_INT_instance = alloca %TIME_TO_INT_interface, align 8
  br label %input496

condition_body425:                                ; preds = %253
  %load_time_offset430 = load i16, i16* %TIME_OFFSET, align 2
  %249 = sext i16 %load_time_offset430 to i32
  %tmpVar431 = icmp slt i32 %249, 0
  br i1 %tmpVar431, label %condition_body429, label %else427

else423:                                          ; preds = %253
  %load_time_offset441 = load i16, i16* %TIME_OFFSET, align 2
  %250 = sext i16 %load_time_offset441 to i32
  %tmpVar442 = icmp slt i32 %250, 0
  br i1 %tmpVar442, label %condition_body440, label %else438

continue424:                                      ; preds = %continue439, %continue428
  store i8 1, i8* %SYNC, align 1
  %load_last449 = load i64, i64* %last, align 4
  store i64 %load_last449, i64* %last_sync, align 4
  %load_last450 = load i64, i64* %last, align 4
  store i64 %load_last450, i64* %ty, align 4
  br label %continue421

251:                                              ; preds = %condition_body422
  %load_dst_en = load i8, i8* %DST_EN, align 1
  %252 = zext i8 %load_dst_en to i32
  br label %253

253:                                              ; preds = %251, %condition_body422
  %254 = phi i32 [ %245, %condition_body422 ], [ %252, %251 ]
  %255 = icmp ne i32 %254, 0
  br i1 %255, label %condition_body425, label %else423

condition_body429:                                ; preds = %condition_body425
  %load_rtc = load i64, i64* %RTC, align 4
  %load_tz = load i64, i64* %tz, align 4
  %tmpVar432 = sub i64 %load_rtc, %load_tz
  %tmpVar433 = add i64 %tmpVar432, 3600000000000
  store i64 %tmpVar433, i64* %RTC1, align 4
  br label %continue428

else427:                                          ; preds = %condition_body425
  %load_rtc434 = load i64, i64* %RTC, align 4
  %load_tz435 = load i64, i64* %tz, align 4
  %tmpVar436 = add i64 %load_rtc434, %load_tz435
  %tmpVar437 = add i64 %tmpVar436, 3600000000000
  store i64 %tmpVar437, i64* %RTC1, align 4
  br label %continue428

continue428:                                      ; preds = %else427, %condition_body429
  br label %continue424

condition_body440:                                ; preds = %else423
  %load_rtc443 = load i64, i64* %RTC, align 4
  %load_tz444 = load i64, i64* %tz, align 4
  %tmpVar445 = sub i64 %load_rtc443, %load_tz444
  store i64 %tmpVar445, i64* %RTC1, align 4
  br label %continue439

else438:                                          ; preds = %else423
  %load_rtc446 = load i64, i64* %RTC, align 4
  %load_tz447 = load i64, i64* %tz, align 4
  %tmpVar448 = add i64 %load_rtc446, %load_tz447
  store i64 %tmpVar448, i64* %RTC1, align 4
  br label %continue439

continue439:                                      ; preds = %else438, %condition_body440
  br label %continue424

256:                                              ; preds = %continue457
  %load_T1 = load i64, i64* %t1, align 4
  %load_ty = load i64, i64* %ty, align 4
  %tmpVar460 = sub i64 %load_T1, %load_ty
  %tmpVar461 = icmp sge i64 %tmpVar460, 1000000000
  %257 = zext i1 %tmpVar461 to i32
  br label %258

258:                                              ; preds = %256, %continue457
  %259 = phi i32 [ %262, %continue457 ], [ %257, %256 ]
  %260 = icmp ne i32 %259, 0
  br i1 %260, label %condition_body451, label %continue421

input454:                                         ; preds = %branch420
  %261 = getelementptr inbounds %DWORD_TO_DT_interface, %DWORD_TO_DT_interface* %DWORD_TO_DT_instance453, i32 0, i32 0
  store i32 0, i32* %261, align 4
  br label %call455

call455:                                          ; preds = %input454
  %call458 = call i64 @DWORD_TO_DT(%DWORD_TO_DT_interface* %DWORD_TO_DT_instance453)
  br label %output456

output456:                                        ; preds = %call455
  br label %continue457

continue457:                                      ; preds = %output456
  %tmpVar459 = icmp sgt i64 %load_rtc452, %call458
  %262 = zext i1 %tmpVar459 to i32
  %263 = icmp ne i32 %262, 0
  br i1 %263, label %256, label %258

264:                                              ; preds = %condition_body451
  %load_last_sync470 = load i64, i64* %last_sync, align 4
  %DWORD_TO_TIME_instance471 = alloca %DWORD_TO_TIME_interface, align 8
  br label %input472

265:                                              ; preds = %continue475, %condition_body451
  %266 = phi i32 [ %247, %condition_body451 ], [ %268, %continue475 ]
  store i32 %266, i8* %SYNC, align 4
  %DAY_OF_WEEK_instance = alloca %DAY_OF_WEEK_interface, align 8
  br label %input478

input472:                                         ; preds = %264
  %267 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance471, i32 0, i32 0
  store i32 0, i32* %267, align 4
  br label %call473

call473:                                          ; preds = %input472
  %call476 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance471)
  br label %output474

output474:                                        ; preds = %call473
  br label %continue475

continue475:                                      ; preds = %output474
  %tmpVar477 = icmp sgt i64 %load_last_sync470, %call476
  %268 = zext i1 %tmpVar477 to i32
  br label %265

input478:                                         ; preds = %265
  %269 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance, i32 0, i32 0
  %DT_TO_DATE_instance = alloca %DT_TO_DATE_interface, align 8
  br label %input482

call479:                                          ; preds = %continue485
  %call488 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance)
  br label %output480

output480:                                        ; preds = %call479
  br label %continue481

continue481:                                      ; preds = %output480
  store i16 %call488, i16* %WDAY, align 2
  %load_dst_en489 = load i8, i8* %DST_EN, align 1
  %270 = zext i8 %load_dst_en489 to i32
  %271 = icmp ne i32 %270, 0
  br i1 %271, label %273, label %274

input482:                                         ; preds = %input478
  %272 = getelementptr inbounds %DT_TO_DATE_interface, %DT_TO_DATE_interface* %DT_TO_DATE_instance, i32 0, i32 0
  %load_rtc1486 = load i64, i64* %RTC1, align 4
  store i64 %load_rtc1486, i64* %272, align 4
  br label %call483

call483:                                          ; preds = %input482
  %call487 = call i64 @DT_TO_DATE(%DT_TO_DATE_interface* %DT_TO_DATE_instance)
  br label %output484

output484:                                        ; preds = %call483
  br label %continue485

continue485:                                      ; preds = %output484
  store i64 %call487, i64* %269, align 4
  br label %call479

273:                                              ; preds = %continue481
  %DST_instance = alloca %DST_interface, align 8
  br label %input490

274:                                              ; preds = %continue493, %continue481
  %275 = phi i32 [ %270, %continue481 ], [ %277, %continue493 ]
  store i32 %275, i8* %DS, align 4
  br label %continue421

input490:                                         ; preds = %273
  %276 = getelementptr inbounds %DST_interface, %DST_interface* %DST_instance, i32 0, i32 0
  %load_utc494 = load i64, i64* %utc, align 4
  store i64 %load_utc494, i64* %276, align 4
  br label %call491

call491:                                          ; preds = %input490
  %call495 = call i8 @DST(%DST_interface* %DST_instance)
  br label %output492

output492:                                        ; preds = %call491
  br label %continue493

continue493:                                      ; preds = %output492
  %277 = zext i8 %call495 to i32
  br label %274

input496:                                         ; preds = %continue421
  %278 = getelementptr inbounds %TIME_TO_INT_interface, %TIME_TO_INT_interface* %TIME_TO_INT_instance, i32 0, i32 0
  %load_t1500 = load i64, i64* %t1, align 4
  %load_ty501 = load i64, i64* %ty, align 4
  %tmpVar502 = sub i64 %load_t1500, %load_ty501
  store i64 %tmpVar502, i64* %278, align 4
  br label %call497

call497:                                          ; preds = %input496
  %call503 = call i16 @TIME_TO_INT(%TIME_TO_INT_interface* %TIME_TO_INT_instance)
  br label %output498

output498:                                        ; preds = %call497
  br label %continue499

continue499:                                      ; preds = %output498
  store i16 %call503, i16* %MSEC, align 2
  ret void
}

define i8 @DST(%DST_interface* %0) {
entry:
  %UTC = getelementptr inbounds %DST_interface, %DST_interface* %0, i32 0, i32 0
  %yr = getelementptr inbounds %DST_interface, %DST_interface* %0, i32 0, i32 1
  %yr4 = getelementptr inbounds %DST_interface, %DST_interface* %0, i32 0, i32 2
  %ltc = getelementptr inbounds %DST_interface, %DST_interface* %0, i32 0, i32 3
  %idate = getelementptr inbounds %DST_interface, %DST_interface* %0, i32 0, i32 4
  %DST = alloca i8, align 1
  store i16 0, i16* %yr, align 2
  store i32 0, i32* %yr4, align 4
  store i32 0, i32* %ltc, align 4
  store i32 0, i32* %idate, align 4
  store i8 0, i8* %DST, align 1
  %YEAR_OF_DATE_instance = alloca %YEAR_OF_DATE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance, i32 0, i32 0
  %DT_TO_DATE_instance = alloca %DT_TO_DATE_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call6, i16* %yr, align 2
  %DT_TO_DWORD_instance = alloca %DT_TO_DWORD_interface, align 8
  br label %input7

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %DT_TO_DATE_interface, %DT_TO_DATE_interface* %DT_TO_DATE_instance, i32 0, i32 0
  %load_UTC = load i64, i64* %UTC, align 4
  store i64 %load_UTC, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i64 @DT_TO_DATE(%DT_TO_DATE_interface* %DT_TO_DATE_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i64 %call5, i64* %1, align 4
  br label %call

input7:                                           ; preds = %continue
  %3 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance, i32 0, i32 0
  %load_UTC11 = load i64, i64* %UTC, align 4
  store i64 %load_UTC11, i64* %3, align 4
  br label %call8

call8:                                            ; preds = %input7
  %call12 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  store i32 %call12, i32* %ltc, align 4
  %DT_TO_DWORD_instance13 = alloca %DT_TO_DWORD_interface, align 8
  br label %input14

input14:                                          ; preds = %continue10
  %4 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance13, i32 0, i32 0
  %SET_DT_instance = alloca %SET_DT_interface, align 8
  br label %input18

call15:                                           ; preds = %continue21
  %call23 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance13)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  store i32 %call23, i32* %idate, align 4
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input24

input18:                                          ; preds = %input14
  %5 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 0
  %load_yr = load i16, i16* %yr, align 2
  store i16 %load_yr, i16* %5, align 2
  %6 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 1
  store i16 3, i16* %6, align 2
  %7 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 2
  store i16 31, i16* %7, align 2
  %8 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 3
  store i16 1, i16* %8, align 2
  %9 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 4
  store i16 0, i16* %9, align 2
  %10 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 5
  store i16 0, i16* %10, align 2
  br label %call19

call19:                                           ; preds = %input18
  %call22 = call i64 @SET_DT(%SET_DT_interface* %SET_DT_instance)
  br label %output20

output20:                                         ; preds = %call19
  br label %continue21

continue21:                                       ; preds = %output20
  store i64 %call22, i64* %4, align 4
  br label %call15

input24:                                          ; preds = %continue17
  %11 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input28

call25:                                           ; preds = %continue31
  %call34 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output26

output26:                                         ; preds = %call25
  br label %continue27

continue27:                                       ; preds = %output26
  %tmpVar35 = add i64 %call34, 1
  %12 = trunc i64 %tmpVar35 to i32
  store i32 %12, i32* %yr4, align 4
  %load_idate = load i32, i32* %idate, align 4
  %load_yr4 = load i32, i32* %yr4, align 4
  %tmpVar36 = add i32 %load_yr4, 3
  %tmpVar37 = srem i32 %tmpVar36, 7
  %tmpVar38 = mul i32 %tmpVar37, 86400
  %tmpVar39 = sub i32 %load_idate, %tmpVar38
  %load_ltc = load i32, i32* %ltc, align 4
  %tmpVar40 = icmp sle i32 %tmpVar39, %load_ltc
  %13 = zext i1 %tmpVar40 to i32
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %18, label %20

input28:                                          ; preds = %input24
  %15 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_yr32 = load i16, i16* %yr, align 2
  store i16 %load_yr32, i16* %15, align 2
  br label %call29

call29:                                           ; preds = %input28
  %call33 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output30

output30:                                         ; preds = %call29
  br label %continue31

continue31:                                       ; preds = %output30
  %tmpVar = mul i32 5, %call33
  %16 = sext i32 %tmpVar to i64
  store i64 %16, i64* %11, align 4
  %17 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %17, align 2
  br label %call25

18:                                               ; preds = %continue27
  %load_idate41 = load i32, i32* %idate, align 4
  %load_yr442 = load i32, i32* %yr4, align 4
  %tmpVar43 = srem i32 %load_yr442, 7
  %tmpVar44 = sub i32 214, %tmpVar43
  %tmpVar45 = mul i32 %tmpVar44, 86400
  %tmpVar46 = add i32 %load_idate41, %tmpVar45
  %load_ltc47 = load i32, i32* %ltc, align 4
  %tmpVar48 = icmp sgt i32 %tmpVar46, %load_ltc47
  %19 = zext i1 %tmpVar48 to i32
  br label %20

20:                                               ; preds = %18, %continue27
  %21 = phi i32 [ %13, %continue27 ], [ %19, %18 ]
  store i32 %21, i8* %DST, align 4
  %DST_ret = load i8, i8* %DST, align 1
  ret i8 %DST_ret
}

define %SDT @DT2_TO_SDT(%DT2_TO_SDT_interface* %0) {
entry:
  %DI = getelementptr inbounds %DT2_TO_SDT_interface, %DT2_TO_SDT_interface* %0, i32 0, i32 0
  %TI = getelementptr inbounds %DT2_TO_SDT_interface, %DT2_TO_SDT_interface* %0, i32 0, i32 1
  %DT2_TO_SDT = alloca %SDT, align 8
  %1 = bitcast %SDT* %DT2_TO_SDT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%SDT* @SDT__init to i8*), i64 mul nuw (i64 ptrtoint (i16* getelementptr (i16, i16* null, i32 1) to i64), i64 8), i1 false)
  %YEAR = getelementptr inbounds %SDT, %SDT* %DT2_TO_SDT, i32 0, i32 0
  %YEAR_OF_DATE_instance = alloca %YEAR_OF_DATE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance, i32 0, i32 0
  %load_di = load i64, i64* %DI, align 4
  store i64 %load_di, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %YEAR, align 2
  %MONTH = getelementptr inbounds %SDT, %SDT* %DT2_TO_SDT, i32 0, i32 1
  %MONTH_OF_DATE_instance = alloca %MONTH_OF_DATE_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %3 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance, i32 0, i32 0
  %load_di6 = load i64, i64* %DI, align 4
  store i64 %load_di6, i64* %3, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call7 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i16 %call7, i16* %MONTH, align 2
  %DAY = getelementptr inbounds %SDT, %SDT* %DT2_TO_SDT, i32 0, i32 2
  %DAY_OF_MONTH_instance = alloca %DAY_OF_MONTH_interface, align 8
  br label %input8

input8:                                           ; preds = %continue5
  %4 = getelementptr inbounds %DAY_OF_MONTH_interface, %DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance, i32 0, i32 0
  %load_di12 = load i64, i64* %DI, align 4
  store i64 %load_di12, i64* %4, align 4
  br label %call9

call9:                                            ; preds = %input8
  %call13 = call i16 @DAY_OF_MONTH(%DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  store i16 %call13, i16* %DAY, align 2
  %WEEKDAY = getelementptr inbounds %SDT, %SDT* %DT2_TO_SDT, i32 0, i32 3
  %DAY_OF_WEEK_instance = alloca %DAY_OF_WEEK_interface, align 8
  br label %input14

input14:                                          ; preds = %continue11
  %5 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance, i32 0, i32 0
  %load_di18 = load i64, i64* %DI, align 4
  store i64 %load_di18, i64* %5, align 4
  br label %call15

call15:                                           ; preds = %input14
  %call19 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  store i16 %call19, i16* %WEEKDAY, align 2
  %MS = getelementptr inbounds %SDT, %SDT* %DT2_TO_SDT, i32 0, i32 7
  %DWORD_TO_INT_instance = alloca %DWORD_TO_INT_interface, align 8
  br label %input20

input20:                                          ; preds = %continue17
  %6 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance, i32 0, i32 0
  %TOD_TO_DWORD_instance = alloca %TOD_TO_DWORD_interface, align 8
  br label %input24

call21:                                           ; preds = %continue27
  %call29 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance)
  br label %output22

output22:                                         ; preds = %call21
  br label %continue23

continue23:                                       ; preds = %output22
  store i16 %call29, i16* %MS, align 2
  %SECOND = getelementptr inbounds %SDT, %SDT* %DT2_TO_SDT, i32 0, i32 6
  %DWORD_TO_INT_instance30 = alloca %DWORD_TO_INT_interface, align 8
  br label %input31

input24:                                          ; preds = %input20
  %7 = getelementptr inbounds %TOD_TO_DWORD_interface, %TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance, i32 0, i32 0
  %load_ti = load i64, i64* %TI, align 4
  store i64 %load_ti, i64* %7, align 4
  br label %call25

call25:                                           ; preds = %input24
  %call28 = call i32 @TOD_TO_DWORD(%TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance)
  br label %output26

output26:                                         ; preds = %call25
  br label %continue27

continue27:                                       ; preds = %output26
  %tmpVar = srem i32 %call28, 1000
  store i32 %tmpVar, i32* %6, align 4
  br label %call21

input31:                                          ; preds = %continue23
  %8 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance30, i32 0, i32 0
  %TOD_TO_DWORD_instance35 = alloca %TOD_TO_DWORD_interface, align 8
  br label %input36

call32:                                           ; preds = %continue39
  %call44 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance30)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  store i16 %call44, i16* %SECOND, align 2
  %MINUTE = getelementptr inbounds %SDT, %SDT* %DT2_TO_SDT, i32 0, i32 5
  %DWORD_TO_INT_instance45 = alloca %DWORD_TO_INT_interface, align 8
  br label %input46

input36:                                          ; preds = %input31
  %9 = getelementptr inbounds %TOD_TO_DWORD_interface, %TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance35, i32 0, i32 0
  %load_ti40 = load i64, i64* %TI, align 4
  store i64 %load_ti40, i64* %9, align 4
  br label %call37

call37:                                           ; preds = %input36
  %call41 = call i32 @TOD_TO_DWORD(%TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance35)
  br label %output38

output38:                                         ; preds = %call37
  br label %continue39

continue39:                                       ; preds = %output38
  %tmpVar42 = sdiv i32 %call41, 1000
  %tmpVar43 = srem i32 %tmpVar42, 60
  store i32 %tmpVar43, i32* %8, align 4
  br label %call32

input46:                                          ; preds = %continue34
  %10 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance45, i32 0, i32 0
  %TOD_TO_DWORD_instance50 = alloca %TOD_TO_DWORD_interface, align 8
  br label %input51

call47:                                           ; preds = %continue54
  %call59 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance45)
  br label %output48

output48:                                         ; preds = %call47
  br label %continue49

continue49:                                       ; preds = %output48
  store i16 %call59, i16* %MINUTE, align 2
  %HOUR = getelementptr inbounds %SDT, %SDT* %DT2_TO_SDT, i32 0, i32 4
  %DWORD_TO_INT_instance60 = alloca %DWORD_TO_INT_interface, align 8
  br label %input61

input51:                                          ; preds = %input46
  %11 = getelementptr inbounds %TOD_TO_DWORD_interface, %TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance50, i32 0, i32 0
  %load_ti55 = load i64, i64* %TI, align 4
  store i64 %load_ti55, i64* %11, align 4
  br label %call52

call52:                                           ; preds = %input51
  %call56 = call i32 @TOD_TO_DWORD(%TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance50)
  br label %output53

output53:                                         ; preds = %call52
  br label %continue54

continue54:                                       ; preds = %output53
  %tmpVar57 = sdiv i32 %call56, 60000
  %tmpVar58 = srem i32 %tmpVar57, 60
  store i32 %tmpVar58, i32* %10, align 4
  br label %call47

input61:                                          ; preds = %continue49
  %12 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance60, i32 0, i32 0
  %TOD_TO_DWORD_instance65 = alloca %TOD_TO_DWORD_interface, align 8
  br label %input66

call62:                                           ; preds = %continue69
  %call73 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance60)
  br label %output63

output63:                                         ; preds = %call62
  br label %continue64

continue64:                                       ; preds = %output63
  store i16 %call73, i16* %HOUR, align 2
  %DT2_TO_SDT_ret = load %SDT, %SDT* %DT2_TO_SDT, align 2
  ret %SDT %DT2_TO_SDT_ret

input66:                                          ; preds = %input61
  %13 = getelementptr inbounds %TOD_TO_DWORD_interface, %TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance65, i32 0, i32 0
  %load_ti70 = load i64, i64* %TI, align 4
  store i64 %load_ti70, i64* %13, align 4
  br label %call67

call67:                                           ; preds = %input66
  %call71 = call i32 @TOD_TO_DWORD(%TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance65)
  br label %output68

output68:                                         ; preds = %call67
  br label %continue69

continue69:                                       ; preds = %output68
  %tmpVar72 = sdiv i32 %call71, 3600000
  store i32 %tmpVar72, i32* %12, align 4
  br label %call62
}

define %SDT @DT_TO_SDT(%DT_TO_SDT_interface* %0) {
entry:
  %DTI = getelementptr inbounds %DT_TO_SDT_interface, %DT_TO_SDT_interface* %0, i32 0, i32 0
  %tmp = getelementptr inbounds %DT_TO_SDT_interface, %DT_TO_SDT_interface* %0, i32 0, i32 1
  %tdt = getelementptr inbounds %DT_TO_SDT_interface, %DT_TO_SDT_interface* %0, i32 0, i32 2
  %DT_TO_SDT = alloca %SDT, align 8
  store i64 0, i64* %tmp, align 4
  store i32 0, i32* %tdt, align 4
  %1 = bitcast %SDT* %DT_TO_SDT to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%SDT* @SDT__init to i8*), i64 mul nuw (i64 ptrtoint (i16* getelementptr (i16, i16* null, i32 1) to i64), i64 8), i1 false)
  %DT_TO_DATE_instance = alloca %DT_TO_DATE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %DT_TO_DATE_interface, %DT_TO_DATE_interface* %DT_TO_DATE_instance, i32 0, i32 0
  %load_dti = load i64, i64* %DTI, align 4
  store i64 %load_dti, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @DT_TO_DATE(%DT_TO_DATE_interface* %DT_TO_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call1, i64* %tmp, align 4
  %DT_TO_DWORD_instance = alloca %DT_TO_DWORD_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %3 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance, i32 0, i32 0
  %load_dti6 = load i64, i64* %DTI, align 4
  store i64 %load_dti6, i64* %3, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call7 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %DATE_TO_DWORD_instance = alloca %DATE_TO_DWORD_interface, align 8
  br label %input8

input8:                                           ; preds = %continue5
  %4 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance, i32 0, i32 0
  %load_tmp = load i64, i64* %tmp, align 4
  store i64 %load_tmp, i64* %4, align 4
  br label %call9

call9:                                            ; preds = %input8
  %call12 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  %tmpVar = sub i32 %call7, %call12
  store i32 %tmpVar, i32* %tdt, align 4
  %YEAR = getelementptr inbounds %SDT, %SDT* %DT_TO_SDT, i32 0, i32 0
  %YEAR_OF_DATE_instance = alloca %YEAR_OF_DATE_interface, align 8
  br label %input13

input13:                                          ; preds = %continue11
  %5 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance, i32 0, i32 0
  %load_tmp17 = load i64, i64* %tmp, align 4
  store i64 %load_tmp17, i64* %5, align 4
  br label %call14

call14:                                           ; preds = %input13
  %call18 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  store i16 %call18, i16* %YEAR, align 2
  %MONTH = getelementptr inbounds %SDT, %SDT* %DT_TO_SDT, i32 0, i32 1
  %MONTH_OF_DATE_instance = alloca %MONTH_OF_DATE_interface, align 8
  br label %input19

input19:                                          ; preds = %continue16
  %6 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance, i32 0, i32 0
  %load_tmp23 = load i64, i64* %tmp, align 4
  store i64 %load_tmp23, i64* %6, align 4
  br label %call20

call20:                                           ; preds = %input19
  %call24 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  store i16 %call24, i16* %MONTH, align 2
  %DAY = getelementptr inbounds %SDT, %SDT* %DT_TO_SDT, i32 0, i32 2
  %DAY_OF_MONTH_instance = alloca %DAY_OF_MONTH_interface, align 8
  br label %input25

input25:                                          ; preds = %continue22
  %7 = getelementptr inbounds %DAY_OF_MONTH_interface, %DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance, i32 0, i32 0
  %load_tmp29 = load i64, i64* %tmp, align 4
  store i64 %load_tmp29, i64* %7, align 4
  br label %call26

call26:                                           ; preds = %input25
  %call30 = call i16 @DAY_OF_MONTH(%DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  store i16 %call30, i16* %DAY, align 2
  %WEEKDAY = getelementptr inbounds %SDT, %SDT* %DT_TO_SDT, i32 0, i32 3
  %DAY_OF_WEEK_instance = alloca %DAY_OF_WEEK_interface, align 8
  br label %input31

input31:                                          ; preds = %continue28
  %8 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance, i32 0, i32 0
  %load_tmp35 = load i64, i64* %tmp, align 4
  store i64 %load_tmp35, i64* %8, align 4
  br label %call32

call32:                                           ; preds = %input31
  %call36 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance)
  br label %output33

output33:                                         ; preds = %call32
  br label %continue34

continue34:                                       ; preds = %output33
  store i16 %call36, i16* %WEEKDAY, align 2
  %SECOND = getelementptr inbounds %SDT, %SDT* %DT_TO_SDT, i32 0, i32 6
  %DWORD_TO_INT_instance = alloca %DWORD_TO_INT_interface, align 8
  br label %input37

input37:                                          ; preds = %continue34
  %9 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance, i32 0, i32 0
  %load_tdt = load i32, i32* %tdt, align 4
  %tmpVar41 = srem i32 %load_tdt, 60
  store i32 %tmpVar41, i32* %9, align 4
  br label %call38

call38:                                           ; preds = %input37
  %call42 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance)
  br label %output39

output39:                                         ; preds = %call38
  br label %continue40

continue40:                                       ; preds = %output39
  store i16 %call42, i16* %SECOND, align 2
  %MINUTE = getelementptr inbounds %SDT, %SDT* %DT_TO_SDT, i32 0, i32 5
  %DWORD_TO_INT_instance43 = alloca %DWORD_TO_INT_interface, align 8
  br label %input44

input44:                                          ; preds = %continue40
  %10 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance43, i32 0, i32 0
  %load_tdt48 = load i32, i32* %tdt, align 4
  %tmpVar49 = sdiv i32 %load_tdt48, 60
  %tmpVar50 = srem i32 %tmpVar49, 60
  store i32 %tmpVar50, i32* %10, align 4
  br label %call45

call45:                                           ; preds = %input44
  %call51 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance43)
  br label %output46

output46:                                         ; preds = %call45
  br label %continue47

continue47:                                       ; preds = %output46
  store i16 %call51, i16* %MINUTE, align 2
  %HOUR = getelementptr inbounds %SDT, %SDT* %DT_TO_SDT, i32 0, i32 4
  %DWORD_TO_INT_instance52 = alloca %DWORD_TO_INT_interface, align 8
  br label %input53

input53:                                          ; preds = %continue47
  %11 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance52, i32 0, i32 0
  %load_tdt57 = load i32, i32* %tdt, align 4
  %tmpVar58 = sdiv i32 %load_tdt57, 3600
  store i32 %tmpVar58, i32* %11, align 4
  br label %call54

call54:                                           ; preds = %input53
  %call59 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance52)
  br label %output55

output55:                                         ; preds = %call54
  br label %continue56

continue56:                                       ; preds = %output55
  store i16 %call59, i16* %HOUR, align 2
  %DT_TO_SDT_ret = load %SDT, %SDT* %DT_TO_SDT, align 2
  ret %SDT %DT_TO_SDT_ret
}

define i64 @EASTER(%EASTER_interface* %0) {
entry:
  %year = getelementptr inbounds %EASTER_interface, %EASTER_interface* %0, i32 0, i32 0
  %b = getelementptr inbounds %EASTER_interface, %EASTER_interface* %0, i32 0, i32 1
  %c = getelementptr inbounds %EASTER_interface, %EASTER_interface* %0, i32 0, i32 2
  %oday = getelementptr inbounds %EASTER_interface, %EASTER_interface* %0, i32 0, i32 3
  %EASTER = alloca i64, align 8
  store i16 0, i16* %b, align 2
  store i16 0, i16* %c, align 2
  store i16 0, i16* %oday, align 2
  store i64 0, i64* %EASTER, align 4
  %load_YEAR = load i16, i16* %year, align 2
  %1 = sext i16 %load_YEAR to i32
  %tmpVar = srem i32 %1, 19
  %tmpVar1 = mul i32 11, %tmpVar
  %tmpVar2 = sub i32 204, %tmpVar1
  %tmpVar3 = srem i32 %tmpVar2, 30
  %2 = trunc i32 %tmpVar3 to i16
  store i16 %2, i16* %b, align 2
  %load_b = load i16, i16* %b, align 2
  %3 = sext i16 %load_b to i32
  %tmpVar4 = icmp sgt i32 %3, 27
  br i1 %tmpVar4, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %load_b5 = load i16, i16* %b, align 2
  %4 = sext i16 %load_b5 to i32
  %tmpVar6 = sub i32 %4, 1
  %5 = trunc i32 %tmpVar6 to i16
  store i16 %5, i16* %b, align 2
  br label %continue

continue:                                         ; preds = %condition_body, %entry
  %load_year = load i16, i16* %year, align 2
  %6 = sext i16 %load_year to i64
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

input:                                            ; preds = %continue
  %7 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_year8 = load i16, i16* %year, align 2
  %8 = sext i16 %load_year8 to i64
  store i64 %8, i64* %7, align 4
  %9 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %9, align 2
  br label %call

call:                                             ; preds = %input
  %call9 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue7

continue7:                                        ; preds = %output
  %tmpVar10 = add i64 %6, %call9
  %load_b11 = load i16, i16* %b, align 2
  %10 = sext i16 %load_b11 to i64
  %tmpVar12 = add i64 %tmpVar10, %10
  %tmpVar13 = sub i64 %tmpVar12, 13
  %tmpVar14 = srem i64 %tmpVar13, 7
  %11 = trunc i64 %tmpVar14 to i16
  store i16 %11, i16* %c, align 2
  %load_b15 = load i16, i16* %b, align 2
  %12 = sext i16 %load_b15 to i32
  %tmpVar16 = add i32 28, %12
  %load_c = load i16, i16* %c, align 2
  %13 = sext i16 %load_c to i32
  %tmpVar17 = sub i32 %tmpVar16, %13
  %14 = trunc i32 %tmpVar17 to i16
  store i16 %14, i16* %oday, align 2
  %load_oday = load i16, i16* %oday, align 2
  %15 = sext i16 %load_oday to i32
  %tmpVar20 = icmp sgt i32 %15, 33
  br i1 %tmpVar20, label %condition_body19, label %else

condition_body19:                                 ; preds = %continue7
  %SET_DATE_instance = alloca %SET_DATE_interface, align 8
  br label %input21

else:                                             ; preds = %continue7
  %SET_DATE_instance29 = alloca %SET_DATE_interface, align 8
  br label %input30

continue18:                                       ; preds = %continue33, %continue24
  %EASTER_ret = load i64, i64* %EASTER, align 4
  ret i64 %EASTER_ret

input21:                                          ; preds = %condition_body19
  %16 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 0
  %load_year25 = load i16, i16* %year, align 2
  store i16 %load_year25, i16* %16, align 2
  %17 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 1
  store i16 4, i16* %17, align 2
  %18 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 2
  %load_oday26 = load i16, i16* %oday, align 2
  %19 = sext i16 %load_oday26 to i32
  %tmpVar27 = sub i32 %19, 31
  %20 = trunc i32 %tmpVar27 to i16
  store i16 %20, i16* %18, align 2
  br label %call22

call22:                                           ; preds = %input21
  %call28 = call i64 @SET_DATE(%SET_DATE_interface* %SET_DATE_instance)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  store i64 %call28, i64* %EASTER, align 4
  br label %continue18

input30:                                          ; preds = %else
  %21 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance29, i32 0, i32 0
  %load_year34 = load i16, i16* %year, align 2
  store i16 %load_year34, i16* %21, align 2
  %22 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance29, i32 0, i32 1
  store i16 3, i16* %22, align 2
  %23 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance29, i32 0, i32 2
  %load_oday35 = load i16, i16* %oday, align 2
  store i16 %load_oday35, i16* %23, align 2
  br label %call31

call31:                                           ; preds = %input30
  %call36 = call i64 @SET_DATE(%SET_DATE_interface* %SET_DATE_instance29)
  br label %output32

output32:                                         ; preds = %call31
  br label %continue33

continue33:                                       ; preds = %output32
  store i64 %call36, i64* %EASTER, align 4
  br label %continue18
}

define void @EVENTS(%EVENTS_interface* %0) {
entry:
  %DATE_IN = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 0
  %ENA = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 1
  %Y = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 2
  %NAME = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 3
  %i = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 4
  %last_active = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 5
  %size = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 6
  %day_in = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 7
  %cyr = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 8
  %lday = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 9
  %check = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 10
  %y_int = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 11
  %name_int = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 12
  %ELIST = getelementptr inbounds %EVENTS_interface, %EVENTS_interface* %0, i32 0, i32 13
  %load_last_active = load i64, i64* %last_active, align 4
  %load_date_in = load i64, i64* %DATE_IN, align 4
  %tmpVar = icmp ne i64 %load_last_active, %load_date_in
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  %load_DATE_IN = load i64, i64* %DATE_IN, align 4
  store i64 %load_DATE_IN, i64* %last_active, align 4
  store i8 0, i8* %y_int, align 1
  %1 = bitcast [31 x i8]* %name_int to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %1, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  %DAY_OF_DATE_instance = alloca %DAY_OF_DATE_interface, align 8
  br label %input

continue:                                         ; preds = %continue10, %entry
  %load_ENA = load i8, i8* %ENA, align 1
  %2 = icmp ne i8 %load_ENA, 0
  br i1 %2, label %condition_body47, label %else

input:                                            ; preds = %condition_body
  %3 = getelementptr inbounds %DAY_OF_DATE_interface, %DAY_OF_DATE_interface* %DAY_OF_DATE_instance, i32 0, i32 0
  %load_DATE_IN2 = load i64, i64* %DATE_IN, align 4
  store i64 %load_DATE_IN2, i64* %3, align 4
  br label %call

call:                                             ; preds = %input
  %call3 = call i32 @DAY_OF_DATE(%DAY_OF_DATE_interface* %DAY_OF_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue1

continue1:                                        ; preds = %output
  store i32 %call3, i32* %day_in, align 4
  %YEAR_OF_DATE_instance = alloca %YEAR_OF_DATE_interface, align 8
  br label %input4

input4:                                           ; preds = %continue1
  %4 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance, i32 0, i32 0
  %load_DATE_IN8 = load i64, i64* %DATE_IN, align 4
  store i64 %load_DATE_IN8, i64* %4, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call9 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  store i16 %call9, i16* %cyr, align 2
  store i16 0, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue7
  %load_i = load i16, i16* %i, align 2
  %load_i11 = load i16, i16* %i, align 2
  %load_size = load i16, i16* %size, align 2
  %tmpVar12 = icmp sle i16 %load_i11, %load_size
  %5 = icmp ne i1 %tmpVar12, false
  br i1 %5, label %11, label %12

for_body:                                         ; preds = %9
  %deref = load [50 x %HOLIDAY_DATA]*, [50 x %HOLIDAY_DATA]** %ELIST, align 8
  %load_i20 = load i16, i16* %i, align 2
  %6 = sext i16 %load_i20 to i32
  %tmpVar21 = mul i32 1, %6
  %tmpVar22 = add i32 %tmpVar21, 0
  %tmpVar23 = getelementptr inbounds [50 x %HOLIDAY_DATA], [50 x %HOLIDAY_DATA]* %deref, i32 0, i32 %tmpVar22
  %load_tmpVar = load %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar23, align 1
  store %HOLIDAY_DATA %load_tmpVar, %HOLIDAY_DATA* %check, align 1
  %DAY_OF_DATE_instance24 = alloca %DAY_OF_DATE_interface, align 8
  br label %input25

increment:                                        ; preds = %continue36
  %tmpVar45 = add i16 %load_i, 1
  store i16 %tmpVar45, i16* %i, align 2
  br label %condition_check

continue10:                                       ; preds = %condition_body37, %9
  br label %continue

7:                                                ; preds = %12
  %load_i15 = load i16, i16* %i, align 2
  %load_size16 = load i16, i16* %size, align 2
  %tmpVar17 = icmp sge i16 %load_i15, %load_size16
  %8 = icmp ne i1 %tmpVar17, false
  br i1 %8, label %15, label %16

9:                                                ; preds = %16, %12
  %10 = phi i1 [ %13, %12 ], [ %17, %16 ]
  br i1 %10, label %for_body, label %continue10

11:                                               ; preds = %condition_check
  %load_i13 = load i16, i16* %i, align 2
  %tmpVar14 = icmp sge i16 %load_i13, 0
  br label %12

12:                                               ; preds = %11, %condition_check
  %13 = phi i1 [ %tmpVar12, %condition_check ], [ %tmpVar14, %11 ]
  %14 = icmp ne i1 %13, false
  br i1 %14, label %9, label %7

15:                                               ; preds = %7
  %load_i18 = load i16, i16* %i, align 2
  %tmpVar19 = icmp sle i16 %load_i18, 0
  br label %16

16:                                               ; preds = %15, %7
  %17 = phi i1 [ %tmpVar17, %7 ], [ %tmpVar19, %15 ]
  br label %9

input25:                                          ; preds = %for_body
  %18 = getelementptr inbounds %DAY_OF_DATE_interface, %DAY_OF_DATE_interface* %DAY_OF_DATE_instance24, i32 0, i32 0
  %SET_DATE_instance = alloca %SET_DATE_interface, align 8
  br label %input29

call26:                                           ; preds = %continue32
  %call35 = call i32 @DAY_OF_DATE(%DAY_OF_DATE_interface* %DAY_OF_DATE_instance24)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  store i32 %call35, i32* %lday, align 4
  %load_day_in = load i32, i32* %day_in, align 4
  %load_lday = load i32, i32* %lday, align 4
  %tmpVar38 = icmp sge i32 %load_day_in, %load_lday
  %19 = zext i1 %tmpVar38 to i32
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %28, label %31

input29:                                          ; preds = %input25
  %21 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 0
  %load_cyr = load i16, i16* %cyr, align 2
  store i16 %load_cyr, i16* %21, align 2
  %22 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 1
  %month = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %check, i32 0, i32 2
  %load_ = load i8, i8* %month, align 1
  %23 = sext i8 %load_ to i16
  store i16 %23, i16* %22, align 2
  %24 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 2
  %day = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %check, i32 0, i32 1
  %load_33 = load i8, i8* %day, align 1
  %25 = sext i8 %load_33 to i16
  store i16 %25, i16* %24, align 2
  br label %call30

call30:                                           ; preds = %input29
  %call34 = call i64 @SET_DATE(%SET_DATE_interface* %SET_DATE_instance)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  store i64 %call34, i64* %18, align 4
  br label %call26

condition_body37:                                 ; preds = %31
  store i8 1, i8* %y_int, align 1
  %name = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %check, i32 0, i32 0
  %26 = bitcast [31 x i8]* %name_int to i8*
  %27 = bitcast [31 x i8]* %name to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %26, i8* align 1 %27, i32 30, i1 false)
  br label %continue10

buffer_block:                                     ; No predecessors!
  br label %continue36

continue36:                                       ; preds = %buffer_block, %31
  br label %increment

28:                                               ; preds = %continue28
  %load_day_in39 = load i32, i32* %day_in, align 4
  %load_lday40 = load i32, i32* %lday, align 4
  %use = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %check, i32 0, i32 3
  %load_41 = load i8, i8* %use, align 1
  %29 = sext i8 %load_41 to i32
  %tmpVar42 = add i32 %load_lday40, %29
  %tmpVar43 = sub i32 %tmpVar42, 1
  %tmpVar44 = icmp sle i32 %load_day_in39, %tmpVar43
  %30 = zext i1 %tmpVar44 to i32
  br label %31

31:                                               ; preds = %28, %continue28
  %32 = phi i32 [ %19, %continue28 ], [ %30, %28 ]
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %condition_body37, label %continue36

condition_body47:                                 ; preds = %continue
  %load_y_int = load i8, i8* %y_int, align 1
  store i8 %load_y_int, i8* %Y, align 1
  %34 = bitcast [31 x i8]* %NAME to i8*
  %35 = bitcast [31 x i8]* %name_int to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %34, i8* align 1 %35, i32 30, i1 false)
  br label %continue46

else:                                             ; preds = %continue
  store i8 0, i8* %Y, align 1
  %36 = bitcast [31 x i8]* %NAME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %36, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  br label %continue46

continue46:                                       ; preds = %else, %condition_body47
  ret void
}

define void @HOLIDAY(%HOLIDAY_interface* %0) {
entry:
  %DATE_IN = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 0
  %LANGU = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 1
  %FRIDAY = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 2
  %SATURDAY = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 3
  %SUNDAY = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 4
  %HOLIDAYS = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 5
  %SIZE = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 6
  %Y = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 7
  %NAME = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 8
  %last_active = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 9
  %ostern = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 10
  %i = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 11
  %jahr = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 12
  %x_date = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 13
  %lx = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 14
  %wdx = getelementptr inbounds %HOLIDAY_interface, %HOLIDAY_interface* %0, i32 0, i32 15
  %load_last_active = load i64, i64* %last_active, align 4
  %load_date_in = load i64, i64* %DATE_IN, align 4
  %tmpVar = icmp eq i64 %load_last_active, %load_date_in
  br i1 %tmpVar, label %condition_body, label %continue

condition_body:                                   ; preds = %entry
  ret void

buffer_block:                                     ; No predecessors!
  br label %continue

continue:                                         ; preds = %buffer_block, %entry
  %load_DATE_IN = load i64, i64* %DATE_IN, align 4
  store i64 %load_DATE_IN, i64* %last_active, align 4
  %load_LANGU = load i16, i16* %LANGU, align 2
  %1 = sext i16 %load_LANGU to i32
  %tmpVar3 = icmp eq i32 %1, 0
  br i1 %tmpVar3, label %condition_body2, label %else

condition_body2:                                  ; preds = %continue
  %load_ = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 0), align 2
  store i16 %load_, i16* %lx, align 2
  br label %continue1

else:                                             ; preds = %continue
  %MIN_instance = alloca %MIN_interface, align 8
  br label %input

continue1:                                        ; preds = %continue4, %condition_body2
  %YEAR_OF_DATE_instance = alloca %YEAR_OF_DATE_interface, align 8
  br label %input8

input:                                            ; preds = %else
  %2 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 0
  %load_5 = load i16, i16* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 1), align 2
  %3 = sext i16 %load_5 to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %MIN_interface, %MIN_interface* %MIN_instance, i32 0, i32 1
  %load_LANGU6 = load i16, i16* %LANGU, align 2
  %5 = sext i16 %load_LANGU6 to i64
  store i64 %5, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call7 = call i64 @MIN(%MIN_interface* %MIN_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue4

continue4:                                        ; preds = %output
  %6 = trunc i64 %call7 to i16
  store i16 %6, i16* %lx, align 2
  br label %continue1

input8:                                           ; preds = %continue1
  %7 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance, i32 0, i32 0
  %load_date_in12 = load i64, i64* %DATE_IN, align 4
  store i64 %load_date_in12, i64* %7, align 4
  br label %call9

call9:                                            ; preds = %input8
  %call13 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  store i16 %call13, i16* %jahr, align 2
  %EASTER_instance = alloca %EASTER_interface, align 8
  br label %input14

input14:                                          ; preds = %continue11
  %8 = getelementptr inbounds %EASTER_interface, %EASTER_interface* %EASTER_instance, i32 0, i32 0
  %load_jahr = load i16, i16* %jahr, align 2
  store i16 %load_jahr, i16* %8, align 2
  br label %call15

call15:                                           ; preds = %input14
  %call18 = call i64 @EASTER(%EASTER_interface* %EASTER_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  store i64 %call18, i64* %ostern, align 4
  %DAY_OF_WEEK_instance = alloca %DAY_OF_WEEK_interface, align 8
  br label %input19

input19:                                          ; preds = %continue17
  %9 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance, i32 0, i32 0
  %load_DATE_IN23 = load i64, i64* %DATE_IN, align 4
  store i64 %load_DATE_IN23, i64* %9, align 4
  br label %call20

call20:                                           ; preds = %input19
  %call24 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  store i16 %call24, i16* %wdx, align 2
  store i8 0, i8* %Y, align 1
  store i16 0, i16* %i, align 2
  br label %condition_check

condition_check:                                  ; preds = %increment, %continue22
  %load_i = load i16, i16* %i, align 2
  %load_i26 = load i16, i16* %i, align 2
  %load_size = load i16, i16* %SIZE, align 2
  %tmpVar27 = icmp sle i16 %load_i26, %load_size
  %10 = icmp ne i1 %tmpVar27, false
  br i1 %10, label %17, label %18

for_body:                                         ; preds = %15
  %SET_DATE_instance = alloca %SET_DATE_interface, align 8
  br label %input35

increment:                                        ; preds = %continue53
  %tmpVar171 = add i16 %load_i, 1
  store i16 %tmpVar171, i16* %i, align 2
  br label %condition_check

continue25:                                       ; preds = %15
  %load_Y = load i8, i8* %Y, align 1
  %tmpVar175 = xor i8 %load_Y, -1
  %11 = zext i8 %tmpVar175 to i32
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %102, label %106

13:                                               ; preds = %18
  %load_i30 = load i16, i16* %i, align 2
  %load_size31 = load i16, i16* %SIZE, align 2
  %tmpVar32 = icmp sge i16 %load_i30, %load_size31
  %14 = icmp ne i1 %tmpVar32, false
  br i1 %14, label %21, label %22

15:                                               ; preds = %22, %18
  %16 = phi i1 [ %19, %18 ], [ %23, %22 ]
  br i1 %16, label %for_body, label %continue25

17:                                               ; preds = %condition_check
  %load_i28 = load i16, i16* %i, align 2
  %tmpVar29 = icmp sge i16 %load_i28, 0
  br label %18

18:                                               ; preds = %17, %condition_check
  %19 = phi i1 [ %tmpVar27, %condition_check ], [ %tmpVar29, %17 ]
  %20 = icmp ne i1 %19, false
  br i1 %20, label %15, label %13

21:                                               ; preds = %13
  %load_i33 = load i16, i16* %i, align 2
  %tmpVar34 = icmp sle i16 %load_i33, 0
  br label %22

22:                                               ; preds = %21, %13
  %23 = phi i1 [ %tmpVar32, %13 ], [ %tmpVar34, %21 ]
  br label %15

input35:                                          ; preds = %for_body
  %24 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 0
  %load_jahr39 = load i16, i16* %jahr, align 2
  store i16 %load_jahr39, i16* %24, align 2
  %25 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 1
  %deref = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i40 = load i16, i16* %i, align 2
  %26 = sext i16 %load_i40 to i32
  %tmpVar41 = mul i32 1, %26
  %tmpVar42 = add i32 %tmpVar41, 0
  %tmpVar43 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref, i32 0, i32 %tmpVar42
  %MONTH = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar43, i32 0, i32 2
  %load_44 = load i8, i8* %MONTH, align 1
  %27 = sext i8 %load_44 to i16
  store i16 %27, i16* %25, align 2
  %28 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 2
  %deref45 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i46 = load i16, i16* %i, align 2
  %29 = sext i16 %load_i46 to i32
  %tmpVar47 = mul i32 1, %29
  %tmpVar48 = add i32 %tmpVar47, 0
  %tmpVar49 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref45, i32 0, i32 %tmpVar48
  %DAY = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar49, i32 0, i32 1
  %load_50 = load i8, i8* %DAY, align 1
  %30 = sext i8 %load_50 to i16
  store i16 %30, i16* %28, align 2
  br label %call36

call36:                                           ; preds = %input35
  %call51 = call i64 @SET_DATE(%SET_DATE_interface* %SET_DATE_instance)
  br label %output37

output37:                                         ; preds = %call36
  br label %continue38

continue38:                                       ; preds = %output37
  store i64 %call51, i64* %x_date, align 4
  %deref55 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i56 = load i16, i16* %i, align 2
  %31 = sext i16 %load_i56 to i32
  %tmpVar57 = mul i32 1, %31
  %tmpVar58 = add i32 %tmpVar57, 0
  %tmpVar59 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref55, i32 0, i32 %tmpVar58
  %USE = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar59, i32 0, i32 3
  %load_60 = load i8, i8* %USE, align 1
  %32 = sext i8 %load_60 to i32
  %tmpVar61 = icmp eq i32 %32, 1
  %33 = zext i1 %tmpVar61 to i32
  %34 = icmp ne i32 %33, 0
  br i1 %34, label %41, label %45

condition_body54:                                 ; preds = %45
  %load_x_date = load i64, i64* %x_date, align 4
  %load_date_in72 = load i64, i64* %DATE_IN, align 4
  %tmpVar73 = icmp eq i64 %load_x_date, %load_date_in72
  br i1 %tmpVar73, label %condition_body71, label %continue70

branch:                                           ; preds = %45
  %deref82 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i83 = load i16, i16* %i, align 2
  %35 = sext i16 %load_i83 to i32
  %tmpVar84 = mul i32 1, %35
  %tmpVar85 = add i32 %tmpVar84, 0
  %tmpVar86 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref82, i32 0, i32 %tmpVar85
  %USE87 = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar86, i32 0, i32 3
  %load_88 = load i8, i8* %USE87, align 1
  %36 = sext i8 %load_88 to i32
  %tmpVar89 = icmp eq i32 %36, 1
  %37 = zext i1 %tmpVar89 to i32
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %51, label %55

condition_body81:                                 ; preds = %55
  %DATE_ADD_instance = alloca %DATE_ADD_interface, align 8
  br label %input100

branch52:                                         ; preds = %55
  %deref122 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i123 = load i16, i16* %i, align 2
  %39 = sext i16 %load_i123 to i32
  %tmpVar124 = mul i32 1, %39
  %tmpVar125 = add i32 %tmpVar124, 0
  %tmpVar126 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref122, i32 0, i32 %tmpVar125
  %USE127 = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar126, i32 0, i32 3
  %load_128 = load i8, i8* %USE127, align 1
  %40 = sext i8 %load_128 to i32
  %tmpVar129 = icmp slt i32 %40, 0
  br i1 %tmpVar129, label %condition_body121, label %continue53

condition_body121:                                ; preds = %branch52
  %DAY_OF_WEEK_instance132 = alloca %DAY_OF_WEEK_interface, align 8
  br label %input133

continue53:                                       ; preds = %continue130, %branch52, %continue98, %continue70
  br label %increment

41:                                               ; preds = %continue38
  %deref62 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i63 = load i16, i16* %i, align 2
  %42 = sext i16 %load_i63 to i32
  %tmpVar64 = mul i32 1, %42
  %tmpVar65 = add i32 %tmpVar64, 0
  %tmpVar66 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref62, i32 0, i32 %tmpVar65
  %MONTH67 = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar66, i32 0, i32 2
  %load_68 = load i8, i8* %MONTH67, align 1
  %43 = sext i8 %load_68 to i32
  %tmpVar69 = icmp sgt i32 %43, 0
  %44 = zext i1 %tmpVar69 to i32
  br label %45

45:                                               ; preds = %41, %continue38
  %46 = phi i32 [ %33, %continue38 ], [ %44, %41 ]
  %47 = icmp ne i32 %46, 0
  br i1 %47, label %condition_body54, label %branch

condition_body71:                                 ; preds = %condition_body54
  store i8 1, i8* %Y, align 1
  %deref74 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i75 = load i16, i16* %i, align 2
  %48 = sext i16 %load_i75 to i32
  %tmpVar76 = mul i32 1, %48
  %tmpVar77 = add i32 %tmpVar76, 0
  %tmpVar78 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref74, i32 0, i32 %tmpVar77
  %NAME79 = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar78, i32 0, i32 0
  %49 = bitcast [31 x i8]* %NAME to i8*
  %50 = bitcast [31 x i8]* %NAME79 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %49, i8* align 1 %50, i32 30, i1 false)
  ret void

buffer_block80:                                   ; No predecessors!
  br label %continue70

continue70:                                       ; preds = %buffer_block80, %condition_body54
  br label %continue53

51:                                               ; preds = %branch
  %deref90 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i91 = load i16, i16* %i, align 2
  %52 = sext i16 %load_i91 to i32
  %tmpVar92 = mul i32 1, %52
  %tmpVar93 = add i32 %tmpVar92, 0
  %tmpVar94 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref90, i32 0, i32 %tmpVar93
  %MONTH95 = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar94, i32 0, i32 2
  %load_96 = load i8, i8* %MONTH95, align 1
  %53 = sext i8 %load_96 to i32
  %tmpVar97 = icmp eq i32 %53, 0
  %54 = zext i1 %tmpVar97 to i32
  br label %55

55:                                               ; preds = %51, %branch
  %56 = phi i32 [ %37, %branch ], [ %54, %51 ]
  %57 = icmp ne i32 %56, 0
  br i1 %57, label %condition_body81, label %branch52

condition_body99:                                 ; preds = %continue103
  store i8 1, i8* %Y, align 1
  %deref114 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i115 = load i16, i16* %i, align 2
  %58 = sext i16 %load_i115 to i32
  %tmpVar116 = mul i32 1, %58
  %tmpVar117 = add i32 %tmpVar116, 0
  %tmpVar118 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref114, i32 0, i32 %tmpVar117
  %NAME119 = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar118, i32 0, i32 0
  %59 = bitcast [31 x i8]* %NAME to i8*
  %60 = bitcast [31 x i8]* %NAME119 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %59, i8* align 1 %60, i32 30, i1 false)
  ret void

buffer_block120:                                  ; No predecessors!
  br label %continue98

continue98:                                       ; preds = %buffer_block120, %continue103
  br label %continue53

input100:                                         ; preds = %condition_body81
  %61 = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %DATE_ADD_instance, i32 0, i32 0
  %load_ostern = load i64, i64* %ostern, align 4
  store i64 %load_ostern, i64* %61, align 4
  %62 = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %DATE_ADD_instance, i32 0, i32 1
  %deref104 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i105 = load i16, i16* %i, align 2
  %63 = sext i16 %load_i105 to i32
  %tmpVar106 = mul i32 1, %63
  %tmpVar107 = add i32 %tmpVar106, 0
  %tmpVar108 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref104, i32 0, i32 %tmpVar107
  %DAY109 = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar108, i32 0, i32 1
  %load_110 = load i8, i8* %DAY109, align 1
  %64 = sext i8 %load_110 to i16
  store i16 %64, i16* %62, align 2
  %65 = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %DATE_ADD_instance, i32 0, i32 2
  store i16 0, i16* %65, align 2
  %66 = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %DATE_ADD_instance, i32 0, i32 3
  store i16 0, i16* %66, align 2
  %67 = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %DATE_ADD_instance, i32 0, i32 4
  store i16 0, i16* %67, align 2
  br label %call101

call101:                                          ; preds = %input100
  %call111 = call i64 @DATE_ADD(%DATE_ADD_interface* %DATE_ADD_instance)
  br label %output102

output102:                                        ; preds = %call101
  br label %continue103

continue103:                                      ; preds = %output102
  %load_date_in112 = load i64, i64* %DATE_IN, align 4
  %tmpVar113 = icmp eq i64 %call111, %load_date_in112
  br i1 %tmpVar113, label %condition_body99, label %continue98

condition_body131:                                ; preds = %72
  store i8 1, i8* %Y, align 1
  %deref164 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i165 = load i16, i16* %i, align 2
  %68 = sext i16 %load_i165 to i32
  %tmpVar166 = mul i32 1, %68
  %tmpVar167 = add i32 %tmpVar166, 0
  %tmpVar168 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref164, i32 0, i32 %tmpVar167
  %NAME169 = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar168, i32 0, i32 0
  %69 = bitcast [31 x i8]* %NAME to i8*
  %70 = bitcast [31 x i8]* %NAME169 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %69, i8* align 1 %70, i32 30, i1 false)
  ret void

buffer_block170:                                  ; No predecessors!
  br label %continue130

continue130:                                      ; preds = %buffer_block170, %72
  br label %continue53

71:                                               ; preds = %77
  %load_date_in155 = load i64, i64* %DATE_IN, align 4
  %DATE_ADD_instance156 = alloca %DATE_ADD_interface, align 8
  br label %input157

72:                                               ; preds = %continue160, %77
  %73 = phi i32 [ %78, %77 ], [ %92, %continue160 ]
  %74 = icmp ne i32 %73, 0
  br i1 %74, label %condition_body131, label %continue130

75:                                               ; preds = %continue142
  %load_date_in152 = load i64, i64* %DATE_IN, align 4
  %load_x_date153 = load i64, i64* %x_date, align 4
  %tmpVar154 = icmp slt i64 %load_date_in152, %load_x_date153
  %76 = zext i1 %tmpVar154 to i32
  br label %77

77:                                               ; preds = %75, %continue142
  %78 = phi i32 [ %85, %continue142 ], [ %76, %75 ]
  %79 = icmp ne i32 %78, 0
  br i1 %79, label %71, label %72

input133:                                         ; preds = %condition_body121
  %80 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance132, i32 0, i32 0
  %load_date_in137 = load i64, i64* %DATE_IN, align 4
  store i64 %load_date_in137, i64* %80, align 4
  br label %call134

call134:                                          ; preds = %input133
  %call138 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance132)
  br label %output135

output135:                                        ; preds = %call134
  br label %continue136

continue136:                                      ; preds = %output135
  %81 = sext i16 %call138 to i64
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input139

input139:                                         ; preds = %continue136
  %82 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %deref143 = load [30 x %HOLIDAY_DATA]*, [30 x %HOLIDAY_DATA]** %HOLIDAYS, align 8
  %load_i144 = load i16, i16* %i, align 2
  %83 = sext i16 %load_i144 to i32
  %tmpVar145 = mul i32 1, %83
  %tmpVar146 = add i32 %tmpVar145, 0
  %tmpVar147 = getelementptr inbounds [30 x %HOLIDAY_DATA], [30 x %HOLIDAY_DATA]* %deref143, i32 0, i32 %tmpVar146
  %USE148 = getelementptr inbounds %HOLIDAY_DATA, %HOLIDAY_DATA* %tmpVar147, i32 0, i32 3
  %load_149 = load i8, i8* %USE148, align 1
  %84 = sext i8 %load_149 to i64
  store i64 %84, i64* %82, align 4
  br label %call140

call140:                                          ; preds = %input139
  %call150 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output141

output141:                                        ; preds = %call140
  br label %continue142

continue142:                                      ; preds = %output141
  %tmpVar151 = icmp eq i64 %81, %call150
  %85 = zext i1 %tmpVar151 to i32
  %86 = icmp ne i32 %85, 0
  br i1 %86, label %75, label %77

input157:                                         ; preds = %71
  %87 = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %DATE_ADD_instance156, i32 0, i32 0
  %load_x_date161 = load i64, i64* %x_date, align 4
  store i64 %load_x_date161, i64* %87, align 4
  %88 = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %DATE_ADD_instance156, i32 0, i32 1
  store i16 -7, i16* %88, align 2
  %89 = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %DATE_ADD_instance156, i32 0, i32 2
  store i16 0, i16* %89, align 2
  %90 = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %DATE_ADD_instance156, i32 0, i32 3
  store i16 0, i16* %90, align 2
  %91 = getelementptr inbounds %DATE_ADD_interface, %DATE_ADD_interface* %DATE_ADD_instance156, i32 0, i32 4
  store i16 0, i16* %91, align 2
  br label %call158

call158:                                          ; preds = %input157
  %call162 = call i64 @DATE_ADD(%DATE_ADD_interface* %DATE_ADD_instance156)
  br label %output159

output159:                                        ; preds = %call158
  br label %continue160

continue160:                                      ; preds = %output159
  %tmpVar163 = icmp sge i64 %load_date_in155, %call162
  %92 = zext i1 %tmpVar163 to i32
  br label %72

condition_body174:                                ; preds = %106
  store i8 1, i8* %Y, align 1
  %load_lx = load i16, i16* %lx, align 2
  %93 = sub i16 %load_lx, 1
  %94 = sext i16 %93 to i32
  %tmpVar181 = mul i32 1, %94
  %tmpVar182 = add i32 %tmpVar181, 0
  %tmpVar183 = getelementptr inbounds [5 x i16], [5 x i16]* getelementptr inbounds (%CONSTANTS_LOCATION, %CONSTANTS_LOCATION* @LOCATION, i32 0, i32 2), i32 0, i32 %tmpVar182
  %load_184 = load i16, i16* %tmpVar183, align 2
  %95 = sub i16 %load_184, 1
  %96 = sext i16 %95 to i32
  %tmpVar185 = mul i32 7, %96
  %tmpVar186 = add i32 %tmpVar185, 0
  %load_wdx187 = load i16, i16* %wdx, align 2
  %97 = sub i16 %load_wdx187, 1
  %98 = sext i16 %97 to i32
  %tmpVar188 = mul i32 1, %98
  %tmpVar189 = add i32 %tmpVar188, %tmpVar186
  %tmpVar190 = getelementptr inbounds [21 x [11 x i8]], [21 x [11 x i8]]* getelementptr inbounds (%CONSTANTS_LANGUAGE, %CONSTANTS_LANGUAGE* @LANGUAGE, i32 0, i32 2), i32 0, i32 %tmpVar189
  %99 = bitcast [31 x i8]* %NAME to i8*
  %100 = bitcast [11 x i8]* %tmpVar190 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %99, i8* align 1 %100, i32 11, i1 false)
  br label %continue173

else172:                                          ; preds = %106
  %101 = bitcast [31 x i8]* %NAME to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %101, i8* align 1 getelementptr inbounds ([1 x i8], [1 x i8]* @utf08_literal_0, i32 0, i32 0), i32 1, i1 false)
  br label %continue173

continue173:                                      ; preds = %else172, %condition_body174
  ret void

102:                                              ; preds = %continue25
  %load_wdx = load i16, i16* %wdx, align 2
  %103 = sext i16 %load_wdx to i32
  %tmpVar176 = icmp eq i32 %103, 5
  %104 = zext i1 %tmpVar176 to i32
  %105 = icmp ne i32 %104, 0
  br i1 %105, label %122, label %124

106:                                              ; preds = %113, %continue25
  %107 = phi i32 [ %11, %continue25 ], [ %114, %113 ]
  %108 = icmp ne i32 %107, 0
  br i1 %108, label %condition_body174, label %else172

109:                                              ; preds = %119
  %load_wdx179 = load i16, i16* %wdx, align 2
  %110 = sext i16 %load_wdx179 to i32
  %tmpVar180 = icmp eq i32 %110, 7
  %111 = zext i1 %tmpVar180 to i32
  %112 = icmp ne i32 %111, 0
  br i1 %112, label %131, label %133

113:                                              ; preds = %133, %119
  %114 = phi i32 [ %120, %119 ], [ %134, %133 ]
  br label %106

115:                                              ; preds = %124
  %load_wdx177 = load i16, i16* %wdx, align 2
  %116 = sext i16 %load_wdx177 to i32
  %tmpVar178 = icmp eq i32 %116, 6
  %117 = zext i1 %tmpVar178 to i32
  %118 = icmp ne i32 %117, 0
  br i1 %118, label %127, label %129

119:                                              ; preds = %129, %124
  %120 = phi i32 [ %125, %124 ], [ %130, %129 ]
  %121 = icmp ne i32 %120, 0
  br i1 %121, label %113, label %109

122:                                              ; preds = %102
  %load_FRIDAY = load i8, i8* %FRIDAY, align 1
  %123 = zext i8 %load_FRIDAY to i32
  br label %124

124:                                              ; preds = %122, %102
  %125 = phi i32 [ %104, %102 ], [ %123, %122 ]
  %126 = icmp ne i32 %125, 0
  br i1 %126, label %119, label %115

127:                                              ; preds = %115
  %load_SATURDAY = load i8, i8* %SATURDAY, align 1
  %128 = zext i8 %load_SATURDAY to i32
  br label %129

129:                                              ; preds = %127, %115
  %130 = phi i32 [ %117, %115 ], [ %128, %127 ]
  br label %119

131:                                              ; preds = %109
  %load_SUNDAY = load i8, i8* %SUNDAY, align 1
  %132 = zext i8 %load_SUNDAY to i32
  br label %133

133:                                              ; preds = %131, %109
  %134 = phi i32 [ %111, %109 ], [ %132, %131 ]
  br label %113
}

define i16 @HOUR(%HOUR_interface* %0) {
entry:
  %itod = getelementptr inbounds %HOUR_interface, %HOUR_interface* %0, i32 0, i32 0
  %HOUR = alloca i16, align 2
  store i16 0, i16* %HOUR, align 2
  %DWORD_TO_INT_instance = alloca %DWORD_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance, i32 0, i32 0
  %TOD_TO_DWORD_instance = alloca %TOD_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call6, i16* %HOUR, align 2
  %HOUR_ret = load i16, i16* %HOUR, align 2
  ret i16 %HOUR_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %TOD_TO_DWORD_interface, %TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance, i32 0, i32 0
  %load_itod = load i64, i64* %itod, align 4
  store i64 %load_itod, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @TOD_TO_DWORD(%TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = sdiv i32 %call5, 3600000
  store i32 %tmpVar, i32* %1, align 4
  br label %call
}

define i16 @HOUR_OF_DT(%HOUR_OF_DT_interface* %0) {
entry:
  %XDT = getelementptr inbounds %HOUR_OF_DT_interface, %HOUR_OF_DT_interface* %0, i32 0, i32 0
  %HOUR_OF_DT = alloca i16, align 2
  store i16 0, i16* %HOUR_OF_DT, align 2
  %DWORD_TO_INT_instance = alloca %DWORD_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance, i32 0, i32 0
  %DT_TO_DWORD_instance = alloca %DT_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call7 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call7, i16* %HOUR_OF_DT, align 2
  %HOUR_OF_DT_ret = load i16, i16* %HOUR_OF_DT, align 2
  ret i16 %HOUR_OF_DT_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance, i32 0, i32 0
  %load_XDT = load i64, i64* %XDT, align 4
  store i64 %load_XDT, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = srem i32 %call5, 86400
  %tmpVar6 = sdiv i32 %tmpVar, 3600
  store i32 %tmpVar6, i32* %1, align 4
  br label %call
}

define i64 @HOUR_TO_TIME(%HOUR_TO_TIME_interface* %0) {
entry:
  %IN = getelementptr inbounds %HOUR_TO_TIME_interface, %HOUR_TO_TIME_interface* %0, i32 0, i32 0
  %HOUR_TO_TIME = alloca i64, align 8
  store i64 0, i64* %HOUR_TO_TIME, align 4
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %HOUR_TO_TIME, align 4
  %HOUR_TO_TIME_ret = load i64, i64* %HOUR_TO_TIME, align 4
  ret i64 %HOUR_TO_TIME_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %load_IN = load float, float* %IN, align 4
  %tmpVar = fmul float %load_IN, 3.600000e+06
  store float %tmpVar, float* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call
}

define i64 @HOUR_TO_TOD(%HOUR_TO_TOD_interface* %0) {
entry:
  %IN = getelementptr inbounds %HOUR_TO_TOD_interface, %HOUR_TO_TOD_interface* %0, i32 0, i32 0
  %HOUR_TO_TOD = alloca i64, align 8
  store i64 0, i64* %HOUR_TO_TOD, align 4
  %DWORD_TO_TOD_instance = alloca %DWORD_TO_TOD_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TOD_interface, %DWORD_TO_TOD_interface* %DWORD_TO_TOD_instance, i32 0, i32 0
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TOD(%DWORD_TO_TOD_interface* %DWORD_TO_TOD_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %HOUR_TO_TOD, align 4
  %HOUR_TO_TOD_ret = load i64, i64* %HOUR_TO_TOD, align 4
  ret i64 %HOUR_TO_TOD_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %load_IN = load float, float* %IN, align 4
  %tmpVar = fmul float %load_IN, 3.600000e+06
  store float %tmpVar, float* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call
}

define float @JD2000(%JD2000_interface* %0) {
entry:
  %DTI = getelementptr inbounds %JD2000_interface, %JD2000_interface* %0, i32 0, i32 0
  %JD2000 = alloca float, align 4
  store float 0.000000e+00, float* %JD2000, align 4
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %DT_TO_DWORD_instance = alloca %DT_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar7 = fdiv float %call6, 8.640000e+04
  store float %tmpVar7, float* %JD2000, align 4
  %JD2000_ret = load float, float* %JD2000, align 4
  ret float %JD2000_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance, i32 0, i32 0
  %load_DTI = load i64, i64* %DTI, align 4
  store i64 %load_DTI, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = sub i32 %call5, 946728000
  store i32 %tmpVar, i32* %1, align 4
  br label %call
}

define i8 @LEAP_DAY(%LEAP_DAY_interface* %0) {
entry:
  %IDATE = getelementptr inbounds %LEAP_DAY_interface, %LEAP_DAY_interface* %0, i32 0, i32 0
  %LEAP_DAY = alloca i8, align 1
  store i8 0, i8* %LEAP_DAY, align 1
  %DATE_TO_UDINT_instance = alloca %DATE_TO_UDINT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DATE_TO_UDINT_interface, %DATE_TO_UDINT_interface* %DATE_TO_UDINT_instance, i32 0, i32 0
  %load_IDATE = load i64, i64* %IDATE, align 4
  store i64 %load_IDATE, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @DATE_TO_UDINT(%DATE_TO_UDINT_interface* %DATE_TO_UDINT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = srem i32 %call1, 126230400
  %tmpVar2 = icmp eq i32 %tmpVar, 68169600
  %2 = zext i1 %tmpVar2 to i8
  store i8 %2, i8* %LEAP_DAY, align 1
  %LEAP_DAY_ret = load i8, i8* %LEAP_DAY, align 1
  ret i8 %LEAP_DAY_ret
}

define i8 @LEAP_OF_DATE(%LEAP_OF_DATE_interface* %0) {
entry:
  %idate = getelementptr inbounds %LEAP_OF_DATE_interface, %LEAP_OF_DATE_interface* %0, i32 0, i32 0
  %LEAP_OF_DATE = alloca i8, align 1
  store i8 0, i8* %LEAP_OF_DATE, align 1
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %DATE_TO_DWORD_instance = alloca %DATE_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call7 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar8 = icmp eq i64 %call7, 2147483648
  %2 = zext i1 %tmpVar8 to i8
  store i8 %2, i8* %LEAP_OF_DATE, align 1
  %LEAP_OF_DATE_ret = load i8, i8* %LEAP_OF_DATE, align 1
  ret i8 %LEAP_OF_DATE_ret

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance, i32 0, i32 0
  %load_idate = load i64, i64* %idate, align 4
  store i64 %load_idate, i64* %3, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = add i32 %call5, 43200
  %tmpVar6 = sdiv i32 %tmpVar, 31557600
  %4 = sext i32 %tmpVar6 to i64
  store i64 %4, i64* %1, align 4
  %5 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 30, i16* %5, align 2
  br label %call
}

define i8 @LEAP_YEAR(%LEAP_YEAR_interface* %0) {
entry:
  %yr = getelementptr inbounds %LEAP_YEAR_interface, %LEAP_YEAR_interface* %0, i32 0, i32 0
  %LEAP_YEAR = alloca i8, align 1
  store i8 0, i8* %LEAP_YEAR, align 1
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_yr = load i16, i16* %yr, align 2
  %2 = sext i16 %load_yr to i64
  store i64 %2, i64* %1, align 4
  %3 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 14, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar = icmp eq i64 %call1, 0
  %4 = zext i1 %tmpVar to i8
  store i8 %4, i8* %LEAP_YEAR, align 1
  %LEAP_YEAR_ret = load i8, i8* %LEAP_YEAR, align 1
  ret i8 %LEAP_YEAR_ret
}

define i64 @LTIME_TO_UTC(%LTIME_TO_UTC_interface* %0) {
entry:
  %LTIME = getelementptr inbounds %LTIME_TO_UTC_interface, %LTIME_TO_UTC_interface* %0, i32 0, i32 0
  %DST = getelementptr inbounds %LTIME_TO_UTC_interface, %LTIME_TO_UTC_interface* %0, i32 0, i32 1
  %TIME_ZONE_OFFSET = getelementptr inbounds %LTIME_TO_UTC_interface, %LTIME_TO_UTC_interface* %0, i32 0, i32 2
  %LTIME_TO_UTC = alloca i64, align 8
  store i64 0, i64* %LTIME_TO_UTC, align 4
  %UDINT_TO_DT_instance = alloca %UDINT_TO_DT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %UDINT_TO_DT_interface, %UDINT_TO_DT_interface* %UDINT_TO_DT_instance, i32 0, i32 0
  %DT_TO_UDINT_instance = alloca %DT_TO_UDINT_interface, align 8
  br label %input1

call:                                             ; preds = %continue9
  %call12 = call i64 @UDINT_TO_DT(%UDINT_TO_DT_interface* %UDINT_TO_DT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call12, i64* %LTIME_TO_UTC, align 4
  %load_DST = load i8, i8* %DST, align 1
  %2 = icmp ne i8 %load_DST, 0
  br i1 %2, label %condition_body, label %continue13

input1:                                           ; preds = %input
  %3 = getelementptr inbounds %DT_TO_UDINT_interface, %DT_TO_UDINT_interface* %DT_TO_UDINT_instance, i32 0, i32 0
  %load_LTIME = load i64, i64* %LTIME, align 4
  store i64 %load_LTIME, i64* %3, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DT_TO_UDINT(%DT_TO_UDINT_interface* %DT_TO_UDINT_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %INT_TO_UDINT_instance = alloca %INT_TO_UDINT_interface, align 8
  br label %input6

input6:                                           ; preds = %continue4
  %4 = getelementptr inbounds %INT_TO_UDINT_interface, %INT_TO_UDINT_interface* %INT_TO_UDINT_instance, i32 0, i32 0
  %load_TIME_ZONE_OFFSET = load i16, i16* %TIME_ZONE_OFFSET, align 2
  store i16 %load_TIME_ZONE_OFFSET, i16* %4, align 2
  br label %call7

call7:                                            ; preds = %input6
  %call10 = call i32 @INT_TO_UDINT(%INT_TO_UDINT_interface* %INT_TO_UDINT_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %tmpVar = mul i32 %call10, 60
  %tmpVar11 = sub i32 %call5, %tmpVar
  store i32 %tmpVar11, i32* %1, align 4
  br label %call

condition_body:                                   ; preds = %continue
  %load_LTIME_TO_UTC = load i64, i64* %LTIME_TO_UTC, align 4
  %tmpVar14 = sub i64 %load_LTIME_TO_UTC, 3600000000000
  store i64 %tmpVar14, i64* %LTIME_TO_UTC, align 4
  br label %continue13

continue13:                                       ; preds = %condition_body, %continue
  %LTIME_TO_UTC_ret = load i64, i64* %LTIME_TO_UTC, align 4
  ret i64 %LTIME_TO_UTC_ret
}

define i16 @MINUTE(%MINUTE_interface* %0) {
entry:
  %itod = getelementptr inbounds %MINUTE_interface, %MINUTE_interface* %0, i32 0, i32 0
  %MINUTE = alloca i16, align 2
  store i16 0, i16* %MINUTE, align 2
  %DWORD_TO_INT_instance = alloca %DWORD_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance, i32 0, i32 0
  %TOD_TO_DWORD_instance = alloca %TOD_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue10
  %call16 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call16, i16* %MINUTE, align 2
  %MINUTE_ret = load i16, i16* %MINUTE, align 2
  ret i16 %MINUTE_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %TOD_TO_DWORD_interface, %TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance, i32 0, i32 0
  %load_itod = load i64, i64* %itod, align 4
  store i64 %load_itod, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @TOD_TO_DWORD(%TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = sdiv i32 %call5, 60000
  %TOD_TO_DWORD_instance6 = alloca %TOD_TO_DWORD_interface, align 8
  br label %input7

input7:                                           ; preds = %continue4
  %3 = getelementptr inbounds %TOD_TO_DWORD_interface, %TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance6, i32 0, i32 0
  %load_itod11 = load i64, i64* %itod, align 4
  store i64 %load_itod11, i64* %3, align 4
  br label %call8

call8:                                            ; preds = %input7
  %call12 = call i32 @TOD_TO_DWORD(%TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance6)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %tmpVar13 = sdiv i32 %call12, 3600000
  %tmpVar14 = mul i32 %tmpVar13, 60
  %tmpVar15 = sub i32 %tmpVar, %tmpVar14
  store i32 %tmpVar15, i32* %1, align 4
  br label %call
}

define i16 @MINUTE_OF_DT(%MINUTE_OF_DT_interface* %0) {
entry:
  %XDT = getelementptr inbounds %MINUTE_OF_DT_interface, %MINUTE_OF_DT_interface* %0, i32 0, i32 0
  %MINUTE_OF_DT = alloca i16, align 2
  store i16 0, i16* %MINUTE_OF_DT, align 2
  %DWORD_TO_INT_instance = alloca %DWORD_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance, i32 0, i32 0
  %DT_TO_DWORD_instance = alloca %DT_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %2 = sext i16 %call6 to i32
  %tmpVar7 = sdiv i32 %2, 60
  %3 = trunc i32 %tmpVar7 to i16
  store i16 %3, i16* %MINUTE_OF_DT, align 2
  %MINUTE_OF_DT_ret = load i16, i16* %MINUTE_OF_DT, align 2
  ret i16 %MINUTE_OF_DT_ret

input1:                                           ; preds = %input
  %4 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance, i32 0, i32 0
  %load_XDT = load i64, i64* %XDT, align 4
  store i64 %load_XDT, i64* %4, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = srem i32 %call5, 3600
  store i32 %tmpVar, i32* %1, align 4
  br label %call
}

define i64 @MINUTE_TO_TIME(%MINUTE_TO_TIME_interface* %0) {
entry:
  %IN = getelementptr inbounds %MINUTE_TO_TIME_interface, %MINUTE_TO_TIME_interface* %0, i32 0, i32 0
  %MINUTE_TO_TIME = alloca i64, align 8
  store i64 0, i64* %MINUTE_TO_TIME, align 4
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %MINUTE_TO_TIME, align 4
  %MINUTE_TO_TIME_ret = load i64, i64* %MINUTE_TO_TIME, align 4
  ret i64 %MINUTE_TO_TIME_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %load_IN = load float, float* %IN, align 4
  %tmpVar = fmul float %load_IN, 6.000000e+04
  store float %tmpVar, float* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call
}

define i64 @MONTH_BEGIN(%MONTH_BEGIN_interface* %0) {
entry:
  %idate = getelementptr inbounds %MONTH_BEGIN_interface, %MONTH_BEGIN_interface* %0, i32 0, i32 0
  %MONTH_BEGIN = alloca i64, align 8
  store i64 0, i64* %MONTH_BEGIN, align 4
  %DWORD_TO_DATE_instance = alloca %DWORD_TO_DATE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_DATE_interface, %DWORD_TO_DATE_interface* %DWORD_TO_DATE_instance, i32 0, i32 0
  %DATE_TO_DWORD_instance = alloca %DATE_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue9
  %call19 = call i64 @DWORD_TO_DATE(%DWORD_TO_DATE_interface* %DWORD_TO_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call19, i64* %MONTH_BEGIN, align 4
  %MONTH_BEGIN_ret = load i64, i64* %MONTH_BEGIN, align 4
  ret i64 %MONTH_BEGIN_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance, i32 0, i32 0
  %load_idate = load i64, i64* %idate, align 4
  store i64 %load_idate, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input6

input6:                                           ; preds = %continue4
  %3 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %DAY_OF_MONTH_instance = alloca %DAY_OF_MONTH_interface, align 8
  br label %input10

call7:                                            ; preds = %continue13
  %call16 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %tmpVar17 = mul i32 %call16, 86400
  %tmpVar18 = sub i32 %call5, %tmpVar17
  store i32 %tmpVar18, i32* %1, align 4
  br label %call

input10:                                          ; preds = %input6
  %4 = getelementptr inbounds %DAY_OF_MONTH_interface, %DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance, i32 0, i32 0
  %load_idate14 = load i64, i64* %idate, align 4
  store i64 %load_idate14, i64* %4, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call15 = call i16 @DAY_OF_MONTH(%DAY_OF_MONTH_interface* %DAY_OF_MONTH_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  %5 = sext i16 %call15 to i32
  %tmpVar = sub i32 %5, 1
  %6 = trunc i32 %tmpVar to i16
  store i16 %6, i16* %3, align 2
  br label %call7
}

define i64 @MONTH_END(%MONTH_END_interface* %0) {
entry:
  %IDATE = getelementptr inbounds %MONTH_END_interface, %MONTH_END_interface* %0, i32 0, i32 0
  %MONTH_END = alloca i64, align 8
  store i64 0, i64* %MONTH_END, align 4
  %DWORD_TO_DATE_instance = alloca %DWORD_TO_DATE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_DATE_interface, %DWORD_TO_DATE_interface* %DWORD_TO_DATE_instance, i32 0, i32 0
  %DATE_TO_DWORD_instance = alloca %DATE_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call23 = call i64 @DWORD_TO_DATE(%DWORD_TO_DATE_interface* %DWORD_TO_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call23, i64* %MONTH_END, align 4
  %MONTH_END_ret = load i64, i64* %MONTH_END, align 4
  ret i64 %MONTH_END_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance, i32 0, i32 0
  %SET_DATE_instance = alloca %SET_DATE_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  %call21 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar22 = sub i32 %call21, 86400
  store i32 %tmpVar22, i32* %1, align 4
  br label %call

input5:                                           ; preds = %input1
  %3 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 0
  %YEAR_OF_DATE_instance = alloca %YEAR_OF_DATE_interface, align 8
  br label %input9

call6:                                            ; preds = %continue17
  %call20 = call i64 @SET_DATE(%SET_DATE_interface* %SET_DATE_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  store i64 %call20, i64* %2, align 4
  br label %call2

input9:                                           ; preds = %input5
  %4 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance, i32 0, i32 0
  %load_idate = load i64, i64* %IDATE, align 4
  store i64 %load_idate, i64* %4, align 4
  br label %call10

call10:                                           ; preds = %input9
  %call13 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  store i16 %call13, i16* %3, align 2
  %5 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 1
  %MONTH_OF_DATE_instance = alloca %MONTH_OF_DATE_interface, align 8
  br label %input14

input14:                                          ; preds = %continue12
  %6 = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance, i32 0, i32 0
  %load_idate18 = load i64, i64* %IDATE, align 4
  store i64 %load_idate18, i64* %6, align 4
  br label %call15

call15:                                           ; preds = %input14
  %call19 = call i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %MONTH_OF_DATE_instance)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %7 = sext i16 %call19 to i32
  %tmpVar = add i32 %7, 1
  %8 = trunc i32 %tmpVar to i16
  store i16 %8, i16* %5, align 2
  %9 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 2
  store i16 1, i16* %9, align 2
  br label %call6
}

define i16 @MONTH_OF_DATE(%MONTH_OF_DATE_interface* %0) {
entry:
  %IDATE = getelementptr inbounds %MONTH_OF_DATE_interface, %MONTH_OF_DATE_interface* %0, i32 0, i32 0
  %MONTH_OF_DATE = alloca i16, align 2
  store i16 0, i16* %MONTH_OF_DATE, align 2
  %DAY_OF_YEAR_instance = alloca %DAY_OF_YEAR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DAY_OF_YEAR_interface, %DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance, i32 0, i32 0
  %load_idate = load i64, i64* %IDATE, align 4
  store i64 %load_idate, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @DAY_OF_YEAR(%DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %MONTH_OF_DATE, align 2
  %load_MONTH_OF_DATE = load i16, i16* %MONTH_OF_DATE, align 2
  %2 = sext i16 %load_MONTH_OF_DATE to i32
  %tmpVar = icmp slt i32 %2, 32
  br i1 %tmpVar, label %condition_body, label %branch

condition_body:                                   ; preds = %continue
  store i16 1, i16* %MONTH_OF_DATE, align 2
  br label %continue2

branch:                                           ; preds = %continue
  %LEAP_OF_DATE_instance = alloca %LEAP_OF_DATE_interface, align 8
  br label %input4

condition_body3:                                  ; preds = %continue7
  %load_MONTH_OF_DATE9 = load i16, i16* %MONTH_OF_DATE, align 2
  %3 = sext i16 %load_MONTH_OF_DATE9 to i32
  %tmpVar10 = mul i32 %3, 53
  %tmpVar11 = add i32 %tmpVar10, 1668
  %tmpVar12 = sdiv i32 %tmpVar11, 1623
  %4 = trunc i32 %tmpVar12 to i16
  store i16 %4, i16* %MONTH_OF_DATE, align 2
  br label %continue2

else:                                             ; preds = %continue7
  %load_MONTH_OF_DATE13 = load i16, i16* %MONTH_OF_DATE, align 2
  %5 = sext i16 %load_MONTH_OF_DATE13 to i32
  %tmpVar14 = mul i32 %5, 53
  %tmpVar15 = add i32 %tmpVar14, 1700
  %tmpVar16 = sdiv i32 %tmpVar15, 1620
  %6 = trunc i32 %tmpVar16 to i16
  store i16 %6, i16* %MONTH_OF_DATE, align 2
  br label %continue2

continue2:                                        ; preds = %else, %condition_body3, %condition_body
  %MONTH_OF_DATE_ret = load i16, i16* %MONTH_OF_DATE, align 2
  ret i16 %MONTH_OF_DATE_ret

input4:                                           ; preds = %branch
  %7 = getelementptr inbounds %LEAP_OF_DATE_interface, %LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance, i32 0, i32 0
  %load_IDATE = load i64, i64* %IDATE, align 4
  store i64 %load_IDATE, i64* %7, align 4
  br label %call5

call5:                                            ; preds = %input4
  %call8 = call i8 @LEAP_OF_DATE(%LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance)
  br label %output6

output6:                                          ; preds = %call5
  br label %continue7

continue7:                                        ; preds = %output6
  %8 = icmp ne i8 %call8, 0
  br i1 %8, label %condition_body3, label %else
}

define i64 @MULTIME(%MULTIME_interface* %0) {
entry:
  %t = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %0, i32 0, i32 0
  %M = getelementptr inbounds %MULTIME_interface, %MULTIME_interface* %0, i32 0, i32 1
  %MULTIME = alloca i64, align 8
  store i64 0, i64* %MULTIME, align 4
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call16 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call16, i64* %MULTIME, align 4
  %MULTIME_ret = load i64, i64* %MULTIME, align 4
  ret i64 %MULTIME_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  %call15 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call15, i32* %1, align 4
  br label %call

input5:                                           ; preds = %input1
  %3 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %TIME_TO_DWORD_instance = alloca %TIME_TO_DWORD_interface, align 8
  br label %input9

call6:                                            ; preds = %continue12
  %call14 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %load_M = load float, float* %M, align 4
  %tmpVar = fmul float %call14, %load_M
  store float %tmpVar, float* %2, align 4
  br label %call2

input9:                                           ; preds = %input5
  %4 = getelementptr inbounds %TIME_TO_DWORD_interface, %TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance, i32 0, i32 0
  %load_t = load i64, i64* %t, align 4
  store i64 %load_t, i64* %4, align 4
  br label %call10

call10:                                           ; preds = %input9
  %call13 = call i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface* %TIME_TO_DWORD_instance)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  store i32 %call13, i32* %3, align 4
  br label %call6
}

define i8 @PERIOD(%PERIOD_interface* %0) {
entry:
  %d1 = getelementptr inbounds %PERIOD_interface, %PERIOD_interface* %0, i32 0, i32 0
  %dx = getelementptr inbounds %PERIOD_interface, %PERIOD_interface* %0, i32 0, i32 1
  %d2 = getelementptr inbounds %PERIOD_interface, %PERIOD_interface* %0, i32 0, i32 2
  %day1 = getelementptr inbounds %PERIOD_interface, %PERIOD_interface* %0, i32 0, i32 3
  %day2 = getelementptr inbounds %PERIOD_interface, %PERIOD_interface* %0, i32 0, i32 4
  %dayx = getelementptr inbounds %PERIOD_interface, %PERIOD_interface* %0, i32 0, i32 5
  %PERIOD = alloca i8, align 1
  store i16 0, i16* %day1, align 2
  store i16 0, i16* %day2, align 2
  store i16 0, i16* %dayx, align 2
  store i8 0, i8* %PERIOD, align 1
  %DAY_OF_YEAR_instance = alloca %DAY_OF_YEAR_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DAY_OF_YEAR_interface, %DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance, i32 0, i32 0
  %load_d1 = load i64, i64* %d1, align 4
  store i64 %load_d1, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @DAY_OF_YEAR(%DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %day1, align 2
  %DAY_OF_YEAR_instance2 = alloca %DAY_OF_YEAR_interface, align 8
  br label %input3

input3:                                           ; preds = %continue
  %2 = getelementptr inbounds %DAY_OF_YEAR_interface, %DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance2, i32 0, i32 0
  %load_d2 = load i64, i64* %d2, align 4
  store i64 %load_d2, i64* %2, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i16 @DAY_OF_YEAR(%DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance2)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  store i16 %call7, i16* %day2, align 2
  %DAY_OF_YEAR_instance8 = alloca %DAY_OF_YEAR_interface, align 8
  br label %input9

input9:                                           ; preds = %continue6
  %3 = getelementptr inbounds %DAY_OF_YEAR_interface, %DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance8, i32 0, i32 0
  %load_dx = load i64, i64* %dx, align 4
  store i64 %load_dx, i64* %3, align 4
  br label %call10

call10:                                           ; preds = %input9
  %call13 = call i16 @DAY_OF_YEAR(%DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance8)
  br label %output11

output11:                                         ; preds = %call10
  br label %continue12

continue12:                                       ; preds = %output11
  store i16 %call13, i16* %dayx, align 2
  %LEAP_OF_DATE_instance = alloca %LEAP_OF_DATE_interface, align 8
  br label %input15

condition_body:                                   ; preds = %9
  %load_dayx22 = load i16, i16* %dayx, align 2
  %4 = sext i16 %load_dayx22 to i32
  %tmpVar23 = add i32 %4, 1
  %5 = trunc i32 %tmpVar23 to i16
  store i16 %5, i16* %dayx, align 2
  br label %continue14

continue14:                                       ; preds = %condition_body, %9
  %LEAP_OF_DATE_instance26 = alloca %LEAP_OF_DATE_interface, align 8
  br label %input27

6:                                                ; preds = %continue18
  %load_dayx = load i16, i16* %dayx, align 2
  %7 = sext i16 %load_dayx to i32
  %tmpVar21 = icmp sgt i32 %7, 58
  %8 = zext i1 %tmpVar21 to i32
  br label %9

9:                                                ; preds = %6, %continue18
  %10 = phi i32 [ %13, %continue18 ], [ %8, %6 ]
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %condition_body, label %continue14

input15:                                          ; preds = %continue12
  %12 = getelementptr inbounds %LEAP_OF_DATE_interface, %LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance, i32 0, i32 0
  %load_dx19 = load i64, i64* %dx, align 4
  store i64 %load_dx19, i64* %12, align 4
  br label %call16

call16:                                           ; preds = %input15
  %call20 = call i8 @LEAP_OF_DATE(%LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %tmpVar = xor i8 %call20, -1
  %13 = zext i8 %tmpVar to i32
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %6, label %9

condition_body25:                                 ; preds = %20
  %load_day135 = load i16, i16* %day1, align 2
  %15 = sext i16 %load_day135 to i32
  %tmpVar36 = add i32 %15, 1
  %16 = trunc i32 %tmpVar36 to i16
  store i16 %16, i16* %day1, align 2
  br label %continue24

continue24:                                       ; preds = %condition_body25, %20
  %LEAP_OF_DATE_instance39 = alloca %LEAP_OF_DATE_interface, align 8
  br label %input40

17:                                               ; preds = %continue30
  %load_day1 = load i16, i16* %day1, align 2
  %18 = sext i16 %load_day1 to i32
  %tmpVar34 = icmp sgt i32 %18, 58
  %19 = zext i1 %tmpVar34 to i32
  br label %20

20:                                               ; preds = %17, %continue30
  %21 = phi i32 [ %24, %continue30 ], [ %19, %17 ]
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %condition_body25, label %continue24

input27:                                          ; preds = %continue14
  %23 = getelementptr inbounds %LEAP_OF_DATE_interface, %LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance26, i32 0, i32 0
  %load_d131 = load i64, i64* %d1, align 4
  store i64 %load_d131, i64* %23, align 4
  br label %call28

call28:                                           ; preds = %input27
  %call32 = call i8 @LEAP_OF_DATE(%LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance26)
  br label %output29

output29:                                         ; preds = %call28
  br label %continue30

continue30:                                       ; preds = %output29
  %tmpVar33 = xor i8 %call32, -1
  %24 = zext i8 %tmpVar33 to i32
  %25 = icmp ne i32 %24, 0
  br i1 %25, label %17, label %20

condition_body38:                                 ; preds = %33
  %load_day248 = load i16, i16* %day2, align 2
  %26 = sext i16 %load_day248 to i32
  %tmpVar49 = add i32 %26, 1
  %27 = trunc i32 %tmpVar49 to i16
  store i16 %27, i16* %day2, align 2
  br label %continue37

continue37:                                       ; preds = %condition_body38, %33
  %load_day252 = load i16, i16* %day2, align 2
  %28 = sext i16 %load_day252 to i32
  %load_day153 = load i16, i16* %day1, align 2
  %29 = sext i16 %load_day153 to i32
  %tmpVar54 = icmp slt i32 %28, %29
  br i1 %tmpVar54, label %condition_body51, label %else

30:                                               ; preds = %continue43
  %load_day2 = load i16, i16* %day2, align 2
  %31 = sext i16 %load_day2 to i32
  %tmpVar47 = icmp sgt i32 %31, 58
  %32 = zext i1 %tmpVar47 to i32
  br label %33

33:                                               ; preds = %30, %continue43
  %34 = phi i32 [ %37, %continue43 ], [ %32, %30 ]
  %35 = icmp ne i32 %34, 0
  br i1 %35, label %condition_body38, label %continue37

input40:                                          ; preds = %continue24
  %36 = getelementptr inbounds %LEAP_OF_DATE_interface, %LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance39, i32 0, i32 0
  %load_d244 = load i64, i64* %d2, align 4
  store i64 %load_d244, i64* %36, align 4
  br label %call41

call41:                                           ; preds = %input40
  %call45 = call i8 @LEAP_OF_DATE(%LEAP_OF_DATE_interface* %LEAP_OF_DATE_instance39)
  br label %output42

output42:                                         ; preds = %call41
  br label %continue43

continue43:                                       ; preds = %output42
  %tmpVar46 = xor i8 %call45, -1
  %37 = zext i8 %tmpVar46 to i32
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %30, label %33

condition_body51:                                 ; preds = %continue37
  %load_dayx55 = load i16, i16* %dayx, align 2
  %39 = sext i16 %load_dayx55 to i32
  %load_day256 = load i16, i16* %day2, align 2
  %40 = sext i16 %load_day256 to i32
  %tmpVar57 = icmp sle i32 %39, %40
  %41 = zext i1 %tmpVar57 to i32
  %42 = icmp ne i32 %41, 0
  br i1 %42, label %51, label %47

else:                                             ; preds = %continue37
  %load_dayx61 = load i16, i16* %dayx, align 2
  %43 = sext i16 %load_dayx61 to i32
  %load_day162 = load i16, i16* %day1, align 2
  %44 = sext i16 %load_day162 to i32
  %tmpVar63 = icmp sge i32 %43, %44
  %45 = zext i1 %tmpVar63 to i32
  %46 = icmp ne i32 %45, 0
  br i1 %46, label %53, label %57

continue50:                                       ; preds = %57, %51
  %PERIOD_ret = load i8, i8* %PERIOD, align 1
  ret i8 %PERIOD_ret

47:                                               ; preds = %condition_body51
  %load_dayx58 = load i16, i16* %dayx, align 2
  %48 = sext i16 %load_dayx58 to i32
  %load_day159 = load i16, i16* %day1, align 2
  %49 = sext i16 %load_day159 to i32
  %tmpVar60 = icmp sge i32 %48, %49
  %50 = zext i1 %tmpVar60 to i32
  br label %51

51:                                               ; preds = %47, %condition_body51
  %52 = phi i32 [ %41, %condition_body51 ], [ %50, %47 ]
  store i32 %52, i8* %PERIOD, align 4
  br label %continue50

53:                                               ; preds = %else
  %load_dayx64 = load i16, i16* %dayx, align 2
  %54 = sext i16 %load_dayx64 to i32
  %load_day265 = load i16, i16* %day2, align 2
  %55 = sext i16 %load_day265 to i32
  %tmpVar66 = icmp sle i32 %54, %55
  %56 = zext i1 %tmpVar66 to i32
  br label %57

57:                                               ; preds = %53, %else
  %58 = phi i32 [ %45, %else ], [ %56, %53 ]
  store i32 %58, i8* %PERIOD, align 4
  br label %continue50
}

define i8 @PERIOD2(%PERIOD2_interface* %0) {
entry:
  %DP = getelementptr inbounds %PERIOD2_interface, %PERIOD2_interface* %0, i32 0, i32 0
  %DX = getelementptr inbounds %PERIOD2_interface, %PERIOD2_interface* %0, i32 0, i32 1
  %PERIOD2 = alloca i8, align 1
  store i8 0, i8* %PERIOD2, align 1
  %load_DX = load i64, i64* %DX, align 4
  %tmpVar = getelementptr inbounds [8 x i64], [8 x i64]* %DP, i32 0, i32 0
  %load_tmpVar = load i64, i64* %tmpVar, align 4
  %tmpVar1 = icmp sge i64 %load_DX, %load_tmpVar
  %1 = zext i1 %tmpVar1 to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %20, label %22

3:                                                ; preds = %11
  %load_DX22 = load i64, i64* %DX, align 4
  %tmpVar23 = getelementptr inbounds [8 x i64], [8 x i64]* %DP, i32 0, i32 6
  %load_tmpVar24 = load i64, i64* %tmpVar23, align 4
  %tmpVar25 = icmp sge i64 %load_DX22, %load_tmpVar24
  %4 = zext i1 %tmpVar25 to i32
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %33, label %35

6:                                                ; preds = %35, %11
  %7 = phi i32 [ %12, %11 ], [ %36, %35 ]
  store i32 %7, i8* %PERIOD2, align 4
  %PERIOD2_ret = load i8, i8* %PERIOD2, align 1
  ret i8 %PERIOD2_ret

8:                                                ; preds = %17
  %load_DX14 = load i64, i64* %DX, align 4
  %tmpVar15 = getelementptr inbounds [8 x i64], [8 x i64]* %DP, i32 0, i32 4
  %load_tmpVar16 = load i64, i64* %tmpVar15, align 4
  %tmpVar17 = icmp sge i64 %load_DX14, %load_tmpVar16
  %9 = zext i1 %tmpVar17 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %29, label %31

11:                                               ; preds = %31, %17
  %12 = phi i32 [ %18, %17 ], [ %32, %31 ]
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %6, label %3

14:                                               ; preds = %22
  %load_DX6 = load i64, i64* %DX, align 4
  %tmpVar7 = getelementptr inbounds [8 x i64], [8 x i64]* %DP, i32 0, i32 2
  %load_tmpVar8 = load i64, i64* %tmpVar7, align 4
  %tmpVar9 = icmp sge i64 %load_DX6, %load_tmpVar8
  %15 = zext i1 %tmpVar9 to i32
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %25, label %27

17:                                               ; preds = %27, %22
  %18 = phi i32 [ %23, %22 ], [ %28, %27 ]
  %19 = icmp ne i32 %18, 0
  br i1 %19, label %11, label %8

20:                                               ; preds = %entry
  %load_DX2 = load i64, i64* %DX, align 4
  %tmpVar3 = getelementptr inbounds [8 x i64], [8 x i64]* %DP, i32 0, i32 1
  %load_tmpVar4 = load i64, i64* %tmpVar3, align 4
  %tmpVar5 = icmp sle i64 %load_DX2, %load_tmpVar4
  %21 = zext i1 %tmpVar5 to i32
  br label %22

22:                                               ; preds = %20, %entry
  %23 = phi i32 [ %1, %entry ], [ %21, %20 ]
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %17, label %14

25:                                               ; preds = %14
  %load_DX10 = load i64, i64* %DX, align 4
  %tmpVar11 = getelementptr inbounds [8 x i64], [8 x i64]* %DP, i32 0, i32 3
  %load_tmpVar12 = load i64, i64* %tmpVar11, align 4
  %tmpVar13 = icmp sle i64 %load_DX10, %load_tmpVar12
  %26 = zext i1 %tmpVar13 to i32
  br label %27

27:                                               ; preds = %25, %14
  %28 = phi i32 [ %15, %14 ], [ %26, %25 ]
  br label %17

29:                                               ; preds = %8
  %load_DX18 = load i64, i64* %DX, align 4
  %tmpVar19 = getelementptr inbounds [8 x i64], [8 x i64]* %DP, i32 0, i32 5
  %load_tmpVar20 = load i64, i64* %tmpVar19, align 4
  %tmpVar21 = icmp sle i64 %load_DX18, %load_tmpVar20
  %30 = zext i1 %tmpVar21 to i32
  br label %31

31:                                               ; preds = %29, %8
  %32 = phi i32 [ %9, %8 ], [ %30, %29 ]
  br label %11

33:                                               ; preds = %3
  %load_DX26 = load i64, i64* %DX, align 4
  %tmpVar27 = getelementptr inbounds [8 x i64], [8 x i64]* %DP, i32 0, i32 7
  %load_tmpVar28 = load i64, i64* %tmpVar27, align 4
  %tmpVar29 = icmp sle i64 %load_DX26, %load_tmpVar28
  %34 = zext i1 %tmpVar29 to i32
  br label %35

35:                                               ; preds = %33, %3
  %36 = phi i32 [ %4, %3 ], [ %34, %33 ]
  br label %6
}

define float @REFRACTION(%REFRACTION_interface* %0) {
entry:
  %ELEV = getelementptr inbounds %REFRACTION_interface, %REFRACTION_interface* %0, i32 0, i32 0
  %REFRACTION = alloca float, align 4
  store float 0.000000e+00, float* %REFRACTION, align 4
  %LIMIT_instance = alloca %LIMIT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 0
  store i64 undef, i64* %1, align 4
  %2 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 1
  %load_elev = load float, float* %ELEV, align 4
  %3 = fptoui float %load_elev to i64
  store i64 %3, i64* %2, align 4
  %4 = getelementptr inbounds %LIMIT_interface, %LIMIT_interface* %LIMIT_instance, i32 0, i32 2
  store i64 80, i64* %4, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @LIMIT(%LIMIT_interface* %LIMIT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = uitofp i64 %call1 to float
  store float %5, float* %ELEV, align 4
  %TAN_instance = alloca %TAN_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %6 = getelementptr inbounds %TAN_interface, %TAN_interface* %TAN_instance, i32 0, i32 0
  %load_ELEV = load float, float* %ELEV, align 4
  %load_ELEV6 = load float, float* %ELEV, align 4
  %tmpVar = fadd float %load_ELEV6, 0x401470A3E0000000
  %tmpVar7 = fdiv float 0x40249999A0000000, %tmpVar
  %tmpVar8 = fadd float %load_ELEV, %tmpVar7
  %tmpVar9 = fmul float 0x3F91DF46A0000000, %tmpVar8
  %7 = fptosi float %tmpVar9 to i32
  store i32 %7, i32* %6, align 4
  br label %call3

call3:                                            ; preds = %input2
  %call10 = call double @TAN(%TAN_interface* %TAN_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %tmpVar11 = fdiv double 0x3F91DF46A2529D3A, %call10
  %8 = fptrunc double %tmpVar11 to float
  store float %8, float* %REFRACTION, align 4
  %REFRACTION_ret = load float, float* %REFRACTION, align 4
  ret float %REFRACTION_ret
}

define void @RTC_2(%RTC_2_interface* %0) {
entry:
  %SET = getelementptr inbounds %RTC_2_interface, %RTC_2_interface* %0, i32 0, i32 0
  %SDT = getelementptr inbounds %RTC_2_interface, %RTC_2_interface* %0, i32 0, i32 1
  %SMS = getelementptr inbounds %RTC_2_interface, %RTC_2_interface* %0, i32 0, i32 2
  %DEN = getelementptr inbounds %RTC_2_interface, %RTC_2_interface* %0, i32 0, i32 3
  %OFS = getelementptr inbounds %RTC_2_interface, %RTC_2_interface* %0, i32 0, i32 4
  %UDT = getelementptr inbounds %RTC_2_interface, %RTC_2_interface* %0, i32 0, i32 5
  %LDT = getelementptr inbounds %RTC_2_interface, %RTC_2_interface* %0, i32 0, i32 6
  %DSO = getelementptr inbounds %RTC_2_interface, %RTC_2_interface* %0, i32 0, i32 7
  %XMS = getelementptr inbounds %RTC_2_interface, %RTC_2_interface* %0, i32 0, i32 8
  %RT = getelementptr inbounds %RTC_2_interface, %RTC_2_interface* %0, i32 0, i32 9
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %RT, i32 0, i32 0
  %load_SET = load i8, i8* %SET, align 1
  store i8 %load_SET, i8* %1, align 1
  %2 = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %RT, i32 0, i32 1
  %load_SDT = load i64, i64* %SDT, align 4
  store i64 %load_SDT, i64* %2, align 4
  %3 = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %RT, i32 0, i32 2
  %load_SMS = load i16, i16* %SMS, align 2
  store i16 %load_SMS, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  call void @RTC_MS(%RTC_MS_interface* %RT)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %xdt = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %RT, i32 0, i32 3
  %load_ = load i64, i64* %xdt, align 4
  store i64 %load_, i64* %UDT, align 4
  %XMS1 = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %RT, i32 0, i32 4
  %load_2 = load i16, i16* %XMS1, align 2
  store i16 %load_2, i16* %XMS, align 2
  %DST_instance = alloca %DST_interface, align 8
  br label %input3

4:                                                ; preds = %continue6
  %load_DEN = load i8, i8* %DEN, align 1
  %5 = zext i8 %load_DEN to i32
  br label %6

6:                                                ; preds = %4, %continue6
  %7 = phi i32 [ %9, %continue6 ], [ %5, %4 ]
  store i32 %7, i8* %DSO, align 4
  %DWORD_TO_DT_instance = alloca %DWORD_TO_DT_interface, align 8
  br label %input8

input3:                                           ; preds = %continue
  %8 = getelementptr inbounds %DST_interface, %DST_interface* %DST_instance, i32 0, i32 0
  %load_udt = load i64, i64* %UDT, align 4
  store i64 %load_udt, i64* %8, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call7 = call i8 @DST(%DST_interface* %DST_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %9 = zext i8 %call7 to i32
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %4, label %6

input8:                                           ; preds = %6
  %11 = getelementptr inbounds %DWORD_TO_DT_interface, %DWORD_TO_DT_interface* %DWORD_TO_DT_instance, i32 0, i32 0
  %DT_TO_DWORD_instance = alloca %DT_TO_DWORD_interface, align 8
  br label %input12

call9:                                            ; preds = %continue20
  %call30 = call i64 @DWORD_TO_DT(%DWORD_TO_DT_interface* %DWORD_TO_DT_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  store i64 %call30, i64* %LDT, align 4
  ret void

input12:                                          ; preds = %input8
  %12 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance, i32 0, i32 0
  %load_UDT = load i64, i64* %UDT, align 4
  store i64 %load_UDT, i64* %12, align 4
  br label %call13

call13:                                           ; preds = %input12
  %call16 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance)
  br label %output14

output14:                                         ; preds = %call13
  br label %continue15

continue15:                                       ; preds = %output14
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input17

input17:                                          ; preds = %continue15
  %13 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_ofs = load i16, i16* %OFS, align 2
  %14 = sext i16 %load_ofs to i32
  %BOOL_TO_INT_instance = alloca %BOOL_TO_INT_interface, align 8
  br label %input21

call18:                                           ; preds = %continue24
  %call27 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %tmpVar28 = mul i32 %call27, 60
  %tmpVar29 = add i32 %call16, %tmpVar28
  store i32 %tmpVar29, i32* %11, align 4
  br label %call9

input21:                                          ; preds = %input17
  %15 = getelementptr inbounds %BOOL_TO_INT_interface, %BOOL_TO_INT_interface* %BOOL_TO_INT_instance, i32 0, i32 0
  %load_DSO = load i8, i8* %DSO, align 1
  store i8 %load_DSO, i8* %15, align 1
  br label %call22

call22:                                           ; preds = %input21
  %call25 = call i16 @BOOL_TO_INT(%BOOL_TO_INT_interface* %BOOL_TO_INT_instance)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %16 = sext i16 %call25 to i32
  %tmpVar = mul i32 %16, 60
  %tmpVar26 = add i32 %14, %tmpVar
  %17 = trunc i32 %tmpVar26 to i16
  store i16 %17, i16* %13, align 2
  br label %call18
}

define void @RTC_MS(%RTC_MS_interface* %0) {
entry:
  %SET = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %0, i32 0, i32 0
  %SDT = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %0, i32 0, i32 1
  %SMS = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %0, i32 0, i32 2
  %XDT = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %0, i32 0, i32 3
  %XMS = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %0, i32 0, i32 4
  %init = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %0, i32 0, i32 5
  %last = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %0, i32 0, i32 6
  %Tx = getelementptr inbounds %RTC_MS_interface, %RTC_MS_interface* %0, i32 0, i32 7
  %T_PLC_MS_instance = alloca %T_PLC_MS_interface, align 8
  br label %input

input:                                            ; preds = %entry
  br label %call

call:                                             ; preds = %input
  %call1 = call i32 @T_PLC_MS(%T_PLC_MS_interface* %T_PLC_MS_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i32 %call1, i32* %Tx, align 4
  %load_set = load i8, i8* %SET, align 1
  %1 = zext i8 %load_set to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %6, label %4

condition_body:                                   ; preds = %6
  store i8 1, i8* %init, align 1
  %load_SDT = load i64, i64* %SDT, align 4
  store i64 %load_SDT, i64* %XDT, align 4
  %load_SMS = load i16, i16* %SMS, align 2
  store i16 %load_SMS, i16* %XMS, align 2
  br label %continue2

else:                                             ; preds = %6
  %load_XMS = load i16, i16* %XMS, align 2
  %3 = sext i16 %load_XMS to i32
  %DWORD_TO_INT_instance = alloca %DWORD_TO_INT_interface, align 8
  br label %input3

continue2:                                        ; preds = %continue10, %condition_body
  %load_tx17 = load i32, i32* %Tx, align 4
  store i32 %load_tx17, i32* %last, align 4
  ret void

4:                                                ; preds = %continue
  %load_init = load i8, i8* %init, align 1
  %tmpVar = xor i8 %load_init, -1
  %5 = zext i8 %tmpVar to i32
  br label %6

6:                                                ; preds = %4, %continue
  %7 = phi i32 [ %1, %continue ], [ %5, %4 ]
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %condition_body, label %else

input3:                                           ; preds = %else
  %9 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance, i32 0, i32 0
  %load_tx = load i32, i32* %Tx, align 4
  %load_last = load i32, i32* %last, align 4
  %tmpVar7 = sub i32 %load_tx, %load_last
  store i32 %tmpVar7, i32* %9, align 4
  br label %call4

call4:                                            ; preds = %input3
  %call8 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance)
  br label %output5

output5:                                          ; preds = %call4
  br label %continue6

continue6:                                        ; preds = %output5
  %10 = sext i16 %call8 to i32
  %tmpVar9 = add i32 %3, %10
  %11 = trunc i32 %tmpVar9 to i16
  store i16 %11, i16* %XMS, align 2
  %load_XMS12 = load i16, i16* %XMS, align 2
  %12 = sext i16 %load_XMS12 to i32
  %tmpVar13 = icmp sgt i32 %12, 999
  br i1 %tmpVar13, label %condition_body11, label %continue10

condition_body11:                                 ; preds = %continue6
  %load_XDT = load i64, i64* %XDT, align 4
  %tmpVar14 = add i64 %load_XDT, 1000000000
  store i64 %tmpVar14, i64* %XDT, align 4
  %load_XMS15 = load i16, i16* %XMS, align 2
  %13 = sext i16 %load_XMS15 to i32
  %tmpVar16 = sub i32 %13, 1000
  %14 = trunc i32 %tmpVar16 to i16
  store i16 %14, i16* %XMS, align 2
  br label %continue10

continue10:                                       ; preds = %condition_body11, %continue6
  br label %continue2
}

define i64 @SDT_TO_DATE(%SDT_TO_DATE_interface* %0) {
entry:
  %DTI = getelementptr inbounds %SDT_TO_DATE_interface, %SDT_TO_DATE_interface* %0, i32 0, i32 0
  %SDT_TO_DATE = alloca i64, align 8
  store i64 0, i64* %SDT_TO_DATE, align 4
  %SET_DATE_instance = alloca %SET_DATE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 0
  %YEAR = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 0
  %load_ = load i16, i16* %YEAR, align 2
  store i16 %load_, i16* %1, align 2
  %2 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 1
  %MONTH = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 1
  %load_1 = load i16, i16* %MONTH, align 2
  store i16 %load_1, i16* %2, align 2
  %3 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 2
  %DAY = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 2
  %load_2 = load i16, i16* %DAY, align 2
  store i16 %load_2, i16* %3, align 2
  br label %call

call:                                             ; preds = %input
  %call3 = call i64 @SET_DATE(%SET_DATE_interface* %SET_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call3, i64* %SDT_TO_DATE, align 4
  %SDT_TO_DATE_ret = load i64, i64* %SDT_TO_DATE, align 4
  ret i64 %SDT_TO_DATE_ret
}

define i64 @SDT_TO_DT(%SDT_TO_DT_interface* %0) {
entry:
  %DTI = getelementptr inbounds %SDT_TO_DT_interface, %SDT_TO_DT_interface* %0, i32 0, i32 0
  %SDT_TO_DT = alloca i64, align 8
  store i64 0, i64* %SDT_TO_DT, align 4
  %SET_DT_instance = alloca %SET_DT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 0
  %YEAR = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 0
  %load_ = load i16, i16* %YEAR, align 2
  store i16 %load_, i16* %1, align 2
  %2 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 1
  %MONTH = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 1
  %load_1 = load i16, i16* %MONTH, align 2
  store i16 %load_1, i16* %2, align 2
  %3 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 2
  %DAY = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 2
  %load_2 = load i16, i16* %DAY, align 2
  store i16 %load_2, i16* %3, align 2
  %4 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 3
  %HOUR = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 4
  %load_3 = load i16, i16* %HOUR, align 2
  store i16 %load_3, i16* %4, align 2
  %5 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 4
  %MINUTE = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 5
  %load_4 = load i16, i16* %MINUTE, align 2
  store i16 %load_4, i16* %5, align 2
  %6 = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %SET_DT_instance, i32 0, i32 5
  %SECOND = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 6
  %load_5 = load i16, i16* %SECOND, align 2
  store i16 %load_5, i16* %6, align 2
  br label %call

call:                                             ; preds = %input
  %call6 = call i64 @SET_DT(%SET_DT_interface* %SET_DT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %SDT_TO_DT, align 4
  %SDT_TO_DT_ret = load i64, i64* %SDT_TO_DT, align 4
  ret i64 %SDT_TO_DT_ret
}

define i64 @SDT_TO_TOD(%SDT_TO_TOD_interface* %0) {
entry:
  %DTI = getelementptr inbounds %SDT_TO_TOD_interface, %SDT_TO_TOD_interface* %0, i32 0, i32 0
  %SDT_TO_TOD = alloca i64, align 8
  store i64 0, i64* %SDT_TO_TOD, align 4
  %DWORD_TO_TOD_instance = alloca %DWORD_TO_TOD_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TOD_interface, %DWORD_TO_TOD_interface* %DWORD_TO_TOD_instance, i32 0, i32 0
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue28
  %call32 = call i64 @DWORD_TO_TOD(%DWORD_TO_TOD_interface* %DWORD_TO_TOD_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call32, i64* %SDT_TO_TOD, align 4
  %SDT_TO_TOD_ret = load i64, i64* %SDT_TO_TOD, align 4
  ret i64 %SDT_TO_TOD_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %HOUR = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 4
  %load_ = load i16, i16* %HOUR, align 2
  store i16 %load_, i16* %2, align 2
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = mul i32 %call5, 3600000
  %INT_TO_DWORD_instance6 = alloca %INT_TO_DWORD_interface, align 8
  br label %input7

input7:                                           ; preds = %continue4
  %3 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance6, i32 0, i32 0
  %MINUTE = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 5
  %load_11 = load i16, i16* %MINUTE, align 2
  store i16 %load_11, i16* %3, align 2
  br label %call8

call8:                                            ; preds = %input7
  %call12 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance6)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %tmpVar13 = mul i32 %call12, 60000
  %tmpVar14 = add i32 %tmpVar, %tmpVar13
  %INT_TO_DWORD_instance15 = alloca %INT_TO_DWORD_interface, align 8
  br label %input16

input16:                                          ; preds = %continue10
  %4 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance15, i32 0, i32 0
  %SECOND = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 6
  %load_20 = load i16, i16* %SECOND, align 2
  store i16 %load_20, i16* %4, align 2
  br label %call17

call17:                                           ; preds = %input16
  %call21 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance15)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %tmpVar22 = mul i32 %call21, 1000
  %tmpVar23 = add i32 %tmpVar14, %tmpVar22
  %INT_TO_DWORD_instance24 = alloca %INT_TO_DWORD_interface, align 8
  br label %input25

input25:                                          ; preds = %continue19
  %5 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance24, i32 0, i32 0
  %MS = getelementptr inbounds %SDT, %SDT* %DTI, i32 0, i32 7
  %load_29 = load i16, i16* %MS, align 2
  store i16 %load_29, i16* %5, align 2
  br label %call26

call26:                                           ; preds = %input25
  %call30 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance24)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  %tmpVar31 = add i32 %tmpVar23, %call30
  store i32 %tmpVar31, i32* %1, align 4
  br label %call
}

define float @SECOND(%SECOND_interface* %0) {
entry:
  %itod = getelementptr inbounds %SECOND_interface, %SECOND_interface* %0, i32 0, i32 0
  %SECOND = alloca float, align 4
  store float 0.000000e+00, float* %SECOND, align 4
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %TOD_TO_DWORD_instance = alloca %TOD_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue10
  %call15 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar16 = fdiv float %call15, 1.000000e+03
  store float %tmpVar16, float* %SECOND, align 4
  %SECOND_ret = load float, float* %SECOND, align 4
  ret float %SECOND_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %TOD_TO_DWORD_interface, %TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance, i32 0, i32 0
  %load_itod = load i64, i64* %itod, align 4
  store i64 %load_itod, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @TOD_TO_DWORD(%TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %TOD_TO_DWORD_instance6 = alloca %TOD_TO_DWORD_interface, align 8
  br label %input7

input7:                                           ; preds = %continue4
  %3 = getelementptr inbounds %TOD_TO_DWORD_interface, %TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance6, i32 0, i32 0
  %load_itod11 = load i64, i64* %itod, align 4
  store i64 %load_itod11, i64* %3, align 4
  br label %call8

call8:                                            ; preds = %input7
  %call12 = call i32 @TOD_TO_DWORD(%TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance6)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %tmpVar = sdiv i32 %call12, 60000
  %tmpVar13 = mul i32 %tmpVar, 60000
  %tmpVar14 = sub i32 %call5, %tmpVar13
  store i32 %tmpVar14, i32* %1, align 4
  br label %call
}

define i16 @SECOND_OF_DT(%SECOND_OF_DT_interface* %0) {
entry:
  %XDT = getelementptr inbounds %SECOND_OF_DT_interface, %SECOND_OF_DT_interface* %0, i32 0, i32 0
  %SECOND_OF_DT = alloca i16, align 2
  store i16 0, i16* %SECOND_OF_DT, align 2
  %DWORD_TO_INT_instance = alloca %DWORD_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance, i32 0, i32 0
  %DT_TO_DWORD_instance = alloca %DT_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call6, i16* %SECOND_OF_DT, align 2
  %SECOND_OF_DT_ret = load i16, i16* %SECOND_OF_DT, align 2
  ret i16 %SECOND_OF_DT_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance, i32 0, i32 0
  %load_XDT = load i64, i64* %XDT, align 4
  store i64 %load_XDT, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = srem i32 %call5, 60
  store i32 %tmpVar, i32* %1, align 4
  br label %call
}

define i64 @SECOND_TO_TIME(%SECOND_TO_TIME_interface* %0) {
entry:
  %IN = getelementptr inbounds %SECOND_TO_TIME_interface, %SECOND_TO_TIME_interface* %0, i32 0, i32 0
  %SECOND_TO_TIME = alloca i64, align 8
  store i64 0, i64* %SECOND_TO_TIME, align 4
  %DWORD_TO_TIME_instance = alloca %DWORD_TO_TIME_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TIME_interface, %DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance, i32 0, i32 0
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface* %DWORD_TO_TIME_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call6, i64* %SECOND_TO_TIME, align 4
  %SECOND_TO_TIME_ret = load i64, i64* %SECOND_TO_TIME, align 4
  ret i64 %SECOND_TO_TIME_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %load_IN = load float, float* %IN, align 4
  %tmpVar = fmul float %load_IN, 1.000000e+03
  store float %tmpVar, float* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i32 %call5, i32* %1, align 4
  br label %call
}

define i64 @SET_DATE(%SET_DATE_interface* %0) {
entry:
  %YEAR = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %0, i32 0, i32 0
  %MONTH = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %0, i32 0, i32 1
  %DAY = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %0, i32 0, i32 2
  %count = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %0, i32 0, i32 3
  %SET_DATE = alloca i64, align 8
  store i16 0, i16* %count, align 2
  store i64 0, i64* %SET_DATE, align 4
  %load_month = load i16, i16* %MONTH, align 2
  %1 = sext i16 %load_month to i32
  %tmpVar = icmp sgt i32 %1, 2
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_month1 = load i16, i16* %MONTH, align 2
  %2 = sext i16 %load_month1 to i32
  %tmpVar2 = sub i32 %2, 1
  %tmpVar3 = mul i32 %tmpVar2, 30
  %3 = trunc i32 %tmpVar3 to i16
  store i16 %3, i16* %count, align 2
  %load_month7 = load i16, i16* %MONTH, align 2
  %4 = sext i16 %load_month7 to i32
  %tmpVar8 = icmp sgt i32 %4, 7
  br i1 %tmpVar8, label %condition_body6, label %else4

else:                                             ; preds = %entry
  %load_month34 = load i16, i16* %MONTH, align 2
  %5 = sext i16 %load_month34 to i32
  %tmpVar35 = sub i32 %5, 1
  %tmpVar36 = mul i32 %tmpVar35, 31
  %6 = trunc i32 %tmpVar36 to i16
  store i16 %6, i16* %count, align 2
  br label %continue

continue:                                         ; preds = %else, %continue24
  %DWORD_TO_DATE_instance = alloca %DWORD_TO_DATE_interface, align 8
  br label %input37

condition_body6:                                  ; preds = %condition_body
  %load_count = load i16, i16* %count, align 2
  %7 = sext i16 %load_count to i64
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input

else4:                                            ; preds = %condition_body
  %load_count14 = load i16, i16* %count, align 2
  %8 = sext i16 %load_count14 to i64
  %SHR_instance15 = alloca %SHR_interface, align 8
  br label %input16

continue5:                                        ; preds = %continue19, %continue9
  %SHL_instance = alloca %SHL_interface, align 8
  br label %input26

input:                                            ; preds = %condition_body6
  %9 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %load_month10 = load i16, i16* %MONTH, align 2
  %10 = sext i16 %load_month10 to i32
  %tmpVar11 = sub i32 %10, 3
  %11 = sext i32 %tmpVar11 to i64
  store i64 %11, i64* %9, align 4
  %12 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 1, i16* %12, align 2
  br label %call

call:                                             ; preds = %input
  %call12 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue9

continue9:                                        ; preds = %output
  %tmpVar13 = add i64 %7, %call12
  %13 = trunc i64 %tmpVar13 to i16
  store i16 %13, i16* %count, align 2
  br label %continue5

input16:                                          ; preds = %else4
  %14 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance15, i32 0, i32 0
  %load_month20 = load i16, i16* %MONTH, align 2
  %15 = sext i16 %load_month20 to i32
  %tmpVar21 = sub i32 %15, 4
  %16 = sext i32 %tmpVar21 to i64
  store i64 %16, i64* %14, align 4
  %17 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance15, i32 0, i32 1
  store i16 1, i16* %17, align 2
  br label %call17

call17:                                           ; preds = %input16
  %call22 = call i64 @SHR(%SHR_interface* %SHR_instance15)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %tmpVar23 = add i64 %8, %call22
  %18 = trunc i64 %tmpVar23 to i16
  store i16 %18, i16* %count, align 2
  br label %continue5

condition_body25:                                 ; preds = %continue29
  %load_count32 = load i16, i16* %count, align 2
  %19 = sext i16 %load_count32 to i32
  %tmpVar33 = add i32 %19, 1
  %20 = trunc i32 %tmpVar33 to i16
  store i16 %20, i16* %count, align 2
  br label %continue24

continue24:                                       ; preds = %condition_body25, %continue29
  br label %continue

input26:                                          ; preds = %continue5
  %21 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 0
  %load_year = load i16, i16* %YEAR, align 2
  %22 = sext i16 %load_year to i64
  store i64 %22, i64* %21, align 4
  %23 = getelementptr inbounds %SHL_interface, %SHL_interface* %SHL_instance, i32 0, i32 1
  store i16 14, i16* %23, align 2
  br label %call27

call27:                                           ; preds = %input26
  %call30 = call i64 @SHL(%SHL_interface* %SHL_instance)
  br label %output28

output28:                                         ; preds = %call27
  br label %continue29

continue29:                                       ; preds = %output28
  %tmpVar31 = icmp eq i64 %call30, 0
  br i1 %tmpVar31, label %condition_body25, label %continue24

input37:                                          ; preds = %continue
  %24 = getelementptr inbounds %DWORD_TO_DATE_interface, %DWORD_TO_DATE_interface* %DWORD_TO_DATE_instance, i32 0, i32 0
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input41

call38:                                           ; preds = %continue53
  %call66 = call i64 @DWORD_TO_DATE(%DWORD_TO_DATE_interface* %DWORD_TO_DATE_instance)
  br label %output39

output39:                                         ; preds = %call38
  br label %continue40

continue40:                                       ; preds = %output39
  store i64 %call66, i64* %SET_DATE, align 4
  %SET_DATE_ret = load i64, i64* %SET_DATE, align 4
  ret i64 %SET_DATE_ret

input41:                                          ; preds = %input37
  %25 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_count45 = load i16, i16* %count, align 2
  %26 = sext i16 %load_count45 to i32
  %load_day = load i16, i16* %DAY, align 2
  %27 = sext i16 %load_day to i32
  %tmpVar46 = add i32 %26, %27
  %tmpVar47 = sub i32 %tmpVar46, 1
  %28 = trunc i32 %tmpVar47 to i16
  store i16 %28, i16* %25, align 2
  br label %call42

call42:                                           ; preds = %input41
  %call48 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output43

output43:                                         ; preds = %call42
  br label %continue44

continue44:                                       ; preds = %output43
  %29 = zext i32 %call48 to i64
  %SHR_instance49 = alloca %SHR_interface, align 8
  br label %input50

input50:                                          ; preds = %continue44
  %30 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance49, i32 0, i32 0
  %INT_TO_DWORD_instance54 = alloca %INT_TO_DWORD_interface, align 8
  br label %input55

call51:                                           ; preds = %continue58
  %call63 = call i64 @SHR(%SHR_interface* %SHR_instance49)
  br label %output52

output52:                                         ; preds = %call51
  br label %continue53

continue53:                                       ; preds = %output52
  %tmpVar64 = add i64 %29, %call63
  %tmpVar65 = mul i64 %tmpVar64, 86400
  %31 = trunc i64 %tmpVar65 to i32
  store i32 %31, i32* %24, align 4
  br label %call38

input55:                                          ; preds = %input50
  %32 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance54, i32 0, i32 0
  %load_year59 = load i16, i16* %YEAR, align 2
  store i16 %load_year59, i16* %32, align 2
  br label %call56

call56:                                           ; preds = %input55
  %call60 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance54)
  br label %output57

output57:                                         ; preds = %call56
  br label %continue58

continue58:                                       ; preds = %output57
  %tmpVar61 = mul i32 %call60, 1461
  %tmpVar62 = sub i32 %tmpVar61, 2878169
  %33 = sext i32 %tmpVar62 to i64
  store i64 %33, i64* %30, align 4
  %34 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance49, i32 0, i32 1
  store i16 2, i16* %34, align 2
  br label %call51
}

define i64 @SET_DT(%SET_DT_interface* %0) {
entry:
  %year = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %0, i32 0, i32 0
  %month = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %0, i32 0, i32 1
  %day = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %0, i32 0, i32 2
  %hour = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %0, i32 0, i32 3
  %minute = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %0, i32 0, i32 4
  %second = getelementptr inbounds %SET_DT_interface, %SET_DT_interface* %0, i32 0, i32 5
  %SET_DT = alloca i64, align 8
  store i64 0, i64* %SET_DT, align 4
  %DWORD_TO_DT_instance = alloca %DWORD_TO_DT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_DT_interface, %DWORD_TO_DT_interface* %DWORD_TO_DT_instance, i32 0, i32 0
  %DATE_TO_DWORD_instance = alloca %DATE_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue28
  %call32 = call i64 @DWORD_TO_DT(%DWORD_TO_DT_interface* %DWORD_TO_DT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call32, i64* %SET_DT, align 4
  %SET_DT_ret = load i64, i64* %SET_DT, align 4
  ret i64 %SET_DT_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance, i32 0, i32 0
  %SET_DATE_instance = alloca %SET_DATE_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  %call10 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input11

input5:                                           ; preds = %input1
  %3 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 0
  %load_YEAR = load i16, i16* %year, align 2
  store i16 %load_YEAR, i16* %3, align 2
  %4 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 1
  %load_MONTH = load i16, i16* %month, align 2
  store i16 %load_MONTH, i16* %4, align 2
  %5 = getelementptr inbounds %SET_DATE_interface, %SET_DATE_interface* %SET_DATE_instance, i32 0, i32 2
  %load_day = load i16, i16* %day, align 2
  store i16 %load_day, i16* %5, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i64 @SET_DATE(%SET_DATE_interface* %SET_DATE_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  store i64 %call9, i64* %2, align 4
  br label %call2

input11:                                          ; preds = %continue4
  %6 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_SECOND = load i16, i16* %second, align 2
  store i16 %load_SECOND, i16* %6, align 2
  br label %call12

call12:                                           ; preds = %input11
  %call15 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %tmpVar = add i32 %call10, %call15
  %INT_TO_DWORD_instance16 = alloca %INT_TO_DWORD_interface, align 8
  br label %input17

input17:                                          ; preds = %continue14
  %7 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance16, i32 0, i32 0
  %load_MINUTE = load i16, i16* %minute, align 2
  store i16 %load_MINUTE, i16* %7, align 2
  br label %call18

call18:                                           ; preds = %input17
  %call21 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance16)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  %tmpVar22 = mul i32 %call21, 60
  %tmpVar23 = add i32 %tmpVar, %tmpVar22
  %INT_TO_DWORD_instance24 = alloca %INT_TO_DWORD_interface, align 8
  br label %input25

input25:                                          ; preds = %continue20
  %8 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance24, i32 0, i32 0
  %load_HOUR = load i16, i16* %hour, align 2
  store i16 %load_HOUR, i16* %8, align 2
  br label %call26

call26:                                           ; preds = %input25
  %call29 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance24)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  %tmpVar30 = mul i32 %call29, 3600
  %tmpVar31 = add i32 %tmpVar23, %tmpVar30
  store i32 %tmpVar31, i32* %1, align 4
  br label %call
}

define i64 @SET_TOD(%SET_TOD_interface* %0) {
entry:
  %hour = getelementptr inbounds %SET_TOD_interface, %SET_TOD_interface* %0, i32 0, i32 0
  %minute = getelementptr inbounds %SET_TOD_interface, %SET_TOD_interface* %0, i32 0, i32 1
  %second = getelementptr inbounds %SET_TOD_interface, %SET_TOD_interface* %0, i32 0, i32 2
  %SET_TOD = alloca i64, align 8
  store i64 0, i64* %SET_TOD, align 4
  %DWORD_TO_TOD_instance = alloca %DWORD_TO_TOD_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_TOD_interface, %DWORD_TO_TOD_interface* %DWORD_TO_TOD_instance, i32 0, i32 0
  %REAL_TO_DWORD_instance = alloca %REAL_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue17
  %call21 = call i64 @DWORD_TO_TOD(%DWORD_TO_TOD_interface* %DWORD_TO_TOD_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call21, i64* %SET_TOD, align 4
  %SET_TOD_ret = load i64, i64* %SET_TOD, align 4
  ret i64 %SET_TOD_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %REAL_TO_DWORD_interface, %REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance, i32 0, i32 0
  %load_SECOND = load float, float* %second, align 4
  %tmpVar = fmul float %load_SECOND, 1.000000e+03
  store float %tmpVar, float* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface* %REAL_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input6

input6:                                           ; preds = %continue4
  %3 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_MINUTE = load i16, i16* %minute, align 2
  store i16 %load_MINUTE, i16* %3, align 2
  br label %call7

call7:                                            ; preds = %input6
  %call10 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %tmpVar11 = mul i32 %call10, 60000
  %tmpVar12 = add i32 %call5, %tmpVar11
  %INT_TO_DWORD_instance13 = alloca %INT_TO_DWORD_interface, align 8
  br label %input14

input14:                                          ; preds = %continue9
  %4 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance13, i32 0, i32 0
  %load_HOUR = load i16, i16* %hour, align 2
  store i16 %load_HOUR, i16* %4, align 2
  br label %call15

call15:                                           ; preds = %input14
  %call18 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance13)
  br label %output16

output16:                                         ; preds = %call15
  br label %continue17

continue17:                                       ; preds = %output16
  %tmpVar19 = mul i32 %call18, 3600000
  %tmpVar20 = add i32 %tmpVar12, %tmpVar19
  store i32 %tmpVar20, i32* %1, align 4
  br label %call
}

define i64 @SUN_MIDDAY(%SUN_MIDDAY_interface* %0) {
entry:
  %LON = getelementptr inbounds %SUN_MIDDAY_interface, %SUN_MIDDAY_interface* %0, i32 0, i32 0
  %UTC = getelementptr inbounds %SUN_MIDDAY_interface, %SUN_MIDDAY_interface* %0, i32 0, i32 1
  %T = getelementptr inbounds %SUN_MIDDAY_interface, %SUN_MIDDAY_interface* %0, i32 0, i32 2
  %OFFSET = getelementptr inbounds %SUN_MIDDAY_interface, %SUN_MIDDAY_interface* %0, i32 0, i32 3
  %SUN_MIDDAY = alloca i64, align 8
  store float 0.000000e+00, float* %T, align 4
  store float 0.000000e+00, float* %OFFSET, align 4
  store i64 0, i64* %SUN_MIDDAY, align 4
  %INT_TO_REAL_instance = alloca %INT_TO_REAL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %INT_TO_REAL_interface, %INT_TO_REAL_interface* %INT_TO_REAL_instance, i32 0, i32 0
  %DAY_OF_YEAR_instance = alloca %DAY_OF_YEAR_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call float @INT_TO_REAL(%INT_TO_REAL_interface* %INT_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store float %call6, float* %T, align 4
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input7

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %DAY_OF_YEAR_interface, %DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance, i32 0, i32 0
  %load_utc = load i64, i64* %UTC, align 4
  store i64 %load_utc, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i16 @DAY_OF_YEAR(%DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  store i16 %call5, i16* %1, align 2
  br label %call

input7:                                           ; preds = %continue
  %3 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %load_T = load float, float* %T, align 4
  %tmpVar = fmul float 0x3FA11DBCA0000000, %load_T
  %tmpVar11 = fadd float %tmpVar, 0x3FE1844D00000000
  %4 = fptosi float %tmpVar11 to i32
  store i32 %4, i32* %3, align 4
  br label %call8

call8:                                            ; preds = %input7
  %call12 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  %tmpVar13 = fmul double 0xBFC66CF420000000, %call12
  %SIN_instance14 = alloca %SIN_interface, align 8
  br label %input15

input15:                                          ; preds = %continue10
  %5 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance14, i32 0, i32 0
  %load_T19 = load float, float* %T, align 4
  %tmpVar20 = fmul float 0x3F92ABEF00000000, %load_T19
  %tmpVar21 = fsub float %tmpVar20, 0x3FC8D1B720000000
  %6 = fptosi float %tmpVar21 to i32
  store i32 %6, i32* %5, align 4
  br label %call16

call16:                                           ; preds = %input15
  %call22 = call double @SIN(%SIN_interface* %SIN_instance14)
  br label %output17

output17:                                         ; preds = %call16
  br label %continue18

continue18:                                       ; preds = %output17
  %tmpVar23 = fmul double 1.340000e-01, %call22
  %tmpVar24 = fsub double %tmpVar13, %tmpVar23
  %7 = fptrunc double %tmpVar24 to float
  store float %7, float* %OFFSET, align 4
  %HOUR_TO_TOD_instance = alloca %HOUR_TO_TOD_interface, align 8
  br label %input25

input25:                                          ; preds = %continue18
  %8 = getelementptr inbounds %HOUR_TO_TOD_interface, %HOUR_TO_TOD_interface* %HOUR_TO_TOD_instance, i32 0, i32 0
  %load_OFFSET = load float, float* %OFFSET, align 4
  %tmpVar29 = fsub float 1.200000e+01, %load_OFFSET
  %load_lon = load float, float* %LON, align 4
  %tmpVar30 = fmul float %load_lon, 0x3FB1111120000000
  %tmpVar31 = fsub float %tmpVar29, %tmpVar30
  store float %tmpVar31, float* %8, align 4
  br label %call26

call26:                                           ; preds = %input25
  %call32 = call i64 @HOUR_TO_TOD(%HOUR_TO_TOD_interface* %HOUR_TO_TOD_instance)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  store i64 %call32, i64* %SUN_MIDDAY, align 4
  %SUN_MIDDAY_ret = load i64, i64* %SUN_MIDDAY, align 4
  ret i64 %SUN_MIDDAY_ret
}

define void @SUN_POS(%SUN_POS_interface* %0) {
entry:
  %latitude = getelementptr inbounds %SUN_POS_interface, %SUN_POS_interface* %0, i32 0, i32 0
  %longitude = getelementptr inbounds %SUN_POS_interface, %SUN_POS_interface* %0, i32 0, i32 1
  %utc = getelementptr inbounds %SUN_POS_interface, %SUN_POS_interface* %0, i32 0, i32 2
  %B = getelementptr inbounds %SUN_POS_interface, %SUN_POS_interface* %0, i32 0, i32 3
  %H = getelementptr inbounds %SUN_POS_interface, %SUN_POS_interface* %0, i32 0, i32 4
  %HR = getelementptr inbounds %SUN_POS_interface, %SUN_POS_interface* %0, i32 0, i32 5
  %g = alloca float, align 4
  %a = alloca float, align 4
  %d = alloca float, align 4
  %t1 = alloca float, align 4
  %n = alloca float, align 4
  %e = alloca float, align 4
  %c = alloca float, align 4
  %tau = alloca float, align 4
  %sin_d = alloca float, align 4
  %rlat = alloca float, align 4
  %sin_lat = alloca float, align 4
  %cos_lat = alloca float, align 4
  %cos_tau = alloca float, align 4
  %cos_d = alloca float, align 4
  store float 0.000000e+00, float* %g, align 4
  store float 0.000000e+00, float* %a, align 4
  store float 0.000000e+00, float* %d, align 4
  store float 0.000000e+00, float* %t1, align 4
  store float 0.000000e+00, float* %n, align 4
  store float 0.000000e+00, float* %e, align 4
  store float 0.000000e+00, float* %c, align 4
  store float 0.000000e+00, float* %tau, align 4
  store float 0.000000e+00, float* %sin_d, align 4
  store float 0.000000e+00, float* %rlat, align 4
  store float 0.000000e+00, float* %sin_lat, align 4
  store float 0.000000e+00, float* %cos_lat, align 4
  store float 0.000000e+00, float* %cos_tau, align 4
  store float 0.000000e+00, float* %cos_d, align 4
  %DWORD_TO_REAL_instance = alloca %DWORD_TO_REAL_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance, i32 0, i32 0
  %DT_TO_DWORD_instance = alloca %DT_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call6 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %tmpVar7 = fmul float %call6, 0x3EE845C8A0000000
  store float %tmpVar7, float* %n, align 4
  %MODR_instance = alloca %MODR_interface, align 8
  br label %input8

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance, i32 0, i32 0
  %load_UTC = load i64, i64* %utc, align 4
  store i64 %load_UTC, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = sub i32 %call5, 946728000
  store i32 %tmpVar, i32* %1, align 4
  br label %call

input8:                                           ; preds = %continue
  %3 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 0
  %load_n = load float, float* %n, align 4
  %tmpVar12 = fmul float 0x3F919D64A0000000, %load_n
  %tmpVar13 = fadd float 0x4018F5CD40000000, %tmpVar12
  store float %tmpVar13, float* %3, align 4
  %4 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance, i32 0, i32 1
  %load_ = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 1), align 4
  store float %load_, float* %4, align 4
  br label %call9

call9:                                            ; preds = %input8
  %call14 = call float @MODR(%MODR_interface* %MODR_instance)
  br label %output10

output10:                                         ; preds = %call9
  br label %continue11

continue11:                                       ; preds = %output10
  store float %call14, float* %g, align 4
  %MODR_instance15 = alloca %MODR_interface, align 8
  br label %input16

input16:                                          ; preds = %continue11
  %5 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance15, i32 0, i32 0
  %load_n20 = load float, float* %n, align 4
  %tmpVar21 = fmul float 0x3F919D9BE0000000, %load_n20
  %tmpVar22 = fadd float 0x4013946DE0000000, %tmpVar21
  store float %tmpVar22, float* %5, align 4
  %6 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance15, i32 0, i32 1
  %load_23 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 1), align 4
  store float %load_23, float* %6, align 4
  br label %call17

call17:                                           ; preds = %input16
  %call24 = call float @MODR(%MODR_interface* %MODR_instance15)
  br label %output18

output18:                                         ; preds = %call17
  br label %continue19

continue19:                                       ; preds = %output18
  %7 = fpext float %call24 to double
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input25

input25:                                          ; preds = %continue19
  %8 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %load_g = load float, float* %g, align 4
  %9 = fptosi float %load_g to i32
  store i32 %9, i32* %8, align 4
  br label %call26

call26:                                           ; preds = %input25
  %call29 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output27

output27:                                         ; preds = %call26
  br label %continue28

continue28:                                       ; preds = %output27
  %tmpVar30 = fmul double 0x3FA11CD3A05097F3, %call29
  %tmpVar31 = fadd double %7, %tmpVar30
  %SIN_instance32 = alloca %SIN_interface, align 8
  br label %input33

input33:                                          ; preds = %continue28
  %10 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance32, i32 0, i32 0
  %load_g37 = load float, float* %g, align 4
  %tmpVar38 = fmul float 2.000000e+00, %load_g37
  %11 = fptosi float %tmpVar38 to i32
  store i32 %11, i32* %10, align 4
  br label %call34

call34:                                           ; preds = %input33
  %call39 = call double @SIN(%SIN_interface* %SIN_instance32)
  br label %output35

output35:                                         ; preds = %call34
  br label %continue36

continue36:                                       ; preds = %output35
  %tmpVar40 = fmul double 3.490660e-04, %call39
  %tmpVar41 = fadd double %tmpVar31, %tmpVar40
  %12 = fptrunc double %tmpVar41 to float
  store float %12, float* %d, align 4
  %load_n42 = load float, float* %n, align 4
  %tmpVar43 = fmul float 0x3E3DFC0A00000000, %load_n42
  %tmpVar44 = fsub float 0x3FDA2E7E40000000, %tmpVar43
  store float %tmpVar44, float* %e, align 4
  %COS_instance = alloca %COS_interface, align 8
  br label %input45

input45:                                          ; preds = %continue36
  %13 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance, i32 0, i32 0
  %load_d = load float, float* %d, align 4
  %14 = fptosi float %load_d to i32
  store i32 %14, i32* %13, align 4
  br label %call46

call46:                                           ; preds = %input45
  %call49 = call double @COS(%COS_interface* %COS_instance)
  br label %output47

output47:                                         ; preds = %call46
  br label %continue48

continue48:                                       ; preds = %output47
  %15 = fptrunc double %call49 to float
  store float %15, float* %cos_d, align 4
  %SIN_instance50 = alloca %SIN_interface, align 8
  br label %input51

input51:                                          ; preds = %continue48
  %16 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance50, i32 0, i32 0
  %load_d55 = load float, float* %d, align 4
  %17 = fptosi float %load_d55 to i32
  store i32 %17, i32* %16, align 4
  br label %call52

call52:                                           ; preds = %input51
  %call56 = call double @SIN(%SIN_interface* %SIN_instance50)
  br label %output53

output53:                                         ; preds = %call52
  br label %continue54

continue54:                                       ; preds = %output53
  %18 = fptrunc double %call56 to float
  store float %18, float* %sin_d, align 4
  %ATAN_instance = alloca %ATAN_interface, align 8
  br label %input57

input57:                                          ; preds = %continue54
  %19 = getelementptr inbounds %ATAN_interface, %ATAN_interface* %ATAN_instance, i32 0, i32 0
  %COS_instance61 = alloca %COS_interface, align 8
  br label %input62

call58:                                           ; preds = %continue65
  %call69 = call double @ATAN(%ATAN_interface* %ATAN_instance)
  br label %output59

output59:                                         ; preds = %call58
  br label %continue60

continue60:                                       ; preds = %output59
  %20 = fptrunc double %call69 to float
  store float %20, float* %a, align 4
  %load_cos_d71 = load float, float* %cos_d, align 4
  %tmpVar72 = fcmp olt float %load_cos_d71, 0.000000e+00
  br i1 %tmpVar72, label %condition_body, label %continue70

input62:                                          ; preds = %input57
  %21 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance61, i32 0, i32 0
  %load_e = load float, float* %e, align 4
  %22 = fptosi float %load_e to i32
  store i32 %22, i32* %21, align 4
  br label %call63

call63:                                           ; preds = %input62
  %call66 = call double @COS(%COS_interface* %COS_instance61)
  br label %output64

output64:                                         ; preds = %call63
  br label %continue65

continue65:                                       ; preds = %output64
  %load_sin_d = load float, float* %sin_d, align 4
  %23 = fpext float %load_sin_d to double
  %tmpVar67 = fmul double %call66, %23
  %load_cos_d = load float, float* %cos_d, align 4
  %24 = fpext float %load_cos_d to double
  %tmpVar68 = fdiv double %tmpVar67, %24
  store double %tmpVar68, double* %19, align 8
  br label %call58

condition_body:                                   ; preds = %continue60
  %load_a = load float, float* %a, align 4
  %load_73 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 0), align 4
  %tmpVar74 = fadd float %load_a, %load_73
  store float %tmpVar74, float* %a, align 4
  br label %continue70

continue70:                                       ; preds = %condition_body, %continue60
  %ASIN_instance = alloca %ASIN_interface, align 8
  br label %input75

input75:                                          ; preds = %continue70
  %25 = getelementptr inbounds %ASIN_interface, %ASIN_interface* %ASIN_instance, i32 0, i32 0
  %SIN_instance79 = alloca %SIN_interface, align 8
  br label %input80

call76:                                           ; preds = %continue83
  %call88 = call double @ASIN(%ASIN_interface* %ASIN_instance)
  br label %output77

output77:                                         ; preds = %call76
  br label %continue78

continue78:                                       ; preds = %output77
  %26 = fptrunc double %call88 to float
  store float %26, float* %c, align 4
  %RAD_instance = alloca %RAD_interface, align 8
  br label %input89

input80:                                          ; preds = %input75
  %27 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance79, i32 0, i32 0
  %load_e84 = load float, float* %e, align 4
  %28 = fptosi float %load_e84 to i32
  store i32 %28, i32* %27, align 4
  br label %call81

call81:                                           ; preds = %input80
  %call85 = call double @SIN(%SIN_interface* %SIN_instance79)
  br label %output82

output82:                                         ; preds = %call81
  br label %continue83

continue83:                                       ; preds = %output82
  %load_sin_d86 = load float, float* %sin_d, align 4
  %29 = fpext float %load_sin_d86 to double
  %tmpVar87 = fmul double %call85, %29
  store double %tmpVar87, double* %25, align 8
  br label %call76

input89:                                          ; preds = %continue78
  %30 = getelementptr inbounds %RAD_interface, %RAD_interface* %RAD_instance, i32 0, i32 0
  %MODR_instance93 = alloca %MODR_interface, align 8
  br label %input94

call90:                                           ; preds = %continue97
  %call123 = call float @RAD(%RAD_interface* %RAD_instance)
  br label %output91

output91:                                         ; preds = %call90
  br label %continue92

continue92:                                       ; preds = %output91
  %load_a124 = load float, float* %a, align 4
  %tmpVar125 = fsub float %call123, %load_a124
  store float %tmpVar125, float* %tau, align 4
  %RAD_instance126 = alloca %RAD_interface, align 8
  br label %input127

input94:                                          ; preds = %input89
  %31 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance93, i32 0, i32 0
  %load_n98 = load float, float* %n, align 4
  %tmpVar99 = fsub float %load_n98, 2.500000e-01
  %tmpVar100 = fmul float %tmpVar99, 0x3FB0D25BE0000000
  %tmpVar101 = fadd float 0x401ACA1CE0000000, %tmpVar100
  %DWORD_TO_REAL_instance102 = alloca %DWORD_TO_REAL_interface, align 8
  br label %input103

call95:                                           ; preds = %continue106
  %call120 = call float @MODR(%MODR_interface* %MODR_instance93)
  br label %output96

output96:                                         ; preds = %call95
  br label %continue97

continue97:                                       ; preds = %output96
  %tmpVar121 = fmul float %call120, 1.500000e+01
  %load_longitude = load float, float* %longitude, align 4
  %tmpVar122 = fadd float %tmpVar121, %load_longitude
  store float %tmpVar122, float* %30, align 4
  br label %call90

input103:                                         ; preds = %input94
  %32 = getelementptr inbounds %DWORD_TO_REAL_interface, %DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance102, i32 0, i32 0
  %TOD_TO_DWORD_instance = alloca %TOD_TO_DWORD_interface, align 8
  br label %input107

call104:                                          ; preds = %continue110
  %call117 = call float @DWORD_TO_REAL(%DWORD_TO_REAL_interface* %DWORD_TO_REAL_instance102)
  br label %output105

output105:                                        ; preds = %call104
  br label %continue106

continue106:                                      ; preds = %output105
  %tmpVar118 = fmul float %call117, 0x3E92B14080000000
  %tmpVar119 = fadd float %tmpVar101, %tmpVar118
  store float %tmpVar119, float* %31, align 4
  %33 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance93, i32 0, i32 1
  store float 2.400000e+01, float* %33, align 4
  br label %call95

input107:                                         ; preds = %input103
  %34 = getelementptr inbounds %TOD_TO_DWORD_interface, %TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance, i32 0, i32 0
  %DT_TO_TOD_instance = alloca %DT_TO_TOD_interface, align 8
  br label %input111

call108:                                          ; preds = %continue114
  %call116 = call i32 @TOD_TO_DWORD(%TOD_TO_DWORD_interface* %TOD_TO_DWORD_instance)
  br label %output109

output109:                                        ; preds = %call108
  br label %continue110

continue110:                                      ; preds = %output109
  store i32 %call116, i32* %32, align 4
  br label %call104

input111:                                         ; preds = %input107
  %35 = getelementptr inbounds %DT_TO_TOD_interface, %DT_TO_TOD_interface* %DT_TO_TOD_instance, i32 0, i32 0
  %load_utc = load i64, i64* %utc, align 4
  store i64 %load_utc, i64* %35, align 4
  br label %call112

call112:                                          ; preds = %input111
  %call115 = call i64 @DT_TO_TOD(%DT_TO_TOD_interface* %DT_TO_TOD_instance)
  br label %output113

output113:                                        ; preds = %call112
  br label %continue114

continue114:                                      ; preds = %output113
  store i64 %call115, i64* %34, align 4
  br label %call108

input127:                                         ; preds = %continue92
  %36 = getelementptr inbounds %RAD_interface, %RAD_interface* %RAD_instance126, i32 0, i32 0
  %load_latitude = load float, float* %latitude, align 4
  store float %load_latitude, float* %36, align 4
  br label %call128

call128:                                          ; preds = %input127
  %call131 = call float @RAD(%RAD_interface* %RAD_instance126)
  br label %output129

output129:                                        ; preds = %call128
  br label %continue130

continue130:                                      ; preds = %output129
  store float %call131, float* %rlat, align 4
  %SIN_instance132 = alloca %SIN_interface, align 8
  br label %input133

input133:                                         ; preds = %continue130
  %37 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance132, i32 0, i32 0
  %load_rlat = load float, float* %rlat, align 4
  %38 = fptosi float %load_rlat to i32
  store i32 %38, i32* %37, align 4
  br label %call134

call134:                                          ; preds = %input133
  %call137 = call double @SIN(%SIN_interface* %SIN_instance132)
  br label %output135

output135:                                        ; preds = %call134
  br label %continue136

continue136:                                      ; preds = %output135
  %39 = fptrunc double %call137 to float
  store float %39, float* %sin_lat, align 4
  %COS_instance138 = alloca %COS_interface, align 8
  br label %input139

input139:                                         ; preds = %continue136
  %40 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance138, i32 0, i32 0
  %load_rlat143 = load float, float* %rlat, align 4
  %41 = fptosi float %load_rlat143 to i32
  store i32 %41, i32* %40, align 4
  br label %call140

call140:                                          ; preds = %input139
  %call144 = call double @COS(%COS_interface* %COS_instance138)
  br label %output141

output141:                                        ; preds = %call140
  br label %continue142

continue142:                                      ; preds = %output141
  %42 = fptrunc double %call144 to float
  store float %42, float* %cos_lat, align 4
  %COS_instance145 = alloca %COS_interface, align 8
  br label %input146

input146:                                         ; preds = %continue142
  %43 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance145, i32 0, i32 0
  %load_tau = load float, float* %tau, align 4
  %44 = fptosi float %load_tau to i32
  store i32 %44, i32* %43, align 4
  br label %call147

call147:                                          ; preds = %input146
  %call150 = call double @COS(%COS_interface* %COS_instance145)
  br label %output148

output148:                                        ; preds = %call147
  br label %continue149

continue149:                                      ; preds = %output148
  %45 = fptrunc double %call150 to float
  store float %45, float* %cos_tau, align 4
  %load_cos_tau = load float, float* %cos_tau, align 4
  %load_sin_lat = load float, float* %sin_lat, align 4
  %tmpVar151 = fmul float %load_cos_tau, %load_sin_lat
  %46 = fpext float %tmpVar151 to double
  %TAN_instance = alloca %TAN_interface, align 8
  br label %input152

input152:                                         ; preds = %continue149
  %47 = getelementptr inbounds %TAN_interface, %TAN_interface* %TAN_instance, i32 0, i32 0
  %load_c = load float, float* %c, align 4
  %48 = fptosi float %load_c to i32
  store i32 %48, i32* %47, align 4
  br label %call153

call153:                                          ; preds = %input152
  %call156 = call double @TAN(%TAN_interface* %TAN_instance)
  br label %output154

output154:                                        ; preds = %call153
  br label %continue155

continue155:                                      ; preds = %output154
  %load_cos_lat = load float, float* %cos_lat, align 4
  %49 = fpext float %load_cos_lat to double
  %tmpVar157 = fmul double %call156, %49
  %tmpVar158 = fsub double %46, %tmpVar157
  %50 = fptrunc double %tmpVar158 to float
  store float %50, float* %t1, align 4
  %ATAN_instance159 = alloca %ATAN_interface, align 8
  br label %input160

input160:                                         ; preds = %continue155
  %51 = getelementptr inbounds %ATAN_interface, %ATAN_interface* %ATAN_instance159, i32 0, i32 0
  %SIN_instance164 = alloca %SIN_interface, align 8
  br label %input165

call161:                                          ; preds = %continue168
  %call172 = call double @ATAN(%ATAN_interface* %ATAN_instance159)
  br label %output162

output162:                                        ; preds = %call161
  br label %continue163

continue163:                                      ; preds = %output162
  %52 = fptrunc double %call172 to float
  store float %52, float* %B, align 4
  %load_t1175 = load float, float* %t1, align 4
  %tmpVar176 = fcmp olt float %load_t1175, 0.000000e+00
  br i1 %tmpVar176, label %condition_body174, label %else

input165:                                         ; preds = %input160
  %53 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance164, i32 0, i32 0
  %load_tau169 = load float, float* %tau, align 4
  %54 = fptosi float %load_tau169 to i32
  store i32 %54, i32* %53, align 4
  br label %call166

call166:                                          ; preds = %input165
  %call170 = call double @SIN(%SIN_interface* %SIN_instance164)
  br label %output167

output167:                                        ; preds = %call166
  br label %continue168

continue168:                                      ; preds = %output167
  %load_t1 = load float, float* %t1, align 4
  %55 = fpext float %load_t1 to double
  %tmpVar171 = fdiv double %call170, %55
  store double %tmpVar171, double* %51, align 8
  br label %call161

condition_body174:                                ; preds = %continue163
  %load_B = load float, float* %B, align 4
  %load_177 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 1), align 4
  %tmpVar178 = fadd float %load_B, %load_177
  store float %tmpVar178, float* %B, align 4
  br label %continue173

else:                                             ; preds = %continue163
  %load_B179 = load float, float* %B, align 4
  %load_180 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 0), align 4
  %tmpVar181 = fadd float %load_B179, %load_180
  store float %tmpVar181, float* %B, align 4
  br label %continue173

continue173:                                      ; preds = %else, %condition_body174
  %DEG_instance = alloca %DEG_interface, align 8
  br label %input182

input182:                                         ; preds = %continue173
  %56 = getelementptr inbounds %DEG_interface, %DEG_interface* %DEG_instance, i32 0, i32 0
  %MODR_instance186 = alloca %MODR_interface, align 8
  br label %input187

call183:                                          ; preds = %continue190
  %call194 = call float @DEG(%DEG_interface* %DEG_instance)
  br label %output184

output184:                                        ; preds = %call183
  br label %continue185

continue185:                                      ; preds = %output184
  store float %call194, float* %B, align 4
  %DEG_instance195 = alloca %DEG_interface, align 8
  br label %input196

input187:                                         ; preds = %input182
  %57 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance186, i32 0, i32 0
  %load_B191 = load float, float* %B, align 4
  store float %load_B191, float* %57, align 4
  %58 = getelementptr inbounds %MODR_interface, %MODR_interface* %MODR_instance186, i32 0, i32 1
  %load_192 = load float, float* getelementptr inbounds (%CONSTANTS_MATH, %CONSTANTS_MATH* @MATH, i32 0, i32 1), align 4
  store float %load_192, float* %58, align 4
  br label %call188

call188:                                          ; preds = %input187
  %call193 = call float @MODR(%MODR_interface* %MODR_instance186)
  br label %output189

output189:                                        ; preds = %call188
  br label %continue190

continue190:                                      ; preds = %output189
  store float %call193, float* %56, align 4
  br label %call183

input196:                                         ; preds = %continue185
  %59 = getelementptr inbounds %DEG_interface, %DEG_interface* %DEG_instance195, i32 0, i32 0
  %ASIN_instance200 = alloca %ASIN_interface, align 8
  br label %input201

call197:                                          ; preds = %continue204
  %call226 = call float @DEG(%DEG_interface* %DEG_instance195)
  br label %output198

output198:                                        ; preds = %call197
  br label %continue199

continue199:                                      ; preds = %output198
  store float %call226, float* %H, align 4
  %load_h = load float, float* %H, align 4
  %tmpVar229 = fcmp ogt float %load_h, 1.800000e+02
  br i1 %tmpVar229, label %condition_body228, label %continue227

input201:                                         ; preds = %input196
  %60 = getelementptr inbounds %ASIN_interface, %ASIN_interface* %ASIN_instance200, i32 0, i32 0
  %COS_instance205 = alloca %COS_interface, align 8
  br label %input206

call202:                                          ; preds = %continue219
  %call225 = call double @ASIN(%ASIN_interface* %ASIN_instance200)
  br label %output203

output203:                                        ; preds = %call202
  br label %continue204

continue204:                                      ; preds = %output203
  %61 = fptrunc double %call225 to float
  store float %61, float* %59, align 4
  br label %call197

input206:                                         ; preds = %input201
  %62 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance205, i32 0, i32 0
  %load_C = load float, float* %c, align 4
  %63 = fptosi float %load_C to i32
  store i32 %63, i32* %62, align 4
  br label %call207

call207:                                          ; preds = %input206
  %call210 = call double @COS(%COS_interface* %COS_instance205)
  br label %output208

output208:                                        ; preds = %call207
  br label %continue209

continue209:                                      ; preds = %output208
  %load_cos_tau211 = load float, float* %cos_tau, align 4
  %64 = fpext float %load_cos_tau211 to double
  %tmpVar212 = fmul double %call210, %64
  %load_cos_lat213 = load float, float* %cos_lat, align 4
  %65 = fpext float %load_cos_lat213 to double
  %tmpVar214 = fmul double %tmpVar212, %65
  %SIN_instance215 = alloca %SIN_interface, align 8
  br label %input216

input216:                                         ; preds = %continue209
  %66 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance215, i32 0, i32 0
  %load_c220 = load float, float* %c, align 4
  %67 = fptosi float %load_c220 to i32
  store i32 %67, i32* %66, align 4
  br label %call217

call217:                                          ; preds = %input216
  %call221 = call double @SIN(%SIN_interface* %SIN_instance215)
  br label %output218

output218:                                        ; preds = %call217
  br label %continue219

continue219:                                      ; preds = %output218
  %load_sin_lat222 = load float, float* %sin_lat, align 4
  %68 = fpext float %load_sin_lat222 to double
  %tmpVar223 = fmul double %call221, %68
  %tmpVar224 = fadd double %tmpVar214, %tmpVar223
  store double %tmpVar224, double* %60, align 8
  br label %call202

condition_body228:                                ; preds = %continue199
  %load_h230 = load float, float* %H, align 4
  %tmpVar231 = fsub float %load_h230, 3.600000e+02
  store float %tmpVar231, float* %H, align 4
  br label %continue227

continue227:                                      ; preds = %condition_body228, %continue199
  %load_h232 = load float, float* %H, align 4
  %REFRACTION_instance = alloca %REFRACTION_interface, align 8
  br label %input233

input233:                                         ; preds = %continue227
  %69 = getelementptr inbounds %REFRACTION_interface, %REFRACTION_interface* %REFRACTION_instance, i32 0, i32 0
  %load_h237 = load float, float* %H, align 4
  store float %load_h237, float* %69, align 4
  br label %call234

call234:                                          ; preds = %input233
  %call238 = call float @REFRACTION(%REFRACTION_interface* %REFRACTION_instance)
  br label %output235

output235:                                        ; preds = %call234
  br label %continue236

continue236:                                      ; preds = %output235
  %tmpVar239 = fadd float %load_h232, %call238
  store float %tmpVar239, float* %HR, align 4
  ret void
}

define void @SUN_TIME(%SUN_TIME_interface* %0) {
entry:
  %LATITUDE = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %0, i32 0, i32 0
  %LONGITUDE = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %0, i32 0, i32 1
  %UTC = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %0, i32 0, i32 2
  %H = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %0, i32 0, i32 3
  %MIDDAY = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %0, i32 0, i32 4
  %SUN_RISE = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %0, i32 0, i32 5
  %SUN_SET = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %0, i32 0, i32 6
  %SUN_DECLINATION = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %0, i32 0, i32 7
  %dk = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %0, i32 0, i32 8
  %delta = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %0, i32 0, i32 9
  %b = getelementptr inbounds %SUN_TIME_interface, %SUN_TIME_interface* %0, i32 0, i32 10
  %load_latitude = load float, float* %LATITUDE, align 4
  %tmpVar = fmul float %load_latitude, 0x3F91DF46A0000000
  store float %tmpVar, float* %b, align 4
  %SUN_MIDDAY_instance = alloca %SUN_MIDDAY_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %SUN_MIDDAY_interface, %SUN_MIDDAY_interface* %SUN_MIDDAY_instance, i32 0, i32 0
  %load_longitude = load float, float* %LONGITUDE, align 4
  store float %load_longitude, float* %1, align 4
  %2 = getelementptr inbounds %SUN_MIDDAY_interface, %SUN_MIDDAY_interface* %SUN_MIDDAY_instance, i32 0, i32 1
  %load_utc = load i64, i64* %UTC, align 4
  store i64 %load_utc, i64* %2, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i64 @SUN_MIDDAY(%SUN_MIDDAY_interface* %SUN_MIDDAY_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call1, i64* %MIDDAY, align 4
  %SIN_instance = alloca %SIN_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %3 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance, i32 0, i32 0
  %INT_TO_REAL_instance = alloca %INT_TO_REAL_interface, align 8
  br label %input6

call3:                                            ; preds = %continue9
  %call19 = call double @SIN(%SIN_interface* %SIN_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  %tmpVar20 = fmul double 4.095400e-01, %call19
  %4 = fptrunc double %tmpVar20 to float
  store float %4, float* %dk, align 4
  %DEG_instance = alloca %DEG_interface, align 8
  br label %input21

input6:                                           ; preds = %input2
  %5 = getelementptr inbounds %INT_TO_REAL_interface, %INT_TO_REAL_interface* %INT_TO_REAL_instance, i32 0, i32 0
  %DAY_OF_YEAR_instance = alloca %DAY_OF_YEAR_interface, align 8
  br label %input10

call7:                                            ; preds = %continue13
  %call16 = call float @INT_TO_REAL(%INT_TO_REAL_interface* %INT_TO_REAL_instance)
  br label %output8

output8:                                          ; preds = %call7
  br label %continue9

continue9:                                        ; preds = %output8
  %tmpVar17 = fsub float %call16, 0x4053D66660000000
  %tmpVar18 = fmul float 0x3F919CE080000000, %tmpVar17
  %6 = fptosi float %tmpVar18 to i32
  store i32 %6, i32* %3, align 4
  br label %call3

input10:                                          ; preds = %input6
  %7 = getelementptr inbounds %DAY_OF_YEAR_interface, %DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance, i32 0, i32 0
  %load_utc14 = load i64, i64* %UTC, align 4
  store i64 %load_utc14, i64* %7, align 4
  br label %call11

call11:                                           ; preds = %input10
  %call15 = call i16 @DAY_OF_YEAR(%DAY_OF_YEAR_interface* %DAY_OF_YEAR_instance)
  br label %output12

output12:                                         ; preds = %call11
  br label %continue13

continue13:                                       ; preds = %output12
  store i16 %call15, i16* %5, align 2
  br label %call7

input21:                                          ; preds = %continue5
  %8 = getelementptr inbounds %DEG_interface, %DEG_interface* %DEG_instance, i32 0, i32 0
  %load_DK = load float, float* %dk, align 4
  store float %load_DK, float* %8, align 4
  br label %call22

call22:                                           ; preds = %input21
  %call25 = call float @DEG(%DEG_interface* %DEG_instance)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  store float %call25, float* %SUN_DECLINATION, align 4
  %load_sun_declination = load float, float* %SUN_DECLINATION, align 4
  %tmpVar27 = fcmp ogt float %load_sun_declination, 1.800000e+02
  br i1 %tmpVar27, label %condition_body, label %continue26

condition_body:                                   ; preds = %continue24
  %load_sun_declination28 = load float, float* %SUN_DECLINATION, align 4
  %tmpVar29 = fsub float %load_sun_declination28, 3.600000e+02
  store float %tmpVar29, float* %SUN_DECLINATION, align 4
  br label %continue26

continue26:                                       ; preds = %condition_body, %continue24
  %load_LATITUDE = load float, float* %LATITUDE, align 4
  %tmpVar30 = fsub float 9.000000e+01, %load_LATITUDE
  %load_sun_declination31 = load float, float* %SUN_DECLINATION, align 4
  %tmpVar32 = fadd float %tmpVar30, %load_sun_declination31
  store float %tmpVar32, float* %SUN_DECLINATION, align 4
  %HOUR_TO_TIME_instance = alloca %HOUR_TO_TIME_interface, align 8
  br label %input33

input33:                                          ; preds = %continue26
  %9 = getelementptr inbounds %HOUR_TO_TIME_interface, %HOUR_TO_TIME_interface* %HOUR_TO_TIME_instance, i32 0, i32 0
  %ACOS_instance = alloca %ACOS_interface, align 8
  br label %input37

call34:                                           ; preds = %continue40
  %call84 = call i64 @HOUR_TO_TIME(%HOUR_TO_TIME_interface* %HOUR_TO_TIME_instance)
  br label %output35

output35:                                         ; preds = %call34
  br label %continue36

continue36:                                       ; preds = %output35
  store i64 %call84, i64* %delta, align 4
  %load_MIDDAY = load i64, i64* %MIDDAY, align 4
  %load_delta = load i64, i64* %delta, align 4
  %tmpVar85 = sub i64 %load_MIDDAY, %load_delta
  store i64 %tmpVar85, i64* %SUN_RISE, align 4
  %load_MIDDAY86 = load i64, i64* %MIDDAY, align 4
  %load_delta87 = load i64, i64* %delta, align 4
  %tmpVar88 = add i64 %load_MIDDAY86, %load_delta87
  store i64 %tmpVar88, i64* %SUN_SET, align 4
  ret void

input37:                                          ; preds = %input33
  %10 = getelementptr inbounds %ACOS_interface, %ACOS_interface* %ACOS_instance, i32 0, i32 0
  %SIN_instance41 = alloca %SIN_interface, align 8
  br label %input42

call38:                                           ; preds = %continue77
  %call82 = call double @ACOS(%ACOS_interface* %ACOS_instance)
  br label %output39

output39:                                         ; preds = %call38
  br label %continue40

continue40:                                       ; preds = %output39
  %tmpVar83 = fmul double %call82, 0x400E8EC8A462E516
  %11 = fptrunc double %tmpVar83 to float
  store float %11, float* %9, align 4
  br label %call34

input42:                                          ; preds = %input37
  %12 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance41, i32 0, i32 0
  %RAD_instance = alloca %RAD_interface, align 8
  br label %input46

call43:                                           ; preds = %continue49
  %call51 = call double @SIN(%SIN_interface* %SIN_instance41)
  br label %output44

output44:                                         ; preds = %call43
  br label %continue45

continue45:                                       ; preds = %output44
  %SIN_instance52 = alloca %SIN_interface, align 8
  br label %input53

input46:                                          ; preds = %input42
  %13 = getelementptr inbounds %RAD_interface, %RAD_interface* %RAD_instance, i32 0, i32 0
  %load_H = load float, float* %H, align 4
  store float %load_H, float* %13, align 4
  br label %call47

call47:                                           ; preds = %input46
  %call50 = call float @RAD(%RAD_interface* %RAD_instance)
  br label %output48

output48:                                         ; preds = %call47
  br label %continue49

continue49:                                       ; preds = %output48
  %14 = fptosi float %call50 to i32
  store i32 %14, i32* %12, align 4
  br label %call43

input53:                                          ; preds = %continue45
  %15 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance52, i32 0, i32 0
  %load_B = load float, float* %b, align 4
  %16 = fptosi float %load_B to i32
  store i32 %16, i32* %15, align 4
  br label %call54

call54:                                           ; preds = %input53
  %call57 = call double @SIN(%SIN_interface* %SIN_instance52)
  br label %output55

output55:                                         ; preds = %call54
  br label %continue56

continue56:                                       ; preds = %output55
  %SIN_instance58 = alloca %SIN_interface, align 8
  br label %input59

input59:                                          ; preds = %continue56
  %17 = getelementptr inbounds %SIN_interface, %SIN_interface* %SIN_instance58, i32 0, i32 0
  %load_DK63 = load float, float* %dk, align 4
  %18 = fptosi float %load_DK63 to i32
  store i32 %18, i32* %17, align 4
  br label %call60

call60:                                           ; preds = %input59
  %call64 = call double @SIN(%SIN_interface* %SIN_instance58)
  br label %output61

output61:                                         ; preds = %call60
  br label %continue62

continue62:                                       ; preds = %output61
  %tmpVar65 = fmul double %call57, %call64
  %tmpVar66 = fsub double %call51, %tmpVar65
  %COS_instance = alloca %COS_interface, align 8
  br label %input67

input67:                                          ; preds = %continue62
  %19 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance, i32 0, i32 0
  %load_B71 = load float, float* %b, align 4
  %20 = fptosi float %load_B71 to i32
  store i32 %20, i32* %19, align 4
  br label %call68

call68:                                           ; preds = %input67
  %call72 = call double @COS(%COS_interface* %COS_instance)
  br label %output69

output69:                                         ; preds = %call68
  br label %continue70

continue70:                                       ; preds = %output69
  %COS_instance73 = alloca %COS_interface, align 8
  br label %input74

input74:                                          ; preds = %continue70
  %21 = getelementptr inbounds %COS_interface, %COS_interface* %COS_instance73, i32 0, i32 0
  %load_DK78 = load float, float* %dk, align 4
  %22 = fptosi float %load_DK78 to i32
  store i32 %22, i32* %21, align 4
  br label %call75

call75:                                           ; preds = %input74
  %call79 = call double @COS(%COS_interface* %COS_instance73)
  br label %output76

output76:                                         ; preds = %call75
  br label %continue77

continue77:                                       ; preds = %output76
  %tmpVar80 = fmul double %call72, %call79
  %tmpVar81 = fdiv double %tmpVar66, %tmpVar80
  %23 = fptosi double %tmpVar81 to i32
  store i32 %23, i32* %10, align 4
  br label %call38
}

define i8 @TIMECHECK(%TIMECHECK_interface* %0) {
entry:
  %TD = getelementptr inbounds %TIMECHECK_interface, %TIMECHECK_interface* %0, i32 0, i32 0
  %START = getelementptr inbounds %TIMECHECK_interface, %TIMECHECK_interface* %0, i32 0, i32 1
  %STOP = getelementptr inbounds %TIMECHECK_interface, %TIMECHECK_interface* %0, i32 0, i32 2
  %TIMECHECK = alloca i8, align 1
  store i8 0, i8* %TIMECHECK, align 1
  %load_stop = load i64, i64* %STOP, align 4
  %load_start = load i64, i64* %START, align 4
  %tmpVar = icmp slt i64 %load_stop, %load_start
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %entry
  %load_start1 = load i64, i64* %START, align 4
  %load_TD = load i64, i64* %TD, align 4
  %tmpVar2 = icmp sle i64 %load_start1, %load_TD
  %1 = zext i1 %tmpVar2 to i32
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %7, label %5

else:                                             ; preds = %entry
  %load_start6 = load i64, i64* %START, align 4
  %load_TD7 = load i64, i64* %TD, align 4
  %tmpVar8 = icmp sle i64 %load_start6, %load_TD7
  %3 = zext i1 %tmpVar8 to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %9, label %11

continue:                                         ; preds = %11, %7
  %TIMECHECK_ret = load i8, i8* %TIMECHECK, align 1
  ret i8 %TIMECHECK_ret

5:                                                ; preds = %condition_body
  %load_TD3 = load i64, i64* %TD, align 4
  %load_stop4 = load i64, i64* %STOP, align 4
  %tmpVar5 = icmp slt i64 %load_TD3, %load_stop4
  %6 = zext i1 %tmpVar5 to i32
  br label %7

7:                                                ; preds = %5, %condition_body
  %8 = phi i32 [ %1, %condition_body ], [ %6, %5 ]
  store i32 %8, i8* %TIMECHECK, align 4
  br label %continue

9:                                                ; preds = %else
  %load_TD9 = load i64, i64* %TD, align 4
  %load_stop10 = load i64, i64* %STOP, align 4
  %tmpVar11 = icmp slt i64 %load_TD9, %load_stop10
  %10 = zext i1 %tmpVar11 to i32
  br label %11

11:                                               ; preds = %9, %else
  %12 = phi i32 [ %3, %else ], [ %10, %9 ]
  store i32 %12, i8* %TIMECHECK, align 4
  br label %continue
}

define i64 @UTC_TO_LTIME(%UTC_TO_LTIME_interface* %0) {
entry:
  %UTC = getelementptr inbounds %UTC_TO_LTIME_interface, %UTC_TO_LTIME_interface* %0, i32 0, i32 0
  %DST_ENABLE = getelementptr inbounds %UTC_TO_LTIME_interface, %UTC_TO_LTIME_interface* %0, i32 0, i32 1
  %TIME_ZONE_OFFSET = getelementptr inbounds %UTC_TO_LTIME_interface, %UTC_TO_LTIME_interface* %0, i32 0, i32 2
  %tmp = getelementptr inbounds %UTC_TO_LTIME_interface, %UTC_TO_LTIME_interface* %0, i32 0, i32 3
  %UTC_TO_LTIME = alloca i64, align 8
  store i16 0, i16* %tmp, align 2
  store i64 0, i64* %UTC_TO_LTIME, align 4
  %load_TIME_ZONE_OFFSET = load i16, i16* %TIME_ZONE_OFFSET, align 2
  %1 = sext i16 %load_TIME_ZONE_OFFSET to i32
  %tmpVar = mul i32 %1, 60
  %BOOL_TO_INT_instance = alloca %BOOL_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %2 = getelementptr inbounds %BOOL_TO_INT_interface, %BOOL_TO_INT_interface* %BOOL_TO_INT_instance, i32 0, i32 0
  %load_DST_ENABLE = load i8, i8* %DST_ENABLE, align 1
  %3 = zext i8 %load_DST_ENABLE to i32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %8, label %9

call:                                             ; preds = %9
  %call6 = call i16 @BOOL_TO_INT(%BOOL_TO_INT_interface* %BOOL_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  %5 = sext i16 %call6 to i32
  %tmpVar7 = mul i32 %5, 3600
  %tmpVar8 = add i32 %tmpVar, %tmpVar7
  %6 = trunc i32 %tmpVar8 to i16
  store i16 %6, i16* %tmp, align 2
  %load_tmp = load i16, i16* %tmp, align 2
  %7 = sext i16 %load_tmp to i32
  %tmpVar10 = icmp slt i32 %7, 0
  br i1 %tmpVar10, label %condition_body, label %else

8:                                                ; preds = %input
  %DST_instance = alloca %DST_interface, align 8
  br label %input1

9:                                                ; preds = %continue4, %input
  %10 = phi i32 [ %3, %input ], [ %12, %continue4 ]
  store i32 %10, i8* %2, align 4
  br label %call

input1:                                           ; preds = %8
  %11 = getelementptr inbounds %DST_interface, %DST_interface* %DST_instance, i32 0, i32 0
  %load_UTC = load i64, i64* %UTC, align 4
  store i64 %load_UTC, i64* %11, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i8 @DST(%DST_interface* %DST_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %12 = zext i8 %call5 to i32
  br label %9

condition_body:                                   ; preds = %continue
  %ABS_instance = alloca %ABS_interface, align 8
  br label %input11

else:                                             ; preds = %continue
  %DWORD_TO_DT_instance35 = alloca %DWORD_TO_DT_interface, align 8
  br label %input36

continue9:                                        ; preds = %continue39, %continue20
  %UTC_TO_LTIME_ret = load i64, i64* %UTC_TO_LTIME, align 4
  ret i64 %UTC_TO_LTIME_ret

input11:                                          ; preds = %condition_body
  %13 = getelementptr inbounds %ABS_interface, %ABS_interface* %ABS_instance, i32 0, i32 0
  %load_tmp15 = load i16, i16* %tmp, align 2
  %14 = sext i16 %load_tmp15 to i64
  store i64 %14, i64* %13, align 4
  br label %call12

call12:                                           ; preds = %input11
  %call16 = call i64 @ABS(%ABS_interface* %ABS_instance)
  br label %output13

output13:                                         ; preds = %call12
  br label %continue14

continue14:                                       ; preds = %output13
  %15 = trunc i64 %call16 to i16
  store i16 %15, i16* %tmp, align 2
  %DWORD_TO_DT_instance = alloca %DWORD_TO_DT_interface, align 8
  br label %input17

input17:                                          ; preds = %continue14
  %16 = getelementptr inbounds %DWORD_TO_DT_interface, %DWORD_TO_DT_interface* %DWORD_TO_DT_instance, i32 0, i32 0
  %DT_TO_DWORD_instance = alloca %DT_TO_DWORD_interface, align 8
  br label %input21

call18:                                           ; preds = %continue30
  %call34 = call i64 @DWORD_TO_DT(%DWORD_TO_DT_interface* %DWORD_TO_DT_instance)
  br label %output19

output19:                                         ; preds = %call18
  br label %continue20

continue20:                                       ; preds = %output19
  store i64 %call34, i64* %UTC_TO_LTIME, align 4
  br label %continue9

input21:                                          ; preds = %input17
  %17 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance, i32 0, i32 0
  %load_UTC25 = load i64, i64* %UTC, align 4
  store i64 %load_UTC25, i64* %17, align 4
  br label %call22

call22:                                           ; preds = %input21
  %call26 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance)
  br label %output23

output23:                                         ; preds = %call22
  br label %continue24

continue24:                                       ; preds = %output23
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input27

input27:                                          ; preds = %continue24
  %18 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_tmp31 = load i16, i16* %tmp, align 2
  store i16 %load_tmp31, i16* %18, align 2
  br label %call28

call28:                                           ; preds = %input27
  %call32 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output29

output29:                                         ; preds = %call28
  br label %continue30

continue30:                                       ; preds = %output29
  %tmpVar33 = sub i32 %call26, %call32
  store i32 %tmpVar33, i32* %16, align 4
  br label %call18

input36:                                          ; preds = %else
  %19 = getelementptr inbounds %DWORD_TO_DT_interface, %DWORD_TO_DT_interface* %DWORD_TO_DT_instance35, i32 0, i32 0
  %DT_TO_DWORD_instance40 = alloca %DT_TO_DWORD_interface, align 8
  br label %input41

call37:                                           ; preds = %continue51
  %call55 = call i64 @DWORD_TO_DT(%DWORD_TO_DT_interface* %DWORD_TO_DT_instance35)
  br label %output38

output38:                                         ; preds = %call37
  br label %continue39

continue39:                                       ; preds = %output38
  store i64 %call55, i64* %UTC_TO_LTIME, align 4
  br label %continue9

input41:                                          ; preds = %input36
  %20 = getelementptr inbounds %DT_TO_DWORD_interface, %DT_TO_DWORD_interface* %DT_TO_DWORD_instance40, i32 0, i32 0
  %load_UTC45 = load i64, i64* %UTC, align 4
  store i64 %load_UTC45, i64* %20, align 4
  br label %call42

call42:                                           ; preds = %input41
  %call46 = call i32 @DT_TO_DWORD(%DT_TO_DWORD_interface* %DT_TO_DWORD_instance40)
  br label %output43

output43:                                         ; preds = %call42
  br label %continue44

continue44:                                       ; preds = %output43
  %INT_TO_DWORD_instance47 = alloca %INT_TO_DWORD_interface, align 8
  br label %input48

input48:                                          ; preds = %continue44
  %21 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance47, i32 0, i32 0
  %load_tmp52 = load i16, i16* %tmp, align 2
  store i16 %load_tmp52, i16* %21, align 2
  br label %call49

call49:                                           ; preds = %input48
  %call53 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance47)
  br label %output50

output50:                                         ; preds = %call49
  br label %continue51

continue51:                                       ; preds = %output50
  %tmpVar54 = add i32 %call46, %call53
  store i32 %tmpVar54, i32* %19, align 4
  br label %call37
}

define i16 @WORK_WEEK(%WORK_WEEK_interface* %0) {
entry:
  %idate = getelementptr inbounds %WORK_WEEK_interface, %WORK_WEEK_interface* %0, i32 0, i32 0
  %d1 = getelementptr inbounds %WORK_WEEK_interface, %WORK_WEEK_interface* %0, i32 0, i32 1
  %w1 = getelementptr inbounds %WORK_WEEK_interface, %WORK_WEEK_interface* %0, i32 0, i32 2
  %ds = getelementptr inbounds %WORK_WEEK_interface, %WORK_WEEK_interface* %0, i32 0, i32 3
  %yr = getelementptr inbounds %WORK_WEEK_interface, %WORK_WEEK_interface* %0, i32 0, i32 4
  %w31 = getelementptr inbounds %WORK_WEEK_interface, %WORK_WEEK_interface* %0, i32 0, i32 5
  %w01 = getelementptr inbounds %WORK_WEEK_interface, %WORK_WEEK_interface* %0, i32 0, i32 6
  %wm = getelementptr inbounds %WORK_WEEK_interface, %WORK_WEEK_interface* %0, i32 0, i32 7
  %WORK_WEEK = alloca i16, align 2
  store i64 0, i64* %d1, align 4
  store i16 0, i16* %w1, align 2
  store i32 0, i32* %ds, align 4
  store i16 0, i16* %yr, align 2
  store i16 0, i16* %w31, align 2
  store i16 0, i16* %w01, align 2
  store i16 0, i16* %wm, align 2
  store i16 0, i16* %WORK_WEEK, align 2
  %YEAR_OF_DATE_instance = alloca %YEAR_OF_DATE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance, i32 0, i32 0
  %load_idate = load i64, i64* %idate, align 4
  store i64 %load_idate, i64* %1, align 4
  br label %call

call:                                             ; preds = %input
  %call1 = call i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %YEAR_OF_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call1, i16* %yr, align 2
  %YEAR_BEGIN_instance = alloca %YEAR_BEGIN_interface, align 8
  br label %input2

input2:                                           ; preds = %continue
  %2 = getelementptr inbounds %YEAR_BEGIN_interface, %YEAR_BEGIN_interface* %YEAR_BEGIN_instance, i32 0, i32 0
  %load_yr = load i16, i16* %yr, align 2
  store i16 %load_yr, i16* %2, align 2
  br label %call3

call3:                                            ; preds = %input2
  %call6 = call i64 @YEAR_BEGIN(%YEAR_BEGIN_interface* %YEAR_BEGIN_instance)
  br label %output4

output4:                                          ; preds = %call3
  br label %continue5

continue5:                                        ; preds = %output4
  store i64 %call6, i64* %d1, align 4
  %DAY_OF_WEEK_instance = alloca %DAY_OF_WEEK_interface, align 8
  br label %input7

input7:                                           ; preds = %continue5
  %3 = getelementptr inbounds %DAY_OF_WEEK_interface, %DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance, i32 0, i32 0
  %load_d1 = load i64, i64* %d1, align 4
  store i64 %load_d1, i64* %3, align 4
  br label %call8

call8:                                            ; preds = %input7
  %call11 = call i16 @DAY_OF_WEEK(%DAY_OF_WEEK_interface* %DAY_OF_WEEK_instance)
  br label %output9

output9:                                          ; preds = %call8
  br label %continue10

continue10:                                       ; preds = %output9
  store i16 %call11, i16* %w1, align 2
  %load_w1 = load i16, i16* %w1, align 2
  %4 = sext i16 %load_w1 to i32
  %tmpVar = icmp slt i32 %4, 5
  br i1 %tmpVar, label %condition_body, label %else

condition_body:                                   ; preds = %continue10
  %DATE_TO_DWORD_instance = alloca %DATE_TO_DWORD_interface, align 8
  br label %input13

else:                                             ; preds = %continue10
  %DATE_TO_DWORD_instance28 = alloca %DATE_TO_DWORD_interface, align 8
  br label %input29

continue12:                                       ; preds = %continue39, %continue22
  %DWORD_TO_INT_instance = alloca %DWORD_TO_INT_interface, align 8
  br label %input45

input13:                                          ; preds = %condition_body
  %5 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance, i32 0, i32 0
  %load_d117 = load i64, i64* %d1, align 4
  store i64 %load_d117, i64* %5, align 4
  br label %call14

call14:                                           ; preds = %input13
  %call18 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance)
  br label %output15

output15:                                         ; preds = %call14
  br label %continue16

continue16:                                       ; preds = %output15
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input19

input19:                                          ; preds = %continue16
  %6 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_w123 = load i16, i16* %w1, align 2
  %7 = sext i16 %load_w123 to i32
  %tmpVar24 = add i32 %7, 6
  %8 = trunc i32 %tmpVar24 to i16
  store i16 %8, i16* %6, align 2
  br label %call20

call20:                                           ; preds = %input19
  %call25 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output21

output21:                                         ; preds = %call20
  br label %continue22

continue22:                                       ; preds = %output21
  %tmpVar26 = mul i32 %call25, 86400
  %tmpVar27 = sub i32 %call18, %tmpVar26
  store i32 %tmpVar27, i32* %ds, align 4
  br label %continue12

input29:                                          ; preds = %else
  %9 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance28, i32 0, i32 0
  %load_d133 = load i64, i64* %d1, align 4
  store i64 %load_d133, i64* %9, align 4
  br label %call30

call30:                                           ; preds = %input29
  %call34 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance28)
  br label %output31

output31:                                         ; preds = %call30
  br label %continue32

continue32:                                       ; preds = %output31
  %INT_TO_DWORD_instance35 = alloca %INT_TO_DWORD_interface, align 8
  br label %input36

input36:                                          ; preds = %continue32
  %10 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance35, i32 0, i32 0
  %load_w140 = load i16, i16* %w1, align 2
  %11 = sext i16 %load_w140 to i32
  %tmpVar41 = sub i32 %11, 1
  %12 = trunc i32 %tmpVar41 to i16
  store i16 %12, i16* %10, align 2
  br label %call37

call37:                                           ; preds = %input36
  %call42 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance35)
  br label %output38

output38:                                         ; preds = %call37
  br label %continue39

continue39:                                       ; preds = %output38
  %tmpVar43 = mul i32 %call42, 86400
  %tmpVar44 = sub i32 %call34, %tmpVar43
  store i32 %tmpVar44, i32* %ds, align 4
  br label %continue12

input45:                                          ; preds = %continue12
  %13 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance, i32 0, i32 0
  %DATE_TO_DWORD_instance49 = alloca %DATE_TO_DWORD_interface, align 8
  br label %input50

call46:                                           ; preds = %continue53
  %call58 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance)
  br label %output47

output47:                                         ; preds = %call46
  br label %continue48

continue48:                                       ; preds = %output47
  store i16 %call58, i16* %WORK_WEEK, align 2
  %load_work_week = load i16, i16* %WORK_WEEK, align 2
  %14 = sext i16 %load_work_week to i32
  %tmpVar62 = icmp eq i32 %14, 0
  br i1 %tmpVar62, label %condition_body61, label %else59

input50:                                          ; preds = %input45
  %15 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance49, i32 0, i32 0
  %load_idate54 = load i64, i64* %idate, align 4
  store i64 %load_idate54, i64* %15, align 4
  br label %call51

call51:                                           ; preds = %input50
  %call55 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance49)
  br label %output52

output52:                                         ; preds = %call51
  br label %continue53

continue53:                                       ; preds = %output52
  %load_ds = load i32, i32* %ds, align 4
  %tmpVar56 = sub i32 %call55, %load_ds
  %tmpVar57 = sdiv i32 %tmpVar56, 604800
  store i32 %tmpVar57, i32* %13, align 4
  br label %call46

condition_body61:                                 ; preds = %continue48
  %load_w166 = load i16, i16* %w1, align 2
  %16 = sext i16 %load_w166 to i32
  %tmpVar67 = icmp sgt i32 %16, 1
  br i1 %tmpVar67, label %condition_body65, label %else63

else59:                                           ; preds = %continue48
  %LEAP_YEAR_instance94 = alloca %LEAP_YEAR_interface, align 8
  br label %input95

continue60:                                       ; preds = %continue120, %continue85
  %WORK_WEEK_ret = load i16, i16* %WORK_WEEK, align 2
  ret i16 %WORK_WEEK_ret

condition_body65:                                 ; preds = %condition_body61
  %load_w168 = load i16, i16* %w1, align 2
  %17 = sext i16 %load_w168 to i32
  %tmpVar69 = sub i32 %17, 1
  %18 = trunc i32 %tmpVar69 to i16
  store i16 %18, i16* %w31, align 2
  br label %continue64

else63:                                           ; preds = %condition_body61
  store i16 7, i16* %w31, align 2
  br label %continue64

continue64:                                       ; preds = %else63, %condition_body65
  %LEAP_YEAR_instance = alloca %LEAP_YEAR_interface, align 8
  br label %input73

condition_body72:                                 ; preds = %24
  %load_W31 = load i16, i16* %w31, align 2
  %19 = sext i16 %load_W31 to i32
  %tmpVar81 = sub i32 %19, 1
  %20 = trunc i32 %tmpVar81 to i16
  store i16 %20, i16* %w01, align 2
  br label %continue71

else70:                                           ; preds = %24
  store i16 7, i16* %w1, align 2
  br label %continue71

continue71:                                       ; preds = %else70, %condition_body72
  %BOOL_TO_INT_instance = alloca %BOOL_TO_INT_interface, align 8
  br label %input82

21:                                               ; preds = %continue76
  %load_w31 = load i16, i16* %w31, align 2
  %22 = sext i16 %load_w31 to i32
  %tmpVar80 = icmp sgt i32 %22, 1
  %23 = zext i1 %tmpVar80 to i32
  br label %24

24:                                               ; preds = %21, %continue76
  %25 = phi i32 [ %30, %continue76 ], [ %23, %21 ]
  %26 = icmp ne i32 %25, 0
  br i1 %26, label %condition_body72, label %else70

input73:                                          ; preds = %continue64
  %27 = getelementptr inbounds %LEAP_YEAR_interface, %LEAP_YEAR_interface* %LEAP_YEAR_instance, i32 0, i32 0
  %load_yr77 = load i16, i16* %yr, align 2
  %28 = sext i16 %load_yr77 to i32
  %tmpVar78 = sub i32 %28, 1
  %29 = trunc i32 %tmpVar78 to i16
  store i16 %29, i16* %27, align 2
  br label %call74

call74:                                           ; preds = %input73
  %call79 = call i8 @LEAP_YEAR(%LEAP_YEAR_interface* %LEAP_YEAR_instance)
  br label %output75

output75:                                         ; preds = %call74
  br label %continue76

continue76:                                       ; preds = %output75
  %30 = zext i8 %call79 to i32
  %31 = icmp ne i32 %30, 0
  br i1 %31, label %21, label %24

input82:                                          ; preds = %continue71
  %32 = getelementptr inbounds %BOOL_TO_INT_interface, %BOOL_TO_INT_interface* %BOOL_TO_INT_instance, i32 0, i32 0
  %load_w3186 = load i16, i16* %w31, align 2
  %33 = sext i16 %load_w3186 to i32
  %tmpVar87 = icmp eq i32 %33, 4
  %34 = zext i1 %tmpVar87 to i32
  %35 = icmp ne i32 %34, 0
  br i1 %35, label %41, label %38

call83:                                           ; preds = %41
  %call89 = call i16 @BOOL_TO_INT(%BOOL_TO_INT_interface* %BOOL_TO_INT_instance)
  br label %output84

output84:                                         ; preds = %call83
  br label %continue85

continue85:                                       ; preds = %output84
  %36 = sext i16 %call89 to i32
  %tmpVar90 = add i32 52, %36
  %37 = trunc i32 %tmpVar90 to i16
  store i16 %37, i16* %WORK_WEEK, align 2
  br label %continue60

38:                                               ; preds = %input82
  %load_w01 = load i16, i16* %w01, align 2
  %39 = sext i16 %load_w01 to i32
  %tmpVar88 = icmp eq i32 %39, 4
  %40 = zext i1 %tmpVar88 to i32
  br label %41

41:                                               ; preds = %38, %input82
  %42 = phi i32 [ %34, %input82 ], [ %40, %38 ]
  store i32 %42, i8* %32, align 4
  br label %call83

condition_body93:                                 ; preds = %continue98
  %load_w1104 = load i16, i16* %w1, align 2
  %43 = sext i16 %load_w1104 to i32
  %tmpVar105 = icmp slt i32 %43, 7
  br i1 %tmpVar105, label %condition_body103, label %else101

else91:                                           ; preds = %continue98
  %load_w1108 = load i16, i16* %w1, align 2
  store i16 %load_w1108, i16* %w31, align 2
  br label %continue92

continue92:                                       ; preds = %else91, %continue102
  %BOOL_TO_INT_instance109 = alloca %BOOL_TO_INT_interface, align 8
  br label %input110

input95:                                          ; preds = %else59
  %44 = getelementptr inbounds %LEAP_YEAR_interface, %LEAP_YEAR_interface* %LEAP_YEAR_instance94, i32 0, i32 0
  %load_yr99 = load i16, i16* %yr, align 2
  store i16 %load_yr99, i16* %44, align 2
  br label %call96

call96:                                           ; preds = %input95
  %call100 = call i8 @LEAP_YEAR(%LEAP_YEAR_interface* %LEAP_YEAR_instance94)
  br label %output97

output97:                                         ; preds = %call96
  br label %continue98

continue98:                                       ; preds = %output97
  %45 = icmp ne i8 %call100, 0
  br i1 %45, label %condition_body93, label %else91

condition_body103:                                ; preds = %condition_body93
  %load_w1106 = load i16, i16* %w1, align 2
  %46 = sext i16 %load_w1106 to i32
  %tmpVar107 = add i32 %46, 1
  %47 = trunc i32 %tmpVar107 to i16
  store i16 %47, i16* %w31, align 2
  br label %continue102

else101:                                          ; preds = %condition_body93
  store i16 1, i16* %w31, align 2
  br label %continue102

continue102:                                      ; preds = %else101, %condition_body103
  br label %continue92

input110:                                         ; preds = %continue92
  %48 = getelementptr inbounds %BOOL_TO_INT_interface, %BOOL_TO_INT_interface* %BOOL_TO_INT_instance109, i32 0, i32 0
  %load_w31114 = load i16, i16* %w31, align 2
  %49 = sext i16 %load_w31114 to i32
  %tmpVar115 = icmp eq i32 %49, 4
  %50 = zext i1 %tmpVar115 to i32
  %51 = icmp ne i32 %50, 0
  br i1 %51, label %59, label %56

call111:                                          ; preds = %59
  %call118 = call i16 @BOOL_TO_INT(%BOOL_TO_INT_interface* %BOOL_TO_INT_instance109)
  br label %output112

output112:                                        ; preds = %call111
  br label %continue113

continue113:                                      ; preds = %output112
  %52 = sext i16 %call118 to i32
  %tmpVar119 = add i32 52, %52
  %53 = trunc i32 %tmpVar119 to i16
  store i16 %53, i16* %wm, align 2
  %load_WORK_WEEK = load i16, i16* %WORK_WEEK, align 2
  %54 = sext i16 %load_WORK_WEEK to i32
  %load_wm = load i16, i16* %wm, align 2
  %55 = sext i16 %load_wm to i32
  %tmpVar122 = icmp sgt i32 %54, %55
  br i1 %tmpVar122, label %condition_body121, label %continue120

56:                                               ; preds = %input110
  %load_w1116 = load i16, i16* %w1, align 2
  %57 = sext i16 %load_w1116 to i32
  %tmpVar117 = icmp eq i32 %57, 4
  %58 = zext i1 %tmpVar117 to i32
  br label %59

59:                                               ; preds = %56, %input110
  %60 = phi i32 [ %50, %input110 ], [ %58, %56 ]
  store i32 %60, i8* %48, align 4
  br label %call111

condition_body121:                                ; preds = %continue113
  store i16 1, i16* %WORK_WEEK, align 2
  br label %continue120

continue120:                                      ; preds = %condition_body121, %continue113
  br label %continue60
}

define i64 @YEAR_BEGIN(%YEAR_BEGIN_interface* %0) {
entry:
  %y = getelementptr inbounds %YEAR_BEGIN_interface, %YEAR_BEGIN_interface* %0, i32 0, i32 0
  %YEAR_BEGIN = alloca i64, align 8
  store i64 0, i64* %YEAR_BEGIN, align 4
  %DWORD_TO_DATE_instance = alloca %DWORD_TO_DATE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_DATE_interface, %DWORD_TO_DATE_interface* %DWORD_TO_DATE_instance, i32 0, i32 0
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call13 = call i64 @DWORD_TO_DATE(%DWORD_TO_DATE_interface* %DWORD_TO_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call13, i64* %YEAR_BEGIN, align 4
  %YEAR_BEGIN_ret = load i64, i64* %YEAR_BEGIN, align 4
  ret i64 %YEAR_BEGIN_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  %call11 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar12 = mul i64 %call11, 86400
  %3 = trunc i64 %tmpVar12 to i32
  store i32 %3, i32* %1, align 4
  br label %call

input5:                                           ; preds = %input1
  %4 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_y = load i16, i16* %y, align 2
  store i16 %load_y, i16* %4, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %tmpVar = mul i32 %call9, 1461
  %tmpVar10 = sub i32 %tmpVar, 2878169
  %5 = sext i32 %tmpVar10 to i64
  store i64 %5, i64* %2, align 4
  %6 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %6, align 2
  br label %call2
}

define i64 @YEAR_END(%YEAR_END_interface* %0) {
entry:
  %y = getelementptr inbounds %YEAR_END_interface, %YEAR_END_interface* %0, i32 0, i32 0
  %YEAR_END = alloca i64, align 8
  store i64 0, i64* %YEAR_END, align 4
  %DWORD_TO_DATE_instance = alloca %DWORD_TO_DATE_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_DATE_interface, %DWORD_TO_DATE_interface* %DWORD_TO_DATE_instance, i32 0, i32 0
  %SHR_instance = alloca %SHR_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call13 = call i64 @DWORD_TO_DATE(%DWORD_TO_DATE_interface* %DWORD_TO_DATE_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i64 %call13, i64* %YEAR_END, align 4
  %YEAR_END_ret = load i64, i64* %YEAR_END, align 4
  ret i64 %YEAR_END_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 0
  %INT_TO_DWORD_instance = alloca %INT_TO_DWORD_interface, align 8
  br label %input5

call2:                                            ; preds = %continue8
  %call11 = call i64 @SHR(%SHR_interface* %SHR_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar12 = mul i64 %call11, 86400
  %3 = trunc i64 %tmpVar12 to i32
  store i32 %3, i32* %1, align 4
  br label %call

input5:                                           ; preds = %input1
  %4 = getelementptr inbounds %INT_TO_DWORD_interface, %INT_TO_DWORD_interface* %INT_TO_DWORD_instance, i32 0, i32 0
  %load_y = load i16, i16* %y, align 2
  store i16 %load_y, i16* %4, align 2
  br label %call6

call6:                                            ; preds = %input5
  %call9 = call i32 @INT_TO_DWORD(%INT_TO_DWORD_interface* %INT_TO_DWORD_instance)
  br label %output7

output7:                                          ; preds = %call6
  br label %continue8

continue8:                                        ; preds = %output7
  %tmpVar = mul i32 %call9, 1461
  %tmpVar10 = sub i32 %tmpVar, 2876712
  %5 = sext i32 %tmpVar10 to i64
  store i64 %5, i64* %2, align 4
  %6 = getelementptr inbounds %SHR_interface, %SHR_interface* %SHR_instance, i32 0, i32 1
  store i16 2, i16* %6, align 2
  br label %call2
}

define i16 @YEAR_OF_DATE(%YEAR_OF_DATE_interface* %0) {
entry:
  %IDATE = getelementptr inbounds %YEAR_OF_DATE_interface, %YEAR_OF_DATE_interface* %0, i32 0, i32 0
  %YEAR_OF_DATE = alloca i16, align 2
  store i16 0, i16* %YEAR_OF_DATE, align 2
  %DWORD_TO_INT_instance = alloca %DWORD_TO_INT_interface, align 8
  br label %input

input:                                            ; preds = %entry
  %1 = getelementptr inbounds %DWORD_TO_INT_interface, %DWORD_TO_INT_interface* %DWORD_TO_INT_instance, i32 0, i32 0
  %DATE_TO_DWORD_instance = alloca %DATE_TO_DWORD_interface, align 8
  br label %input1

call:                                             ; preds = %continue4
  %call8 = call i16 @DWORD_TO_INT(%DWORD_TO_INT_interface* %DWORD_TO_INT_instance)
  br label %output

output:                                           ; preds = %call
  br label %continue

continue:                                         ; preds = %output
  store i16 %call8, i16* %YEAR_OF_DATE, align 2
  %YEAR_OF_DATE_ret = load i16, i16* %YEAR_OF_DATE, align 2
  ret i16 %YEAR_OF_DATE_ret

input1:                                           ; preds = %input
  %2 = getelementptr inbounds %DATE_TO_DWORD_interface, %DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance, i32 0, i32 0
  %load_idate = load i64, i64* %IDATE, align 4
  store i64 %load_idate, i64* %2, align 4
  br label %call2

call2:                                            ; preds = %input1
  %call5 = call i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface* %DATE_TO_DWORD_instance)
  br label %output3

output3:                                          ; preds = %call2
  br label %continue4

continue4:                                        ; preds = %output3
  %tmpVar = add i32 %call5, 43200
  %tmpVar6 = sdiv i32 %tmpVar, 31557600
  %tmpVar7 = add i32 %tmpVar6, 1970
  store i32 %tmpVar7, i32* %1, align 4
  br label %call
}

declare i64 @ABS(%ABS_interface*)

declare double @ACOS(%ACOS_interface*)

declare i32 @ADR(%ADR_interface*)

declare double @ASIN(%ASIN_interface*)

declare double @ATAN(%ATAN_interface*)

declare i8 @BOOL_TO_BYTE(%BOOL_TO_BYTE_interface*)

declare i64 @BOOL_TO_DATE(%BOOL_TO_DATE_interface*)

declare i32 @BOOL_TO_DINT(%BOOL_TO_DINT_interface*)

declare i64 @BOOL_TO_DT(%BOOL_TO_DT_interface*)

declare i32 @BOOL_TO_DWORD(%BOOL_TO_DWORD_interface*)

declare i16 @BOOL_TO_INT(%BOOL_TO_INT_interface*)

declare double @BOOL_TO_LREAL(%BOOL_TO_LREAL_interface*)

declare float @BOOL_TO_REAL(%BOOL_TO_REAL_interface*)

declare i8 @BOOL_TO_SINT(%BOOL_TO_SINT_interface*)

declare [81 x i8] @BOOL_TO_STRING(%BOOL_TO_STRING_interface*)

declare i64 @BOOL_TO_TIME(%BOOL_TO_TIME_interface*)

declare i64 @BOOL_TO_TOD(%BOOL_TO_TOD_interface*)

declare i32 @BOOL_TO_UDINT(%BOOL_TO_UDINT_interface*)

declare i16 @BOOL_TO_UINT(%BOOL_TO_UINT_interface*)

declare i8 @BOOL_TO_USINT(%BOOL_TO_USINT_interface*)

declare i16 @BOOL_TO_WORD(%BOOL_TO_WORD_interface*)

declare i8 @BYTE_TO_BOOL(%BYTE_TO_BOOL_interface*)

declare i64 @BYTE_TO_DATE(%BYTE_TO_DATE_interface*)

declare i32 @BYTE_TO_DINT(%BYTE_TO_DINT_interface*)

declare i64 @BYTE_TO_DT(%BYTE_TO_DT_interface*)

declare i32 @BYTE_TO_DWORD(%BYTE_TO_DWORD_interface*)

declare i16 @BYTE_TO_INT(%BYTE_TO_INT_interface*)

declare double @BYTE_TO_LREAL(%BYTE_TO_LREAL_interface*)

declare float @BYTE_TO_REAL(%BYTE_TO_REAL_interface*)

declare i8 @BYTE_TO_SINT(%BYTE_TO_SINT_interface*)

declare [81 x i8] @BYTE_TO_STRING(%BYTE_TO_STRING_interface*)

declare i64 @BYTE_TO_TIME(%BYTE_TO_TIME_interface*)

declare i64 @BYTE_TO_TOD(%BYTE_TO_TOD_interface*)

declare i32 @BYTE_TO_UDINT(%BYTE_TO_UDINT_interface*)

declare i16 @BYTE_TO_UINT(%BYTE_TO_UINT_interface*)

declare i8 @BYTE_TO_USINT(%BYTE_TO_USINT_interface*)

declare i16 @BYTE_TO_WORD(%BYTE_TO_WORD_interface*)

declare [1024 x i8] @CONCAT(%CONCAT_interface*)

declare double @COS(%COS_interface*)

declare void @CTD(%CTD_interface*)

declare void @CTU(%CTU_interface*)

declare void @CTUD(%CTUD_interface*)

declare i8 @DATE_TO_BOOL(%DATE_TO_BOOL_interface*)

declare i8 @DATE_TO_BYTE(%DATE_TO_BYTE_interface*)

declare i32 @DATE_TO_DINT(%DATE_TO_DINT_interface*)

declare i64 @DATE_TO_DT(%DATE_TO_DT_interface*)

declare i32 @DATE_TO_DWORD(%DATE_TO_DWORD_interface*)

declare i16 @DATE_TO_INT(%DATE_TO_INT_interface*)

declare double @DATE_TO_LREAL(%DATE_TO_LREAL_interface*)

declare float @DATE_TO_REAL(%DATE_TO_REAL_interface*)

declare i8 @DATE_TO_SINT(%DATE_TO_SINT_interface*)

declare [81 x i8] @DATE_TO_STRING(%DATE_TO_STRING_interface*)

declare i64 @DATE_TO_TIME(%DATE_TO_TIME_interface*)

declare i64 @DATE_TO_TOD(%DATE_TO_TOD_interface*)

declare i32 @DATE_TO_UDINT(%DATE_TO_UDINT_interface*)

declare i16 @DATE_TO_UINT(%DATE_TO_UINT_interface*)

declare i8 @DATE_TO_USINT(%DATE_TO_USINT_interface*)

declare i16 @DATE_TO_WORD(%DATE_TO_WORD_interface*)

declare [1024 x i8] @DELETE(%DELETE_interface*)

declare i8 @DINT_TO_BOOL(%DINT_TO_BOOL_interface*)

declare i8 @DINT_TO_BYTE(%DINT_TO_BYTE_interface*)

declare i64 @DINT_TO_DATE(%DINT_TO_DATE_interface*)

declare i64 @DINT_TO_DT(%DINT_TO_DT_interface*)

declare i32 @DINT_TO_DWORD(%DINT_TO_DWORD_interface*)

declare i16 @DINT_TO_INT(%DINT_TO_INT_interface*)

declare double @DINT_TO_LREAL(%DINT_TO_LREAL_interface*)

declare float @DINT_TO_REAL(%DINT_TO_REAL_interface*)

declare i8 @DINT_TO_SINT(%DINT_TO_SINT_interface*)

declare [81 x i8] @DINT_TO_STRING(%DINT_TO_STRING_interface*)

declare i64 @DINT_TO_TIME(%DINT_TO_TIME_interface*)

declare i64 @DINT_TO_TOD(%DINT_TO_TOD_interface*)

declare i32 @DINT_TO_UDINT(%DINT_TO_UDINT_interface*)

declare i16 @DINT_TO_UINT(%DINT_TO_UINT_interface*)

declare i8 @DINT_TO_USINT(%DINT_TO_USINT_interface*)

declare i16 @DINT_TO_WORD(%DINT_TO_WORD_interface*)

declare i8 @DT_TO_BOOL(%DT_TO_BOOL_interface*)

declare i8 @DT_TO_BYTE(%DT_TO_BYTE_interface*)

declare i64 @DT_TO_DATE(%DT_TO_DATE_interface*)

declare i32 @DT_TO_DINT(%DT_TO_DINT_interface*)

declare i32 @DT_TO_DWORD(%DT_TO_DWORD_interface*)

declare i16 @DT_TO_INT(%DT_TO_INT_interface*)

declare double @DT_TO_LREAL(%DT_TO_LREAL_interface*)

declare float @DT_TO_REAL(%DT_TO_REAL_interface*)

declare i8 @DT_TO_SINT(%DT_TO_SINT_interface*)

declare [81 x i8] @DT_TO_STRING(%DT_TO_STRING_interface*)

declare i64 @DT_TO_TIME(%DT_TO_TIME_interface*)

declare i64 @DT_TO_TOD(%DT_TO_TOD_interface*)

declare i32 @DT_TO_UDINT(%DT_TO_UDINT_interface*)

declare i16 @DT_TO_UINT(%DT_TO_UINT_interface*)

declare i8 @DT_TO_USINT(%DT_TO_USINT_interface*)

declare i16 @DT_TO_WORD(%DT_TO_WORD_interface*)

declare i8 @DWORD_TO_BOOL(%DWORD_TO_BOOL_interface*)

declare i8 @DWORD_TO_BYTE(%DWORD_TO_BYTE_interface*)

declare i64 @DWORD_TO_DATE(%DWORD_TO_DATE_interface*)

declare i32 @DWORD_TO_DINT(%DWORD_TO_DINT_interface*)

declare i64 @DWORD_TO_DT(%DWORD_TO_DT_interface*)

declare i16 @DWORD_TO_INT(%DWORD_TO_INT_interface*)

declare double @DWORD_TO_LREAL(%DWORD_TO_LREAL_interface*)

declare float @DWORD_TO_REAL(%DWORD_TO_REAL_interface*)

declare i8 @DWORD_TO_SINT(%DWORD_TO_SINT_interface*)

declare [81 x i8] @DWORD_TO_STRING(%DWORD_TO_STRING_interface*)

declare i64 @DWORD_TO_TIME(%DWORD_TO_TIME_interface*)

declare i64 @DWORD_TO_TOD(%DWORD_TO_TOD_interface*)

declare i32 @DWORD_TO_UDINT(%DWORD_TO_UDINT_interface*)

declare i16 @DWORD_TO_UINT(%DWORD_TO_UINT_interface*)

declare i8 @DWORD_TO_USINT(%DWORD_TO_USINT_interface*)

declare i16 @DWORD_TO_WORD(%DWORD_TO_WORD_interface*)

declare double @EXP(%EXP_interface*)

declare double @EXPT(%EXPT_interface*)

declare void @F_TRIG(%F_TRIG_interface*)

declare i16 @FIND(%FIND_interface*)

declare [1024 x i8] @INSERT(%INSERT_interface*)

declare i8 @INT_TO_BOOL(%INT_TO_BOOL_interface*)

declare i8 @INT_TO_BYTE(%INT_TO_BYTE_interface*)

declare i64 @INT_TO_DATE(%INT_TO_DATE_interface*)

declare i32 @INT_TO_DINT(%INT_TO_DINT_interface*)

declare i64 @INT_TO_DT(%INT_TO_DT_interface*)

declare i32 @INT_TO_DWORD(%INT_TO_DWORD_interface*)

declare double @INT_TO_LREAL(%INT_TO_LREAL_interface*)

declare float @INT_TO_REAL(%INT_TO_REAL_interface*)

declare i8 @INT_TO_SINT(%INT_TO_SINT_interface*)

declare [81 x i8] @INT_TO_STRING(%INT_TO_STRING_interface*)

declare i64 @INT_TO_TIME(%INT_TO_TIME_interface*)

declare i64 @INT_TO_TOD(%INT_TO_TOD_interface*)

declare i32 @INT_TO_UDINT(%INT_TO_UDINT_interface*)

declare i16 @INT_TO_UINT(%INT_TO_UINT_interface*)

declare i8 @INT_TO_USINT(%INT_TO_USINT_interface*)

declare i16 @INT_TO_WORD(%INT_TO_WORD_interface*)

declare [1024 x i8] @LEFT(%LEFT_interface*)

declare i16 @LEN(%LEN_interface*)

declare i64 @LIMIT(%LIMIT_interface*)

declare double @LN(%LN_interface*)

declare i64 @LOG(%LOG_interface*)

declare i8 @LREAL_TO_BOOL(%LREAL_TO_BOOL_interface*)

declare i8 @LREAL_TO_BYTE(%LREAL_TO_BYTE_interface*)

declare i64 @LREAL_TO_DATE(%LREAL_TO_DATE_interface*)

declare i32 @LREAL_TO_DINT(%LREAL_TO_DINT_interface*)

declare i64 @LREAL_TO_DT(%LREAL_TO_DT_interface*)

declare i32 @LREAL_TO_DWORD(%LREAL_TO_DWORD_interface*)

declare i16 @LREAL_TO_INT(%LREAL_TO_INT_interface*)

declare float @LREAL_TO_REAL(%LREAL_TO_REAL_interface*)

declare i8 @LREAL_TO_SINT(%LREAL_TO_SINT_interface*)

declare [81 x i8] @LREAL_TO_STRING(%LREAL_TO_STRING_interface*)

declare i64 @LREAL_TO_TIME(%LREAL_TO_TIME_interface*)

declare i64 @LREAL_TO_TOD(%LREAL_TO_TOD_interface*)

declare i32 @LREAL_TO_UDINT(%LREAL_TO_UDINT_interface*)

declare i16 @LREAL_TO_UINT(%LREAL_TO_UINT_interface*)

declare i8 @LREAL_TO_USINT(%LREAL_TO_USINT_interface*)

declare i16 @LREAL_TO_WORD(%LREAL_TO_WORD_interface*)

declare i64 @MAX(%MAX_interface*)

declare [1024 x i8] @MID(%MID_interface*)

declare i64 @MIN(%MIN_interface*)

declare i64 @MOVE(%MOVE_interface*)

declare i64 @MUX(%MUX_interface*)

declare void @R_TRIG(%R_TRIG_interface*)

declare i8 @REAL_TO_BOOL(%REAL_TO_BOOL_interface*)

declare i8 @REAL_TO_BYTE(%REAL_TO_BYTE_interface*)

declare i64 @REAL_TO_DATE(%REAL_TO_DATE_interface*)

declare i32 @REAL_TO_DINT(%REAL_TO_DINT_interface*)

declare i64 @REAL_TO_DT(%REAL_TO_DT_interface*)

declare i32 @REAL_TO_DWORD(%REAL_TO_DWORD_interface*)

declare i16 @REAL_TO_INT(%REAL_TO_INT_interface*)

declare double @REAL_TO_LREAL(%REAL_TO_LREAL_interface*)

declare i8 @REAL_TO_SINT(%REAL_TO_SINT_interface*)

declare [81 x i8] @REAL_TO_STRING(%REAL_TO_STRING_interface*)

declare i64 @REAL_TO_TIME(%REAL_TO_TIME_interface*)

declare i64 @REAL_TO_TOD(%REAL_TO_TOD_interface*)

declare i32 @REAL_TO_UDINT(%REAL_TO_UDINT_interface*)

declare i16 @REAL_TO_UINT(%REAL_TO_UINT_interface*)

declare i8 @REAL_TO_USINT(%REAL_TO_USINT_interface*)

declare i16 @REAL_TO_WORD(%REAL_TO_WORD_interface*)

declare [1024 x i8] @REPLACE(%REPLACE_interface*)

declare [1024 x i8] @RIGHT(%RIGHT_interface*)

declare i64 @ROL(%ROL_interface*)

declare i64 @ROR(%ROR_interface*)

declare void @RS(%RS_interface*)

declare i64 @SEL(%SEL_interface*)

declare i64 @SHL(%SHL_interface*)

declare i64 @SHR(%SHR_interface*)

declare double @SIN(%SIN_interface*)

declare i8 @SINT_TO_BOOL(%SINT_TO_BOOL_interface*)

declare i8 @SINT_TO_BYTE(%SINT_TO_BYTE_interface*)

declare i64 @SINT_TO_DATE(%SINT_TO_DATE_interface*)

declare i32 @SINT_TO_DINT(%SINT_TO_DINT_interface*)

declare i64 @SINT_TO_DT(%SINT_TO_DT_interface*)

declare i32 @SINT_TO_DWORD(%SINT_TO_DWORD_interface*)

declare i16 @SINT_TO_INT(%SINT_TO_INT_interface*)

declare double @SINT_TO_LREAL(%SINT_TO_LREAL_interface*)

declare float @SINT_TO_REAL(%SINT_TO_REAL_interface*)

declare [81 x i8] @SINT_TO_STRING(%SINT_TO_STRING_interface*)

declare i64 @SINT_TO_TIME(%SINT_TO_TIME_interface*)

declare i64 @SINT_TO_TOD(%SINT_TO_TOD_interface*)

declare i32 @SINT_TO_UDINT(%SINT_TO_UDINT_interface*)

declare i16 @SINT_TO_UINT(%SINT_TO_UINT_interface*)

declare i8 @SINT_TO_USINT(%SINT_TO_USINT_interface*)

declare i16 @SINT_TO_WORD(%SINT_TO_WORD_interface*)

declare i16 @SIZEOF(%SIZEOF_interface*)

declare double @SQRT(%SQRT_interface*)

declare void @SR(%SR_interface*)

declare i8 @STRING_TO_BOOL(%STRING_TO_BOOL_interface*)

declare i8 @STRING_TO_BYTE(%STRING_TO_BYTE_interface*)

declare i64 @STRING_TO_DATE(%STRING_TO_DATE_interface*)

declare i32 @STRING_TO_DINT(%STRING_TO_DINT_interface*)

declare i64 @STRING_TO_DT(%STRING_TO_DT_interface*)

declare i32 @STRING_TO_DWORD(%STRING_TO_DWORD_interface*)

declare i16 @STRING_TO_INT(%STRING_TO_INT_interface*)

declare double @STRING_TO_LREAL(%STRING_TO_LREAL_interface*)

declare float @STRING_TO_REAL(%STRING_TO_REAL_interface*)

declare i8 @STRING_TO_SINT(%STRING_TO_SINT_interface*)

declare i64 @STRING_TO_TIME(%STRING_TO_TIME_interface*)

declare i64 @STRING_TO_TOD(%STRING_TO_TOD_interface*)

declare i32 @STRING_TO_UDINT(%STRING_TO_UDINT_interface*)

declare i16 @STRING_TO_UINT(%STRING_TO_UINT_interface*)

declare i8 @STRING_TO_USINT(%STRING_TO_USINT_interface*)

declare i16 @STRING_TO_WORD(%STRING_TO_WORD_interface*)

declare double @TAN(%TAN_interface*)

declare i64 @_TIME(%_TIME_interface*)

declare i8 @TIME_TO_BOOL(%TIME_TO_BOOL_interface*)

declare i8 @TIME_TO_BYTE(%TIME_TO_BYTE_interface*)

declare i64 @TIME_TO_DATE(%TIME_TO_DATE_interface*)

declare i32 @TIME_TO_DINT(%TIME_TO_DINT_interface*)

declare i64 @TIME_TO_DT(%TIME_TO_DT_interface*)

declare i32 @TIME_TO_DWORD(%TIME_TO_DWORD_interface*)

declare i16 @TIME_TO_INT(%TIME_TO_INT_interface*)

declare double @TIME_TO_LREAL(%TIME_TO_LREAL_interface*)

declare float @TIME_TO_REAL(%TIME_TO_REAL_interface*)

declare i8 @TIME_TO_SINT(%TIME_TO_SINT_interface*)

declare [81 x i8] @TIME_TO_STRING(%TIME_TO_STRING_interface*)

declare i64 @TIME_TO_TOD(%TIME_TO_TOD_interface*)

declare i32 @TIME_TO_UDINT(%TIME_TO_UDINT_interface*)

declare i16 @TIME_TO_UINT(%TIME_TO_UINT_interface*)

declare i8 @TIME_TO_USINT(%TIME_TO_USINT_interface*)

declare i16 @TIME_TO_WORD(%TIME_TO_WORD_interface*)

declare i8 @TOD_TO_BOOL(%TOD_TO_BOOL_interface*)

declare i8 @TOD_TO_BYTE(%TOD_TO_BYTE_interface*)

declare i64 @TOD_TO_DATE(%TOD_TO_DATE_interface*)

declare i32 @TOD_TO_DINT(%TOD_TO_DINT_interface*)

declare i64 @TOD_TO_DT(%TOD_TO_DT_interface*)

declare i32 @TOD_TO_DWORD(%TOD_TO_DWORD_interface*)

declare i16 @TOD_TO_INT(%TOD_TO_INT_interface*)

declare double @TOD_TO_LREAL(%TOD_TO_LREAL_interface*)

declare float @TOD_TO_REAL(%TOD_TO_REAL_interface*)

declare i8 @TOD_TO_SINT(%TOD_TO_SINT_interface*)

declare [81 x i8] @TOD_TO_STRING(%TOD_TO_STRING_interface*)

declare i64 @TOD_TO_TIME(%TOD_TO_TIME_interface*)

declare i32 @TOD_TO_UDINT(%TOD_TO_UDINT_interface*)

declare i16 @TOD_TO_UINT(%TOD_TO_UINT_interface*)

declare i8 @TOD_TO_USINT(%TOD_TO_USINT_interface*)

declare i16 @TOD_TO_WORD(%TOD_TO_WORD_interface*)

declare void @TOF(%TOF_interface*)

declare [1024 x i8] @TOLOWERCASE(%TOLOWERCASE_interface*)

declare void @TON(%TON_interface*)

declare [1024 x i8] @TOUPPERCASE(%TOUPPERCASE_interface*)

declare void @TP(%TP_interface*)

declare i16 @TRUNC(%TRUNC_interface*)

declare i8 @UDINT_TO_BOOL(%UDINT_TO_BOOL_interface*)

declare i8 @UDINT_TO_BYTE(%UDINT_TO_BYTE_interface*)

declare i64 @UDINT_TO_DATE(%UDINT_TO_DATE_interface*)

declare i32 @UDINT_TO_DINT(%UDINT_TO_DINT_interface*)

declare i64 @UDINT_TO_DT(%UDINT_TO_DT_interface*)

declare i32 @UDINT_TO_DWORD(%UDINT_TO_DWORD_interface*)

declare i16 @UDINT_TO_INT(%UDINT_TO_INT_interface*)

declare double @UDINT_TO_LREAL(%UDINT_TO_LREAL_interface*)

declare float @UDINT_TO_REAL(%UDINT_TO_REAL_interface*)

declare i8 @UDINT_TO_SINT(%UDINT_TO_SINT_interface*)

declare [81 x i8] @UDINT_TO_STRING(%UDINT_TO_STRING_interface*)

declare i64 @UDINT_TO_TIME(%UDINT_TO_TIME_interface*)

declare i64 @UDINT_TO_TOD(%UDINT_TO_TOD_interface*)

declare i16 @UDINT_TO_UINT(%UDINT_TO_UINT_interface*)

declare i8 @UDINT_TO_USINT(%UDINT_TO_USINT_interface*)

declare i16 @UDINT_TO_WORD(%UDINT_TO_WORD_interface*)

declare i8 @UINT_TO_BOOL(%UINT_TO_BOOL_interface*)

declare i8 @UINT_TO_BYTE(%UINT_TO_BYTE_interface*)

declare i64 @UINT_TO_DATE(%UINT_TO_DATE_interface*)

declare i32 @UINT_TO_DINT(%UINT_TO_DINT_interface*)

declare i64 @UINT_TO_DT(%UINT_TO_DT_interface*)

declare i32 @UINT_TO_DWORD(%UINT_TO_DWORD_interface*)

declare i16 @UINT_TO_INT(%UINT_TO_INT_interface*)

declare double @UINT_TO_LREAL(%UINT_TO_LREAL_interface*)

declare float @UINT_TO_REAL(%UINT_TO_REAL_interface*)

declare i8 @UINT_TO_SINT(%UINT_TO_SINT_interface*)

declare [81 x i8] @UINT_TO_STRING(%UINT_TO_STRING_interface*)

declare i64 @UINT_TO_TIME(%UINT_TO_TIME_interface*)

declare i64 @UINT_TO_TOD(%UINT_TO_TOD_interface*)

declare i32 @UINT_TO_UDINT(%UINT_TO_UDINT_interface*)

declare i8 @UINT_TO_USINT(%UINT_TO_USINT_interface*)

declare i16 @UINT_TO_WORD(%UINT_TO_WORD_interface*)

declare i8 @USINT_TO_BOOL(%USINT_TO_BOOL_interface*)

declare i8 @USINT_TO_BYTE(%USINT_TO_BYTE_interface*)

declare i64 @USINT_TO_DATE(%USINT_TO_DATE_interface*)

declare i32 @USINT_TO_DINT(%USINT_TO_DINT_interface*)

declare i64 @USINT_TO_DT(%USINT_TO_DT_interface*)

declare i32 @USINT_TO_DWORD(%USINT_TO_DWORD_interface*)

declare i16 @USINT_TO_INT(%USINT_TO_INT_interface*)

declare double @USINT_TO_LREAL(%USINT_TO_LREAL_interface*)

declare float @USINT_TO_REAL(%USINT_TO_REAL_interface*)

declare i8 @USINT_TO_SINT(%USINT_TO_SINT_interface*)

declare [81 x i8] @USINT_TO_STRING(%USINT_TO_STRING_interface*)

declare i64 @USINT_TO_TIME(%USINT_TO_TIME_interface*)

declare i64 @USINT_TO_TOD(%USINT_TO_TOD_interface*)

declare i32 @USINT_TO_UDINT(%USINT_TO_UDINT_interface*)

declare i16 @USINT_TO_UINT(%USINT_TO_UINT_interface*)

declare i16 @USINT_TO_WORD(%USINT_TO_WORD_interface*)

declare i8 @WORD_TO_BOOL(%WORD_TO_BOOL_interface*)

declare i8 @WORD_TO_BYTE(%WORD_TO_BYTE_interface*)

declare i64 @WORD_TO_DATE(%WORD_TO_DATE_interface*)

declare i32 @WORD_TO_DINT(%WORD_TO_DINT_interface*)

declare i64 @WORD_TO_DT(%WORD_TO_DT_interface*)

declare i32 @WORD_TO_DWORD(%WORD_TO_DWORD_interface*)

declare i16 @WORD_TO_INT(%WORD_TO_INT_interface*)

declare double @WORD_TO_LREAL(%WORD_TO_LREAL_interface*)

declare float @WORD_TO_REAL(%WORD_TO_REAL_interface*)

declare i8 @WORD_TO_SINT(%WORD_TO_SINT_interface*)

declare [81 x i8] @WORD_TO_STRING(%WORD_TO_STRING_interface*)

declare i64 @WORD_TO_TIME(%WORD_TO_TIME_interface*)

declare i64 @WORD_TO_TOD(%WORD_TO_TOD_interface*)

declare i32 @WORD_TO_UDINT(%WORD_TO_UDINT_interface*)

declare i16 @WORD_TO_UINT(%WORD_TO_UINT_interface*)

declare i8 @WORD_TO_USINT(%WORD_TO_USINT_interface*)

define i8 @STRING_EQUAL(%STRING_EQUAL_interface* %0) {
entry:
  %a = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %0, i32 0, i32 0
  %b = getelementptr inbounds %STRING_EQUAL_interface, %STRING_EQUAL_interface* %0, i32 0, i32 1
  %STRING_EQUAL = alloca i8, align 1
  store i8 0, i8* %STRING_EQUAL, align 1
  %STRING_EQUAL_ret = load i8, i8* %STRING_EQUAL, align 1
  ret i8 %STRING_EQUAL_ret
}

; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i32, i1 immarg) #0

; Function Attrs: argmemonly nofree nosync nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #1

; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #0

attributes #0 = { argmemonly nofree nosync nounwind willreturn }
attributes #1 = { argmemonly nofree nosync nounwind willreturn writeonly }
